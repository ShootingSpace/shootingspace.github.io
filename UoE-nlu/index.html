<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="0p5a0VOKCc8etsdDimlaZoAC96x8VeV9Ab5HWs5NcVw" />








  <meta name="baidu-site-verification" content="EbMAKHjVzF" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Computer Science & AI" type="application/atom+xml" />






<meta name="description" content="References:Natural language understandingCS224n: Natural Language Processing with Deep LearningLecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christo">
<meta property="og:type" content="article">
<meta property="og:title" content="Natural Language Understanding - Informatics - University of Edinburgh 爱丁堡大学">
<meta property="og:url" content="http://yoursite.com/UoE-nlu/index.html">
<meta property="og:site_name" content="Computer Science &amp; AI">
<meta property="og:description" content="References:Natural language understandingCS224n: Natural Language Processing with Deep LearningLecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christo">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/RNN-unrolled.png">
<meta property="og:image" content="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/09/rnn.jpg">
<meta property="og:image" content="http://karpathy.github.io/assets/rnn/diags.jpeg">
<meta property="og:image" content="http://yoursite.com/images/vanish_gradient.png">
<meta property="og:image" content="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-f.png">
<meta property="og:image" content="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-i.png">
<meta property="og:image" content="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-C.png">
<meta property="og:image" content="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-o.png">
<meta property="og:image" content="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-var-GRU.png">
<meta property="og:image" content="http://yoursite.com/images/gru.vs.lstm.png">
<meta property="og:image" content="http://yoursite.com/images/bidirectional_rnn.png">
<meta property="og:image" content="http://yoursite.com/images/word2vec_window.png">
<meta property="og:image" content="http://yoursite.com/images/word2vec_likelihood.png">
<meta property="og:image" content="http://yoursite.com/images/word2vec_costfunction.png">
<meta property="og:image" content="http://yoursite.com/images/word2vec_conprobability.png">
<meta property="og:image" content="http://yoursite.com/images/sub-sample.png">
<meta property="og:image" content="http://yoursite.com/images/negative-sample.png">
<meta property="og:image" content="http://yoursite.com/images/count_based_vs_direct_prediction.png">
<meta property="og:image" content="http://yoursite.com/images/Morphological_Recursive_Neural_Network.png">
<meta property="og:image" content="http://yoursite.com/images/cimRNN_cost.png">
<meta property="og:image" content="http://yoursite.com/images/Context_sensitive_morphological_RNN.png">
<meta property="og:image" content="http://yoursite.com/images/char_rep.png">
<meta property="og:image" content="http://yoursite.com/images/Subword_Unit.png">
<meta property="og:image" content="http://yoursite.com/images/sum_biLSTMs_char_trigrams.png">
<meta property="og:image" content="http://yoursite.com/images/fixed_window_nn_lm.png">
<meta property="og:image" content="http://yoursite.com/images/rnn_lm.png">
<meta property="og:image" content="http://yoursite.com/images/dependency_relation.png">
<meta property="og:image" content="http://yoursite.com/images/non_projective.jpg">
<meta property="og:image" content="http://yoursite.com/images/dependency_nn_edge_scores.jpg">
<meta property="og:image" content="http://yoursite.com/images/break_the_cycle.jpg">
<meta property="og:image" content="http://yoursite.com/images/Transition_based_Dependency_Parsing.png">
<meta property="og:image" content="http://yoursite.com/images/tree_traversals.gif">
<meta property="og:image" content="http://yoursite.com/images/tree_traversals_table.gif">
<meta property="og:image" content="http://yoursite.com/images/NP_The_hungry_cat.png">
<meta property="og:image" content="http://yoursite.com/images/Stack_symbols_composed_recursively.png">
<meta property="og:image" content="http://yoursite.com/images/stack_LSTM_over_time.gif">
<meta property="og:image" content="http://yoursite.com/images/RNNGs_history_informationn.png">
<meta property="og:image" content="http://yoursite.com/images/RNNGs_model.png">
<meta property="og:image" content="http://yoursite.com/images/Importance_Sampling.png">
<meta property="og:image" content="http://yoursite.com/images/PropBank.png">
<meta property="og:image" content="http://yoursite.com/images/end_to_end_SRL.png">
<meta property="og:image" content="http://yoursite.com/images/meaning_representation_model.png">
<meta property="og:image" content="http://yoursite.com/images/HMM.png">
<meta property="og:image" content="http://yoursite.com/images/Inference_for_HMMs.png">
<meta property="og:image" content="http://yoursite.com/images/Dirichlet_Distribution.png">
<meta property="og:image" content="http://yoursite.com/images/Bayesianizing_the_HMM.png">
<meta property="og:image" content="http://yoursite.com/images/BHMM_Dirichlet_Distribution_.png">
<meta property="og:image" content="http://yoursite.com/images/Gender_subspace.png">
<meta property="og:updated_time" content="2018-06-29T19:34:30.851Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Natural Language Understanding - Informatics - University of Edinburgh 爱丁堡大学">
<meta name="twitter:description" content="References:Natural language understandingCS224n: Natural Language Processing with Deep LearningLecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christo">
<meta name="twitter:image" content="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/RNN-unrolled.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/UoE-nlu/"/>





  <title>Natural Language Understanding - Informatics - University of Edinburgh 爱丁堡大学 | Computer Science & AI</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Computer Science & AI</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/UoE-nlu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Computer Science & AI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Natural Language Understanding - Informatics - University of Edinburgh 爱丁堡大学</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-01T00:00:00+01:00">
                2018-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NLP/" itemprop="url" rel="index">
                    <span itemprop="name">NLP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/UoE-nlu/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="UoE-nlu/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/UoE-nlu/" class="leancloud_visitors" data-flag-title="Natural Language Understanding - Informatics - University of Edinburgh 爱丁堡大学">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words&#58;</span>
                
                <span title="Words">
                  12,292
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Estimated &asymp;</span>
                
                <span title="Estimated">
                  60 min
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>References:<br><a href="http://www.inf.ed.ac.uk/teaching/courses/nlu/" target="_blank" rel="noopener">Natural language understanding</a><br><a href="http://web.stanford.edu/class/cs224n/syllabus.html" target="_blank" rel="noopener">CS224n: Natural Language Processing with Deep Learning</a><br><a href="https://web.stanford.edu/~jurafsky/NLPCourseraSlides.html" target="_blank" rel="noopener">Lecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christopher Manning</a></p>
<a id="more"></a>
<h2 id="循环神经网络-RNNs"><a href="#循环神经网络-RNNs" class="headerlink" title="循环神经网络 RNNs"></a>循环神经网络 RNNs</h2><p><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/RNN-unrolled.png" alt="" title="A recurrent neural network and the unfolding in time of the computation involved in its forward computation. Source: http://colah.github.io"></p>
<p><img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/09/rnn.jpg" alt="" title="Source: Nature"></p>
<p>For a sequence of input data (sequence of words, or speech) and sequence of output problem (many to many):<br>· feed input $x_{t}$ into the RNN: feeding one word (represented as vector) at a time, e.g one word in a sentence from left to right, $x_1$ corresponds to the second word of a sentence.</p>
<p>· $s_t$ is the hidden state at time step t. It is calculated based on the previous hidden state and the input at the current step:$s_t = f(Ux_t + Ws_{t-1})$. Function f is the activation.</p>
<p>· o(t) is the output at step t. For example, if we wanted to predict the next word in a sentence it would be a vector of probabilities across our vocabulary. $o_t = softmax(Vs_t)$.</p>
<p>RNN shares the same parameters ($U, V, W$ above) across all steps.</p>
<p>In addition to the above normal many to many structure RNNs, there are other non-sequence input or output: Many to one, e.g. when predicting the sentiment of a sentence we may only care about the final output, not the sentiment after each word. One to many: Music generation.<br><img src="http://karpathy.github.io/assets/rnn/diags.jpeg" alt="" title="source from http://karpathy.github.io/2015/05/21/rnn-effectiveness/"></p>
<p>除了应用于语言模型, RNNs 还可以应用于<br>· tagging, e.g. part-of-speech tagging, named entity recognition (many to many RNNs)<br>· sentence classification, e.g. sentiment classification (many to one RNNs)<br>· generate text, e.g. speech recognition, machine translation, summarization</p>
<h3 id="RNNs-Backpropagation"><a href="#RNNs-Backpropagation" class="headerlink" title="RNNs Backpropagation"></a>RNNs Backpropagation</h3><p>Backpropagation Through Time (BPTT): Because the parameters are shared by all time steps in the network, the gradient at each output depends not only on the calculations of the current time step, but also the previous time steps.</p>
<p>RNNs trained with BPTT have difficulties learning long-term dependencies (e.g. dependencies between steps that are far apart) due to what is called the vanishing/exploding gradient problem.</p>
<h3 id="梯度消失与爆炸"><a href="#梯度消失与爆炸" class="headerlink" title="梯度消失与爆炸"></a>梯度消失与爆炸</h3><p>The Vanishing/Exploding Gradient problem。</p>
<p>RNNs shares the same matrix (w, u, etc.) at each time step during forward prop and backprop. 求导数时, 根据链式法则, loss对各参数的导数会转换为loss对输出y的导数, 乘以y对隐含层的导数, 乘以隐含层相对隐含层之间的导数, 再乘以隐含层对参数的导数.<img src="/images/vanish_gradient.png" alt=""></p>
<p>不同隐含层（举例如$h_t$和$h_k$）之间如果相隔太远, $h_t$对$h_k$的导数就变成多个jacobian矩阵的相乘， 对各个jacobian范数（norms）进行分析后，发现$h_t$对$h_k$的导数值在训练过程中会很快变得很极端（非常小或者非常大）。</p>
<p>Gradient作为传导误差以帮助系统纠正参数的关键角色，如果本身变得接近于<code>0</code>或者<code>nan</code>，那么我们就无法判断t和t+n的数据的依赖性（是没有依赖？还是因为vanish of gradient？还是因为参数设置错误？）。梯度衰减会直接降低模型学习长距离依赖关系的能力，给定一个时间序列，例如文本序列，循环神经网络较难捕捉两个时刻距离较大的文本元素（字或词）之间的依赖关系。</p>
<p>在使用RNN学习language model的时候，非常容易出现梯度爆炸，解决办法是使用 gradient clipping 梯度裁剪，就是通过把梯度映射到另一个大小的空间，以限制梯度范数的最大值<a href="https://arxiv.org/abs/1211.5063" target="_blank" rel="noopener">On the difficulty of training Recurrent Neural Networks</a>。</p>
<p>虽然梯度裁剪可以应对梯度爆炸，但无法解决梯度衰减的问题。一个缓解梯度衰减的方案是使用更好的参数初始化方案和激活函数（ReLUs）<a href="https://arxiv.org/abs/1504.00941" target="_blank" rel="noopener">A Simple Way to Initialize Recurrent Networks of Rectified Linear Units</a>.</p>
<p>不过更主流的解决梯度衰减的方案是使用更复杂的rnn隐含单元: Gated Recurrent Units (GRU) introduced by <a href="https://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation</a> and LSTMs.</p>
<h3 id="Long-Short-Term-Memory"><a href="#Long-Short-Term-Memory" class="headerlink" title="Long Short-Term Memory"></a>Long Short-Term Memory</h3><p>Outside of the vanilla RNNs work flow, LSTMs use gated <strong>cells</strong> as memory to chose what error to be remembered. The cells take as input the previous state $s_{t-1}$ and current input $x_t$. Thus help to solve the long-term dependencies.</p>
<p>Whether the gated cell let information flow through (open) or not (closed) depends on its inner sigmoid activation layer with a pointwise multiplication operation. A sigmoid function values between 0 and 1, it could be used to describe how much information is allowed to through the cell.</p>
<p>Take a most basic sequence problem as example - predict next word: the cell state might include the gender of the present subject, so that the correct pronouns can be used. When we see a new subject, we want to forget the gender of the old subject.</p>
<p>LSTM的细胞的直观理解，就是细胞可以完整地保存信息，而新的输入可以诱发细胞对旧信息的遗忘，细胞自行决定记忆哪些新信息。</p>
<p>LSTM 用遗忘门来决定从 cell state 中丢弃哪些信息。<br>Forget gate: Control how much information of pervious state $h_{t-1}$ should be forgetten in the current internal cell. Learned by a sigmoid layer called the “forget gate layer” <img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-f.png" alt="" title="image from: http://colah.github.io/posts/2015-08-Understanding-LSTMs/"></p>
<p>用输入门 Input gate 来决定有多少新信息是值得储存的（记忆）。<br>Control how much new information is going to be remembered by internal state cell in current step t.<br>1, an input gate (a sigmoid hidden layer) decides which values we’ll update.<br>2, a hidden(tanh/relu) layer creates a vector of new candidate values $\hat{C}_t$, that could be added to the state. <img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-i.png" alt="" title="image from: http://colah.github.io/posts/2015-08-Understanding-LSTMs/"></p>
<p>下一步就可以更新旧的 cell sate $C_{t-1}$.<br>Input and forget gates together allow the network to control what information is stored and overwritten at each step. Combine the forget and remember information together to update the previous cell state.<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-C.png" alt="" title="image from: http://colah.github.io/posts/2015-08-Understanding-LSTMs/"></p>
<p>最后，用一个输出门 Output gate 来决定要输出的内容。<br>1, Run a sigmoid layer to decide what parts of the cell state we’re going to output.<br>2, put the cell state through tanh pointwise operation (to push the values to be between −1 and 1) and multiply it by the output of the output gate, so that we only output the parts decided by the output gate.<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-o.png" alt="" title="image from: http://colah.github.io/posts/2015-08-Understanding-LSTMs/"></p>
<p>总的来说, LSTM有输入门、遗忘门和输出门。这三个门形式上，都是关于旧隐含状态和新输入向量的 Sigmoid 隐含神经网络层, 只是各自有各自的参数矩阵.</p>
<h3 id="Gated-Recurring-Unit"><a href="#Gated-Recurring-Unit" class="headerlink" title="Gated Recurring Unit"></a>Gated Recurring Unit</h3><p>GRU combines the forget and remember gates into one single gate. This combination leads to a simpler LSTMs model. This combined gate is called update gate. GRU first computes the update gate $z_t$ (another layer) based on current input word vector and hidden state. Then there is a reset gate r similarly but with different weights. The new memory content $\hat{h}_t$; Final memory $h_t$ at time step combines current and previous time steps:<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-var-GRU.png" alt="" title="image from: http://colah.github.io/posts/2015-08-Understanding-LSTMs/"></p>
<h4 id="GRU-intuition"><a href="#GRU-intuition" class="headerlink" title="GRU intuition"></a>GRU intuition</h4><ul>
<li>重置门赋予了模型丢弃与未来无关的信息的能力。若重置门接近于0，则忽略之前的记忆，仅储存新加入的信息.</li>
<li>更新门控制过去的状态对现在的影响程度（即决定更新多少），如果接近于1，则 h<sub>t</sub>=z<sub>t</sub>*h<sub>t-1</sub>, 等同于把过去的信息完整复制到未来，相应地缓解梯度衰减。</li>
<li>短距离依赖的单元，过去的信息仅保留很短的时间，重置门一般很活跃，也就是数值在0和1之间频繁变动。</li>
<li>长距离依赖的单元，重置门较稳定（保留过去的记忆较长时间），而更新门较活跃。</li>
</ul>
<h3 id="不同RNNs变种的比较"><a href="#不同RNNs变种的比较" class="headerlink" title="不同RNNs变种的比较"></a>不同RNNs变种的比较</h3><p>Vanilla RNNs Execution:</p>
<ol>
<li>Read the whole register h</li>
<li>Update the whole register</li>
</ol>
<p>GRU Execution:</p>
<ol>
<li>Select a readable subset</li>
<li>Read the subset</li>
<li>Select a writable subset</li>
<li>Update the subset</li>
</ol>
<p><img src="/images/gru.vs.lstm.png" alt="" title="image from: http://web.stanford.edu/class/cs224n"></p>
<h3 id="门控循环神经网络的训练"><a href="#门控循环神经网络的训练" class="headerlink" title="门控循环神经网络的训练"></a>门控循环神经网络的训练</h3><ol>
<li>把参数矩阵初始化为正交</li>
<li>把遗忘门的bias初始化为1，默认不遗忘</li>
<li>别忘了梯度裁剪</li>
<li>注意dropout在RNNs中的应用不同于DNN和CNN</li>
</ol>
<h3 id="Bidirectional-RNNs"><a href="#Bidirectional-RNNs" class="headerlink" title="Bidirectional RNNs"></a>Bidirectional RNNs</h3><p>Bidirectional RNNs are based on the idea that the output at time t may not only depend on the previous elements in the sequence, but also future elements. They are just two RNNs stacked on top of each other. The output is then computed based on the hidden state of both RNNs.<br><img src="/images/bidirectional_rnn.png" alt="" title="image from: http://web.stanford.edu/class/cs224n"></p>
<h2 id="Meaning-representations"><a href="#Meaning-representations" class="headerlink" title="Meaning representations"></a>Meaning representations</h2><p>意思的表达有很多方法。一种有效的表示单词的含义的方法是 distributional semantic.</p>
<blockquote>
<p>Semantics (from Ancient Greek: σημαντικός sēmantikos, “significant”) is the linguistic and philosophical study of meaning, in language, programming languages, formal logics, and semiotics.</p>
</blockquote>
<blockquote>
<p>语义学 Semantics 在语言学中的研究目的在于找出语义表达的规律性、内在解释、不同语言在语义表达方面的个性以及共性；与计算机科学相关的语义学研究在于机器对自然语言的理解。</p>
</blockquote>
<p>Tradition solution of usable meaning in a computer: Use e.g. WordNet, a resource containing lists of synonym sets and hypernyms.</p>
<p>To convert natural language into values that computer understands, represent words as discrete symbols: Words can be represented by one-hot vectors, Vector dimension is the vocabulary. But there is no natural notion of similarity for one-hot vectors!</p>
<p>So learn to encode similarity in the vectors themselves.</p>
<p>The core idea is representing words by their context, building a <strong>dense</strong> vector for each word, chosen so that it is similar to vectors of words that appear in similar contexts.</p>
<p><code>Distributional models of meaning = vector-­space models of meaning = vector semantics</code>.<br><code>word vectors = word embeddings = word representations</code>.</p>
<h3 id="Four-kinds-of-vector-models"><a href="#Four-kinds-of-vector-models" class="headerlink" title="Four kinds of vector models"></a>Four kinds of vector models</h3><p>Sparse vector representations:<br>1, Mutual-­information weighted word co-­occurrence matrices</p>
<p>Dense vector representations:<br>2, Singular value decomposition (SVD): A special case of this is called LSA - Latent Semantic Analysis<br>3, Neural­‐network­‐inspired models (skip­‐grams, CBOW)<br>4, Brown clusters</p>
<p>Prediction-­based models learn embeddings as part of the process of word prediction. Train a neural network to predict neighboring words. The advantages:<br>· Fast, easy to train (much faster than SVD)<br>· Available online in the word2vec package<br>· Including sets of pretrained embeddings</p>
<h3 id="Word-representation-and-Word2vec"><a href="#Word-representation-and-Word2vec" class="headerlink" title="Word representation and Word2vec"></a>Word representation and Word2vec</h3><p>Word2vec is a framework for learning word vectors representation.<br>Idea:<br>1, We have a large corpus of text<br>2, Every word in a fixed vocabulary is represented by a vector<br>3, Go through each position t in the text, which has a center word c and context (“outside”) words o<br>4, Use the similarity of the word vectors for c and o to calculate the probability of o given c (or vice versa)<br>5, Keep adjusting the word vectors to maximize this probability</p>
<p>在上面第四点, 如果是给定中心词，计算上下文词, 那么就是 <strong>Skip-grams model</strong>, 比如 Given word w<sub>t</sub>, in a context window of 2C words, predict 4 context words [w<sub>t-2</sub>, w<sub>t-1</sub>, w<sub>t+1</sub>, w<sub>t+2</sub>]<br><img src="/images/word2vec_window.png" alt="" title="Example windows and process for computing P(w&lt;sub&gt;t+j&lt;/sub&gt; | w&lt;sub&gt;t&lt;/sub&gt;), image from: http://web.stanford.edu/class/cs224n"><br>Skip-grams 给予模型跳词能力，比如 “I hit the tennis ball” 有三个trigrams: “I hit the”, “hit the tennis”, “the tennis ball”. 但是，这个句子也同样包含一个同样重要但是N-Gram无法提取的trigram:”hit the ball”. 而使用 skip-grams 允许我们跳过 “tennis” 生成这个trigram.</p>
<p>反之，给定 bag-of-words context, predict target word, 那就是 <strong>Continuous Bag of Words, CBOW model</strong>.</p>
<p>缺点：因为output size 等于 vocabulary，而 softmax 分母中需要求和每一个词的 output size × hidden units 的内积， 计算会非常昂贵。解决办法是使用负采样 <a href="#negative-sampling">negative sampling</a>。</p>
<p>Word2vec的本质是遍历语料库的每一个词$w_i$，捕捉$w_i$与其上下文位置目标词的同时出现的概率。</p>
<h4 id="目标函数-Obejective-funtion-cost-or-loss-function-J-θ"><a href="#目标函数-Obejective-funtion-cost-or-loss-function-J-θ" class="headerlink" title="目标函数 Obejective funtion (cost or loss function) J(θ):"></a>目标函数 Obejective funtion (cost or loss function) J(θ):</h4><p>For each position $t = 1, … , T$, predict context words within a window of fixed size m, given center word, use chain rule to multiply all the probability to get the likelihood $L(θ)$:<br><img src="/images/word2vec_likelihood.png" alt="" title="Function for L(θ), image from: http://web.stanford.edu/class/cs224n"><br>The θ is the vectors representations, which is the only parameters we needs to optimize(其实还有其他hyperparameters，这里暂时忽略).</p>
<p>The loss function is the (average) negative log likelihood:<br><img src="/images/word2vec_costfunction.png" alt="" title="image from: http://web.stanford.edu/class/cs224n"></p>
<p>Minimizing objective function ⟺ Maximizing predictive accuracy.</p>
<p>The problem is how to calculate $P(w_{t+j} \mid w_t; θ)$:</p>
<p>每个词由两个向量表示（Easier optimization. Average both at the end）：<br>$v_w$ when w is a center word, $u_w$ when w is a context word.</p>
<p>Then for a center word c and a “outside” word o:<br><img src="/images/word2vec_conprobability.png" alt="" title="image from: http://web.stanford.edu/class/cs224n"><br>The numerator contains dot product, compares similarity of o and c, larger dot product = larger probability. The denominator works as a normalization over entire vocabulary.</p>
<h4 id="高频词二次采样-subsampling"><a href="#高频词二次采样-subsampling" class="headerlink" title="高频词二次采样 subsampling"></a>高频词二次采样 subsampling</h4><p>二次采样是指当决定是否选取一个词作为样本时，它被选择的概率反比于它出现的概率，这样不仅可以降低无意义但高频的词(“the”, “a”等)的重要性，也可以加快采样速度。$$P(w_i) = (\sqrt{\frac{z(w_i)}{0.001}} + 1) \cdot \frac{0.001}{z(w_i)}$$ $z(w_i)$ 是词$w_i$在语料库中的占比，如果”peanut”在10亿语料库中出现了1,000次, 那么z(“peanut”) = 1e-6.<br><img src="/images/sub-sample.png" alt="" title="sub sample of P(wi)"></p>
<h4 id="Negative-sampling"><a href="#Negative-sampling" class="headerlink" title="Negative sampling"></a>Negative sampling</h4><p>负采样是指每个训练样本仅更新模型权重的一小部分：only the output that represents the positive class(1) + other few randomly selected classes(0) are evaluated.<br><a href="https://arxiv.org/pdf/1310.4546.pdf" target="_blank" rel="noopener">该论文指出</a></p>
<blockquote>
<p>负采样5-20个单词适用于较小的数据集，对于大型数据集只需要2-5个单词。</p>
</blockquote>
<p>修改目标函数，选择k个负样本（即除了概率最高的那个目标词之外的其他词）：<img src="/images/negative-sample.png" alt="" title="image from: http://web.stanford.edu/class/cs224n"></p>
<p>这样可以最大化真正的外部词出现的概率，最小化随机负采样的词概率。</p>
<p>负面样本的选择是基于 unigram 分布 $f(w_i)$: 一个词作为负面样本被选择的概率与其出现的频率有关，更频繁的词更可能被选作负面样本。<br>$$P(w_i) = \frac{  {f(w_i)}^{3/4}  }{\sum_{j=0}^{n}\left(  {f(w_j)}^{3/4} \right) }$$<br>负采样的优点是：<br>· Training speed is independent of the vocabulary size<br>· Allowing parallelism.<br>· 模型的表现更好。因为负采样契合NLP的稀疏性质，大部分情况下，虽然语料库很大，但是每一个词只跟很小部分词由关联，大部分词之间是毫无关联的，从无关联的两个词之间也别指望能学到什么有用的信息，不如直接忽略。</p>
<h4 id="与传统的NLP方法比较"><a href="#与传统的NLP方法比较" class="headerlink" title="与传统的NLP方法比较"></a>与传统的NLP方法比较</h4><p>在word2vec出现之前，NLP使用经典且直观的共生矩阵（co-occurrence matrix）来统计词语两两同时出现的频率，参考<a href="/NOTE-ANLP-01-distributional-semantic-models">ANLP - Distributional semantic models</a>。缺点也明显，词汇量的增加导致矩阵增大，需要大量内存，随之而来的分类模型出现稀疏性问题，模型不稳定。虽然可以使用SVD来降维，但是一个<code>n×m</code>矩阵的计算成本是O(mn<sup>2</sup>)浮点数（当<code>n&lt;m</code>），还是非常大的。而且很难并入新词或新文档。<br><img src="/images/count_based_vs_direct_prediction.png" alt="" title="Count based vs direct prediction, image from: http://web.stanford.edu/class/cs224n"></p>
<p>目前融合了两种方法的优点的Glove是最常用的。</p>
<h4 id="TODO-Glove"><a href="#TODO-Glove" class="headerlink" title="TODO(Glove)"></a>TODO(Glove)</h4><h3 id="Morphological-Recursive-Neural-Network-morphoRNN"><a href="#Morphological-Recursive-Neural-Network-morphoRNN" class="headerlink" title="Morphological Recursive Neural Network (morphoRNN)"></a>Morphological Recursive Neural Network (morphoRNN)</h3><p>Limitation of word2vec:<br>• Closed vocabulary assumption<br>• Cannot exploit functional relationships in learning:</p>
<blockquote>
<p>如英语的dog、dogs和dog-catcher有相当的关系，英语使用者能够利用他们的背景知识来判断此关系，对他们来说，dog和dogs的关系就如同cat和cats，dog和dog-catcher就如同dish和dishwasher</p>
</blockquote>
<p>To walk closer to open vocabulary, use compositional representations based on morphemes. Instead of word embedding, embed morphemes - the smallest meaningful unit of language.  Compute representation recursively from morphemes, word embedding 由 morphemes embedding 拼接而来.<img src="/images/Morphological_Recursive_Neural_Network.png" alt="" title="Morphological Recursive Neural Network. A vector representation for the word &quot;unfortunately&quot; is constructed from morphemic vectors: un&lt;sub&gt;pre&lt;/sub&gt;, fortunate&lt;sub&gt;stm&lt;/sub&gt;, ly&lt;sub&gt;suf&lt;/sub&gt;. Dotted nodes are computed on-the-fly and not in the lexicon. image from: http://www.aclweb.org/anthology/W13-3512"></p>
<p>与基础版的morphoRNN结构相同，Context-insensitive Morphological RNN model (cimRNN) 考察 morphoRNN 在不参考任何上下文信息情况下， 仅仅用 morphemic representation 构造词向量的能力。训练时，给每个词xi定义损失函数s(xi)为新构造的词向量p<sub>c</sub>(xi)和参考词向量p<sub>r</sub>(xi)之间的欧几里得距离平方<br><img src="/images/cimRNN_cost.png" alt=""></p>
<p>该cimRNN模型没有机会改进可能被估计不足的罕见词的表达.</p>
<p>Context-sensitive Morphological RNN (csmRNN) 在学习语素组成时同时参考语境信息，在训练过程中，神经网络顶层的更新将一直反向传播直至底层的语素层。<br><img src="/images/Context_sensitive_morphological_RNN.png" alt="" title="Context-sensitive morphological RNN has two layers: (a) the morphological RNN, which constructs representations for words from their morphemes and (b) the word-based neural language which optimizes scores for relevant ngrams. image from: http://www.aclweb.org/anthology/W13-3512"></p>
<h3 id="Compositional-character-representations"><a href="#Compositional-character-representations" class="headerlink" title="Compositional character representations"></a>Compositional character representations</h3><p>在自然语言处理中使用 word 作为基本单位的问题在于词汇量太大了，所以几乎所有主流模型都会省略很多词，比如Bengio的RNNs语言模型就把所有出现频率<code>&lt;3</code>的单词统一标记为一个特殊词。但这样的操作也只是把词汇量降到了16,383。又比如word2vec模型只考虑出现频率最高的30,000个词。</p>
<p>所以寻找其他有限集合的语言单位成为替代选择，比如字母 character（更确切地说是 unicode code points），比如前面提到的 Morphemes，还有其他比如 Character n-grams，Morphological analysis等，这些可以统称为 subwords units。</p>
<p>然后再通过 subwords 来重构 word representation，进而构建整个文本的meaning representation.</p>
<p>构建 word representation 最简单的方法就是把 subwords vectors 相加、平均或者拼接等，但更好的是使用非线性的方法，比如 Bidirectional LSTMs, Convolutional NNs 等。<br><img src="/images/char_rep.png" alt="" title="Compose character representations into word representations with LSTMs. Illustration of the word lookup tables (top) and the lexical Composition Model (bottom). Square boxes represent vectors of neuron activations. Shaded boxes indicate that a non-linearity. image from: Finding function in form: compositional character models for open vocabulary word representation, Ling et al. 2015"></p>
<h4 id="哪种方式构建-subword-representations-比较好？"><a href="#哪种方式构建-subword-representations-比较好？" class="headerlink" title="哪种方式构建 subword representations 比较好？"></a>哪种方式构建 subword representations 比较好？</h4><p>在 word representation 的重构中，涉及了几个变量:<br>1, Subword Unit<br><img src="/images/Subword_Unit.png" alt="" title="The last row is part of an oracle: the true morphology, a human annotator."></p>
<p>2, Composition Function<br>• Linear Vector operation<br>• Bi-LSTMs<br>• Convolutional NNs</p>
<p>3, Language Typology</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>example</th>
<th>Morphology</th>
<th>analysis</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fusional (English)</td>
<td>“reads”</td>
<td>read-s</td>
<td>read-3SG.SG</td>
</tr>
<tr>
<td>Agglutinative (Turkish)</td>
<td>“If I read …”</td>
<td>oku-r-sa-m</td>
<td>read-AOR.COND.1SG</td>
</tr>
<tr>
<td>Root&amp;Pattern (Arabic)</td>
<td>“he wrote”</td>
<td>k(a)t(a)b(a)</td>
<td>write-PST.3SG.M</td>
</tr>
<tr>
<td>Reduplication (Indonesian)</td>
<td>“children”</td>
<td>anak~anak</td>
<td>child-PL</td>
</tr>
</tbody>
</table>
<p><img src="/images/sum_biLSTMs_char_trigrams.png" alt="" title="Summary of perplexity: use biLSTMs over character trigrams. In general, the results are better than vanilla word representation"></p>
<p>除了语言模型外, 其他NLP任务如SQuAd问答数据集上的很多优秀模型，也会加入character embedding.</p>
<p>但目前 Character-level models 并不具有触及实际 morphology 的模型预测能力。</p>
<h3 id="Multi-word-language-representations"><a href="#Multi-word-language-representations" class="headerlink" title="Multi-word language representations"></a>Multi-word language representations</h3><p><strong>Neural bag-of-words models</strong>:<br>· Simply average (or just sum) word vectors,<br>· Can improve effectiveness by putting output through 1+ fully connected layers (DANs)<br>· Recurrent neural networks(LSTM/GRU): cannot capture phrases without prefix context, and empirically, representations capture too much of last words in final vector – focus is LM next word prediction<br>· Convolutional Neural Network: compute vectors for every h-word phrase, often for several values of h. Example: “the country of my birth” computes vectors for: the country, country of, of my, my birth, the country of, country of my, of my birth, the country of my, country of my birth. Not very linguistic, but you get everything!</p>
<p><strong>Data-dependent composition</strong>:<br>Recursion is natural for describing language, Phrases correspond to semantic units of language.</p>
<p>How to map longer phrases into the same vector space?<br>利用复合性原理 principle of compositionality:</p>
<blockquote>
<p>在数学、语义学和语言哲学中，复合性原理是指，一个复杂表达式的意义是由其各组成部分的意义以及用以结合它们的规则来决定的。</p>
</blockquote>
<p>Recursive neural nets, a tree structure.<br>For Structure Prediction:<br>Inputs: two candidate children’s representations<br>Outputs:<br>1, The semantic representation if the two nodes are merged.<br>2, Score of how plausible the new node would be.</p>
<h2 id="神经网络语言模型"><a href="#神经网络语言模型" class="headerlink" title="神经网络语言模型"></a>神经网络语言模型</h2><p>如何构建一个神经网络语言模型?<br>语言模型的目的是输入一串字符, 输出下一个字符的概率分布, 可以使用 fixed-window neural Language Model, 类似于N-Gram, 仅考虑前(n-1)个窗口长度序列, “<del>as  the  proctor  started  the clock</del> the students opened their _“ 得到定长的输入序列, 而 Feedforward neural networks 的输入就是要求固定长度的向量.<br><img src="/images/fixed_window_nn_lm.png" alt="" title="一个固定长度的神经网络语言模型 image from: http://web.stanford.edu/class/cs224n"></p>
<p>用前馈神经网络做语言模型的优点（相对于N-Gram）就是没有了稀疏性问题，而且模型的大小也控制在 <code>O(n)</code>（N-Gram是<code>O(exp(n))</code>）</p>
<p>固定长度的前馈神经网络的固有缺陷就是它要求输入和输出都是固定长度的, 仅考虑前的(n-1)长度的序列, 很多时候会丢失NLP中的长距离依赖信息, 跟N-Gram的有一样的缺陷。而且实际的应用中语句的长度是不固定的，最好有一个神经网络可以接受任意长度的输入序列, 输出任意长度的序列。循环神经网络 (Recurrent neural networks, aka RNNs) 就可以解决这个问题.</p>
<h2 id="循环神经网络语言模型"><a href="#循环神经网络语言模型" class="headerlink" title="循环神经网络语言模型"></a>循环神经网络语言模型</h2><p>不同于前馈神经网络使用输入序列的每一个词单独训练一行(或一列, 取决于矩阵的设计)参数矩阵, RNNs的设计核心是用输入序列的每一个词, 反复地训练同一个参数, 即”共享参数”.<br><img src="/images/rnn_lm.png" alt="" title="RNNs神经网络语言模型 image from: http://web.stanford.edu/class/cs224n"></p>
<p>因为参数共享:<br>1, 模型大小不会随着输入序列长度增加而增加。<br>2, 每一步的计算，理论上都使用到了之前的历史信息，所以理论上可以更好的捕捉长距离依赖（但实际上表现并不好，看后面的<a href="#梯度消失与爆炸">梯度消失与爆炸</a>）.<br>3, 模型有更好的泛化能力</p>
<p>使用基于Softmax的RNNs语言模型等同于解决矩阵分解问题, 参考<a href="https://openreview.net/forum?id=HkwZSG-CZ" target="_blank" rel="noopener">Breaking the Softmax Bottleneck: A High-Rank RNN Language Model</a>。</p>
<p>循环神经网络语言模型使用损失函数评估模型表现: 损失函数 loss function on step t is usual 交叉熵 cross-entropy between predicted probability distribution and the true next word.</p>
<p>传统的统计语言模型使用困惑度(perplexity)来评估模型表现，但其实降低困惑度等价于减小损失函数.</p>
<h2 id="神经网络语言模型的学习能力"><a href="#神经网络语言模型的学习能力" class="headerlink" title="神经网络语言模型的学习能力"></a>神经网络语言模型的学习能力</h2><p>Character models are good at reduplication (no oracle, though), works well on language with reduplication patterns like Indonesian, Malay. Character NLMs learn word boundaries, memorize POS tags.</p>
<p>What do NLMs learn about morphology?<br>1, Character-level NLMs work across typologies, but especially well for agglutinative morphology.<br>2, predictive accuracy is not as good as model with explicit knowledge of morphology (or POS).<br>3, They actually learn orthographic similarity of affixes, and forget meaning of root morphemes accordong to qualitative analyses.<br>4, More generally, they appear to <strong>memorize frequent subpatterns</strong></p>
<p>总的来说，神经网络处理自然语言的能力并不特殊，表现的性能，跟神经网络本身的长处相匹配，如泛化、模式匹配、端到端应用的能力等。</p>
<h2 id="Dependency-parsing"><a href="#Dependency-parsing" class="headerlink" title="Dependency parsing"></a>Dependency parsing</h2><p>语言学里有两种角度看待语法结构 - Constituency and Dependency：</p>
<ul>
<li>Constituency: phrase structure grammar, 从句子成分构造的角度看，capture the configurational patterns of sentences，即把句子的语法理解为词组成分的递归嵌套. 可以用 context-free grammars (CFGs) 来表达语法规则，就是语法树。</li>
<li>Dependency syntax: 主要是从语义的角度来看，显示哪些单词依赖于（一般指修改或作为参数其参数）哪些单词。特别用于区分动词的主格（subject position or with nominative inflection）宾格（object position or with accusative inflection）. Dependencies can be identified even in non-configurational languages.</li>
</ul>
<p>A sentence dependency structure explains the <strong>dependency relation</strong> between its words: represented as a graph with the words as its nodes, linked by directed, labeled edges, with the following properties:<br>• connected: every node is related to <strong>at least one other node</strong>, and (through transitivity) to ROOT;<br>• single headed: every node (except ROOT) has exactly <strong>one incoming edge</strong> (from its head);<br>• acyclic: the graph cannot contain cycles of directed edges.<br><img src="/images/dependency_relation.png" alt="" title="A dependency relation consists of: a head (H); a dependent (D); a label identifying the relation between H and D. image from: Joakim Nivre, Dependency Grammar and Dependency Parsing."></p>
<p>Dependency trees 有两种，如果dependency graph中有edges交叉则是<strong>non-projective</strong>, 反之则是 <strong>projective</strong>。更确切的定义是：A dependency tree is <strong>projective</strong> wrt. a particular linear order of its nodes if, for all edges <code>h → d</code> and nodes w, w occurs between h and d in linear order only if w is dominated by h.</p>
<p>A non-projective dependency grammar is not context-free.<br><img src="/images/non_projective.jpg" alt="" title="上图是 non-projective，下图是 projective. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l07.pdf"></p>
<p>Motivation for Dependency parsing:<br>• context-free parsing algorithms base their decisions on adjacency;<br>• in a dependency structure, a dependent need not be adjacent to its head (even if the structure is projective);<br>• we need new parsing algorithms to deal with non-adjacency (and with non-projectivity if present).</p>
<p>Evaluation: accuracy (# correct dependencies with or ignore label)).</p>
<h3 id="Graph-based-dependency-parsing"><a href="#Graph-based-dependency-parsing" class="headerlink" title="Graph-based dependency parsing"></a>Graph-based dependency parsing</h3><p>Based on <strong>maximum spanning trees (MST parser)</strong>, views syntactic structure as a set of constraints</p>
<p>Intuition as tagging problem: since each word has exactly one parent, the possible tags are the other words in the sentence (or a dummy node called root). If we <strong>edge factorize</strong> the score of a tree so that it is simply the product of its edge scores, then we can simply select the best incoming edge for each word.</p>
<p>The tartget function is to find the highest scoring dependency tree in the space of all possible trees for a sentence. The score of dependency tree y for sentence x is:<br>$$s(x,y) = \sum_{(i,j)\in y} s(i,j)$$<br>$x = x_1…x_n, y$ is a set of dependency edges, with $(i, j) ∈ y$ if there is an edge from $x_i$ to $x_j$.</p>
<p>Scoring edges with a neural network<br><img src="/images/dependency_nn_edge_scores.jpg" alt="" title="Get a&lt;sub&gt;i&lt;/sub&gt; by concatenating the hidden states of a forward and backward RNN at position i. image from: Zhang and Lapata (2016)"><br>The function g(a<sub>j</sub>, a<sub>i</sub>) computes an <strong>association score</strong> telling us how much word wi prefers word wj as its head. Association scores are a useful way to select from a dynamic group of candidates, 跟注意力机制的similarity score 异曲同工，方程的形式也很相似。</p>
<p>Parsing 算法：</p>
<ul>
<li>start with a <strong>totally connected graph</strong> G, i.e., assume a directed edge between every pair of words;</li>
<li>find the maximum spanning tree (MST) of G, i.e., the directed tree with the highest overall score that includes all nodes of G;</li>
<li>this is possible in O(n<sup>2</sup>) time using the <strong>Chu-Liu-Edmonds algorithm</strong>; it finds a MST which is not guaranteed to be projective;<br>  1, Each node j in the graph greedily selects the incoming edge with the highest score s(i,j)<br>  2, If result were a tree, it would have to be the maximum spanning tree; If not, there must be a cycle.<br>  3, Break the cycle by replacing a single incoming edge to one of the nodes in the cycle. To choose the node, decide recursively by identifying the cycle and contract it into a single node and recalculate scores of incoming and outgoing edges. Now call CLE recursively on the contracted graph. MST on the contracted graph is equivalent to MST on the original graph. 这里是指先识别出循环体<code>saw ⇄ john</code>②，然后在这个循环体范围内，使用CLE找出 root 进出这个循环体的最大概率路线<code>(root → saw → john = 40) &gt; (root → john → saw = 29)</code>③；<br>  4, Greedily collect incoming edges to all nodes, find out to be a tree and thus the MST of the graph. 把循环体以及其包含的nodes合并为一个node wjs，并且已经有了进出wjs的最大概率路径，这样就可以在整个图上继续运行CLE算法找出最大概率路线<code>(root → wjs → mary = 70) &gt; (root → mary → wjs = 40)</code>④.<br><img src="/images/break_the_cycle.jpg" alt="" title="Graph-based dependency parsing procedure. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l07.pdf"></li>
</ul>
<p>Chu-Liu-Edmonds (CLE) Algorithm:</p>
<blockquote>
<p>In graph theory, Edmonds’ algorithm or Chu–Liu/Edmonds’ algorithm is an algorithm for finding a spanning arborescence of minimum weight (sometimes called an optimum branching). It is the directed analog of the minimum spanning tree problem</p>
</blockquote>
<h3 id="Transition-based-dependency-parsing"><a href="#Transition-based-dependency-parsing" class="headerlink" title="Transition-based dependency parsing"></a>Transition-based dependency parsing</h3><p>An extension of shift-reduce parsing (MALT parser), views syntactic structure as the actions of an automaton:<br>• for a given parse state, the transition system defines a set of actions T which the parser can take;<br>• if more than one action is applicable, a machine learning classifier is used to decide which action to take;<br>• just like in the MST model, this requires a mechanism to compute scores over a set of (possibly dynamic) candidates.<br><img src="/images/Transition_based_Dependency_Parsing.png" alt="" title="Configuration c = (s, b, A) with stack s, buffer b, set of dependency arcs A; c is terminal if buffer is empty, stack contains only ROOT, and parse tree is given by Ac image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l07.pdf"><br>if si is the ith top element on stack, and bi the ith element on buffer, then we have the following transitions:<br>• <code>LEFT-ARC(l)</code>: adds arc <code>s1 → s2</code> with label <code>l</code> and removes s2 from stack (|s| ≥ 2);<br>• <code>RIGHT-ARC(l)</code>: adds arc <code>s2 → s1</code> with label <code>l</code> and removes s1 from stack (|s| ≥ 2);<br>• <code>SHIFT</code>: moves b1 from buffer to stack; recondition: |b| ≥ 1.<br>总的来说就是：父节点保留在stack中; 从始至终 root 一直都是父节点；从 buffer 中把候选词一个一个 push 到stack中，根据 classifier 预测的结果，分辨出哪个候选词是子节点，并把子节点 pop 出 stack；直到清空 buffer，stack 中只剩下 root。</p>
<h3 id="Comparing-MST-and-transition-based-parsers"><a href="#Comparing-MST-and-transition-based-parsers" class="headerlink" title="Comparing MST and transition-based parsers:"></a>Comparing MST and transition-based parsers:</h3><p>Both require dynamic classifiers, and these can be implemented using neural networks, conditioned on bidirectional RNN encodings of the sentence.</p>
<p>The MST parser selects the globally optimal tree, given a set of edges with scores;<br>• it can naturally handle projective and non-projective trees;</p>
<p>A transition-based parser makes a sequence of local decisions about the best parse action;<br>• it can be extended to projective dependency trees by changing the transition set;</p>
<p>Accuracies are similar, but transition-based is faster;</p>
<h2 id="Recurrent-neural-network-grammars-RNNGs"><a href="#Recurrent-neural-network-grammars-RNNGs" class="headerlink" title="Recurrent neural network grammars (RNNGs)"></a>Recurrent neural network grammars (RNNGs)</h2><p>Widespread phenomenon: <strong>Polarity items</strong> can only appear in certain contexts, e.g. “anybody”.</p>
<blockquote>
<p>In linguistics, a <strong>polarity item</strong> is a lexical item that can appear only in environments associated with a particular grammatical polarity – affirmative or negative. A polarity item that appears in affirmative (positive) contexts is called a positive polarity item (PPI), and one that appears in negative contexts is a negative polarity item (NPI).</p>
</blockquote>
<blockquote>
<p>The environment in which a polarity item is permitted to appear is called a “<strong>licensing context</strong>“.</p>
</blockquote>
<p>The lecture that I gave did not appeal to anybody;<br><del>The lecture that I gave appealed to anybody.</del></p>
<p>也许”anybody”出现的条件是前面出现过”not”，那么应该可以使用 RNNs 模型来解码这点信息。然而:<br><del>The lecture that I did not give appealed to anybody.</del></p>
<p>这说明 Language is hierarchical: The <strong>licensing context</strong> depends on recursive structure (syntax)。不能简单根据”not”是否出现来判断，而是需要看”not”修饰的成分，也就是说要考虑语法的合理。这就给文本生成任务（或者说构建语言模型）带来挑战。</p>
<p><a href="https://arxiv.org/pdf/1602.07776.pdf" target="_blank" rel="noopener">Recurrent neural network grammars (Dyer et al. 2016)</a>提出了一种具有明确短语结构的语言模型 RNNGs。</p>
<blockquote>
<p> RNNGs operate via a recursive syntactic process reminiscent of probabilistic context-free grammar generation, but decisions are parameterized using RNNs that condition on the entire syntactic derivation history, greatly relaxing context-free independence assumptions.</p>
</blockquote>
<p>就是在使用 RNNs 构建语言模型，除了考虑历史词信息, 还会生成历史的语法结构, 并以此为参考预测语法结构和词语,以保证生成的语言符合语法结构。这里的语法是针对 phrase structure (constituency) grammars，所以 RNNGs 也是一种 <strong>constituency parsing</strong>：</p>
<ul>
<li>Generate symbols sequentially using an RNN</li>
<li>Add some “control symbols” to rewrite the history periodically<ul>
<li>Periodically “compress” a sequence into a single “constituent”</li>
<li>Augment RNN with an operation to compress recent history into a single vector (-&gt; “reduce”)</li>
<li>RNN predicts next symbol based on the history of compressed elements and non-compressed terminals (“shift” or “generate”)</li>
<li>RNN must also predict “control symbols” that decide how big constituents are</li>
</ul>
</li>
</ul>
<p>首先注意到，如果有序地去遍历语法树，得出的就是一个序列：<br><img src="/images/tree_traversals.gif" alt="" title="(Ordered) tree traversals are sequences. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></p>
<p>What information can we use to predict the next action, and how can we encode it with an RNN?</p>
<p>Use an RNN for each of:</p>
<ul>
<li>Previous terminal symbols</li>
<li>Previous actions</li>
<li>Current stack contents<br><img src="/images/tree_traversals_table.gif" alt="" title="Actions prediction. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"><br>最后得出的 stack 就是完整的语法树（以序列的形式）。</li>
</ul>
<h3 id="Syntactic-Composition"><a href="#Syntactic-Composition" class="headerlink" title="Syntactic Composition"></a>Syntactic Composition</h3><p>人们通过较小元素的语义组合来解释较大文本单元的含义 - 实体，描述性词语，事实，论据，故事.<br>When compressing “The hungry cat” into a single composite symbol, use Bi-LSTM to encode <code>(NP The hungry cat)</code>.<br><img src="/images/NP_The_hungry_cat.png" alt="" title="Representation of (NP The hungry cat). image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></p>
<p>基于此可以递归地解码更复杂的短语，比如<code>(NP The (ADJP very hungry) cat)</code>, 只需要把原来的<code>hungry</code>替换为<code>(ADJP very hungry)</code>即可。</p>
<p>这种递归地堆栈符号的构建行为映射了符号对应的树结构<br><img src="/images/Stack_symbols_composed_recursively.png" alt="" title="Stack encodes top-down syntactic recency, rather than left-to-right string recency. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></p>
<p>除此了使用 Bi-LSTM 解码，还可以使用 Attention：Replace composition with one that computes attention over objects in the composed sequence, using embedding of NT for similarity.</p>
<h3 id="Implement-RNNGs"><a href="#Implement-RNNGs" class="headerlink" title="Implement RNNGs"></a>Implement RNNGs</h3><p>Stack RNNs</p>
<ul>
<li>Augment a sequential RNN with a <strong>stack pointer</strong></li>
<li>Two constant-time operations<ul>
<li><label style="color:#1565C0"><strong>push</strong></label> - read input, add to top of stack, connect to current location of the stack pointer</li>
<li><label style="color:#C62828"><strong>pop</strong></label> - move stack pointer to its parent</li>
</ul>
</li>
<li>A <strong>summary</strong> of stack contents is obtained by accessing the output of the RNN at location of the stack pointer<br><img src="/images/stack_LSTM_over_time.gif" alt="" title="The evolution of the stack LSTM over time mirrors tree structure. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></li>
</ul>
<p>Training RNNs:</p>
<ul>
<li>Each word is conditioned on history represented by a trio of RNNs</li>
<li>backpropagate through these three RNNs, and recursively through the phrase structure <code>S → NP VP</code>.<br><img src="/images/RNNGs_history_informationn.png" alt="" title="RNNs compute probability conditions on histroy. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></li>
</ul>
<p>完整的RNNGs模型，用 softmax 计算下一个 action 的概率分布：<br><img src="/images/RNNGs_model.png" alt="" title="Complete RNNGs model. x is sentence, y is tree; $A_G$ is allowable actions at this step;  $a(x,y)$ is sequence of actions, ; $r_α$ is action embedding, $u_t$ is history embedding; $o_t$ is output (buffer), $s_t$ is stack, $h_t$ is action history, the three are concatenated together. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></p>
<h3 id="Parameter-Estimation"><a href="#Parameter-Estimation" class="headerlink" title="Parameter Estimation"></a>Parameter Estimation</h3><p>RNNGs jointly model sequences of words together with a “tree structure”.</p>
<p>Any parse tree can be converted to a sequence of actions (depth first traversal) and vice versa (subject to wellformedness constraints).</p>
<h3 id="Inference-problems-of-RNNGs"><a href="#Inference-problems-of-RNNGs" class="headerlink" title="Inference problems of RNNGs"></a>Inference problems of RNNGs</h3><p>An RNNG is a joint distribution p(x,y) over strings (x) and parse trees (y), i.e. it jointly predicts the word, and the parse context together. So the model will still generate the syntactic information and the next word but we can discard the additional outputs if all we want is the language model.</p>
<p>Two inference questions:<br>• What is $p(x)$ for a given x? - language modeling<br>• What is $argmax_yp(y | x)$ for a given x? - parsing</p>
<p>The model predicts the next action (NT() GEN() or REDUCE in generative mode, NT() SHIFT or REDUCE in discriminative mode). The set of actions completely determines the string and tree structure, so we can get their joint probability by multiplying over the probabilities of all actions.</p>
<p>In discriminative mode, the input is a string of words, and the model cannot generate words, but instead “consumes” the words in the input buffer. The model can be used as a parser (find the maximum prob. tree, i.e., $argmax_yP(y \mid x)$).</p>
<p>In generative mode, there is a respective GEN() action for every word, so the word is predicted with the action. To be a language model (find the maximum prob. sentence/assign probabilities to a sentence, i.e., $p(x)$), we must marginalize over trees to get the probability of the sentence. This is intractable so is approximated with importance sampling by sampling from a discriminatively trained model.</p>
<h3 id="importance-sampling"><a href="#importance-sampling" class="headerlink" title="importance sampling"></a>importance sampling</h3><p>Assume we”ve got a conditional distribution $q(y | x)$<br>s.t. (i) $p(x, y) &gt; 0 \Rightarrow q(y | x) &gt; 0$<br>(ii) $y \sim q(y | x)$ is tractable and<br>(iii) $q(y | x)$ is tractable</p>
<p>The importance weights $w(x,y) = \frac{p(x, y)}{q(y | x)}$</p>
<p><img src="/images/Importance_Sampling.png" alt="" title="image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></p>
<h3 id="从句子到语法树的seq2seq模型"><a href="#从句子到语法树的seq2seq模型" class="headerlink" title="从句子到语法树的seq2seq模型"></a>从句子到语法树的seq2seq模型</h3><p>其实从句子到语法的映射类似于一个seq2seq模型。而直接的把语法树以字符序列的形式表达，使用简单的 RNNs 直接构建句子到语法序列的 seq2seq 模型效果也不错，比如：<br>input:     The hungry cat meows .<br>output:    S( NP( _ _ _ ) VP( _ ) _ )<br>Vanilla RNNs 在模式匹配和计数方面非常出色，经验证明，训练有素的 seq2seq 模型通常会输出格式良好的字符串，见<a href="https://arxiv.org/abs/1412.7449" target="_blank" rel="noopener">这篇文章 section 3.2</a></p>
<p>但潜在的问题是，seq2seq 模型并不要求输出是有正确括号字符（数量对齐，位置正确）。另外，理论上单个RNN也只能记忆括号结构一定的有限深度，因为 RNNs 只有固定的有限数量的隐藏单元。例如，它将为这些输出分配非零概率：<br>S( NP( _ _ ) VP ( _ ) _ )<br>S( NP( _ _ _ ) VP ( _ ) _ ) ) )</p>
<p>理想情况下，模型应该给任何不完整的输出分配零概率。使用 RNNGs 是因为它本身能够履行这些限制， 保证生成完整正确的语法树。</p>
<p>从中可以看出，seq2seq模型可以用于快速原型和 baseline 搭建，但如果遇到要求输出遵守某些约束条件的问题，则需要直接执行这些约束条件。</p>
<h2 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h2><p>Parsing is a fundamental task in NLP. But what is parsing actually good for?</p>
<p>Parsing breaks up sentences into meaningful parts or finds meaningful relationships, which can then feed into downstream semantic tasks:<br>• semantic role labeling (figure out who did what do whom);<br>• semantic parsing (turn a sentence into a logical form);<br>• word sense disambiguation (figure out what the words in a sentence mean);<br>• compositional semantics (compute the meaning of a sentence based on the meaning of its parts).</p>
<h2 id="Semantic-role-labeling-SRL"><a href="#Semantic-role-labeling-SRL" class="headerlink" title="Semantic role labeling (SRL)"></a>Semantic role labeling (SRL)</h2><p>虽然可以使用 Distributional semantics 表达含义，只是 Distributional semantics 比较擅长处理相似度，且无法很明确地处理复合性 Compositionality。</p>
<blockquote>
<p>在数学、语义学和语言哲学中，复合性原理是指，一个复杂表达式的意义是由其各组成部分的意义以及用以结合它们的规则来决定的。</p>
</blockquote>
<p>为了能够处理复合性和推理，我们需要象征性和结构化的意义表示。</p>
<p>虽然语言是无穷无尽的，句子是无限的集合，而人脑的能力却是有限的，但人们总能够理解一个句子的含义（假如人们熟知表达句子的语言）. 因此, 对于 semantics, 语义肯定是有限的集合, 这样才能确定句子的确切意义.</p>
<blockquote>
<p>In generative grammar, a central principle of formal semantics is that the relation between syntax and semantics is <strong>compositional</strong>.</p>
</blockquote>
<blockquote>
<p>The principle of compositionality (Fregean Principle): The meaning of a complex expression is determined by the meanings of its parts and the way they are syntactically combined.</p>
</blockquote>
<p>Semantic role labeling means identifying the arguments (<strong>frame elements</strong>) that participate in a prototypical situation (frame) and labeling them with their roles;</p>
<p>SRL task is typically broken down into a sequence of sub-tasks:</p>
<ol>
<li>parse the training corpus;</li>
<li>match <strong>frame elements</strong> to constituents;</li>
<li>extract features from the parse tree;</li>
<li>train a probabilistic model on the features.</li>
</ol>
<p>所谓 frame elements 是针对 Frame Semantics 而言的。</p>
<p>SRL provides a shallow semantic analysis that can benefit various NLP applications; no parsing needed, no handcrafted features.</p>
<h3 id="Frame-Semantics"><a href="#Frame-Semantics" class="headerlink" title="Frame Semantics"></a>Frame Semantics</h3><p>表达词义，除了 Firth, J.R. (1957) 的 “a word is characterized by the company it keeps”（也即是 Distributional semantics）之外, 还有 Charles J. Fillmore 的 Frame Semantics.</p>
<blockquote>
<p>The basic idea is that one cannot understand the meaning of a single word without access to all the essential knowledge that relates to that word.</p>
</blockquote>
<blockquote>
<p>A semantic frame is a collection of facts that specify “characteristic features, attributes, and functions of a denotatum, and its characteristic interactions with things necessarily or typically associated with it.”</p>
</blockquote>
<blockquote>
<p>A semantic frame can also be defined as a coherent structure of related concepts that are related such that without knowledge of all of them, one does not have complete knowledge of any one; they are in that sense types of gestalt.</p>
</blockquote>
<h3 id="Proposition-Bank"><a href="#Proposition-Bank" class="headerlink" title="Proposition Bank"></a>Proposition Bank</h3><p>完整的句子表达了命题 propositions, 也即一个主张. 比如”John smokes”这个句子的命题如果是真的,那么”John”在这里一定是某个”smokes”的人, 也就是必须是<code>NP</code>.</p>
<blockquote>
<p>在现代哲学、逻辑学、语言学中，命题是指一个判断（陈述）的语义（实际表达的概念），这个概念是可以被定义并观察的现象。命题不是指判断（陈述）本身。当相异判断（陈述）具有相同语义的时候，他们表达相同的命题。例如，雪是白的（汉语）和Snow is white（英语）是相异的判断（陈述），但它们表达的命题是相同的。在同一种语言中，两个相异判断（陈述）也可能表达相同命题。例如，刚才的命题也可以说成冰的小结晶是白的，不过，之所以是相同命题，取决于冰的小结晶可视为雪的有效定义。</p>
</blockquote>
<p>PropBank is a version of the Penn Treebank annotated with semantic roles. More coarse-grained than Frame Semantics:<br><img src="/images/PropBank.png" alt="" title="Proposition Bank, Arg2–Arg4 are often verb specific. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l09.pdf"></p>
<h3 id="End-to-end-SRL-system"><a href="#End-to-end-SRL-system" class="headerlink" title="End-to-end SRL system"></a>End-to-end SRL system</h3><p>基本的结构单元是Bi-LSTM，用法是：<br>· a standard LSTM layer processes the input in forward direction;<br>· the output of this LSTM layer is the input to another LSTM layer, but in reverse direction;<br>这些Bi-LSTM单元可以叠加起来构造更深层的神经网络.</p>
<p>The input (processed word by word) features are:<br>• argument and predicate: the argument is the word being processed, the predicate is the word it depends on;<br>• predicate context (ctx-p): the words around the predicate; also used to distinguish multiple instances of the same predicate;<br>• region mark (m<sub>r</sub>): indicates if the argument is in the predicate context region or not;<br>• if a sequence has n<sub>p</sub> predicates it is processed n<sub>p</sub> times.</p>
<p>Output: semantic role label for the predicate/argument pair using IOB tags (inside, outside, beginning).<br><img src="/images/end_to_end_SRL.png" alt="" title="End to end SRL model. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l09.pdf"></p>
<p>Training:<br>• Word embeddings are used as input, not raw words;<br>• the embeddings for arguments, predicate, and ctx-p, as well as m<sub>r</sub> are <strong>concatenated</strong> and used as input for the Bi-LSTM;<br>• the output is passed through a conditional random field (CRF); allows to model dependencies between output labels;<br>• Viterbi decoding is used to compute the best output sequence</p>
<p>Model learns “syntax”(Maybe): it associates argument and predicate words using the forget gate:</p>
<h2 id="Semantic-Parsing"><a href="#Semantic-Parsing" class="headerlink" title="Semantic Parsing"></a>Semantic Parsing</h2><p>Semantic Parsing 指语义分析，把文本解析为任意的逻辑形式(一种 meaning representation)，比如 first-order logic(FOL).<br><code>Sam likes Casey</code> - <code>likes(Sam, Casey)</code>;<br><code>Anna&#39;s dog Mr. PeanutButter misses her</code> - <code>misses(MrPB, Anna) ∧ dog(MrPB)</code>;<br><code>Kim likes everyone</code> - <code>∀x.likes(x, Kim)</code>.<br>Predicate-argument structure is a good match for FOL, as well as structures with argument-like elements (e.g. NPs).<br>Determiners, quantifiers (e.g. “everyone”, “anyone”), and negation can be expressed in FOL.</p>
<p>However, much of natural language is unverifiable, ambiguous, non-canonical. That makes it hard to represent the wide-coverage meaning of arbitrary NL. Closed domains are easier, and can sometimes be harvested automatically, e.g. GEOQUERY dataset.</p>
<p>This leads to a proliferation of domain-specific MRs.<br>· Pairs of NL sentences with structured MR can be collected, e.g. IFTTT dataset (Quirk et al. 2015).<br>· WikiTableQuestions<br>· Google’s knowledge graph</p>
<p>Viewing MR as a string, semantic parsing is just conditional language modeling. Trainable alternative to compositional approaches: encoder-decoder neural models. The encoder and decoder can be mixed and matched: RNN, top-down tree RNN.<br><img src="/images/meaning_representation_model.png" alt="" title="Meaning representation model using standard sequence models. Since logical forms are treelike, can use treeLSTM decoder. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l10.pdf"></p>
<p>Works well on small, closed domains if we have training data, but there are many unsolved phenomena/ problems in semantics.</p>
<h3 id="Abstract-meaning-representation-AMR"><a href="#Abstract-meaning-representation-AMR" class="headerlink" title="Abstract meaning representation (AMR)"></a>Abstract meaning representation (AMR)</h3><p>• The edges (ARG0 and ARG1) are <label style="color:#C62828">relations</label><br>• Each node in the graph has a <label style="color:#BA68C8">variable</label><br>• They are labeled with <label style="color:#1565C0">concepts</label><br>• <label style="color:#BA68C8">d</label> / <label style="color:#1565C0">dog</label> means “<label style="color:#BA68C8">d</label> is an instance of <label style="color:#1565C0">dog</label>“<br><code>The dog is eating a bone</code><br>(<label style="color:#BA68C8">e</label> / <label style="color:#1565C0">eat-01</label><br>&nbsp;&nbsp;&nbsp;&nbsp;:<label style="color:#C62828">ARG0</label> (<label style="color:#BA68C8">d</label> / <label style="color:#1565C0">dog</label>)<br>&nbsp;&nbsp;&nbsp;&nbsp;:<label style="color:#C62828">ARG1</label> (<label style="color:#BA68C8">b</label> / <label style="color:#1565C0">bone</label>))</p>
<p><code>The dog wants to eat the bone</code><br>(want-01<br>&nbsp;&nbsp;&nbsp;&nbsp;:ARG0 (d / dog)<br>&nbsp;&nbsp;&nbsp;&nbsp;:ARG1 (e / eat-01<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:ARG0 d<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:ARG1 (b / bone)))</p>
<p><strong>Coreference</strong><br>Charles just graduated, and now Bob wants Anna to give <strong>him</strong> a job.<br>Q: who does <strong>him</strong> refer to?</p>
<p><strong>Metonymy</strong><br><strong>Westminster</strong> decided to distribute funds throughout England, Wales, Northern Island, and Scotland<br>decided(Parliament, …)</p>
<p><strong>Implicature</strong><br>That cake looks delicious - I would like a piece of that cake.</p>
<p>Even more phenomena…<br>• Abbreviations (e.g. National Health Service=NHS)<br>• Nicknames (JLaw=Jennifer Lawrence)<br>• Metaphor (crime is a virus infecting the city)<br>• Time expressions and change of state<br>• Many others</p>
<h2 id="TODO-指代消解-Coreference-Resolution"><a href="#TODO-指代消解-Coreference-Resolution" class="headerlink" title="TODO(指代消解 Coreference Resolution)"></a>TODO(指代消解 Coreference Resolution)</h2><h2 id="Unsupervised-Part-of-Speech-Tagging"><a href="#Unsupervised-Part-of-Speech-Tagging" class="headerlink" title="Unsupervised Part-of-Speech Tagging"></a>Unsupervised Part-of-Speech Tagging</h2><p>Parts-of-speech(POS), word classes, or syntactic categories, 一般指八个词性：noun, verb, adjective, adverb, pronoun, preposition, conjunction, interjection, 有时候是 numeral, article or determiner.<br>1, noun 名詞 ( n. )<br>2, pronoun 代名詞 ( pron. )<br>3, verb 動詞 ( v. )<br>4, adjective 形容詞 ( adj. )<br>5, adverb 副詞 ( adv. )<br>6, preposition 介系詞 ( prep. )<br>7, conjunction 連接詞 ( conj. )<br>8, interjection 感歎詞 ( int. )</p>
<p>Tagging is a task that take a sentence, assign each word a label indicating its syntactic category (part of speech).</p>
<p>One common standard label is Penn Treebank PoS tagset.</p>
<blockquote>
<p>DT - Determiner 定语<br>IN - Preposition or subord. conjunction<br>NN - Noun, singular or mass<br>NNS - Noun, plural<br>NNP - Proper noun, singular<br>RB - Adverb<br>TO - to<br>VB - Verb, base form<br>VBZ - Verb, 3rd person singular present</p>
</blockquote>
<p>In supervised POS tagging, the input is the text and a set of allowed POS labels. The training data contains input and output examples. The output is a guess, for each word in the test data, which POS label it should have.</p>
<p>A common approach is to use an HMM. To train it, choose parameters θ that maximize $P(x,y \mid θ)$, the probability of the training data given the parameters. This is <strong>maximum likelihood estimation</strong> and it was covered in <a href="">ANLP</a>. You can use the model to predict y for each x in the test data by solving $P(y \mid x,θ)$ using the <strong>Viterbi algorithm</strong>.</p>
<p>A consequence of supervised training with MLE is that the model will only learn <strong>non-zero probability</strong> for tag-word pairs that actually appear in the data. Hence, if “the” is only ever tagged with DT in the training data, then the model will learn that the probability of producing “the” from any other tag is zero. This means that many word tokens will be (empirically) unambiguous, which is one of the things that makes supervised POS tagging easy.</p>
<p>RNNs 虽然也可以处理序列模型, 但是神经网络需要目标函数, 没有目标无法计算损失, 就无法调整参数, 也就是”监督学习”.</p>
<p>Current PoS taggers are highly accurate (97% accuracy on Penn Treebank). But they require manually labelled training data, which for many major language is not available. Hence motivated for unsupervised PoS tagging.</p>
<p>In unsupervised POS tagging, the input is the text and <strong>the number of clusters</strong>. The training data contains only input examples. The output is a guess, for each word in the text, which cluster the word belongs to. For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number of clusters: 50</span><br><span class="line">Input x: The hungry cat meows</span><br><span class="line">Output y: 23 45 7 18</span><br></pre></td></tr></table></figure></p>
<p>What we hope is that the cluster labels will correlate with true POS labels; that is, that tokens labeled 23 will tend to be determiners, that clusters label 45 will tend to be adjectives, and so on.</p>
<p>这个时候可以使用隐马尔科夫模型, 这个”隐”就是针对没有目标可以参考这种情况.</p>
<h3 id="Hidden-Markov-Models"><a href="#Hidden-Markov-Models" class="headerlink" title="Hidden Markov Models"></a>Hidden Markov Models</h3><p>The unsupervised tagging models here are based on Hidden Markov Models (HMMs).<br><img src="/images/HMM.png" alt="" title="Hidden Markov Models (HMMs). image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l11.pdf"><br>To train it, choose parameters θ that maximize $P(x \mid θ)$, the probability of the training data given the parameters.</p>
<p>The parameters θ = (τ, ω) define:<br>• τ : the probability distribution over tag-tag transitions;<br>• ω: the probability distribution over word-tag outputs.<br>The parameters are sets of multinomial distributions:<br>• $ω = ω^{(1)} . . . ω^{(T)}$: the output distributions for each tag;<br>• $τ = τ^{(1)} . . . τ^{(T)}$: the transition distributions for each tag;<br>• $ω^{(t)} = ω_1^{(t)}. . . ω_W^{(t)}$: the output distribution from tag $t$;<br>• $τ^{(t)} = τ_1^{(t)}. . . τ_T^{(t)}$: the transition distribution from tag $t$.</p>
<p>Another way to write the model, often used in statistics and machine learning:</p>
<p>$w_i | t_i = t ∼ Multinomial(ω^{(t)})$</p>
<p>So as tag, given that $t_{i−1} = t$, the value of $t_i$ is drawn from a multinomial distribution with parameters $τ^{(t)}$.</p>
<p>How to estimate ω and τ without supervision. This is still maximum likelihood estimation, but notice that it’s more difficult because the tags y are unobserved, so you must marginalize them out.</p>
<p>For <strong>estimation</strong> (i.e., training the model, determining its parameters), we need a procedure to set θ based on data. Rely on Bayes Rule:<br>\begin{equation}\begin{split}<br>    P(θ|w)&amp;=\frac{P(w|θ)P(θ)}{P(w)}\\<br>    &amp;∝P(w|θ)P(θ)\\<br>\end{split}\end{equation}<br>Choose the θ that maximize the likelihood $P(w|θ)$. Basically, we ignore the prior. In most cases, this is equivalent to assuming a uniform prior.</p>
<p>To do this, you can use <strong>expectation maximization</strong> (EM), a variant of MLE that can cope with unobserved data, which was also covered in <a href="">ANLP</a>. For examples, forward-backward algorithm for HMMs, inside-outside algorithm for PCFGs, k-means clustering.</p>
<p>For <strong>inference</strong> (i.e., decoding, applying the model at test time), we need to know θ and then we can compute $P(t, w)$:<br><img src="/images/Inference_for_HMMs.png" alt="" title="Inference for HMMs. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l11.pdf"></p>
<p>E-step: use current estimate of θ to compute expected counts of hidden events ($n(t,t^{\prime})$, $n(t,w)$).<br>M-step: recompute θ using expected counts.</p>
<p>You can then use the trained model to predict y for each x in the test data by solving $P(y \mid x,θ)$ using the Viterbi algorithm.</p>
<p>But EM often fails, even very small amounts of training data have been show to work better than EM. One consequence of unsupervised training with EM is that every word can be assigned to any cluster label. This makes things really difficult, because it means every word is ambiguous. The basic assumptions of EM (that any tag-word or tag-tag distribution is equally likely) make this even more difficult.</p>
<p>Instead, use Bayesian HMM with Gibbs sampling.</p>
<h3 id="Bayesian-HMM"><a href="#Bayesian-HMM" class="headerlink" title="Bayesian HMM"></a>Bayesian HMM</h3><p>When training HMM model, we are not actually interested in the value of θ, we could simply integrate it out. This approach is called <strong>Bayesian integration</strong>. Integrating over θ gives us an average over all possible parameters values.</p>
<p>The Bayesian HMM is simply an alternative way to solve the unsupervised POS tagging problem. The input and output is the same. But instead of learning θ, we directly solve $P(y \mid x)$. Note that we don’t need to learn θ (though we could) - in this setting, we integrate it out, after first supplying some information about the tag-tag and word-tag distributions encoded in θ. Specifically, we tell the model that a sparse distribution is much more likely than a uniform distribution. We do this by defining a distribution $P(θ)$, and this gives us a new model,  $P(y,x \mid θ)×P(θ)$. By integrating out θ we can solve the unsupervised tagging problem directly.</p>
<p>Example: we want to predict a spinner result will be “a” or not?<br>• Parameter θ indicates spinner result: $P(θ = a) = .45$, $P(θ = b) = .35$, $P(θ = c) = .2$;<br>• define t = 1: result is “a”, t = 0: result is not “a”;<br>• make a prediction about one random variable (t) based on the value of another random variable (θ).</p>
<p><strong>Maximum likelihood approach</strong>: choose most probable θ, $\hat{θ} = a$, and $P(t = 1|\hat{θ}) = 1$, so we predict $t = 1$.</p>
<p><strong>Bayesian approach</strong>:<br>average over θ,<br>$P(t = 1) = \sum_θ P(t = 1|θ)P(θ) = 1(.45) + 0(.35) + 0(0.2) = .45$, predict t = 0.</p>
<p>Advantages of Bayesian integration:<br>• accounts for uncertainty as to the exact value of θ;<br>• models the shape of the distribution over θ;<br>• increases robustness: there may be a range of good values of θ;<br>• we can use priors favoring sparse solutions (more on this later).</p>
<p>Dirichlet distribution<br>Choosing the right prior can make integration easier. A $K$-dimensional Dirichlet with parameters $α = α_1 . . . α_K$ is defined as:</p>
<p>$$ P(θ) = \frac{1}{Z} \prod_{j=1}^K θ_j^{α_j−1} $$</p>
<p>We usually only use symmetric Dirichlets, where $α_1 . . . α_K$ are all equal to β. We write Dirichlet(β) to mean $Dirichlet(β, . . . , β)$.</p>
<p><img src="/images/Dirichlet_Distribution.png" alt="" title="A 2-dimensional symmetric Dirichlet(β) prior over θ = (θ1, θ2), β &gt; 1: prefer uniform distributions, β = 1: no preference, β &lt; 1: prefer sparse (skewed) distributions. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l11.pdf"><br>注意到这是一个二维的概率密度图. $β&gt;1$意味着更喜欢均值分布, 此时$θ$大概率落在$0.5$附近,因为$θ_1+θ_2=1$, 所以此时$θ_1, θ_2$概率均等. 如果$β=1$, $θ_1$的任何取值是等概率的, 等于说任何$θ_1,θ_2$的组合概率都是均等的.</p>
<p>To Bayesianize the HMM, we augment with it with symmetric Dirichlet priors:<br><img src="/images/Bayesianizing_the_HMM.png" alt="" title="image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l11.pdf"></p>
<p>To simplify things, use a bigram version of the Bayesian HMM; If we integrate out the parameters θ = (τ, ω), we get:<br><img src="/images/BHMM_Dirichlet_Distribution_.png" alt="" title="With T possible tags and Wt possible words with tag t. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l11.pdf"></p>
<p>Use these distributions to find $P(t|w)$ using an estimation method called <strong>Gibbs sampling</strong>.</p>
<p>Results: Integrating over parameters is useful in itself, even with uninformative priors $(α = β = 1)$;</p>
<p>总结：<br>· Bayesian HMM improves performance by averaging out uncertainty;<br>· allows us to use priors that favor sparse solutions as they occur in language data.<br>· Using a tag dictionary is also really helpful. We still have no labeled training data, but if we only allow each word to be tagged with one of the labels that appears in the dictionary, then most word-tag pairs will have probability zero. So this is a very different way of supplying information to the unsupervised model that is very effective.</p>
<h2 id="Bias-in-NLP"><a href="#Bias-in-NLP" class="headerlink" title="Bias in NLP"></a>Bias in NLP</h2><h3 id="The-social-impact-of-NLP"><a href="#The-social-impact-of-NLP" class="headerlink" title="The social impact of NLP"></a>The social impact of NLP</h3><p>Outcome of an NLP experiment can have a direct effect on people’s lives, e.g.</p>
<ol>
<li><a href="https://www.youtube.com/watch?v=p8phGxzUC_Y" target="_blank" rel="noopener">频繁出现亚马逊 Alexa 突然发出诡异笑声，给多名用户造成困惑和恐慌</a>, 因为人们谈话中偶然包含 trigger 词：”Alexa, laugh” 而发出 - 亚马逊的<a href="https://www.nytimes.com/2018/03/08/business/alexa-laugh-amazon-echo.html" target="_blank" rel="noopener">解决方案是把 trigger 改为更难触发的 “Alexa, can you laugh”</a></li>
<li>Chatbot 对于人们敏感问题的不恰当回答, 比如 “Should I kill myself?” - “Yes.”，这些回答对患有心理障碍的人群或者青少年儿童带来非常大的危害。</li>
<li><a href="https://www.theverge.com/2016/3/24/11297050/tay-microsoft-chatbot-racist" target="_blank" rel="noopener">Microsoft 的 AI chatbot 上线仅一天, 就通过 twitter 和人交谈并学会涉及种族, 性别歧视等的话语</a>, 典型的 “garbage in, garbage out” 现象.</li>
<li>其他涉及数据隐私等问题</li>
</ol>
<p><strong>语言的特性，导致NLP涉及的社会伦理问题非常多, 而且影响非常大</strong>：<br>· 语言传递着信息、偏见，是政治性的、权力的工具, 同时比其他技术带有更明显的拟人化、人格化倾向，这可能给个人生活带来不便或危害，给整个社会带来舆论影响。<br>· Any dataset carries demographic bias: latent information about the demographics of the people that produced it. That excludes people from other demographics.</p>
<p><strong>同时人类本身的认知容易加深偏见</strong>:<br>The <strong>availability heuristic</strong>: the more knowledge people have about a specific topic, the more important they think it must be. <strong>Topic overexposure</strong> creates biases that can lead to discrimination and reinforcement of existing biases. E.g. NLP focused on English may be self-reinforcing.</p>
<p><strong>NLP 实验本身容易加深偏见</strong>：<br>• Advanced grammar analysis can improve search and educational NLP, but also reinforce prescriptive linguistic norms.<br>• Stylometric analysis can help discover provenance of historical documents, but also unmask anonymous political dissenters.</p>
<p><strong>NLP 技术可能被不恰当地使用</strong>：<br>• Text classification and IR can help identify information of interest, but also aid censors.<br>• NLP can be used to discriminate fake reviews and news, and also to generate them.</p>
<h3 id="Word-embeddings-contain-human-like-biases"><a href="#Word-embeddings-contain-human-like-biases" class="headerlink" title="Word embeddings contain human-like biases"></a>Word embeddings contain human-like biases</h3><p>word2vec learns semantic/ syntactic relationships, also keep company with unsavoury stereotypes and biases?<br>• Man:Woman - King:Queen<br>• Man:Doctor - Woman:Nurse<br>• Man:Computer Programmer - Woman:Homemaker</p>
<p>Measure bias using implicit association tests:<br>1, Compute similarity of group1 and stereotype1 word embeddings. Cosine similarity is use to measure association (in place of reaction time).<br>2, Compute similarity of group1 and stereotype 2 word embeddings.<br>3, Null hypothesis: if group1 is not more strongly associated to one of the stereotypes, there will be no difference in the means.<br>4, Effect size measured using Cohen’s d.<br>5, Repeat for group 2.</p>
<p>Experiments<br>• Uses GloVe trained on Common Crawl—a large-scale crawl of the web.<br>• Removed low frequency names.<br>• Removed names that were least “name-like” (e.g. Will) algorithmically.<br>• Each concept is represented using a small set of words, designed for previous experiments in the psychology literature.</p>
<p>Result:<br>· flowers associate with pleasant, insects associate with unpleasant. $p &lt; 10^{−7}$<br>· Men’s names associate with career, women’s names associate with family. $p &lt; 10^{−3}$<br>· European American names associate with pleasant, African American names associate with unpleasant. $p &lt; 10^{−8}$</p>
<p>这些结果的确真实地反映人类社会的现状。但大部分性别方面的偏见其实是反映了目前的社会分工，无所谓高低贵贱；人种的偏见倒是反映了历史问题对现在的影响，这种偏见是不符合道德的。人对于其他生物的偏见，虽然是没必要的，但人类的确倾向于喜爱行为”可爱”，外形”美好”的生物，比如大熊猫就是比鳄鱼受欢迎。</p>
<p>偏见的存在不一定合理。哪些偏见是不合理的，才是人们更应该去思考和讨论的地方。</p>
<h3 id="Debiasing-word-embeddings"><a href="#Debiasing-word-embeddings" class="headerlink" title="Debiasing word embeddings"></a>Debiasing word embeddings</h3><p><a href="https://arxiv.org/abs/1607.06520" target="_blank" rel="noopener">Bolukbasi. et. al., 2016. Man is to Computer Programmer as Woman is to Homemaker? Debiasing Word Embeddings</a>提供了一个思路:</p>
<ol>
<li>确认偏见的方向</li>
<li>中和抵消偏见: 对于非定性的词（如”医生”），通过投射来消除偏见</li>
<li>等价：让<code>father - mother</code>和<code>boy - girl</code>等距，让定性词间的距离只有性别的距离；或者让<code>doctor - woman</code>和<code>doctor - man</code>等距，消除非定性词的性别偏见。</li>
</ol>
<p>什么词需要抵消偏见: 训练一个线性分类器来确定词是非定性还是非定性的, 结果当然是大部分英语词都是非定性的.</p>
<p>If analogies reveal a gender dimension, use analogies on specific seed pairs to find it.<br><img src="/images/Gender_subspace.png" alt="" title="Selected words projected along two axes: x is a projection onto the difference between the embeddings of the words he and she, and y is a direction learned in the embedding that captures gender neutrality, with gender neutral words above the line and gender specific words below the line. In this figure, the words above the horizontal line would all be collapsed to the vertical line. image from: Bolukbasi. et. al., 2016. Man is to Computer Programmer as Woman is to Homemaker? Debiasing Word Embeddings"><br>y 轴下面的词属于定性词, 不需要中性化, 而y轴之上的词则需要进行中性化处理.</p>
<p>不同的偏见, 需要不同的 seed words; 一种偏见, 可以有多种 seed words 选择: 除了用”She-He”作为性别偏见的基准, 还有其他选择.</p>
<h2 id="编码器—解码器-Sequence-to-sequence-和注意力机制"><a href="#编码器—解码器-Sequence-to-sequence-和注意力机制" class="headerlink" title="编码器—解码器 Sequence-to-sequence 和注意力机制"></a>编码器—解码器 Sequence-to-sequence 和注意力机制</h2><p>当输入输出都是不定长序列时, 比如机器翻译这种任务，需要使用 Sequence-to-sequence（seq2seq）或者 encoder-decoder 神经网络结构。这种结构可以通过一种方法叫注意力机制来显著提高性能。</p>
<h3 id="编码器—解码器-Sequence-to-sequence（seq2seq）"><a href="#编码器—解码器-Sequence-to-sequence（seq2seq）" class="headerlink" title="编码器—解码器 Sequence-to-sequence（seq2seq）"></a>编码器—解码器 Sequence-to-sequence（seq2seq）</h3><p>编码器：所谓编码，就是把不定长的输入序列输入RNN，以得出某种定长的编码信息。<br>解码器：所谓解码，就是把编码器编码后的信息（一般取编码器的RNN最终时刻的隐含层变量）输入到解码器的RNN中，每个t时刻的输出既取决于之前时刻（t-1）的输出又取决于编码信息。等同于一个以解码信息作为条件概率生成目标语言句子的语言模型。</p>
<p>所以 seq2seq 本质是一个条件概率语言模型：语言模型是指解码器每次会预测下一个出现的单词，条件概率是指预测是基于编码后的源句子。</p>
<h3 id="注意力"><a href="#注意力" class="headerlink" title="注意力"></a>注意力</h3><p>在传统的seq2seq模型中，解码器各个时刻都使用相同的编码信息，这就要求解码器把源输入序列的所有信息都解码并整合到最后时刻的隐含状态中，这个是很大的信息瓶颈。而人们知道，在实际任务中，比如机器翻译，目标句子的不同单词，一般只对应源句子的某一部分而已。如果能够让解码器在解码时，在不同时刻专注于源输入序列的不同部分，那么就可以突破这个瓶颈。</p>
<ol>
<li>对于解码器的每一时间步的隐含状态s<sub>t</sub>，可以衡量其与编码器的所有时间步隐含状态h<sub>0</sub>……e<sub>t</sub>的相似性(或score评分) <code>e = α(s, h)</code>，简单的评分方式是元素间相乘, <code>e = s*h</code>（<a href="https://arxiv.org/abs/1409.0473" target="_blank" rel="noopener">Bahanau的论文</a>提供了更复杂的形式), 也可以参考<a href="https://nlp.stanford.edu/pubs/emnlp15_attn.pdf" target="_blank" rel="noopener">论文Effective Approaches to Attention-based Neural Machine Translation</a>探讨的集中评分方式, 这篇论文提供了一种 Bilinear 形式的相似性评分法, 就是在s和h之间以点乘的形式插入一个交互矩阵 interaction matrix.</li>
<li>对得出的评分求加权平均<code>a = softmax(e)</code>, 得出的权值分布也称注意力权重</li>
<li>通过注意力权重把编码器隐含状态加权求和，得到注意力输出 <code>A = Σah</code></li>
<li>最后把注意力输出和对应时间步的解码器隐含状态s<sub>t</sub>拼接在一起 [A;s<sub>t</sub>]，作为解码器rnn的隐含层.</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/NOTE-ANLP-02-n-gram-model/" rel="next" title="自然语言处理快速入门 | 02 N-Gram 语言模型 - ANLP UoE 爱丁堡">
                <i class="fa fa-chevron-left"></i> 自然语言处理快速入门 | 02 N-Gram 语言模型 - ANLP UoE 爱丁堡
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/UoE-st/" rel="prev" title="Software Testing - Informatics - University of Edinburgh 爱丁堡大学">
                Software Testing - Informatics - University of Edinburgh 爱丁堡大学 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- Go to www.addthis.com/dashboard to customize your tools -->
<div class="addthis_inline_share_toolbox">
  <script type = "text/javascript" src = "//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5b35f789bd238372" async = "async" ></script>
</div>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Cong" />
            
              <p class="site-author-name" itemprop="name">Cong</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/congchan/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:shooterbeta@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#循环神经网络-RNNs"><span class="nav-number">1.</span> <span class="nav-text">循环神经网络 RNNs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RNNs-Backpropagation"><span class="nav-number">1.1.</span> <span class="nav-text">RNNs Backpropagation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#梯度消失与爆炸"><span class="nav-number">1.2.</span> <span class="nav-text">梯度消失与爆炸</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Long-Short-Term-Memory"><span class="nav-number">1.3.</span> <span class="nav-text">Long Short-Term Memory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gated-Recurring-Unit"><span class="nav-number">1.4.</span> <span class="nav-text">Gated Recurring Unit</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GRU-intuition"><span class="nav-number">1.4.1.</span> <span class="nav-text">GRU intuition</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不同RNNs变种的比较"><span class="nav-number">1.5.</span> <span class="nav-text">不同RNNs变种的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#门控循环神经网络的训练"><span class="nav-number">1.6.</span> <span class="nav-text">门控循环神经网络的训练</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bidirectional-RNNs"><span class="nav-number">1.7.</span> <span class="nav-text">Bidirectional RNNs</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Meaning-representations"><span class="nav-number">2.</span> <span class="nav-text">Meaning representations</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Four-kinds-of-vector-models"><span class="nav-number">2.1.</span> <span class="nav-text">Four kinds of vector models</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Word-representation-and-Word2vec"><span class="nav-number">2.2.</span> <span class="nav-text">Word representation and Word2vec</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目标函数-Obejective-funtion-cost-or-loss-function-J-θ"><span class="nav-number">2.2.1.</span> <span class="nav-text">目标函数 Obejective funtion (cost or loss function) J(θ):</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高频词二次采样-subsampling"><span class="nav-number">2.2.2.</span> <span class="nav-text">高频词二次采样 subsampling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Negative-sampling"><span class="nav-number">2.2.3.</span> <span class="nav-text">Negative sampling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#与传统的NLP方法比较"><span class="nav-number">2.2.4.</span> <span class="nav-text">与传统的NLP方法比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TODO-Glove"><span class="nav-number">2.2.5.</span> <span class="nav-text">TODO(Glove)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Morphological-Recursive-Neural-Network-morphoRNN"><span class="nav-number">2.3.</span> <span class="nav-text">Morphological Recursive Neural Network (morphoRNN)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Compositional-character-representations"><span class="nav-number">2.4.</span> <span class="nav-text">Compositional character representations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#哪种方式构建-subword-representations-比较好？"><span class="nav-number">2.4.1.</span> <span class="nav-text">哪种方式构建 subword representations 比较好？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multi-word-language-representations"><span class="nav-number">2.5.</span> <span class="nav-text">Multi-word language representations</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#神经网络语言模型"><span class="nav-number">3.</span> <span class="nav-text">神经网络语言模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环神经网络语言模型"><span class="nav-number">4.</span> <span class="nav-text">循环神经网络语言模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#神经网络语言模型的学习能力"><span class="nav-number">5.</span> <span class="nav-text">神经网络语言模型的学习能力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dependency-parsing"><span class="nav-number">6.</span> <span class="nav-text">Dependency parsing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Graph-based-dependency-parsing"><span class="nav-number">6.1.</span> <span class="nav-text">Graph-based dependency parsing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transition-based-dependency-parsing"><span class="nav-number">6.2.</span> <span class="nav-text">Transition-based dependency parsing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Comparing-MST-and-transition-based-parsers"><span class="nav-number">6.3.</span> <span class="nav-text">Comparing MST and transition-based parsers:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Recurrent-neural-network-grammars-RNNGs"><span class="nav-number">7.</span> <span class="nav-text">Recurrent neural network grammars (RNNGs)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Syntactic-Composition"><span class="nav-number">7.1.</span> <span class="nav-text">Syntactic Composition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implement-RNNGs"><span class="nav-number">7.2.</span> <span class="nav-text">Implement RNNGs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parameter-Estimation"><span class="nav-number">7.3.</span> <span class="nav-text">Parameter Estimation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Inference-problems-of-RNNGs"><span class="nav-number">7.4.</span> <span class="nav-text">Inference problems of RNNGs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#importance-sampling"><span class="nav-number">7.5.</span> <span class="nav-text">importance sampling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从句子到语法树的seq2seq模型"><span class="nav-number">7.6.</span> <span class="nav-text">从句子到语法树的seq2seq模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parsing"><span class="nav-number">8.</span> <span class="nav-text">Parsing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semantic-role-labeling-SRL"><span class="nav-number">9.</span> <span class="nav-text">Semantic role labeling (SRL)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Frame-Semantics"><span class="nav-number">9.1.</span> <span class="nav-text">Frame Semantics</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proposition-Bank"><span class="nav-number">9.2.</span> <span class="nav-text">Proposition Bank</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#End-to-end-SRL-system"><span class="nav-number">9.3.</span> <span class="nav-text">End-to-end SRL system</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semantic-Parsing"><span class="nav-number">10.</span> <span class="nav-text">Semantic Parsing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Abstract-meaning-representation-AMR"><span class="nav-number">10.1.</span> <span class="nav-text">Abstract meaning representation (AMR)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TODO-指代消解-Coreference-Resolution"><span class="nav-number">11.</span> <span class="nav-text">TODO(指代消解 Coreference Resolution)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsupervised-Part-of-Speech-Tagging"><span class="nav-number">12.</span> <span class="nav-text">Unsupervised Part-of-Speech Tagging</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hidden-Markov-Models"><span class="nav-number">12.1.</span> <span class="nav-text">Hidden Markov Models</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bayesian-HMM"><span class="nav-number">12.2.</span> <span class="nav-text">Bayesian HMM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bias-in-NLP"><span class="nav-number">13.</span> <span class="nav-text">Bias in NLP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-social-impact-of-NLP"><span class="nav-number">13.1.</span> <span class="nav-text">The social impact of NLP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Word-embeddings-contain-human-like-biases"><span class="nav-number">13.2.</span> <span class="nav-text">Word embeddings contain human-like biases</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Debiasing-word-embeddings"><span class="nav-number">13.3.</span> <span class="nav-text">Debiasing word embeddings</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编码器—解码器-Sequence-to-sequence-和注意力机制"><span class="nav-number">14.</span> <span class="nav-text">编码器—解码器 Sequence-to-sequence 和注意力机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编码器—解码器-Sequence-to-sequence（seq2seq）"><span class="nav-number">14.1.</span> <span class="nav-text">编码器—解码器 Sequence-to-sequence（seq2seq）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意力"><span class="nav-number">14.2.</span> <span class="nav-text">注意力</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cong</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://shootingspace.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/UoE-nlu/';
          this.page.identifier = 'UoE-nlu/';
          this.page.title = 'Natural Language Understanding - Informatics - University of Edinburgh 爱丁堡大学';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://shootingspace.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("KJ3aRNAv0BvPIe1SoKj9frht-gzGzoHsz", "gm1RJIiLJ5g6f6lmDxkpWzVG");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
