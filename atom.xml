<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Computer Science &amp; AI</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shukebeta.me/"/>
  <updated>2018-10-14T15:45:57.724Z</updated>
  <id>http://shukebeta.me/</id>
  
  <author>
    <name>Cong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NLP与信息处理 09 - 数据压缩 - 哈夫曼编码</title>
    <link href="http://shukebeta.me/NLP-09-data-compression-huffman-compression/"/>
    <id>http://shukebeta.me/NLP-09-data-compression-huffman-compression/</id>
    <published>2018-10-11T16:00:00.000Z</published>
    <updated>2018-10-14T15:45:57.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="避免歧义的编码"><a href="#避免歧义的编码" class="headerlink" title="避免歧义的编码"></a>避免歧义的编码</h2><p>在构建压缩编码的对应关系时，我们使用不同的数量的位来编码不同的字符. 比如摩斯密码<img src="/images/Morse_Code.png" alt="" title="Chart of the Morse code letters and numerals.">. 如果单纯使用这种对应关系，会出现一些问题， 如<code>•••−−−•••</code>会产生歧义: <code>SOS</code>? <code>V7</code>? <code>IAMIE</code>? <code>EEWNI</code>? 所以在实际使用中, 密码使用一些间隔来分隔代码字。</p><p>那么对于不同的压缩编码, 有什么常用方法来避免歧义？<br><a id="more"></a><br>方法是确保没有一个编码是另一个编码的前缀。比如</p><ul><li>使用固定长度编码。</li><li>为每个编码添加特殊的stop char。</li><li><strong>使用一种具备广泛使用性的prefix-free编码</strong>。</li></ul><p>用什么数据结构来设计prefix-free编码?</p><h3 id="用Trie构造编码"><a href="#用Trie构造编码" class="headerlink" title="用Trie构造编码"></a>用Trie构造编码</h3><p>一个二叉(<code>0, 1</code>)Trie: 叶节点是字符, 根节点到叶节点的路径就是编码.<img src="/images/huffman_trie.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"></p><p>压缩:<br>方法1：从叶开始; 按照路径到达根; 反向打印bits。<br>方法2：创建<code>键-值</code>对的符号表。</p><p>解压:</p><ol><li>从根节点开始, 根据位值是0还是1在Trie图上游走, 直到走到叶节点，则解压出一个字符</li><li>返回根节点, 继续第一步, 直到跑完所有编码.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> ch;   <span class="comment">// used only for leaf nodes</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> freq;  <span class="comment">// used only for compress</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> freq, Node left, Node right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.ch    = ch;</span><br><span class="line">      <span class="keyword">this</span>.freq  = freq;</span><br><span class="line">      <span class="keyword">this</span>.left  = left;</span><br><span class="line">      <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compare Nodes by frequency</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node that)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="keyword">return</span> <span class="keyword">this</span>.freq - that.freq;  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Runtime - Linear in input size N</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       Node root = readTrie(); <span class="comment">// read in encoding trie</span></span><br><span class="line">       <span class="keyword">int</span> N = BinaryStdIn.readInt(); <span class="comment">// read in number of chars</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">       &#123;</span><br><span class="line">          Node x = root;</span><br><span class="line">          <span class="keyword">while</span> (!x.isLeaf())</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="keyword">if</span> (!BinaryStdIn.readBoolean())</span><br><span class="line">                x = x.left;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                x = x.right;</span><br><span class="line">          &#125;</span><br><span class="line">          BinaryStdOut.write(x.ch, <span class="number">8</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       BinaryStdOut.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何读取一个Trie：根据Trie的前序遍历序列重构.<img src="/images/preorder_traversal_trie.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">readTrie</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (BinaryStdIn.readBoolean())</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">char</span> c = BinaryStdIn.readChar(<span class="number">8</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(c, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   Node x = readTrie();</span><br><span class="line">   Node y = readTrie();</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">'\0'</span>, <span class="number">0</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如何把Trie写为序列：以前序遍历的方式写Trie；额外用一个位标记是否叶节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTrie</span><span class="params">(Node x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (x.isLeaf())</span><br><span class="line">   &#123;</span><br><span class="line">      BinaryStdOut.write(<span class="keyword">true</span>);</span><br><span class="line">      BinaryStdOut.write(x.ch, <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   BinaryStdOut.write(<span class="keyword">false</span>);</span><br><span class="line">   writeTrie(x.left);</span><br><span class="line">   writeTrie(x.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="用哈夫曼算法构建最优编码"><a href="#用哈夫曼算法构建最优编码" class="headerlink" title="用哈夫曼算法构建最优编码"></a>用哈夫曼算法构建最优编码</h3><p>就是用Huffman算法. Huffman算法是把最短的编码赋给出现频率最高的字符, 把最长的编码留给出现频率较低的字符. 在Trie上的效果就变成频率最高的字符路径最短, 长路径都留给频率低的字符. 这样总的效果就是使用了更少的数据位来表达同样的信息.</p><ol><li>统计输入的各个字符的频率<code>freq[i]</code>。</li><li>为每个<code>char i</code>构建一个具有权重<code>freq[i]</code>的Trie(子节点为null), 从此节点开始</li><li>重复以下过程直到融合为一个trie(根节点)：<ul><li>选择当前权重最小的两Tries, <code>freq[i]</code>和<code>freq[j]</code>, 其中<code>i &lt;= j, freq[i] &lt;= freq[j]</code></li><li>给它们创建父节点, 权重为<code>freq[i] + freq[j]</code>, 两个子Trie和其父节点合并为一个Trie, 而且路径0(左边)总是指向较小的子Trie, 路径1(右边)指向较大的.</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">buildTrie</span><span class="params">(<span class="keyword">int</span>[] freq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinPQ&lt;Node&gt; pq = <span class="keyword">new</span> MinPQ&lt;Node&gt;();</span><br><span class="line">    <span class="comment">// initialize PQ with singleton tries</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="number">0</span>; i &lt; R; i++)</span><br><span class="line">       <span class="keyword">if</span> (freq[i] &gt; <span class="number">0</span>)</span><br><span class="line">          pq.insert(<span class="keyword">new</span> Node(i, freq[i], <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;  <span class="comment">// merge two smallest tries</span></span><br><span class="line">       Node x = pq.delMin();</span><br><span class="line">       Node y = pq.delMin();</span><br><span class="line">       Node parent = <span class="keyword">new</span> Node(<span class="string">'\0'</span>, x.freq + y.freq, x, y);</span><br><span class="line">       pq.insert(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.delMin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个算法, 可以保证频率最高(权重最大)的字符的叶节点就是最左叶节点, 一般编码为<code>0</code>, 其他依次类推. 可以证明Huffman算法生成的最优prefix-free编码.</p><p><a href="https://algs4.cs.princeton.edu/55compression/Huffman.java.html" target="_blank" rel="noopener">完整代码见</a></p><p>Implementation.<br>・Pass 1:  tabulate char frequencies and build trie.<br>・Pass 2:  encode file by traversing trie or lookup table</p><p>Running time. Using a binary heap ⇒ <code>N + R log R</code>. N input size, R alphabet size.</p><p>哈夫曼编码广泛应用于jpeg, pdf, MP3, MP4等文件编码中.</p><p>在神经网络中, 哈夫曼树也被用于构建层级Softmax.</p><p>一个使用Huffman Encoding的实例：<br><a href="https://github.com/congchan/cs106b-programming-abstraction/tree/master/HW6_Huffman%20Encoding/Huffman/src" target="_blank" rel="noopener">https://github.com/congchan/cs106b-programming-abstraction/tree/master/HW6_Huffman%20Encoding/Huffman/src</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;避免歧义的编码&quot;&gt;&lt;a href=&quot;#避免歧义的编码&quot; class=&quot;headerlink&quot; title=&quot;避免歧义的编码&quot;&gt;&lt;/a&gt;避免歧义的编码&lt;/h2&gt;&lt;p&gt;在构建压缩编码的对应关系时，我们使用不同的数量的位来编码不同的字符. 比如摩斯密码&lt;img src=&quot;/images/Morse_Code.png&quot; alt=&quot;&quot; title=&quot;Chart of the Morse code letters and numerals.&quot;&gt;. 如果单纯使用这种对应关系，会出现一些问题， 如&lt;code&gt;•••−−−•••&lt;/code&gt;会产生歧义: &lt;code&gt;SOS&lt;/code&gt;? &lt;code&gt;V7&lt;/code&gt;? &lt;code&gt;IAMIE&lt;/code&gt;? &lt;code&gt;EEWNI&lt;/code&gt;? 所以在实际使用中, 密码使用一些间隔来分隔代码字。&lt;/p&gt;
&lt;p&gt;那么对于不同的压缩编码, 有什么常用方法来避免歧义？&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Information Retrieval" scheme="http://shukebeta.me/tags/Information-Retrieval/"/>
    
      <category term="Data Compression" scheme="http://shukebeta.me/tags/Data-Compression/"/>
    
      <category term="Huffman Compression" scheme="http://shukebeta.me/tags/Huffman-Compression/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 08 - 数据压缩 - Run Length Encoding</title>
    <link href="http://shukebeta.me/NLP-08-data-compression-run-length-encoding/"/>
    <id>http://shukebeta.me/NLP-08-data-compression-run-length-encoding/</id>
    <published>2018-10-10T16:00:00.000Z</published>
    <updated>2018-10-11T07:41:54.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Run-length-encoding"><a href="#Run-length-encoding" class="headerlink" title="Run-length encoding"></a>Run-length encoding</h2><p>Simple type of redundancy in a bitstream. Long runs of repeated bits：<br><code>0000000000000001111111000000011111111111</code><br>Compression, 4-bit counts to represent alternating runs of 0s and 1s: 15 0s, then 7 1s, then 7 0s, then 11 1s.<br><code>1111 0111 0111 1011</code><br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunLength</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// maximum run-length count</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> R    = <span class="number">256</span>;</span><br><span class="line">   <span class="comment">// number of bits per count</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> LG_R = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads a sequence of bits from standard input; compresses</span></span><br><span class="line"><span class="comment">     * them using run-length coding with 8-bit run lengths; and writes the</span></span><br><span class="line"><span class="comment">     * results to standard output.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> run = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> old = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!BinaryStdIn.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> b = BinaryStdIn.readBoolean();</span><br><span class="line">            <span class="keyword">if</span> (b != old) &#123;</span><br><span class="line">                BinaryStdOut.write(run, LG_R);</span><br><span class="line">                run = <span class="number">1</span>;</span><br><span class="line">                old = !old;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 如果长度超过最大值, 写入0</span></span><br><span class="line">                <span class="keyword">if</span> (run == R-<span class="number">1</span>) &#123;</span><br><span class="line">                    BinaryStdOut.write(run, LG_R);</span><br><span class="line">                    run = <span class="number">0</span>;</span><br><span class="line">                    BinaryStdOut.write(run, LG_R);</span><br><span class="line">                &#125;</span><br><span class="line">                run++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryStdOut.write(run, LG_R);</span><br><span class="line">        BinaryStdOut.close();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads a sequence of bits from standard input (that are encoded</span></span><br><span class="line"><span class="comment">     * using run-length encoding with 8-bit run lengths); decodes them;</span></span><br><span class="line"><span class="comment">     * and writes the results to standard output.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> bit = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">while</span> (!BinaryStdIn.isEmpty())</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">int</span> run = BinaryStdIn.readInt(lgR);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; run; i++)</span><br><span class="line">            BinaryStdOut.write(bit);</span><br><span class="line">         bit = !bit;</span><br><span class="line">      &#125;</span><br><span class="line">      BinaryStdOut.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Run-length-encoding&quot;&gt;&lt;a href=&quot;#Run-length-encoding&quot; class=&quot;headerlink&quot; title=&quot;Run-length encoding&quot;&gt;&lt;/a&gt;Run-length encoding&lt;/h2&gt;&lt;p&gt;Simple type of redundancy in a bitstream. Long runs of repeated bits：&lt;br&gt;&lt;code&gt;0000000000000001111111000000011111111111&lt;/code&gt;&lt;br&gt;Compression, 4-bit counts to represent alternating runs of 0s and 1s: 15 0s, then 7 1s, then 7 0s, then 11 1s.&lt;br&gt;&lt;code&gt;1111 0111 0111 1011&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Information Retrieval" scheme="http://shukebeta.me/tags/Information-Retrieval/"/>
    
      <category term="Data Compression" scheme="http://shukebeta.me/tags/Data-Compression/"/>
    
      <category term="Run Length Encoding" scheme="http://shukebeta.me/tags/Run-Length-Encoding/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 07 - 数据压缩</title>
    <link href="http://shukebeta.me/NLP-07-data-compression-introduction/"/>
    <id>http://shukebeta.me/NLP-07-data-compression-introduction/</id>
    <published>2018-10-09T16:00:00.000Z</published>
    <updated>2018-10-11T12:13:28.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><p>压缩数据以节省储存空间，节省传输时间。同时很多文件都有很多冗余信息，这为压缩提供了很多可能性。<br><a id="more"></a><br>通用文件压缩<br>·文件：GZIP，BZIP，7z<br>·Archivers：PKZIP<br>·文件系统：NTFS，HFS +，ZFS</p><p>多媒体<br>·图像：GIF，JPEG<br>·声音：MP3<br>·视频：MPEG，DivX™，HDTV</p><p>通讯<br>·ITU-T T4 Group 3 Fax<br>·V.42bis调制解调器<br>·Skype</p><p>数据库</p><h3 id="压缩率"><a href="#压缩率" class="headerlink" title="压缩率"></a>压缩率</h3><p><code>Compression ratio = Bits in Compressed B / bits in B</code>.</p><blockquote><p>自然语言的压缩率为50-75％或更高.</p></blockquote><h3 id="读写二进制"><a href="#读写二进制" class="headerlink" title="读写二进制"></a>读写二进制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BinaryStdIn &#123;</span><br><span class="line">    boolean readBoolean() // read 1 bit of data and return as a boolean value</span><br><span class="line">    char readChar() // read 8 bits of data and return as a char value</span><br><span class="line">    char readChar(int r) // read r bits of data and return as a char value</span><br><span class="line">    // similar methods for byte (8 bits); short (16 bits); int (32 bits); long and double (64 bits)</span><br><span class="line">    boolean isEmpty() // is the bitstream empty?</span><br><span class="line">    void close() // close the bitstream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BinaryStdOut &#123;</span><br><span class="line">    void write(boolean b) // write the specified bit</span><br><span class="line">    void write(char c) // write the specified 8-bit char</span><br><span class="line">    void write(char c, int r) // write the r least significant bits of the specified char</span><br><span class="line">    // similar methods for byte (8 bits); short (16 bits); int (32 bits); long and double (64 bits)</span><br><span class="line">    void close() // close the bitstream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如使用三种方法表达<code>12/31/1999</code><br>1, A character stream (StdOut),<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StdOut.print(month + <span class="string">"/"</span> + day + <span class="string">"/"</span> + year);</span><br></pre></td></tr></table></figure></p><p><code>00110001</code> 1<br><code>00110010</code> 2<br><code>00101111</code> /<br><code>00110111</code> 3<br><code>00110001</code> 1<br><code>00101111</code> /<br><code>00110001</code> 1<br><code>00111001</code> 9<br><code>00111001</code> 9<br><code>00111001</code> 1<br>共 80bits<br>2, Three ints (BinaryStdOut)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BinaryStdOut.write(month);</span><br><span class="line">BinaryStdOut.write(day);</span><br><span class="line">BinaryStdOut.write(year);</span><br></pre></td></tr></table></figure></p><p><code>00000000 00000000 00000000 00001100</code> 12<br><code>00000000 00000000 00000000 00011111</code> 31<br><code>00000000 00000000 00000111 11001111</code> 1999<br>共96bits<br>3，A 4-bit field, a 5-bit field, and a 12-bit field (BinaryStdOut)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BinaryStdOut.write(month, <span class="number">4</span>);</span><br><span class="line">BinaryStdOut.write(day, <span class="number">5</span>);</span><br><span class="line">BinaryStdOut.write(year, <span class="number">12</span>);</span><br></pre></td></tr></table></figure></p><p><code>1100</code> 12<br><code>11111</code> 13<br><code>0111110 01111</code> 1999<br>共21bits</p><h3 id="通用数据压缩算法？"><a href="#通用数据压缩算法？" class="headerlink" title="通用数据压缩算法？"></a>通用数据压缩算法？</h3><p>不存在的，因为假如真的存在一种可以压缩所有比特串的算法，那么该算法就可以继续压缩已经被它压缩过的数据，那意味着所有比特串可以被压缩为0比特.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据压缩&quot;&gt;&lt;a href=&quot;#数据压缩&quot; class=&quot;headerlink&quot; title=&quot;数据压缩&quot;&gt;&lt;/a&gt;数据压缩&lt;/h2&gt;&lt;p&gt;压缩数据以节省储存空间，节省传输时间。同时很多文件都有很多冗余信息，这为压缩提供了很多可能性。&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Information Retrieval" scheme="http://shukebeta.me/tags/Information-Retrieval/"/>
    
      <category term="Data Compression" scheme="http://shukebeta.me/tags/Data-Compression/"/>
    
  </entry>
  
  <entry>
    <title>机器阅读理解 - 自注意力机制</title>
    <link href="http://shukebeta.me/NLP-attention-03-self-attention/"/>
    <id>http://shukebeta.me/NLP-attention-03-self-attention/</id>
    <published>2018-10-02T16:00:00.000Z</published>
    <updated>2018-10-15T03:20:24.367Z</updated>
    
    <content type="html"><![CDATA[<p>计算注意力主要分为三个步骤。</p><ol><li>计算query和每个key之间的相似性以获得权重。常用的相似性函数包括点积，拼接，检测器等。</li><li>然后通常是使用softmax函数来正则化这些权重。</li><li>最后将这些权重与相应的value一起加权并获得最终的注意力。</li></ol><p>在大部分NLP任务中，key一般就是value。</p><p>在前面的介绍中， 注意力机制一般都是附加于seq2seq或者encoder-decoder架构中。但这篇2017 NIPS的文章<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Attention is all you need</a>提出了自注意力机制. 与过去流行的使用基于RNN的Seq2Seq模型框架不同:</p><ol><li>文章中使用注意机制完全取代了RNN来构建整个模型框架。</li><li>Multi-Headed Attention Mechanism: 在编码器和解码器中使用 Multi-Headed self-attention。</li><li>比LSTM更快的计算速度。</li></ol><p>文章的实验数据暂且不论，其提出的核心想法很重要，就是LSTM这种时序模型速度实在是太慢了，很难应用到超大规模的数据和线上的应用中。Google因其自身业务的大规模性质，本身是很工程化的。所以他们非常反感需要繁琐特征提取的任务，所以他们早早就转投了神经网络。也非常不看好繁琐的神经网络，特别是那些无法并行化计算的。</p><p>近些年来，RNN（及其变种 LSTM, GRU）已成为很多nlp任务如机器翻译的经典网络结构。RNN从左到右或从右到左的方式顺序处理语言。RNN的按顺序处理的性质也使得其更难以充分利用现代快速计算设备，例如GPU等优于并行而非顺序处理的计算单元。虽然卷积神经网络（CNN）的时序性远小于RNN，但CNN体系结构如ByteNet或ConvS2S中，糅合远距离部分的信息所需的步骤数仍随着距离的增加而增长。</p><p>因为一次处理一个单词，RNN需要处理多个时序的单词来做出依赖于长远离单词的决定。但各种研究和实验逐渐表明，决策需要的步骤越多，循环网络就越难以学习如何做出这些决定。而本身LSTM就是为了解决long term dependency问题，但是解决得并不好。很多时候还需要额外加一层注意力层来处理long term dependency。</p><p>所以这次他们直接在编码器和解码器之间直接用attention，这样句子单词的依赖长度最多只有1，减少了信息传输路径。他们称之为Transformer。Transformer只执行一小段constant的步骤（根据经验选择）。在每个步骤中，应用self-attention机制，直接模拟句子中所有单词之间的关系，不管它们之间的位置如何。比如子“I arrived at the bank after crossing the river”，要确定“bank”一词是指河岸而不是金融机构，Transformer可以学会立即关注“river”这个词并在一步之内做出这个决定。</p><h3 id="Transformer总体架构"><a href="#Transformer总体架构" class="headerlink" title="Transformer总体架构"></a>Transformer总体架构</h3><p>Seq2seq神经网络通常包含读取输入句子并生成其表达的编码器。具体地说，为了计算给定单词的下一个表示 - 例如“bank” - Transformer将其与句子中的所有其他单词进行比较。这些比较的结果就是其他单词的注意力权重。这些注意力权重决定了其他单词应该为“bank”的下一个表达做出多少贡献。在计算“bank”的新表示时，能够消除歧义的“river”可以获得跟高的关注。将注意力权重用来加权平均所有单词的表达，然后将加权平均的表达喂给一个全连接网络以生成“bank”的新表达，以反映出该句子正在谈论的是“河岸”。<img src="transform20fps.gif" alt="" title="image from: https://ai.googleblog.com/2017/08/transformer-novel-neural-network.html"><br>Transformer的解码阶段概括起来就是：首先为每个单词生成初始表达或embeddings。这些由空心圆表示。然后，使用自我注意力，聚合来自所有其他单词的信息，生成参考了整个上下文的每个单词的新表达，由实心球表示。不断对每个单词并行地重复这个步骤多次，连续地生成新的表达。</p><p>解码器操作类似，只是从左到右依次生成一个字。它不仅关注先前生成的单词，而且还参考编码器生成的最终表示。</p><p><img src="/images/transformer.png" alt="" title="单层编码器（左）和解码器（右），由 N = 6 个相同的层构建。"><br><code>N = 6</code>实际超过6层。这些“层”中的每一个实际上由两层组成：position-wise FNN 和一个（编码器），或两个（解码器），基于注意力的子层。其中每个还包含4个线性投影和注意逻辑。</p><p>编码器:</p><ol><li>Stage 1 - 输入编码: 序列的顺序信息是非常重要的。由于没有循环，也没有卷积，因此使用“位置编码”表示序列中每个标记的绝对（或相对）位置的信息。<ul><li>位置编码信息 + embedded input</li></ul></li><li>Stage 2 – Multi-head attention 和 Stage 3 – position-wise FFN. 两个阶段都是用来残差连接, 接着正则化输出层</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stage1_out = Embedding512 + TokenPositionEncoding512</span><br><span class="line">Stage2_out = layer_normalization(multihead_attention(Stage1_out) + Stage1_out)</span><br><span class="line">Stage3_out = layer_normalization(FFN(Stage2_out) + Stage2_out)</span><br><span class="line"></span><br><span class="line">out_enc = Stage3_out</span><br></pre></td></tr></table></figure><p>解码器的架构类似，但它在第3阶段采用了附加层, 在输出层上的 mask multi-head attention:</p><ol><li>Stage 1 – 输入解码: 输入 output embedding，偏移一个位置以确保对位置<code>i</code>的预测仅取决于<code>&lt; i</code>的位置。</li><li>Stage 2 - Masked Multi-head attention: 稍作修改以防止注意到后续位置。</li></ol><p>阶段2,3和4同样使用了残差连接，然后在输出使用归一化层。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Stage1_out = OutputEmbedding512 + TokenPositionEncoding512</span><br><span class="line"></span><br><span class="line">Stage2_Mask = masked_multihead_attention(Stage1_out)</span><br><span class="line">Stage2_Norm1 = layer_normalization(Stage2_Mask) + Stage1_out</span><br><span class="line">Stage2_Multi = multihead_attention(Stage2_Norm1 + out_enc) +  Stage2_Norm1</span><br><span class="line">Stage2_Norm2 = layer_normalization(Stage2_Multi) + Stage2_Multi</span><br><span class="line"></span><br><span class="line">Stage3_FNN = FNN(Stage2_Norm2)</span><br><span class="line">Stage3_Norm = layer_normalization(Stage3_FNN) + Stage2_Norm2</span><br><span class="line"></span><br><span class="line">out_dec = Stage3_Norm</span><br></pre></td></tr></table></figure></p><p>可以利用开源的<a href="https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/transformer.py" target="_blank" rel="noopener">Tensor2Tensor</a>，通过调用几个命令来训练Transformer网络进行翻译和解析。</p><h3 id="各个技术细节"><a href="#各个技术细节" class="headerlink" title="各个技术细节"></a>各个技术细节</h3><p>Positional Encoding – PE<br>Attention<br>Scaled Dot-Product Attention<br>Multi-head attention<br>Self-Attention (SA)<br>Position-wise FFN</p><h3 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h3><p>作者已经进行了一系列测试（论文表3），其中他们讨论N = 6层的建议，模型大小为512，基于h = 8个heads，键值维度为64，使用100K步。</p><p>还指出，由于模型质量随着$d_k$（行B）的减小而降低，因此可以进一步优化点积兼容性功能。</p><p>其声称提出的固定正弦位置编码，与学习到的位置编码相比，产生几乎相等的分数。</p><h3 id="算法适合哪些类型的问题？"><a href="#算法适合哪些类型的问题？" class="headerlink" title="算法适合哪些类型的问题？"></a>算法适合哪些类型的问题？</h3><ul><li>序列转导（语言翻译）</li><li>语法选区解析的经典语言分析任务 syntactic constituency parsing</li><li>共指消解 coreference resolution</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://research.googleblog.com/2017/08/transformer-novel-neural-network.html" target="_blank" rel="noopener">https://research.googleblog.com/2017/08/transformer-novel-neural-network.html</a><br><a href="https://research.googleblog.com/2017/06/accelerating-deep-learning-research.html" target="_blank" rel="noopener">https://research.googleblog.com/2017/06/accelerating-deep-learning-research.html</a><br><a href="https://mchromiak.github.io/articles/2017/Sep/12/Transformer-Attention-is-all-you-need/#positional-encoding-pe" target="_blank" rel="noopener">https://mchromiak.github.io/articles/2017/Sep/12/Transformer-Attention-is-all-you-need/#positional-encoding-pe</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算注意力主要分为三个步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算query和每个key之间的相似性以获得权重。常用的相似性函数包括点积，拼接，检测器等。&lt;/li&gt;
&lt;li&gt;然后通常是使用softmax函数来正则化这些权重。&lt;/li&gt;
&lt;li&gt;最后将这些权重与相应的value一起
      
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 06 - 不同树结构的字符串符号表</title>
    <link href="http://shukebeta.me/NLP-06-string-symbol-table-other-Trie/"/>
    <id>http://shukebeta.me/NLP-06-string-symbol-table-other-Trie/</id>
    <published>2018-09-30T16:00:00.000Z</published>
    <updated>2018-10-09T15:20:32.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="各种树的变种"><a href="#各种树的变种" class="headerlink" title="各种树的变种"></a>各种树的变种</h2><p>为了适应不同的应用场景, 人们使用不同的树结构来实现符号表.</p><h3 id="九宫格输入法"><a href="#九宫格输入法" class="headerlink" title="九宫格输入法"></a>九宫格输入法</h3><p>对于手机的九宫格输入法, 简单的实现方式是多次敲击: 通过反复按键输入一个字母，直到出现所需的字母。<br><a id="more"></a><br>但 <a href="http://www.t9.com/" target="_blank" rel="noopener">http://www.t9.com/</a> 的 T9 texting 支持更高效的输入方法:<br>・Find all words that correspond to given sequence of numbers.<br>・Press 0 to see all completion options.<br><img src="/images/t9.png" alt=""><br>Ex. hello<br>・多次敲击: 4 4 3 3 5 5 5 5 5 5 6 6 6<br>・T9: 4 3 5 5 6</p><p>可以使用 8-way trie 来实现.</p><h3 id="三元搜索Trie"><a href="#三元搜索Trie" class="headerlink" title="三元搜索Trie"></a>三元搜索Trie</h3><p><code>R</code>较大的R-way trie的空间效率不高，读取比较大的文件往往导致内存不足。但弊端是开辟出的数组内存利用率其实不高。现在很多系统都使用Unicode，分支可高达<code>65,536</code>. 所以需要更高效的方法。</p><p>Ternary search tries:<br>・Store characters and values in nodes (not keys).<br>・Each node has 3 children: smaller (left), equal (middle), larger (right).<br><img src="/images/tst.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br>Search in a TST: Follow links corresponding to each character in the key.<br>・If less, take left link; if greater, take right link.<br>・If equal, take the middle link and move to the next key character.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TST</span>&lt;<span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Value val;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">private</span> Node left, mid, right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Value val)</span></span></span><br><span class="line"><span class="function">    </span>&#123; root = put(root, key, val, <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, String key, Value val, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123; x = <span class="keyword">new</span> Node(); x.c = c; &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; x.c) x.left = put(x.left, key, val, d);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; x.c) x.right = put(x.right, key, val, d);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; key.length() - <span class="number">1</span>) x.mid = put(x.mid, key, val, d+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> x.val = val;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> get(key) != <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node x = get(root, key, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">get</span><span class="params">(Node x, String key, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">         <span class="keyword">if</span> (c &lt; x.c) <span class="keyword">return</span> get(x.left, key, d);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; x.c) <span class="keyword">return</span> get(x.right, key, d);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; key.length() - <span class="number">1</span>) <span class="keyword">return</span> get(x.mid, key, d+<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>TSTs比hashing更快（特别是对于搜索缺失键的情况）。</p><h3 id="基数树"><a href="#基数树" class="headerlink" title="基数树"></a>基数树</h3><p>Radix Tree, 也叫 Patricia trie (Practical Algorithm to Retrieve Information Coded in Alphanumeric), crit-bit tree, 压缩前缀树:<br>・Remove one-way branching.<br>・Each node represents a sequence of characters.<br>・Implementation: one step beyond this course.<br><img src="/images/radix_trie.png" alt="" title="put(&quot;shells&quot;, 1); put(&quot;shellfish&quot;, 2); image from: https://algs4.cs.princeton.edu/"><br>对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。</p><p>Applications.<br>・Database search.<br>・P2P network search.<br>・IP routing tables: find longest prefix match.<br>・Compressed quad-tree for N-body simulation.<br>・Efficiently storing and querying XML documents.</p><h3 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h3><p>后缀树（Suffix tree）指字符串后缀的基数树: 一个<code>String S</code>的后缀树是一个边（edge）被标记为字符串的树。因此每一个<code>S</code>的后缀都唯一对应一条从根节点到叶节点的路径。这样就形成了一个<code>S</code>的后缀的基数树。<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Suffix_tree_BANANA.svg/250px-Suffix_tree_BANANA.svg.png" alt="" title="image from: https://en.wikipedia.org/"></p><p>Applications.<br>・Linear-time: longest repeated substring, longest common substring, longest palindromic substring, substring search, tandem repeats, ….<br>・Computational biology databases (BLAST, FASTA).</p><h2 id="字符符号表总结"><a href="#字符符号表总结" class="headerlink" title="字符符号表总结"></a>字符符号表总结</h2><p>Red-black BST.<br>・Performance guarantee: log N key compares.<br>・Supports ordered symbol table API.</p><p>Hash tables.<br>・Performance guarantee: constant number of probes.<br>・Requires good hash function for key type.</p><p>Tries. R-way, TST.<br>・Performance guarantee: log N characters accessed.<br>・Supports character-based operations.<br><img src="/images/string_symbol_table_cost_sum.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"></p><blockquote><p>You can get at anything by examining 50-100 bits</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;各种树的变种&quot;&gt;&lt;a href=&quot;#各种树的变种&quot; class=&quot;headerlink&quot; title=&quot;各种树的变种&quot;&gt;&lt;/a&gt;各种树的变种&lt;/h2&gt;&lt;p&gt;为了适应不同的应用场景, 人们使用不同的树结构来实现符号表.&lt;/p&gt;
&lt;h3 id=&quot;九宫格输入法&quot;&gt;&lt;a href=&quot;#九宫格输入法&quot; class=&quot;headerlink&quot; title=&quot;九宫格输入法&quot;&gt;&lt;/a&gt;九宫格输入法&lt;/h3&gt;&lt;p&gt;对于手机的九宫格输入法, 简单的实现方式是多次敲击: 通过反复按键输入一个字母，直到出现所需的字母。&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Trie" scheme="http://shukebeta.me/tags/Trie/"/>
    
      <category term="Information Retrieval" scheme="http://shukebeta.me/tags/Information-Retrieval/"/>
    
      <category term="Symbol table" scheme="http://shukebeta.me/tags/Symbol-table/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 05 - 字符串符号表和三元搜索Trie</title>
    <link href="http://shukebeta.me/NLP-05-string-symbol-table-Trie/"/>
    <id>http://shukebeta.me/NLP-05-string-symbol-table-Trie/</id>
    <published>2018-09-29T16:00:00.000Z</published>
    <updated>2018-09-30T09:02:12.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><blockquote><p>在计算机科学中，符号表是一种用于语言翻译器（例如编译器和解释器）中的数据结构。在符号表中，程序源代码中的每个标识符都和它的声明或使用信息绑定在一起，比如其数据类型、作用域以及内存地址。<br>常用哈希表来实现.</p></blockquote><p>符号表的应用非常广泛, 可用于实现Set, Dictionary, 文件索引, 稀疏向量/矩阵等数据结构和相关的运算操作, 还有其他如过滤查询(Exception filter), 一致性查询(concordance queries)等操作.</p><p>字符符号表就是专门针对字符操作的符号表, API:<br>Prefix match - Keys with prefix <code>sh</code>: <code>she</code>, <code>shells</code>, and <code>shore</code>.<br>Wildcard match - Keys that match <code>.he</code>: <code>she</code> and <code>the</code>.<br>Longest prefix - Key that is the longest prefix of <code>shellsort</code>: <code>shells</code>.<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StringST</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    StringST(); create a symbol table with string keys</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Value val)</span></span>; put key-value pair into the symbol table</span><br><span class="line">    <span class="function">Value <span class="title">get</span><span class="params">(String key)</span></span>; value paired with key</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(String key)</span></span>; delete key and corresponding value</span><br><span class="line">    <span class="function">Iterable&lt;String&gt; <span class="title">keys</span><span class="params">()</span></span>; all keys</span><br><span class="line">    <span class="function">Iterable&lt;String&gt; <span class="title">keysWithPrefix</span><span class="params">(String s)</span></span>; keys having s as a prefix</span><br><span class="line">    <span class="function">Iterable&lt;String&gt; <span class="title">keysThatMatch</span><span class="params">(String s)</span></span>; <span class="function">keys that match <span class="title">s</span> <span class="params">(where . is a wildcard)</span></span></span><br><span class="line"><span class="function">    String <span class="title">longestPrefixOf</span><span class="params">(String s)</span></span>; longest key that is a prefix of s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="以Trie为基础的字符符号表"><a href="#以Trie为基础的字符符号表" class="headerlink" title="以Trie为基础的字符符号表"></a>以Trie为基础的字符符号表</h3><p>algs4中提供了用 R-way trie 来实现符号表(symbol table)例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieST</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">256</span>; <span class="comment">// extended ASCII</span></span><br><span class="line">    <span class="keyword">private</span> Node root = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object value;</span><br><span class="line">        <span class="keyword">private</span> Node[] next = <span class="keyword">new</span> Node[R];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Value val)</span> </span>&#123;</span><br><span class="line">        root = put(root, key, val, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, String key, Value val, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) x = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="keyword">if</span> (d == key.length()) &#123; x.value = val; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        x.next[c] = put(x.next[c], key, val, d+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String key)</span> </span>&#123; <span class="keyword">return</span> get(key) != <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Node x = get(root, key, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> (Value) x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">get</span><span class="params">(Node x, String key, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (d == key.length()) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        <span class="keyword">return</span> get(x.next[c], key, d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按顺序迭代所有键：<br>·中序遍历trie，找到的键添加到队列中<br>·维护从根到当前节点路径的字符序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">keys</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> Queue&lt;String&gt;();</span><br><span class="line">    collect(root, <span class="string">""</span>, queue);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Node x, String prefix, Queue&lt;String&gt; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x.val != <span class="keyword">null</span>) q.enqueue(prefix);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">        collect(x.next[c], prefix + c, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="前缀匹配"><a href="#前缀匹配" class="headerlink" title="前缀匹配"></a>前缀匹配</h3><p>Find all keys in a symbol table starting with a given prefix.<br>Ex. Autocomplete in a cell phone, search bar, text editor, or shell.<br>・User types characters one at a time.<br>・System reports all matching strings.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">keysWithPrefix</span><span class="params">(String prefix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> Queue&lt;String&gt;();</span><br><span class="line">    Node x = get(root, prefix, <span class="number">0</span>);</span><br><span class="line">    collect(x, prefix, queue);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最长前缀"><a href="#最长前缀" class="headerlink" title="最长前缀"></a>最长前缀</h3><p>Find longest key in symbol table that is a prefix of query string.<br>Ex. To send packet toward destination IP address, router chooses IP address in routing table that is longest prefix match.</p><p>・Search for query string.<br>・Keep track of longest key encountered.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPrefixOf</span><span class="params">(String query)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = search(root, query, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> query.substring(<span class="number">0</span>, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Node x, String query, <span class="keyword">int</span> d, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> length;</span><br><span class="line">    <span class="keyword">if</span> (x.val != <span class="keyword">null</span>) length = d;</span><br><span class="line">    <span class="keyword">if</span> (d == query.length()) <span class="keyword">return</span> length;</span><br><span class="line">    <span class="keyword">char</span> c = query.charAt(d);</span><br><span class="line">    <span class="keyword">return</span> search(x.next[c], query, d+<span class="number">1</span>, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;符号表&quot;&gt;&lt;a href=&quot;#符号表&quot; class=&quot;headerlink&quot; title=&quot;符号表&quot;&gt;&lt;/a&gt;符号表&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在计算机科学中，符号表是一种用于语言翻译器（例如编译器和解释器）中的数据结构。在符号表中，程序源代码中的每个标识符都和它的声明或使用信息绑定在一起，比如其数据类型、作用域以及内存地址。&lt;br&gt;常用哈希表来实现.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;符号表的应用非常广泛, 可用于实现Set, Dictionary, 文件索引, 稀疏向量/矩阵等数据结构和相关的运算操作, 还有其他如过滤查询(Exception filter), 一致性查询(concordance queries)等操作.&lt;/p&gt;
&lt;p&gt;字符符号表就是专门针对字符操作的符号表, API:&lt;br&gt;Prefix match - Keys with prefix &lt;code&gt;sh&lt;/code&gt;: &lt;code&gt;she&lt;/code&gt;, &lt;code&gt;shells&lt;/code&gt;, and &lt;code&gt;shore&lt;/code&gt;.&lt;br&gt;Wildcard match - Keys that match &lt;code&gt;.he&lt;/code&gt;: &lt;code&gt;she&lt;/code&gt; and &lt;code&gt;the&lt;/code&gt;.&lt;br&gt;Longest prefix - Key that is the longest prefix of &lt;code&gt;shellsort&lt;/code&gt;: &lt;code&gt;shells&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Trie" scheme="http://shukebeta.me/tags/Trie/"/>
    
      <category term="Information Retrieval" scheme="http://shukebeta.me/tags/Information-Retrieval/"/>
    
      <category term="Symbol table" scheme="http://shukebeta.me/tags/Symbol-table/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 04 - “和谐” - 多模式匹配算法 - AC自动机</title>
    <link href="http://shukebeta.me/NLP-04-string-match-algorithm-ac-automaton/"/>
    <id>http://shukebeta.me/NLP-04-string-match-algorithm-ac-automaton/</id>
    <published>2018-09-28T16:00:00.000Z</published>
    <updated>2018-09-30T09:02:18.827Z</updated>
    
    <content type="html"><![CDATA[<p>虽然KMP可以用于<a href="/NLP-01-string-searching-algorithm-01-kmp">单模式匹配问题</a>，但如果是多模式问题, KMP的性能就得不到保证。比如根据墙内法律要求, 墙内的搜索引擎需要过滤敏感词后才能合法运营。敏感词的数量不少, 如果要求包含敏感词的网页不能被搜索到, 那么搜索引擎在爬取网页信息时, 就要标记网页的文本中是否包含任意个敏感词.<br><a id="more"></a></p><p>这就是典型的多模匹配问题. 这种情况下如果使用Trie，那么需要遍历网页的每一个字符位置，对每一个位置进行Trie前缀匹配。如果词典的词语数量为N，每个词语长度为L，文章的长度为M，那么需要进行的计算次数是在<code>N*M*L</code>这个级别的. 即使把词语的长度L简化为常数级别的, 整个算法的复杂度也至少是$O(n^2)$.</p><h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>可以看到，KMP算法可以避免back up（在检查字符的过程中不需要回头），而Trie可以存储多个模式的信息。如果把二者结合在一起，也许能从性能上解决多模式（任意位置）匹配问题。这就是Aho–Corasick算法（AC自动机）。</p><blockquote><p>Aho–Corasick算法是由Alfred V. Aho和Margaret J.Corasick 发明的字符串搜索算法，用于在输入的一串字符串中匹配有限组字典中的子串。它与普通字符串匹配的不同点在于同时与所有字典串进行匹配。算法均摊情况下具有近似于线性的时间复杂度，约为字符串的长度加所有匹配的数量。</p></blockquote><p>所以算法的关键就是通过Trie把多个模式构建为一个DFA（Deterministic finite state automaton），然后让模式串末尾对应的状态作为一个DFA的终止节点。这样，对于一个要检查的长字符串（如一段网页内容），让这个字符串在DFA上跑一趟，每一个字符表示一种跳转方式，如果这段字符能够跳到任何一个终结节点, 那么就表明这段字符串匹配了至少一个模式, 如果整段字符跑完都没到达终结节点, 那么这个网页就是”和谐的”.</p><p>在单模式匹配中, 用KMP构建的DFA是比较简单的, 从左到右, 开头的状态就是开始状态, 结尾的状态就是结束状态:<br><img src="/images/build_dfa.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br>而多模式匹配中, 在Trie的结构基础上构建出来的DFA更像一个DFA的样子:<br><img src="/images/ushers_dfa.png" alt="" title="经典的ushers自动机，模式串是he/ she/ his /hers, 忽略了部分到根节点的转移边. image from: https://baike.baidu.com/pic"><br>Trie中的节点, 就类似于DFA中的状态. 如果让字符串<code>shis</code>在上面跑, 假如仅仅是靠Trie(也即是没有虚线标识的转移), 那么第一次从字符串的第一个字符<code>s</code>开始转移, 经过转移路径<code>0 - 85 - 90</code>之后就转不动了, 因为Trie记录的模式中没有<code>shi</code>, 这个时候得back up, 从第二个位置<code>h</code>开始再匹配一遍. 这个过程中就产生重复匹配, 而参考KMP的思路, 在匹配<code>shi</code>的过程中, 其实已经挖掘出了<code>hi</code>这个子串了, 而这个子串是跟模式<code>his</code>对应的, 如果有办法不回头继续匹配下去就能提高性能了.</p><p>而DFA中虚线的失败转移就是用来解决这个问题的: 当走到状态<code>90</code>时, 前面有了小部分子串<code>h</code>刚好对应状态<code>74</code>, 这个时候用虚线作为失败转移, 转移到<code>74</code>, 在状态<code>74</code>中寻找下一个转移<code>i</code>, 这样就实现了不回头继续匹配了.</p><p>因为AC自动机是在Trie的基础上添加边, 用于指示各个节点经过不同字符后跳转到哪个节点, 结果就变成了图, 所以也叫做<strong>Trie图</strong>.</p><p>要构建AC自动机:</p><ol><li>首先要把所有模式都吃进一个Trie中(最近看多进击的巨人了), 构建出一个由不同实线串联起来的状态机, 其中代表更好吻合一个模式的状态标记为终结节点(如上图绿色节点)</li><li>然后补全其他字符的转移(失败转移), 用虚线表示. 补全了所有字符的转移方式, 才能让字符串永不回头地匹配下去, 避免了back up, 保证性能.</li></ol><p>问题的关键在如何补全所有的状态转移.</p><h3 id="补全状态转移"><a href="#补全状态转移" class="headerlink" title="补全状态转移"></a>补全状态转移</h3><p><img src="/images/ushers_dfa.png" alt="" title="经典的ushers自动机，模式串是he/ she/ his /hers, 忽略了部分到根节点的转移边. image from: https://baike.baidu.com/pic"><br>这里要在Trie结构中定义一个<a href="https://hihocoder.com/problemset/problem/1036" target="_blank" rel="noopener">后缀节点</a>的概念: Trie中对应路径(已有模式)去掉部分前缀字符后剩余的后缀字符在Trie中对应的结点. 比如上图中, <code>h</code>作为<code>sh</code>的一个后缀, <code>h</code>对应的Trie节点<code>74</code>就是<code>sh</code>对应节点<code>90</code>的后缀节点. 等于说, <strong>节点和其后缀节点对应的模式有一部分后缀是相同</strong>.</p><p>如果知道了每一个节点的后缀节点, 那么在匹配的过程中, 在任一位置匹配失败, 都可以通过失败转移的方式转移到后缀节点, 继续进行后续匹配, 而不会遗漏, 因为后缀节点对应这个目前为止已匹配字符的某一部分后缀. 等于说, 后缀节点告诉我们, 在字符串中出现与模式不同的字符串时(匹配失败), 如何转移到其他状态.</p><p>所以问题的关键又变成了如何求后缀节点.</p><h3 id="求后缀节点"><a href="#求后缀节点" class="headerlink" title="求后缀节点"></a>求后缀节点</h3><p>观察Trie结构可以发现两个要点</p><ol><li>字符串任何一个位置对应的状态节点，一定比它的后缀节点更深，比如前面例子中状态节点<code>90</code>在第二层, 而其后缀节点<code>74</code>在第一层. 这点也是理所当然的, 毕竟后缀比较短. 从动态规划的角度考虑, 字符串任一位置<code>i</code>对应的状态节点的后缀节点一定是<code>k&lt;i</code>的节点中的某一个.</li><li>因为每一个状态<code>i</code>都是由其父节点<code>j</code>通过某一个字符<code>c</code>转移而来, 那么<code>i</code>的后缀节点一定是<code>j</code>的后缀节点通过同样的字符<code>c</code>转移而来. 或者说, 如果<code>j</code>的后缀节点是<code>jj</code>, 那么<code>j</code>和<code>jj</code>有着相同的后缀, 它们通过同样的转移字符<code>c</code>转移后, 二者到达的节点也一定有着相同的后缀.</li></ol><p>比如上面Ushers自动机例子中, 如果用字符串<code>sshis</code>来跑, 那么<code>ssh</code>对应的状态<code>90</code>, 是由前缀<code>ss</code>通过字符<code>h</code>转移而来. 因为<code>ssh</code>的后缀节点, 同样是某一个有共同后缀的字符(<code>h</code>或者<code>sh</code>)对应的状态(在这里是<code>h</code>对应的<code>74</code>). 可以发现<code>74</code>是由根节点<code>0</code>通过同样的字符<code>h</code>转移而来的. 反过来说, 节点<code>0</code>就是节点<code>90</code>的父节点<code>85</code>的后缀节点.</p><p>在多个模式中, 如果有某模式的前缀刚好是另一模式的子串(后缀). 比如上面Ushers自动机例子中, 模式<code>her</code>(或者<code>he</code>)的前缀<code>he</code>就是模式<code>she</code>的子串, 则会二者存在失败转移的关联. 如果没有, 那么就跳回初始状态节点.</p><p>所以补全所有状态转移的具体实现方法就是运用动态规划的原理:</p><ul><li>从Trie根节点开始, 逐层往下补全每一层的状态转移, 也就是宽度优先遍历(BFS), 这样下层的状态转移就可以利用上层的结果. 动态规划的转移方程可以描述为: <strong>每一个通过字符<code>c</code>转移而来的状态节点<code>i</code>的后缀节点 = <code>i</code>的父节点的后缀节点通过<code>c</code>转移到的状态节点</strong></li><li>初始状态包含两部分:<ul><li>一个是根节点(初始状态<code>0</code>), 它的后缀节点就是它自己,</li><li>另一个是第一层的状态节点, 如<code>85, 74</code>, 因为它们对应的是长度为<code>1</code>的字符, 没有后缀, 所以它们的后缀节点也是根节点<code>0</code>.</li></ul></li></ul><p>在实现中还要注意, <strong>后缀结点为标记结点的结点也需要被标记</strong>. 因为在状态转移过程中, 如果某个虚线转移刚好转移到终结节点, 但在字符串遍历的过程中, 并没有选择走这一条线, 就会忽略了这个终结节点, 导致匹配失败, 或者多走了更多的路. 比如在上面的例子中, 如果把模式<code>she</code>改为<code>shee</code>, <code>91</code>不再是终结节点, 而是延伸到<code>92</code>为终结节点, <code>91</code>的后缀节点是<code>76</code>. 如果用字符串<code>sshe</code>来跑这个DFA, 就会出现走到最后字符<code>e</code>时, 在节点<code>91</code>结束, 匹配失败. 所以需要把<code>91</code>也标记为终结节点.</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 把字典通过insert把所有单词插入Trie树，</span></span><br><span class="line"><span class="comment"> * 然后通过setSuffix()构建出对应的Trie图，</span></span><br><span class="line"><span class="comment"> * 然后从Trie图的根节点开始，沿着文章str的每一个字符，走出对应的边，</span></span><br><span class="line"><span class="comment"> * 直到遇到一个标记结点或者整个str都遍历完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode trie;</span><br><span class="line">    Queue&lt;TrieNode&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        trie = <span class="keyword">new</span> TrieNode(<span class="keyword">null</span>, <span class="string">' '</span>);</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode curNode = trie;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x : word.toCharArray()) &#123;</span><br><span class="line">            curNode = insert(curNode, x);</span><br><span class="line">        &#125;</span><br><span class="line">        curNode.setLast(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** insert char x, means create a new node in the x edge.</span></span><br><span class="line"><span class="comment">     * return created node  */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">insert</span><span class="params">(TrieNode node, <span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.get(x) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.set(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.get(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** BFS on the trie */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue.add(trie);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">/** poll() removes the present head.</span></span><br><span class="line"><span class="comment">             http://www.tutorialspoint.com/java/util/linkedlist_poll.htm */</span></span><br><span class="line">            TrieNode node = queue.poll();</span><br><span class="line">            setSuffix(node);</span><br><span class="line">            complementDFA(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Set node's suffix, complement lacking edge</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">setSuffix</span><span class="params">(TrieNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.root == <span class="keyword">null</span>) &#123; <span class="comment">// Trie root</span></span><br><span class="line">            node.suffix = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.root.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.suffix = node.root.suffix;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.suffix = node.root.suffix.get(node.fromIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.suffix.isLast) &#123;</span><br><span class="line">            node.isLast = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Complement DFA according to suffix */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">complementDFA</span><span class="params">(TrieNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.isLast) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node.edges.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.edges[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.edges[i] = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.edges[i] = node.suffix.edges[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.add(node.edges[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> contains = <span class="keyword">false</span>;</span><br><span class="line">        TrieNode curNode = trie;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> x = s.charAt(i);</span><br><span class="line">            curNode = curNode.get(x);</span><br><span class="line">            <span class="keyword">if</span> (curNode.isLast) &#123;</span><br><span class="line">                contains = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> contains;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATO0 = <span class="number">97</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isLast;</span><br><span class="line">        TrieNode[] edges;</span><br><span class="line">        TrieNode root;</span><br><span class="line">        <span class="keyword">char</span> fromIndex;</span><br><span class="line">        TrieNode suffix;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(TrieNode root, <span class="keyword">char</span> from)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.root = root;</span><br><span class="line">            fromIndex = from;</span><br><span class="line">            edges = <span class="keyword">new</span> TrieNode[R];</span><br><span class="line">            isLast = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> edges[ch - ATO0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** instantiate the ch child in edges */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            edges[ch - ATO0] = <span class="keyword">new</span> TrieNode(<span class="keyword">this</span>, ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLast</span><span class="params">(<span class="keyword">boolean</span> isLast)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isLast = isLast;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Trie t = <span class="keyword">new</span> Trie();</span><br><span class="line">        String[] X = &#123;<span class="string">"sb"</span>, <span class="string">"dsb"</span>, <span class="string">"cjdsb"</span>, <span class="string">"qnmlgb"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String x : X) &#123;</span><br><span class="line">            t.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t.setSuffix();</span><br><span class="line">        String s = <span class="string">"aadbaaadaaac"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t.search(s)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"YES"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然KMP可以用于&lt;a href=&quot;/NLP-01-string-searching-algorithm-01-kmp&quot;&gt;单模式匹配问题&lt;/a&gt;，但如果是多模式问题, KMP的性能就得不到保证。比如根据墙内法律要求, 墙内的搜索引擎需要过滤敏感词后才能合法运营。敏感词的数量不少, 如果要求包含敏感词的网页不能被搜索到, 那么搜索引擎在爬取网页信息时, 就要标记网页的文本中是否包含任意个敏感词.&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Trie图" scheme="http://shukebeta.me/tags/Trie%E5%9B%BE/"/>
    
      <category term="AC自动机" scheme="http://shukebeta.me/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 03 - 单模式匹配与拼写检查 - Trie</title>
    <link href="http://shukebeta.me/NLP-03-string-match-algorithm-Trie/"/>
    <id>http://shukebeta.me/NLP-03-string-match-algorithm-Trie/</id>
    <published>2018-09-27T16:00:00.000Z</published>
    <updated>2018-09-30T09:02:24.563Z</updated>
    
    <content type="html"><![CDATA[<p>Trie 也称字典树，名称来源于Re<font color="red">trie</font>val，支持$O(n)$插入和查询操作，以空间换取时间的数据结构. 用于词频统计和输入统计领域, 可以高效地存储大规模的字典数据, 也可以用于模糊匹配, 搜索最长前缀词等.</p><blockquote><p>A <strong>trie</strong>, also called <strong>digital tre</strong>e, <strong>radix tree</strong> or <strong>prefix tree</strong> is a kind of search tree - an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings. Unlike a binary search tree, no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the string associated with that node, and the root is associated with the empty string. Keys tend to be associated with leaves, though some inner nodes may correspond to keys of interest. Hence, keys are not necessarily associated with every node.</p></blockquote><a id="more"></a><p><img src="/images/Trie_example.png" alt="" title="A trie for keys &quot;A&quot;,&quot;to&quot;, &quot;tea&quot;, &quot;ted&quot;, &quot;ten&quot;, &quot;i&quot;, &quot;in&quot;, and &quot;inn&quot;. Image from https://en.wikipedia.org/wiki/Trie"></p><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>Trie没有规定每一个节点的分支数量, 用<strong>R-way Trie</strong>来表示分支数量为<code>R</code>的Trie. 对于不同的应用, 可以设置不同的<code>R</code>.</p><h3 id="字符（模糊）匹配与拼写检查"><a href="#字符（模糊）匹配与拼写检查" class="headerlink" title="字符（模糊）匹配与拼写检查"></a>字符（模糊）匹配与拼写检查</h3><p>应用例子是在一本字典中查找特定前缀的所有单词. 简化的例子是在英文字典中, 根据查询前缀, 返回相同前缀的所有单词数. 同样的结构可以用来检查拼写错误.</p><p>那么只需要在每一个节点存储该节点以下所有单词数就行了. 每一个节点包含一个长度26的数组，以方便快速定位对应的26个字母, 类似B-tree:<img src="/images/b_tree.png" alt="" title="image from https://www.coursera.org/learn/algorithms-part1"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字母本身可以用来作为索引：a - 97, z - 122</span></span><br><span class="line"><span class="comment"> * Color 是备用属性， 用于标记该节点是否为单词结尾，这里暂时用不到。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALPHABET = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATO0 = <span class="number">97</span>;</span><br><span class="line">    <span class="keyword">int</span> color;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    Trie[] node;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        node = <span class="keyword">new</span> Trie[ALPHABET];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String words)</span> </span>&#123;</span><br><span class="line">        Trie[] curNode = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x : words.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = x - ATO0;</span><br><span class="line">            insert(curNode, index);</span><br><span class="line">            curNode = curNode[index].node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Trie[] curNode, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            curNode[index] = <span class="keyword">new</span> Trie(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curNode[index].n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Trie[] curNode = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = x - ATO0;</span><br><span class="line">            <span class="keyword">if</span> (curNode[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count = curNode[index].n;</span><br><span class="line">            curNode = curNode[index].node;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果要问题扩展为返回所有相同前缀的单词，那么就要在插入字典时，在对应单词结尾的节点标记颜色。</p><h3 id="提高扩展性"><a href="#提高扩展性" class="headerlink" title="提高扩展性"></a>提高扩展性</h3><p>用固定长度为26的数组来处理英文，好处是数组内存占用小，索引时也不需要搜索，直接用字符码作为索引。也可以根据ASCII码进一步扩大数组长度以支持更多字符。</p><p>为了提高可扩展性，可以考虑用其他更灵活的数据结构来替代数组，比如HashMap，同时把HashMap放进一个TrieNode类。这样以后要修改核心的存储结构，只需要改动TrieNode即可，其余的接口不用改。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode node;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode curNode = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x : word.toCharArray()) &#123;</span><br><span class="line">            curNode = curNode.set(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode curNode = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curNode.get(x) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode.get(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curNode.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, TrieNode&gt; map;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(Character val)</span> </span>&#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.value = val;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TrieNode <span class="title">set</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            TrieNode t = map.get(ch);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                t = <span class="keyword">new</span> TrieNode(ch);</span><br><span class="line">                <span class="keyword">this</span>.map.put(ch, t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>HashMap的寻址虽然会靠字符码作为地址的数组慢一点点，但也是非常快的:$O(\log N)$。但HashMap本身是比较耗内存的数据结构, 所以如果知道要处理的数据是在特定范围内的, 比如节点就是在256个字符中, 那么还是不要不用HashMap.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Trie 也称字典树，名称来源于Re&lt;font color=&quot;red&quot;&gt;trie&lt;/font&gt;val，支持$O(n)$插入和查询操作，以空间换取时间的数据结构. 用于词频统计和输入统计领域, 可以高效地存储大规模的字典数据, 也可以用于模糊匹配, 搜索最长前缀词等.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;trie&lt;/strong&gt;, also called &lt;strong&gt;digital tre&lt;/strong&gt;e, &lt;strong&gt;radix tree&lt;/strong&gt; or &lt;strong&gt;prefix tree&lt;/strong&gt; is a kind of search tree - an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings. Unlike a binary search tree, no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the string associated with that node, and the root is associated with the empty string. Keys tend to be associated with leaves, though some inner nodes may correspond to keys of interest. Hence, keys are not necessarily associated with every node.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Trie" scheme="http://shukebeta.me/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 02 - 字符搜索匹配算法 02 - Boyer-Moore(BM) 和 Rabin-Karp(RK)</title>
    <link href="http://shukebeta.me/NLP-02-string-searching-algorithm-02-bm-rk/"/>
    <id>http://shukebeta.me/NLP-02-string-searching-algorithm-02-bm-rk/</id>
    <published>2018-09-26T16:00:00.000Z</published>
    <updated>2018-10-07T07:44:44.008Z</updated>
    
    <content type="html"><![CDATA[<p>字符串搜索/匹配算法中, Boyer-Moore(BM)比前面的<a href="/NLP-01-string-searching-algorithm-kmp">Knuth–Morris–Pratt(KMP)</a>更高效. BM算法从右到左扫描模式中的字符。当匹配的字符在模式中不存在时，可以跳过最多达M个字符.<img src="/images/bm.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br><a id="more"></a></p><h2 id="BM"><a href="#BM" class="headerlink" title="BM"></a>BM</h2><p>在决定要跳过多少字符时, 分几种情况考虑:<br>1, mismatch character <code>T</code> not in pattern: increment <code>i</code> one character beyond <code>T</code><br>2.1, Mismatch character in pattern: mismatch character <code>N</code> in pattern, align text <code>N</code> with rightmost pattern <code>N</code><br>2.2, Mismatch character in pattern (but heuristic no help): mismatch character <code>E</code> in pattern, align text <code>E</code> with rightmost pattern <code>E</code>? 还是 increment i by 1? 无法确定, 需要辅助信息.</p><p>需要预先计算模式各个字符在模式最右边出现的索引(若无则<code>-1</code>):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">right = <span class="keyword">new</span> <span class="keyword">int</span>[R];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">right[c] = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)</span><br><span class="line">right[pat.charAt(j)] = j;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = txt.length();</span><br><span class="line"><span class="keyword">int</span> M = pat.length();</span><br><span class="line"><span class="keyword">int</span> skip;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N-M; i += skip)</span><br><span class="line">&#123;</span><br><span class="line">skip = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = M-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pat.charAt(j) != txt.charAt(i+j))</span><br><span class="line">&#123;</span><br><span class="line">skip = Math.max(<span class="number">1</span>, j - right[txt.charAt(i+j)]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (skip == <span class="number">0</span>) <span class="keyword">return</span> i; <span class="comment">// match</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Substring search with the Boyer-Moore mismatched character heuristic takes about <code>~ N / M</code> character compares to search for a pattern of length <code>M</code> in a text of length <code>N</code>.<br>Worst-case. Can be as bad as <code>~ M N</code>.</p></blockquote><p>Boyer-Moore变种: 通过添加类似KMP的规则来防止重复模式，可以将最坏情况改善为<code>~3 N</code>字符比较。</p><h2 id="RK"><a href="#RK" class="headerlink" title="RK"></a>RK</h2><p>Rabin-Karp 基于 modular hashing：<br>・Compute a hash of pattern characters <code>0</code> to <code>M - 1</code>.<br>・For each <code>i</code>, compute a hash of text characters <code>i</code> to <code>M + i - 1</code>.<br>・If pattern hash = text substring hash, check for a match.</p><p>所以算法的关键在于如何高效地计算哈希值：Horner’s method - 用于评估M阶多项式的线性时间方法<br><img src="/images/horner_method.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute hash for M-digit key</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(String key, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)</span><br><span class="line">h = (R * h + key.charAt(j)) % Q;</span><br><span class="line"><span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>给定$x_i$，如何计算$x_{i+1}$：<br>$$x_i = t_i R^{M-1} + T_{i+1}R^{M-2} + … + t_{i+M-1}R^0$$<br>$$x_{i+1} = t_{i+1}R^{M-1} + T_{i+2}R^{M-2} + … + t_{i+M}R^0$$<br>$$x_{i+1} = (x_i - t_i R^{M-1}) R + t_{i+M}$$<br>M-digit, base-R integer, modulo Q，$R^{M-1}$是可以预先计算的.<br><img src="/images/rk.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabinKarp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> patHash; <span class="comment">// pattern hash value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> M; <span class="comment">// pattern length</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> Q; <span class="comment">// modulus</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> R; <span class="comment">// radix</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> RM; <span class="comment">// R^(M-1) % Q</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RabinKarp</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">M = pat.length();</span><br><span class="line">R = <span class="number">256</span>;</span><br><span class="line">Q = longRandomPrime(); <span class="comment">// a large prime (but avoid overflow)</span></span><br><span class="line"></span><br><span class="line">RM = <span class="number">1</span>; <span class="comment">// precompute R^&#123;M – 1&#125; (mod Q)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M-<span class="number">1</span>; i++)</span><br><span class="line">RM = (R * RM) % Q;</span><br><span class="line">patHash = hash(pat, M);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(String key, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* as before */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** check for hash collision using rolling hash function */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = txt.length();</span><br><span class="line"><span class="keyword">int</span> txtHash = hash(txt, M);</span><br><span class="line"><span class="keyword">if</span> (patHash == txtHash) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">txtHash = (txtHash + Q - RM*txt.charAt(i-M) % Q) % Q;</span><br><span class="line">txtHash = (txtHash*R + txt.charAt(i)) % Q;</span><br><span class="line"><span class="keyword">if</span> (patHash == txtHash) <span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有两种方式判断是否匹配：</p><ul><li>Monte Carlo version. Return match if hash match.<ul><li>Always runs in linear time. Extremely likely to return correct answer (but not always!).</li></ul></li><li>Las Vegas version. Check for substring match if hash match; continue search if false collision.<ul><li>Always returns correct answer. Extremely likely to run in linear time (but worst case is M N).</li></ul></li></ul><blockquote><p>In theory, if <code>Q</code> is a sufficiently large random prime (about $M N^2$), then the probability of a false collision is about <code>1 / N</code>.<br>In practice, choose <code>Q</code> to be a large prime (but not so large to cause overflow). Under reasonable assumptions, probability of a collision is about <code>1 / Q</code>.</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/substring_search_cost_summary.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br>算法可以拓展到二维模式匹配, 多模式匹配等问题.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字符串搜索/匹配算法中, Boyer-Moore(BM)比前面的&lt;a href=&quot;/NLP-01-string-searching-algorithm-kmp&quot;&gt;Knuth–Morris–Pratt(KMP)&lt;/a&gt;更高效. BM算法从右到左扫描模式中的字符。当匹配的字符在模式中不存在时，可以跳过最多达M个字符.&lt;img src=&quot;/images/bm.png&quot; alt=&quot;&quot; title=&quot;image from: https://www.coursera.org/learn/algorithms-part2/&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Boyer-Moore" scheme="http://shukebeta.me/tags/Boyer-Moore/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 快速幂</title>
    <link href="http://shukebeta.me/bits-operations-07/"/>
    <id>http://shukebeta.me/bits-operations-07/</id>
    <published>2018-09-25T16:00:00.000Z</published>
    <updated>2018-10-10T03:26:41.653Z</updated>
    
    <content type="html"><![CDATA[<p>如何实现快速的幂运算？<br><a id="more"></a></p><p>要求$c = a^b$, 按照朴素算法把<code>a</code>连乘<code>b</code>次的时间复杂度是$O(n)$. 而快速幂能做到$O(\log n)$。把<code>b</code>转换为二进制, 二进制数第<code>i</code>位的权为$2^{i-1}$，就可以把二进制拆分为若干个以<code>2</code>为底的真数, 然后利用幂数的性质，例如用朴素算法求$a^{11}$要求乘<code>11</code>次. 考虑到<code>11</code>的二进制为<code>1011</code>, 如果把$a^{11}$拆分为:<br>$$a^{11} = a^{a_0 2^0 + a_1 2^1 + a_2 0 + a_3 2^3} = a^1 a^2 a^8$$<br>可以看到每一个因子都是上一个因子的平方，利用$a^2 a^2$求出$a^4$, 同样利用$a^4$的平方求出$a^8$, 每次计算只需要用到上一次计算出来的结果, 所以总的运算次数是<code>4</code>次. 任何一个数<code>b</code>最多能写成长度为$O(\log b)$的二进制, 因此这个算法就是$O(\log n)$.</p><p>在程序设计中是根据<code>b</code>的二进制中是否为<code>1</code>来控制是否乘以上一次翻倍的积</p><ul><li>不断右移<code>b</code>, 直到<code>b</code>不再有<code>1</code>：<ul><li>根据当前位的权重（当前<code>b</code>最后一位）是否为<code>1</code>来决定<code>c</code>是否乘以最新的<code>a</code></li><li>把<code>a</code>平方，用于下一位计算</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span> == <span class="number">1</span>)</span><br><span class="line">            c *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何实现快速的幂运算？&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 01 - 字符搜索匹配算法 01 - KMP</title>
    <link href="http://shukebeta.me/NLP-01-string-searching-algorithm-01-kmp/"/>
    <id>http://shukebeta.me/NLP-01-string-searching-algorithm-01-kmp/</id>
    <published>2018-09-25T16:00:00.000Z</published>
    <updated>2018-10-07T07:57:01.029Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>In computer science, string-searching algorithms, sometimes called string-matching algorithms, are an important class of string algorithms that try to find a place where one or several strings (also called patterns) are found within a larger string or text.</p></blockquote><p>字符串搜索/匹配算法在大规模文本应用中有非常重要的作用，比如文章敏感词搜索，多关键词过滤搜索等。如果使用暴力搜索，则时间复杂度很高（若 m 为关键字的长度， n 为要待搜索的字符串长度， k为关键字数量，则复杂度为$O(n \times m \times k)$。而好的算法可以让这些问题的时间复杂度大大降低。</p><p>常用的算法有Knuth–Morris–Pratt(KMP), Boyer-Moore(BM), Rabin-Karp(RK), Trie, Trie图, AC自动机等.<br><a id="more"></a></p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>Knuth–Morris–Pratt 算法在每次搜索匹配前，预处理模式字符串，记录模式字符串自身重复的情况，即包含左临界的子字符串和包含右临界的子字符串的重复长度，以此来作为后续匹配的参考。当实际去匹配带搜索字符串时，想象是我们拿着模式字符串从左到右匹配过去。任何时候，如果发现匹配不上的时，不是简单地右移一位继续重新匹配，而是在已匹配部分的范围内，直接跳过k个字符，右移到与模式开头部分重复的位置，并接着重复部分后面继续开始匹配（重复的部分证明已经匹配过）。</p><p>一个很好解释<a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">参考</a><br><img src="/images/kmp1.png" alt=""><img src="/images/kmp2.png" alt="" title="https://blog.csdn.net/v_july_v/article/details/7041827"><br>KMP算法的理论基础基于确定性有限状态自动机 DFA（Deterministic finite state automaton）。DFA可以理解为抽象的字符搜索机：</p><ul><li>有限数量的<strong>状态</strong>（包括开始和停止）。</li><li>字母表每个字符对应一个状态转换。</li><li>只接受能通往停止状态的转换序列。</li></ul><p><img src="/images/kmp_dfa.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br>如<code>ABCAABABABAB</code>对应<code>0→1→2→0→1→1→2→3→4→5→4→5→4</code></p><p>可以看出KMP算法的几个要点:</p><ul><li>状态State: 表示模式中已匹配的字符数。<code>pattern[]</code>最长前缀(同时是<code>txt[0..i]</code>的后缀)的长度.</li><li>需要预先从<code>pattern</code>中计算<code>dfa[][]</code></li><li>字符串遍历指针只会前进不会后退</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, N = txt.length();</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; N &amp;&amp; j &lt; M; i++)</span><br><span class="line">j = dfa[txt.charAt(i)][j];</span><br><span class="line"><span class="keyword">if</span> (j == M) <span class="keyword">return</span> i - M;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Running time: at most N character accesses to Simulate DFA on text.</p><h3 id="使用DFA"><a href="#使用DFA" class="headerlink" title="使用DFA"></a>使用DFA</h3><p>用状态<code>state j</code>表示模式<code>pat</code>的前<code>j</code>个字符已经匹配. 用<code>dfa[c][j]</code>表示在状态<code>state j</code>时, 遇到下一个字符<code>c</code>, 应该转移到什么状态.</p><p>在状态<code>state j</code>：<br>· 如果匹配成功，<code>char c == pat.charAt(j)</code>，则转移到<code>state j+1</code>: <code>dfa[pat.charAt(j)][j] = j+1</code>.<br>· 如果失败，则从<code>pat[1..j-1]</code>对应的DFA状态<code>X</code>，向着<code>c</code>方向转移：<code>copy dfa[][X] to dfa[][j]</code>.<br>・Update <code>X</code>.<br><img src="/images/build_dfa.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.pat = pat;</span><br><span class="line">M = pat.length();</span><br><span class="line">dfa = <span class="keyword">new</span> <span class="keyword">int</span>[R][M];</span><br><span class="line">dfa[pat.charAt(<span class="number">0</span>)][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> X = <span class="number">0</span>, j = <span class="number">1</span>; j &lt; M; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">dfa[c][j] = dfa[c][X]; <span class="comment">// copy mismatch cases</span></span><br><span class="line">dfa[pat.charAt(j)][j] = j+<span class="number">1</span>;</span><br><span class="line">X = dfa[pat.charAt(j)][X];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Running time. M character accesses (but space/time proportional to R M).</p><h3 id="NEXT数组"><a href="#NEXT数组" class="headerlink" title="NEXT数组"></a>NEXT数组</h3><p>假设现在文本串<code>S</code>匹配到<code>i</code>位置，模式串<code>P</code>匹配到<code>j</code>位置:<br><img src="https://img-blog.csdn.net/20140812223633281" alt="" title="image from: https://blog.csdn.net/v_july_v/article/details/7041827"><br>首先第一位NEXT值<code>next[0]</code>一定是<code>-1</code>, 后面的第<code>j+1</code>个值<code>next[j]</code>代表<code>[0, j-1]</code>部分有多少重复前后缀. 可以根据前一位的<code>next[j-1]</code>值<code>k</code>推断:</p><ul><li>如果<code>P[j] == P[k]</code>, 则意味着重复前后缀长度<code>+1</code>, 那么<code>next[j] = next[j-1] + 1 = k + 1</code>.</li><li>如果<code>P[j] != P[k]</code>, 则意味着前面重复前后缀无法继续下去. 此时不能简单地判定<code>next[j] = 0</code>, 需要继续往前看是否有更短小的重复前后缀. 又因为重复前后缀意味着前后端相同, 因此可以直接匹配<code>P[j] ?= P[k&#39;], k&#39; = next[k]</code>, 以此循环下去直到<code>k&#39; = -1</code>为止.</li></ul><p>以上算法还可以进一步优化: 当<code>P[j] != S[i]</code>时，下次必然匹配<code>P[next [j]] ?= S[i]</code>，此时如果<code>P[j] == P[next[j]]</code>，则意味着匹配必然失败. 这样就出现了冗余匹配。所以如果出现<code>P[j] == P[next[j]]</code>，则令<code>next[j] = next[next[j]] = next[next[j-1] + 1] = next[k + 1]</code>.<img src="http://hi.csdn.net/attachment/201106/14/8394323_13080758591kyV.jpg" alt="" title="image from: https://blog.csdn.net/v_july_v/article/details/7041827"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span>[] p, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; p.length - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line"><span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[++j] != p[++k])</span><br><span class="line">                next[j] = k;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">next[j] = next[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>对于优化后的next数组可以发现一点：如果模式串的后缀跟前缀相同，那么它们的next值也是相同的，例如模式串abcabc，它的前缀后缀都是abc，其优化后的next数组为：-1 0 0 -1 0 0，前缀后缀abc的next值都为-1 0 0.</p></blockquote><h3 id="基于NEXT数组的KMP算法"><a href="#基于NEXT数组的KMP算法" class="headerlink" title="基于NEXT数组的KMP算法"></a>基于NEXT数组的KMP算法</h3><p>基于前面求出的NEXT数组, 可以根据以下步骤实现KMP算法:</p><ul><li>假设现在文本串<code>S</code>匹配到<code>i</code>位置，模式串<code>P</code>匹配到<code>j</code>位置<ul><li>if <code>j = -1</code>, or <code>S[i] == P[j]</code>(当前字符匹配成功), then <code>i++, j++</code></li><li>else, <code>j = next[j]</code>。当失配时，模式串<code>P</code>相对于文本串<code>S</code>向右移动<code>j - next[j]</code>位(大于等于1)。</li></ul></li></ul><p><img src="https://img-blog.csdn.net/20150812214857858" alt="" title="image from: https://img-blog.csdn.net/20150812214857858"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 返回模式串第一次在文本串中出现的位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">char</span>[] p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; s.length &amp;&amp; j &lt; p.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == -<span class="number">1</span> || s[i] == p[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="KMP应用"><a href="#KMP应用" class="headerlink" title="KMP应用"></a>KMP应用</h3><p>判断一段文字（原串）里面是否存在敏感词（模式串）。原题地址 <a href="http://hihocoder.com/problemset/problem/1015?sid=1368409：" target="_blank" rel="noopener">http://hihocoder.com/problemset/problem/1015?sid=1368409：</a></p><p>输入：第一行一个整数N，表示测试数据组数。接下来的N*2行，每两行表示一个测试数据。在每一个测试数据中，第一行为模式串，由不超过10^4个大写字母组成，第二行为原串，由不超过10^6个大写字母组成。其中N&lt;=20.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">HA</span><br><span class="line">HAHAHA</span><br><span class="line">WQN</span><br><span class="line">WQN</span><br><span class="line">ADA</span><br><span class="line">ADADADA</span><br><span class="line">BABABB</span><br><span class="line">BABABABABABABABABB</span><br><span class="line">DAD</span><br><span class="line">ADDAADAADDAAADAAD</span><br></pre></td></tr></table></figure></p><p>输出: 对于每一个测试数据，按照它们在输入中出现的顺序输出一行Ans，表示模式串在原串中出现的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>这里是需要找出出现的次数，因此不仅仅是找到第一个，还要继续遍历原串统计剩余出现的次数，同时要考虑重叠的部分。关键的功能代码可以复制上面的，但是需要作出一些改动。</p><p>首先，因为部分重叠情况也是要统计的，比如<code>ADADADA</code>这个原串, 包含3个<code>ADA</code>. 所以要考虑即使匹配成功后, 模式串的索引<code>j</code>能够跳回前面的重复前缀位置. 考虑使用未优化过的NEXT计算方法.</p><p>除此之外, 通过额外计算多一位NEXT值, 记录完整的模式串的重复前后缀长度, 以协助索引.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span>[] p, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; p.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k]) &#123;</span><br><span class="line">            next[++j] = ++k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于<code>ADA</code>, 原来未优化过的NEXT是<code>-1,0,0</code>, 现在是<code>-1,0,0,1</code>, 最后一位<code>1</code>表示<code>ADA</code>这个模式串的重复前后缀是长度为<code>1</code>的<code>A</code>.</p><p>借助额外长度的NEXT, 只需要小小地改动KMP计算逻辑, 最重要的是当<code>j</code>到达<code>NEXT</code>的额外位置时, 通过<code>j = next[j];</code>把<code>j</code>后拨到重复前缀的位置, 以方便进行后面的搜索.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 返回模式串在原串中出现的次数 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">char</span>[] p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[p.length + <span class="number">1</span>]; <span class="comment">// 额外多计算一位</span></span><br><span class="line">    GetNext(p, next);</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || s[i] == p[j]) &#123;</span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line">            c++;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;In computer science, string-searching algorithms, sometimes called string-matching algorithms, are an important class of string algorithms that try to find a place where one or several strings (also called patterns) are found within a larger string or text.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;字符串搜索/匹配算法在大规模文本应用中有非常重要的作用，比如文章敏感词搜索，多关键词过滤搜索等。如果使用暴力搜索，则时间复杂度很高（若 m 为关键字的长度， n 为要待搜索的字符串长度， k为关键字数量，则复杂度为$O(n \times m \times k)$。而好的算法可以让这些问题的时间复杂度大大降低。&lt;/p&gt;
&lt;p&gt;常用的算法有Knuth–Morris–Pratt(KMP), Boyer-Moore(BM), Rabin-Karp(RK), Trie, Trie图, AC自动机等.&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="KMP" scheme="http://shukebeta.me/tags/KMP/"/>
    
      <category term="Aho–Corasick algorithm" scheme="http://shukebeta.me/tags/Aho%E2%80%93Corasick-algorithm/"/>
    
      <category term="Trie" scheme="http://shukebeta.me/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 汉明距离</title>
    <link href="http://shukebeta.me/bits-operations-06/"/>
    <id>http://shukebeta.me/bits-operations-06/</id>
    <published>2018-09-24T16:00:00.000Z</published>
    <updated>2018-10-10T03:26:37.010Z</updated>
    
    <content type="html"><![CDATA[<p>求两个整数的汉明距离 hamming distance<br><a id="more"></a><br><a href="https://leetcode.com/problems/hamming-distance/description/" target="_blank" rel="noopener">Leetcode 461</a><br>两个整数之间的汉明距离是该两个数之间不同的位数。 给定两个整数x和y，计算汉明距离。问题也可以理解为对于两个整数<code>m</code>和<code>n</code>, 需要改变<code>m</code>的二进制多少位才能得到<code>n</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Use Brian Kernighan's way to count bits */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = x ^ y;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        y++;</span><br><span class="line">        x &amp;= x - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(x ^ y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样用到Brian Kernighan算法：</p><blockquote><p>Lets say that the bit at index n is 1 and that the bits in indexes 0 up to <code>n-1</code> are all 0 (we’ll use little endianess - so index 0 is 1, index 1 is 2, index 2 is 4, index 3 is 8 and so on).</p></blockquote><blockquote><p><code>v-1</code> subtracts from index 0 - but it’s 0, so it converts it to 1 and subtracts from index 1 - but it’s also 0, so it converts it to 1 and subtracts from index 2 - and so on until we reach index n. Since index n is 1 it can subtract from it and turn it to 0 - and there it stops: <code>1101000 - 1 = 1100111</code></p></blockquote><blockquote><p>So, <code>v-1</code> is like <code>v</code> except there are <code>n</code> 0 that became 1 and one 1 that became 0. In <code>v &amp; v - 1</code> all the other bits remain as is, the <code>n</code> zeros that where turned to ones remain 0 (because <code>0 &amp; 1 == 0</code>), and the one 1 that was turned to 0 turns to 0(because <code>1 &amp; 0 == 0</code>). So overall - only a single bit was changed in the iteration, and this change was from 1 to 0: <code>1101000 &amp; 1100111 = 1100000</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;求两个整数的汉明距离 hamming distance&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 找出只出现一次的数 - 及同类问题</title>
    <link href="http://shukebeta.me/bits-operations-05/"/>
    <id>http://shukebeta.me/bits-operations-05/</id>
    <published>2018-09-23T16:00:00.000Z</published>
    <updated>2018-10-10T09:22:22.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="找出唯一一个仅出现M次的数"><a href="#找出唯一一个仅出现M次的数" class="headerlink" title="找出唯一一个仅出现M次的数"></a>找出唯一一个仅出现M次的数</h2><p>在一个非空整数数组，找出那个只出现了一次的元素，已知其余每个元素均出现两次。<br><a id="more"></a><br>要达到O(n)复杂度需要利用<strong>位异或</strong>. 位异或运算能够把二进制相同的数化为0. 把数组所有的数都异或, 出现两次的数就会互相抵消为0, 剩余的就是那个只出现了一次的数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums)</span><br><span class="line">        output ^= i;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但如果把问题扩展为“其余每个元素均出现三次”， 这样就无法直接利用异或抵消的性质了。剑指Offer的解法是用一个长度<code>32</code>的数组<code>bitSum</code>, 把原数组所有整数的二进制每一位分别累加到<code>bitSum</code>里面, 这样就可以通过判断<code>bitSum</code>哪些位不可以被3整除来找出那个数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bitSum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> bitMask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> b = nums[i] &amp; bitMask;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="number">0</span>)</span><br><span class="line">                bitSum[j] += <span class="number">1</span>;</span><br><span class="line">            bitMask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        res += bitSum[i] % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为<code>bitSum</code>的长度是常数, 所以该方法复杂度还是O(N). 该方法可以进一步扩展问题为求唯一一个元素出现M次，其他所有元素出现K次的问题。</p><p>除此之外, 还有其他更精简的通用的方法来解决此类问题.</p><h3 id="构造状态转移表"><a href="#构造状态转移表" class="headerlink" title="构造状态转移表"></a>构造状态转移表</h3><p>方法来自<a href="https://leetcode.com/problems/single-number-ii/discuss/43296/An-General-Way-to-Handle-All-this-sort-of-questions." target="_blank" rel="noopener">An General Way to Handle All this sort of questions</a>, 这个方法核心思想是建立一个记录状态的变量, 该变量代表某个数字出现一次后的状态. 目标就是使得一个数字重复出现K次后状态刚好归0.</p><p>对于<code>K=2</code>, 就要使两次叠加后归0, 需要两种状态, 从信息论的角度看待, 只需要一个位(<code>0</code>,<code>1</code>)来表达，状态<code>0</code>对应着两种等价的情况: 一个数字完全没出现过, 或者出现了2次后一起抵消重置. 状态<code>1</code>对应着仅仅出现一次的情况. 在这里数字和状态概念等价，构建一个状态转移表（真值表）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">状态 输入 输出</span><br><span class="line">a    c    a</span><br><span class="line">0    0    0</span><br><span class="line">1    0    1</span><br><span class="line">0    1    1</span><br><span class="line">1    1    0</span><br></pre></td></tr></table></figure></p><p>可以看到，不管是状态1还是0，如果输入相同数字，就会变为0；如果输入不同的数字，就会变为1. 根据表写出逻辑表达式为异或运算.</p><p>根据真值表写出逻辑式的基本套路是: 只看输出结果为1的转移, 凡取值为1的变量写成原变量，取值为0的变量写成反变量, 得出对应的表达式, 再把所有转移方程的表达式加起来. 如输出为1的是<code>0 &amp; 1 = 1, 1 &amp; 0 = 1</code>, 表达式就是<code>(~a &amp; c) | (a &amp; ~c)</code>, 这个本质上就是<code>a ^ c</code></p><p>对于<code>K = 3, M = 1(or 2)</code>, 需要三种状态, 那么至少需要两个位(<code>00</code>, <code>01</code>, <code>10</code>)来表达. 让状态<code>00</code>对应”假”输出, 对应两种等价的情况: 一个数字完全没出现过, 或者出现了3次后一起抵消重置. 再定义<code>01</code>为出现了一次的状态, <code>10</code>为出现了2次, 这两种状态都对应着”真”输出, 也就是我们想要的答案, 得出状态转移为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">状态      输入      输出</span><br><span class="line">(a, b)    (c)      (a,b)</span><br><span class="line">0, 0   0   0, 0</span><br><span class="line">0, 1   0   0, 1</span><br><span class="line">1, 0   0   1, 0</span><br><span class="line">0, 0   1   0, 1</span><br><span class="line">0, 1   1   1, 0</span><br><span class="line">1, 0   1   0, 0</span><br></pre></td></tr></table></figure></p><p>得出<code>a = (a &amp; ~b &amp; ~c) | (~a &amp; b &amp; c)</code>, <code>b = (~a &amp; b &amp; ~c) | (~a &amp; ~b &amp; c)</code>.<br>只要把数组所有数按照这个逻辑分别叠加到<code>a</code>和<code>b</code>上面, 最后答案就是<code>a | b</code>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = (a &amp; ~b &amp; ~c) | (~a &amp; b &amp; c);</span><br><span class="line">        b = (~a &amp; b &amp; ~c) | (~a &amp; ~b &amp; c);</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (a | b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上只是一种通用的套路，对于每一种特定的<code>K, M</code>组合, 可能会有不同的特殊最优方案.</p><h3 id="通过不同集合收录不同数字"><a href="#通过不同集合收录不同数字" class="headerlink" title="通过不同集合收录不同数字"></a>通过不同集合收录不同数字</h3><p>同上面的问题，LeetCode某大神给出一个<a href="https://leetcode.com/problems/single-number-ii/discuss/43294/Challenge-me-thx" target="_blank" rel="noopener">目前为止最优的方案</a>, 并放言”Challenge me”, 草鸡们看了瑟瑟发抖：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        ones = (ones ^ c) &amp; ~twos;</span><br><span class="line">        twos = (twos ^ c) &amp; ~ones;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原理是利用两个数<code>ones</code>和<code>twos</code>作为一种概念上的集合<code>set</code>，通过异或操作来收录分别出现了1次和2次的数, <code>set ^ val</code>有两种结果:</p><ul><li>如果<code>set</code>里面没有<code>val</code>, 把<code>val</code>异或进去, 如<code>a ^ 0 = a</code></li><li>如果<code>set</code>之前已经收录了<code>val</code>, 那么亦或操作就会在<code>set</code>中移除这个<code>val</code>, 如 <code>a ^ a = 0</code></li></ul><p>按照上面的定义来理解:</p><ul><li><code>(ones ^ c) &amp; ~twos</code>: 当且仅当<code>c</code>没有收录在<code>twos</code>中, 把<code>ones</code>收录<code>c</code>，否则移除<code>c</code>。这样的话，任何第一次出现的数都会被收入<code>ones</code>中, 而任何第二次出现的数会从<code>ones</code>中移出.<br>So, effectively anything that appears for the first time will be in the set. Anything that appears a second time will be removed. We’ll see what happens when an element appears a third time (thats handled by the set “twos”).</li><li>紧接着, <code>(twos ^ c) &amp; ~ones</code>用同样的逻辑更新<code>twos</code>. 这样意味着<ul><li><code>twos</code>不会收录第一次出现的数;</li><li>但对于第二次出现的数, 因为上一步已经把这个数从<code>ones</code>中移除, 那么这个数就会被收录进<code>twos</code>中,</li><li>对于第三次出现的数, 因为<code>twos</code>中已经收录了, 所以<code>ones</code>不会再收录, 而异或操作会把<code>twos</code>中的这个数移除.</li></ul></li></ul><p>最后的结果就是, <code>ones</code>仅保留出现了1次的数, <code>twos</code>仅保留出现了2次的数, 而那些出现了3次的数都被移除了.</p><p>这种方法可以扩展为通用方法, 适用于任何仅存在一个只出现了<code>M</code>次的数, 其他数都出现了<code>K</code>次的数组, 如<code>K = 4, M = 3</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>, threes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        ones = (ones ^ c) &amp; ~twos &amp; ~threes;</span><br><span class="line">        twos = (twos ^ c) &amp; ~ones &amp; ~threes;</span><br><span class="line">        threes = (threes ^ c) &amp; ~twos &amp; ~ones;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> threes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    System.out.println(singleNumber(nums)); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="找出唯二的仅出现M次的数"><a href="#找出唯二的仅出现M次的数" class="headerlink" title="找出唯二的仅出现M次的数"></a>找出唯二的仅出现M次的数</h2><p><a href="https://leetcode.com/problems/single-number-iii/" target="_blank" rel="noopener">LeetCode原题</a>:给定一个整数数组<code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。跟前面的问题类似, 我们需要再次使用XOR来解决这个问题。通过分割数组, 把出现一次的两个数, 划分到不同的数组中, 问题就转化为寻找唯一的出现一次的数问题. 所以关键就是如何拆分数组.</p><p>具体需要两次遍历：</p><ul><li>第一次遍历，对数组所有元素进行异或，获得要找的两个数字的XOR。由于两个数字是不同的，因此在XOR结果中必定有一个<code>set bit</code>, 即位值为’1’的位。</li><li>找出任意<code>set bit</code>（如最右边的）。</li><li>第二次遍历，将所有数字分成两组: 一组为具有上述<code>set bit</code>的数, 另一组没有。按照这种方法分组, 相同的数字一定会被分配到同一组中, 而两个只出现一次的数会分配到不同数组中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**代码来自: https://leetcode.com/problems/single-number-iii/discuss/68900/Accepted-C%2B%2BJava-O(n)-time-O(1)-space-Easy-Solution-with-Detail-Explanations</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// Pass 1 :</span></span><br><span class="line">        <span class="comment">// Get the XOR of the two numbers we need to find</span></span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            diff ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Get its last set bit</span></span><br><span class="line">        diff &amp;= -diff;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pass 2 :</span></span><br><span class="line">        <span class="keyword">int</span>[] rets = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">// this array stores the two numbers we will return</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; diff) == <span class="number">0</span>) <span class="comment">// the bit is not set</span></span><br><span class="line">            &#123;</span><br><span class="line">                rets[<span class="number">0</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// the bit is set</span></span><br><span class="line">            &#123;</span><br><span class="line">                rets[<span class="number">1</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;找出唯一一个仅出现M次的数&quot;&gt;&lt;a href=&quot;#找出唯一一个仅出现M次的数&quot; class=&quot;headerlink&quot; title=&quot;找出唯一一个仅出现M次的数&quot;&gt;&lt;/a&gt;找出唯一一个仅出现M次的数&lt;/h2&gt;&lt;p&gt;在一个非空整数数组，找出那个只出现了一次的元素，已知其余每个元素均出现两次。&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 不使用加减符号求和整数</title>
    <link href="http://shukebeta.me/bits-operations-04/"/>
    <id>http://shukebeta.me/bits-operations-04/</id>
    <published>2018-09-22T16:00:00.000Z</published>
    <updated>2018-09-30T09:25:49.173Z</updated>
    
    <content type="html"><![CDATA[<p>不能使用<code>+</code>和<code>-</code>, 仅通过<code>^</code>和<code>&amp;</code>操作来求和两个整数<code>a</code>.<br><a id="more"></a><br>参考<a href="https://www.cnblogs.com/kiven-code/archive/2012/09/15/2686922.html" target="_blank" rel="noopener"></a><br>每位相加可能会产生进位(carry), 所以可以把相加拆分为两部分, 如<code>759 + 674</code>可以拆分为不考虑进位的部分<code>323</code>和仅考虑进位的部分<code>1110</code>, 故<code>759 + 674 = 323 + 1110 = 1433</code>.</p><p>二进制的加法也是从低位开始逐步往高位计算:</p><ol><li>进行一位二进制的加法, 也就是暂不考虑进位的位相加: <code>0+0=0， 0+1=1, 1+0=1， 1+1=0</code>, 那么就是<code>^</code>操作. 所得的和作为新的<code>a</code>.</li><li>求进位: 通过<code>a &amp; b</code>判断是否进位, 因为只有两个位均为<code>1</code>才会进位. 所得的进位左移一位作为新的<code>b</code>.</li><li>不断重复这个过程, 把低位的进位传递到高位, 累加到<code>a</code>中, 直到进位为<code>0</code>, 最后得到的<code>a</code>就是答案.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123; <span class="comment">// 关键在于判断终止的时机</span></span><br><span class="line"><span class="keyword">int</span> c = a &amp; b; <span class="comment">//carry</span></span><br><span class="line">a ^= b; <span class="comment">//add</span></span><br><span class="line">b = c &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及的运算就是一个多位二进制加法真值表：(对应于硬件中的全加器)</p><blockquote><p>全加器（full adder）将两个一位二进制数相加，并根据接收到的低位进位信号，输出和、进位输出。全加器的三个输入信号为两个加数A、B和低位进位Cin。全加器通常可以通过级联（cascade）的方式，构成多位（如8位、16位、32位）二进制数加法器的基本部分。全加器的输出和半加器类似，包括向高位的进位信号Cout和本位的和信号S，相加结果的总和表达为 ${\displaystyle \mathrm {sum} =2\times C_{out}+S}$。</p></blockquote><p><img src="/images/full_adder.png" alt="" title="image from https://en.wikipedia.org/wiki/Adder_(electronics)"><br>规则是<br><code>s = (x ^ y) ^ Cin</code><br><code>Cout = (x &amp; y) | (y &amp; Cin) | (x &amp; Cin)</code></p><p>更简单的版本:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : getSum(a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不能使用&lt;code&gt;+&lt;/code&gt;和&lt;code&gt;-&lt;/code&gt;, 仅通过&lt;code&gt;^&lt;/code&gt;和&lt;code&gt;&amp;amp;&lt;/code&gt;操作来求和两个整数&lt;code&gt;a&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 风骚的走位操作</title>
    <link href="http://shukebeta.me/bits-operations-03/"/>
    <id>http://shukebeta.me/bits-operations-03/</id>
    <published>2018-09-21T16:00:00.000Z</published>
    <updated>2018-10-10T09:45:33.617Z</updated>
    
    <content type="html"><![CDATA[<p>通过位移实现很多风骚的操作， 参考<a href="https://www.youtube.com/watch?v=7jkIUgLC29I" target="_blank" rel="noopener">这个视频</a>。<br><a id="more"></a><br>检查一个数是否是偶数, 本质上就是取最后一位来判断, 如果是1那么就一定是奇数, 反之则为偶数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x &amp; <span class="number">1</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>Check if power of two:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x &amp; x - <span class="number">1</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>因为如果数<code>x</code>是以2底的真数, 那么其二进制一定只有一个位置是<code>1</code>, 如<code>0b1000</code>, 那么<code>x-1</code>就会变成只有该位置是<code>0</code>其右边所有位变为<code>1</code>, 即<code>0b0111</code>, 也就是说这种情况下<code>x</code>和<code>x-1</code>所有位置都互异. 那么它们的位与运算就是<code>x &amp; x - 1 = 0b0000</code>.</p><p><code>x &amp; x - 1</code>的广义用途是求<code>x</code>二进制中<code>1</code>的个数, <a href="https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan" target="_blank" rel="noopener">Counting bits set</a>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned int v; // count the number of bits set in v</span><br><span class="line">unsigned int c; // c accumulates the total bits set in v</span><br><span class="line">for (c = 0; v; c++)</span><br><span class="line">&#123;</span><br><span class="line">  v &amp;= v - 1; // clear the least significant bit set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>Brian Kernighan’s algorithm takes <code>O(log N)</code> to count set bits (1s) in an integer: each iteration sets the least significance bit that isn’t zero to zero - and only it. Since each iteration converts exactly bit from 1 to 0, it’ll take as many iterations as there are non-0 bits to convert all the bits to 0(and thus <code>v == 0</code> and the loop finishes). An integer n has <code>log(n)</code> bits, hence the worst case is <code>O(log(n))</code></p></blockquote><p>如果一个整数不为<code>0</code>, 那么其二进制就至少有一个<code>1</code>. 假设最右边一位是<code>1</code>, 那么减<code>1</code>就会把最后一位变为<code>0</code>, 前面所有位保持不变. 假如最后一位是<code>0</code>, 那么最靠右的<code>1</code>假设在<code>m</code>位置, 那么减去<code>1</code>, 该位置会变为<code>0</code>, 而其右边的所有<code>0</code>都会变为<code>1</code>, 其左边的所有位不变. <code>v &amp;= v - 1</code>把最右的<code>1</code>变为<code>0</code>.</p><p>获取二进制的最后一个<code>1</code>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last_set_bit</span><span class="params">(x)</span>:</span></span><br><span class="line">    y = ~(x - <span class="number">1</span>) <span class="comment"># = - (x - 1) - 1 = -x</span></span><br><span class="line">    <span class="keyword">return</span> x &amp; y</span><br></pre></td></tr></table></figure></p><p>假设最右边的<code>1</code>位于n, <code>-1</code>操作会把n右边所有<code>0</code>变为<code>1</code>, 而n位变为<code>0</code>. 接着<code>~</code>操作会把n左边所有位翻转, 而n及其右边的数会变为原来的样子, 也就是n为<code>1</code>, 右边全为<code>0</code>(或者没有右边). 最后<code>&amp;</code>操作就只剩下n位的<code>1</code>和右边的<code>0</code>(如果有的话).</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过位移实现很多风骚的操作， 参考&lt;a href=&quot;https://www.youtube.com/watch?v=7jkIUgLC29I&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个视频&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>算法和程序设计范例 03 - Dynamic Programming 03 - Knapsack背包问题</title>
    <link href="http://shukebeta.me/algorithm-paradigm-03-dynamic-programming-03/"/>
    <id>http://shukebeta.me/algorithm-paradigm-03-dynamic-programming-03/</id>
    <published>2018-09-02T16:00:00.000Z</published>
    <updated>2018-09-14T12:21:12.105Z</updated>
    
    <content type="html"><![CDATA[<p>继上两篇<a href="/algorithm-paradigm-01-dynamic-programming-01">01 理解动态规划</a>和<a href="/algorithm-paradigm-02-dynamic-programming-02">02 应用动态规划</a>后, 这篇继续分享各种动态规划的高级应用案例.<br><a id="more"></a></p><h2 id="Knapsack背包问题"><a href="#Knapsack背包问题" class="headerlink" title="Knapsack背包问题"></a>Knapsack背包问题</h2><blockquote><p>背包问题（Knapsack problem）是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。<br>也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V。</p></blockquote><h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h3><p>最基础的背包问题：有N件物品和一个体积为V的背包, <strong>每种物品均只有一件</strong>, 第i件物品的大小/重量是<code>s[i]</code>，价值是<code>v[i]</code>. 求将哪些物品装入背包可使这些物品的体积总和不超过背包体积，且价值总和最大.</p><p>对于每一个物品，只有两种结果，放入或者不放入背包，那么<code>kn(i, j)</code>则表示背包容量剩余<code>j</code>时, 前<code>i</code>个物品能够达到的最大值:</p><ul><li><code>kn1 = kn(i-1, j-s(i)) + v(i)</code>表示物品<code>i</code>放入背包后的总价值, 为前<code>i-1</code>物品在第<code>i</code>个物品占用了背包容量<code>s(i)</code>后的的最优解加上第<code>i</code>个物品的价值<code>v(i)</code>.</li><li><code>kn2 = kn(i-1, j)</code>表示物品<code>i</code>并没有放入背包, 等于前<code>i-1</code>个物品在相同背包容量的最优价值.</li></ul><p>归纳出来的大小子问题间的关系(转移方程)为: <code>kn(i, j) = max(kn1, kn2) = max(kn(i-1, j-s(i)) + v(i), kn(i-1, j))</code>. 初始状态是对于不同背包剩余容量, 当没有物品可放时, 返回的最大价值一定是<code>0</code>. 所以背包问题, 就是二维的动态规划问题. 需要确定初始状态, 和哪些信息需要<strong>记忆</strong>.</p><p>可以简单地用一个二维数组记忆所有<code>kn(i, j)</code>, 但要考虑到当容量非常大, 物品非常多时, 这个二维数组是很大的, 比如当<code>(i, j) = (2000, 2000000)</code>, 会抛出<code>java.lang.OutOfMemoryError: Java heap space</code>. 特别是, 当每个物品的价值也比较大时, 二维数组的<code>j</code>维度其实利用率很低. 所以存在很多优化的空间.</p><p>优化的关键点在于减少记忆点. 注意到转移方程中:</p><ul><li><code>kn(i, *)</code>只需要用到<code>kn(i-1, *)</code>的值, 但我们又清楚地知道，物品在这里是没有顺序的意义的，所以这里的<code>i</code>仅仅是表示迭代的步骤, 只是为了遍历所有物品, 至于具体的顺序是不重要的, 所以不需要记录所有<code>i</code>对应的<code>kn(i, *)</code>, 仅仅记录最近一次计算值即可. 所以我们只需要至多两个数组用来记录<code>i-1</code>和<code>i</code>对应的<code>kn</code>值.</li><li><code>kn(i, j)</code>要用到<code>kn(i-1, k), k&lt;=j</code>的值, 具体要用到哪些<code>k</code>是取决于<code>i</code>. 所以<code>j</code>维度的值必须都要记录下来, 以防后续需要用到.</li><li>结合起来发现只需要一个一维数组<code>kn = new int[size + 1]</code>即可, <code>i</code>对应的值可以直接在数组上更新, 不需要额外的数组记录上一次迭代的值. 在实现中, 因为<code>kn(i, j)</code>要用到<code>kn(i-1, &lt;=j)</code>的值, 也就是<code>kn[&lt;j]</code>的值不能先于<code>kn[j]</code>更新, 所以<code>kn</code>的计算要从右往左(<code>j = size; j--</code>).</li><li>每次决定是否加入<code>i</code>物品之前, 如果剩余容量<code>j</code>小于<code>s[i]</code>, 那么肯定无法放入, 这个判断可以融合进<code>j</code>的遍历中, 因为<code>j</code>本身代表了剩余容量.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] values;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] sizes;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = values.length;</span><br><span class="line">    <span class="keyword">int</span>[] vs = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// items</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = size; j &gt;= sizes[i]; j--) &#123;</span><br><span class="line">            vs[j] = Math.max(vs[j - sizes[i]] + values[i], vs[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化以后空间复杂度由$\theta(NS)$降到$\theta(S)$。但时间复杂度不变.</p><p>对于0-1背包问题，如果问题变为求恰好装满时的最大值, 参考<a href="https://blog.csdn.net/liangbopirates/article/details/9750463" target="_blank" rel="noopener">这篇博文</a>: 此时只有容量为<code>0</code>的背包可能被价值为<code>0</code>的物品(无物品)恰好装满，初始化合法状态<code>kn[0] = 0</code>, <code>kn[j &gt; 0]</code>为负数. 反之, 如果要求的是恰好装满时的最小值，初始化为正无穷。要注意的是改变初始化以后最后一个值是恰好装满的最大值，如果不能恰好装满，那肯定是一个负数，而且对于恰好装满的的初始化情况的不要求满的最大值是0-v背包容量的最大值。即是最后一行的MAX。</p><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>Unbounded Knapsack: 有<code>N</code>种物品和一个体积为<code>S</code>的背包，每种物品都有无限件可用。第<code>i</code>件物品的体积是<code>s[i]</code>，价值是<code>value[i]</code>。求解将哪些物品装入背包可使这些物品的体积总和不超过背包体积，且价值总和最大。</p><p>0-1背包的问题中每一种物品在背包中的数量只有<code>0</code>和<code>1</code>两种, 而完全背包问题每一种物品在背包中的数量是<code>0</code>个到<code>k = S/s[i]</code>个. 使用与0-1背包类似的定义, <code>kn(i, j)</code>表示背包容量剩余<code>j</code>时, 放入任意个前<code>i</code>个物品能够达到的最大值, 这样转移方程变为: <code>kn(i, j) = max{kn(i-1, j-k*s(i)) + k*v(i)}, 0 &lt;= k &lt;= S/s[i]</code>。可以直接在0-1背包的代码中增加一个循环，这样时间复杂度就增加了。对于取多少也可以利用二进制拆分，取的时候取<code>1, 2, 4, ...</code>。</p><h4 id="完全背包的算法优化"><a href="#完全背包的算法优化" class="headerlink" title="完全背包的算法优化"></a>完全背包的算法优化</h4><p>注意到完全背包本身也包含0-1背包的情况, 0-1背包是完全背包的特例. 完全背包的<code>kn(i, j)</code>包含了第<code>i</code>种物品的数量在<code>0 - S/s[i]</code>所有可能选择, 并取其最大值:</p><ul><li>若至少放一个物品<code>i</code>进背包, 那么在对物品<code>i</code>的数量进行<code>0 - S/s[i]</code>的遍历时, 迭代方程变为<code>kn1 = kn(i, j-s(i)) + v(i)</code></li><li>若第<code>i</code>个物品不放入背包时, 情况和0-1背包的<code>kn2</code>一样, <code>kn2 = kn(i-1, j)</code></li></ul><p>所以0-1背包的迭代方程<code>vs[j] = Math.max(vs[j - sizes[i]] + values[i], vs[j]);</code>可以直接套用在完全背包上.</p><p>只是<code>kn</code>的计算要改为从左往右(<code>j = 0; j &lt;= size; j++</code>). 因为此时<code>kn1</code>用的不再是上一次迭代的<code>kn(i-1, j-s(i))</code>, 而是本次迭代的<code>kn(i, j-s(i))</code>. 即<code>kn(i, j)</code>要用到<code>kn(i, &lt;=j)</code>的值, 所以<code>kn[&lt;j]</code>的值要先于<code>kn[j]</code>更新.</p><p>同样, 每次决定是否加入<code>i</code>物品之前, 如果剩余容量<code>j</code>小于<code>s[i]</code>, 那么肯定无法放入, 这个判断可以融合进<code>j</code>的遍历中.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] values;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] sizes;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">unboundedKnapsack</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = values.length;</span><br><span class="line">    <span class="keyword">int</span>[] vs = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// items</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = sizes[i]; j &lt;= size; j++) &#123;</span><br><span class="line">            vs[j] = Math.max(vs[j - sizes[i]] + values[i], vs[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>优化后的时间复杂度为<code>O(NV)</code>.</p><p>在数据上也可以优化：如果物品<code>a</code>比<code>b</code>价值更高, 但体积更小, 那么完全可以不考虑物品<code>b</code>。对于随机生成的数据，这个方法往往会大大减少搜索空间。</p><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>有N种物品和一个体积为V的背包。第<code>i</code>种物品最多有<code>num[i]</code>件可用，每件体积是<code>sizes[i]</code>，价值是<code>value[i]</code>。求解将哪些物品装入背包可使这些物品的体积总和不超过背包体积，且价值总和最大。</p><p>多重背包问题可以采取基于0-1背包的算法基础上增加一层循环搜索<code>num[i]</code>. 但这样的时间复杂度是<code>O(NVC)</code>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// items</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= num[i]; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = size; j &gt;= sizes[i]; j--) &#123;</span><br><span class="line">            vs[j] = Math.max(vs[j - sizes[i]] + values[i], vs[j]);</span><br><span class="line">　　  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>多重背包问题其实包含0-1背包和完全背包，可以分类处理。</p><ul><li>如果满足<code>value[i]*num[i]&gt;=size</code>，这个时候就是完全背包问题, 而完全背包要比多重背包的复杂度低，是<code>O(NV)</code>。</li><li>如果满足<code>num[i]=1</code>就是0-1背包。</li></ul><h3 id="其他背包"><a href="#其他背包" class="headerlink" title="其他背包"></a>其他背包</h3><p>混合背包: 如果将0-1、完全、多重混合起来，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。需要分类求解，判断是哪一种，然后分别给出循环和循环顺序，分别调用状态转换方程。</p><p>其他还有二维费用背包，依赖背包，分组背包…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继上两篇&lt;a href=&quot;/algorithm-paradigm-01-dynamic-programming-01&quot;&gt;01 理解动态规划&lt;/a&gt;和&lt;a href=&quot;/algorithm-paradigm-02-dynamic-programming-02&quot;&gt;02 应用动态规划&lt;/a&gt;后, 这篇继续分享各种动态规划的高级应用案例.&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Dynamic Programming" scheme="http://shukebeta.me/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>算法和程序设计范例 02 - Dynamic Programming 02 - 动态规划应用</title>
    <link href="http://shukebeta.me/algorithm-paradigm-02-dynamic-programming-02/"/>
    <id>http://shukebeta.me/algorithm-paradigm-02-dynamic-programming-02/</id>
    <published>2018-09-01T16:00:00.000Z</published>
    <updated>2018-10-12T14:53:49.962Z</updated>
    
    <content type="html"><![CDATA[<p>继上篇的<a href="/algorithm-paradigm-01-dynamic-programming-01">01 理解动态规划</a>后, 这篇继续分享各种动态规划的初级应用案例.<br><a id="more"></a></p><h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><p>跳上一个n级的台阶总共有多少种跳法，先后次序不同算不同的结果，限制条件是每次只能跳1级或者2级。</p><p>抽象出来的模型是：给定正整数<code>N</code>，有多少种累加方案，不同顺序当做不同方案，限制条件可以是给定的整数$n_0, n_1, …, n_k$作为可选累加元素.</p><p>对于限制条件为只有两种跳法, 即1阶或者2阶的, 问题可以分解为:</p><ul><li>假定第一次跳的是<code>1</code>阶，那么就剩下<code>n-1</code>个台阶，剩余跳法是<code>f(n-1)</code>;</li><li>假定第一次跳的是<code>2</code>阶，则剩下<code>n-2</code>个台阶，剩余跳法是<code>f(n-2)</code></li></ul><p>可以归纳出通用的公式: <code>f(n) = f(n-1) + f(n-2)</code>, 只有一阶的时候<code>f(1) = 1</code>, 只有两阶的时候可以有<code>f(2) = 2</code>, 刚好就是斐波那契数列. 所以这个简单的跳台阶问题就是计算斐波那契数列的问题。</p><p>反过来思考, 比如对于<code>8</code>个台阶, 有多少种回滚方案? 只有两种: 回滚1个台阶, 就到了<code>7</code>; 回滚2个台阶, 就到了<code>6</code>. 等于说: 假如有<code>f(7)</code>种方案跳到<code>7</code>, 有<code>f(6)</code>种方案跳到<code>6</code>，那么就有<code>f(7) + f(6)</code>种方案到达<code>8</code></p><p>从树结构来理解: 如果节点代表台阶数<code>n</code>对应的跳法<code>f(n)</code>, 节点与节点间的枝代表单次可以跳的阶数, 父节点的值就是其所有子节点的值和. 对于只有两种跳法限制问题, 父节点<code>f(n)</code>就只有两个子节点, 分别为<code>f(n-1)</code>和<code>f(n-2)</code>.</p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>举例：Fibonacci sequence: ${\displaystyle 0,\;1,\;1,\;2,\;3,\;5,\;8,\;13,\;21,\;34,\;55,\;89,\;144,\;\ldots }$<br>$$F_0 = 0, F_1 = 1, F_2 = 1, F_n = F_{n-1} + F_{n-2} (n&gt;2) $$</p><p>Fibonacci numbers grow almost as fast as the powers of 2.</p><p>Recursive solution is exponential algorithm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fib1(n):</span><br><span class="line">    if n = 0:  return 0</span><br><span class="line">    if n = 1:  return 1</span><br><span class="line">    return fib1(n - 1) + fib1(n - 2)</span><br></pre></td></tr></table></figure></p><p>因为每一个<code>fib1()</code>都会生成指数级数量的子分支计算, 所以这个算法复杂度是$O(2^n)$.</p><p>但是注意到斐波那契数列公式是$F_n = F_{n-1} + F_{n-2}$, 也就是只要知道n前面两个值, 就能计算出$f_n$. 又因为斐波那契数列天然的是从低往高算, 那么每次迭代只需要用到前两次的值$F_{n-1}, F_{n-2}$, 计算后更新它们即可. 用这个思路来计算斐波那契数列, 复杂度就是$O(n)$.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> target; &#125;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n0 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt;= target) &#123;</span><br><span class="line">        ways = n0 + n1;</span><br><span class="line">        n0 = n1;</span><br><span class="line">        n1 = ways;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h3><p>变态跳台阶就是是用来更复杂的限制条件, 比如可选单次跳阶数为<code>[1, ... n]</code>, 也就是无限制的情况, 也可以按照上面的思路推导.</p><p>比如从树结构的考虑, 就变成每个父节点<code>f(n)</code>可以有<code>n</code>个子节点, 就是<code>f(n-1), f(n-2), ..., f(n-n)</code>, 所以<code>f(n)</code>就是所有这些子节点的和. <code>f(n-n)</code>也就是<code>f(0)</code>意味着一次跳完所有阶数<code>n</code>, 所以<code>f(0) = 1</code>. 进一步归纳, <code>f(n-2) + ... + f(n-n) = f(n-1)</code>, 所以<code>f(n) = f(n-1) + f(n-1)</code>, 可以用递归或者动态规划来计算.</p><p>当然进一步归纳会发现$f(n) = 2^{n-1}$, 可以用位移来操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a &lt;&lt; (target - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只是要注意<code>int</code>是有范围的.</p><h3 id="大变态跳台阶"><a href="#大变态跳台阶" class="headerlink" title="大变态跳台阶"></a>大变态跳台阶</h3><p>再举一个更复杂的限制条件, 可选单次跳阶数为$2^0, 2^1, …, 2^k$, $2^k$要小于<code>n</code>. 那么相应的,<br>$$f(n) = f(n - 2^0) + f(n - 2^1)… + f(n - 2^k), \quad s.t. \quad 2^k &lt;= n,$$<br>这样就意味着对于每个<code>f(n)</code>, 需要用到的<code>f(k)</code>值数量是不同的, 就不能简单地用固定数量的变量来保留较小值了.</p><p>对于不同的<code>f(n)</code>, 它们的很多子分支计算是共享的, 比如<code>f(6)</code>和<code>f(5)</code>都用到了<code>f(4)</code>. 那么在递归的过程中，只要把每次计算出来的较小的<code>f(k)</code>储存到数组中, 后续其他<code>f(n)</code>要用到<code>f(n - 2^k)</code>时, 直接从内存中取值即可. 初始值取<code>f(0) = f(1) = 1</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorIII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[target];</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> jump(f, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[target] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= target; i++) &#123;</span><br><span class="line">            ways += jump(f, target - (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">        &#125;</span><br><span class="line">        f[target] = ways;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个代码适用于<code>n &lt;= 1024</code>的情况.</p><h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。</p><p>要判断一个数是不是丑数, 不断地分别除以<code>2, 3, 5</code>，然后检查<code>num</code>是否到达<code>1</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(除数包括`4`可以让代码更简洁)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;<span class="number">6</span> &amp;&amp; num&gt;<span class="number">0</span>; i++)</span><br><span class="line">        <span class="keyword">while</span> (num % i == <span class="number">0</span>)</span><br><span class="line">            num /= i;</span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果要返回第<code>n</code>个丑数(<a href="https://leetcode.com/problems/ugly-number-ii/" target="_blank" rel="noopener">leetcode原题</a>), 情况就稍微复杂点. 从动态规划的角度考虑, 对于一个较大的丑数<code>N</code>, 必定是由某个更小的丑数<code>M</code>乘以<code>2, 3, 5</code>其中一个得来的. 所以可以从小到大不断生成丑数. 为了避免在循环中每一次计算都从头开始检查每一个数<code>k</code>对应的<code>2*k, 3*k, 5*k</code>, 需要用三个变量<code>last2, last3, last5</code>来分别记录最近一次用到的丑数的索引, 下一次计算时就直接从上一次停止的地方开始运行.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** return the nth ugly number */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">unglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> INIT = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span>[] uglys = <span class="keyword">new</span> <span class="keyword">int</span>[n + INIT];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;) &#123;</span><br><span class="line">        uglys[i] = ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> last2, last3, last5, m2, m3, m5;</span><br><span class="line">    last2 = last3 = last5 = <span class="number">0</span>;</span><br><span class="line">    m2 = m3 = m5 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = INIT; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = last2 + <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m2 &lt;= uglys[i - <span class="number">1</span>] &amp;&amp; uglys[j] * <span class="number">2</span> &gt; uglys[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                m2 = uglys[j] * <span class="number">2</span>;</span><br><span class="line">                last2 = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = last3 + <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m3 &lt;= uglys[i - <span class="number">1</span>] &amp;&amp; uglys[j] * <span class="number">3</span> &gt; uglys[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                m3 = uglys[j] * <span class="number">3</span>;</span><br><span class="line">                last3 = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = last5 + <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m5 &lt;= uglys[i - <span class="number">1</span>] &amp;&amp; uglys[j] * <span class="number">5</span> &gt; uglys[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                m5 = uglys[j] * <span class="number">5</span>;</span><br><span class="line">                last5 = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uglys[i] = Math.min(Math.min(m2, m3), m5);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uglys[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://www.geeksforgeeks.org/ugly-numbers/" target="_blank" rel="noopener">这里</a>提供了另一个理解这个问题的思路，并由此得出了一个更快的的算法(<code>O(n)</code>)：根据前面算法的原理，可以知道下一个丑数一定是前面某一个丑数乘以2,3,5中的一个，所以可以把问题转换为从以下三组数据中不断取最小值的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) 1×2, 2×2, 3×2, 4×2, 5×2, …</span><br><span class="line">(2) 1×3, 2×3, 3×3, 4×3, 5×3, …</span><br><span class="line">(3) 1×5, 2×5, 3×5, 4×5, 5×5, …</span><br></pre></td></tr></table></figure></p><p>可以发现每个子序列是丑数序列本身<code>1, 2, 3, 4, 5......</code>分别乘以<code>2, 3, 5</code>。使用类似merge sort的合并方法，每次从三个数组中弹出最小的数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** return the nth ugly number */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] ugly = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    ugly[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> next2 = <span class="number">2</span>, next3 = <span class="number">3</span>, next5 = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ugly[i] = Math.min(next2, Math.min(next3, next5));</span><br><span class="line">        <span class="keyword">if</span> (next2 == ugly[i])</span><br><span class="line">            next2 = ugly[++i2] * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (next3 == ugly[i])</span><br><span class="line">            next3 = ugly[++i3] * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (next5 == ugly[i])</span><br><span class="line">            next5 = ugly[++i5] * <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ugly[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>对于一个字符串, 它的子序列，就是将给字符串中任意个元素去掉之后剩余的字符串, 所以子序列不要求是连续的, 但是维持原来的顺序. 在文本相似度比较中，常用到最长公共子序列（longest common sequence）。</p><p>同时遍历两个字符串, 如果<code>x[i] == y[j]</code>, 则<code>x[i]</code>和<code>y[j]</code>参与了最长公共子序列<code>z[k]</code>的构建.</p><p>如果用<code>lcs[i, j]</code>表示遍历到<code>x[0-i]</code>和<code>y[0-j]</code>时的LCS长度, 那么现在就需要判断<code>x[i]</code>和<code>y[j]</code>的关系, 分两种情况:</p><ul><li>如果二者相等, 那么<code>lcs1 = lcs[i - 1, j - 1] + 1</code></li><li>若不相等, 那么只能在<code>x</code>和<code>y</code>中选择一个进行推进, 选择依据就是取较大值, <code>lcs2 = max(lcs[i - 1, j], lcs[i, j - 1])</code></li></ul><p>初始状态自然是<code>lcs[0, 0] = 0</code>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[][] lcs;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestCS</span><span class="params">(String x, String y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] xList = x.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] yList = y.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= xList.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= yList.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xList[i - <span class="number">1</span>] == yList[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                lcs[i][j] = lcs[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lcs[i][j] = Math.max(lcs[i - <span class="number">1</span>][j], lcs[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lcs[x.length()][y.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><p>最长公共子串（longest common substring）, 要求的是任意连续的子字符串。设定<code>LCS(i, j)</code>为包含当前字符<code>a[i]</code>和<code>b[j]</code>的最长lcs. 假如当前满足<code>a[i] == b[j]</code>, 那么<code>LCS(i, j) = LCS(i - 1, j - 1) + 1</code>, 否则为0.</p><p>比如字符串<code>21232523311324</code>和字符串<code>312123223445</code>的匹配矩阵，前者为X方向的，后者为Y方向的。例子来源于<a href="http://www.cnblogs.com/dartagnan/archive/2011/10/06/2199764.html" target="_blank" rel="noopener">这篇文章</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 1 0 0 0 1 1 0 0 1 0 0 0</span><br><span class="line">0 1 0 0 0 0 0 0 0 2 1 0 0 0 0</span><br><span class="line">1 0 2 0 1 0 1 0 0 0 0 0 1 0 0</span><br><span class="line">0 2 0 0 0 0 0 0 0 1 1 0 0 0 0</span><br><span class="line">1 0 3 0 1 0 1 0 0 0 0 0 1 0 0</span><br><span class="line">0 0 0 4 0 0 0 2 1 0 0 1 0 0 0</span><br><span class="line">1 0 1 0 5 0 1 0 0 0 0 0 2 0 0</span><br><span class="line">1 0 1 0 1 0 1 0 0 0 0 0 1 0 0</span><br><span class="line">0 0 0 2 0 0 0 2 1 0 0 1 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 1 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 1 0</span><br><span class="line">0 0 0 0 0 1 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongest</span><span class="params">(String A, <span class="keyword">int</span> n, String B, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] cha = A.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] chb = B.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="keyword">if</span> (cha[i] == chb[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) ? matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                max = Math.max(max, cur);</span><br><span class="line">                matrix[i][j] = cur;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从另一个角度理解, 这个解法就是用一个矩阵来记录两个字符串中所有位置的两个字符之间的匹配情况，若是匹配则赋上其左上角元素的值加1，否则为0。矩阵中值最大的值，就对应着对角线最长的非0连续序列，其对应的位置就是最长匹配子串的位置，最长匹配子串的位置和长度就已经出来了。计算这个矩阵的复杂度是<code>O(N*M)</code>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继上篇的&lt;a href=&quot;/algorithm-paradigm-01-dynamic-programming-01&quot;&gt;01 理解动态规划&lt;/a&gt;后, 这篇继续分享各种动态规划的初级应用案例.&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Dynamic Programming" scheme="http://shukebeta.me/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>算法和程序设计范例 01 - Dynamic Programming 01 - 理解动态规划</title>
    <link href="http://shukebeta.me/algorithm-paradigm-01-dynamic-programming-01/"/>
    <id>http://shukebeta.me/algorithm-paradigm-01-dynamic-programming-01/</id>
    <published>2018-08-31T16:00:00.000Z</published>
    <updated>2018-09-14T10:33:22.527Z</updated>
    
    <content type="html"><![CDATA[<p>在解决问题中，有很多经典的方法，如 divide-and-conquer, graph exploration, and greedy。这些方法虽然很有效，但尤其自身的局限性。某些问题（Advanced problem: the knapsack problem, sequence alignment, and optimal binary search trees）需要其他思路解决，如 Dynamic programing 和 linear programming。</p><p>参考：<a href="https://people.eecs.berkeley.edu/~vazirani/algorithms/chap6.pdf" target="_blank" rel="noopener">https://people.eecs.berkeley.edu/~vazirani/algorithms/chap6.pdf</a><br><a id="more"></a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划作为一种编程范例，可以从一个例子着手理解：求数列的 weighted independent sets (WIS, 最大非连续非相邻子集)和, 对于<code>a = [1, 4, 5, 4]</code>, 其WIS为<code>{a[1], a[3]} = 8</code>.</p><p>如果使用贪心法, 每次都在可选范围内取最大值, 那么就会得到<code>{a[2], a[0]} = 6</code>.</p><p>如果使用分而治之法, 把数组分为两半<code>a1 = [1, 4], a2 = [5, 4]</code>, 则分别得到WIS<code>{a1[1]}, {a2[0]}</code>, 合并后发现是相邻的, 与要求相悖.</p><p>要解决这个问题，关键的步骤是找到<strong>基于子问题最优解的最优解</strong>：想办法把缩小最优解备选方案的数量，在这个较小的空间中可以直接采取暴力搜索寻找最优解。</p><p>对于<code>a = [1, 4, 5, 4]</code>, 假设其MSI为<code>S</code>, 假如从最右边的元素开始考虑, <code>a[3] = 4</code>只有属于<code>S</code>和不属于<code>S</code>两种情况</p><ul><li>若<code>a[3] = 4</code>属于<code>S</code>: 那么<code>a[2] = 5</code>就肯定不属于<code>S</code>, 则<code>S1 = MSI([1, 4]) + MSI([4])</code></li><li>若<code>a[3]</code>不属于<code>S</code>: 那么<code>S</code>只能存在于<code>[1, 4, 5]</code>中, 问题就变成<code>S2 = MSI([1, 4, 5])</code></li></ul><p>所以归纳出<code>S = max(S1, S2) = max(MSI([1, 4]) + MSI([4]), MSI([1, 4, 5])) = ...</code>。 对于只剩下一个元素的去情况, <code>MSI([4]) = max(4) = 4</code>, 即<code>MSI([i]) = i</code></p><p>这就是一个递归的调用: 也就是从右往左, 每一个元素都要考虑一遍是否属于<code>S</code>, 每次会分裂出两种情况, 所以递归的复杂度是$Θ(2^n)$.</p><p>这个算法效率不高, 需要优化. 我们考虑这个问题到底有多少不同的子问题? 因为我们是从右往左扫描每一个元素, 对于每一个元素<code>i</code>, 不管其属于或不属于<code>S</code>, 待解决的递归子问题只有一个, 就是求其左边的所有元素(前缀)的MSI, 所以理论上有$Θ(n)$个不同的子问题.</p><p>所以虽然递归的调用是$Θ(2^n)$, 但需要解决的子问题只有$Θ(n)$, 那么就存在优化的空间. 办法就是通过<strong>记忆</strong>已经解决了的子问题的答案, 来避免重复的计算. 因为右边的元素的子问题答案需要用到其左边的子问题的答案, 所以计算时, 要从左往右计算， 所以这个算法成为forward算法. 在定义初始值时, <code>MSI(i)</code>表示<code>a[i]</code>的前缀<code>a[0 : i]</code>的MSI,</p><ol><li><code>MSI(0) = 0</code>, 因为<code>a[0]</code>左边没有任何元素.</li><li><code>MSI(1) = max(a[0:1]) = a[0]</code></li><li>对于<code>i &gt; 1</code>, <code>MSI(i) = max(MSI(i - 1), MSI(i - 2) + a[i - 1])</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] forwardMSI(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] msi = <span class="keyword">new</span> <span class="keyword">int</span>[a.length + <span class="number">1</span>];</span><br><span class="line">    msi[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    msi[<span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; msi.length; i++) &#123;</span><br><span class="line">        msi[i] = Math.max(msi[i - <span class="number">1</span>], msi[i - <span class="number">2</span>] + a[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但以上算法并没有记录MSI具体包含哪些子集，虽然可以通过修改<code>msi</code>数据结构来额外存储每个值对应的MSI点集, 但这样会影响效率而且浪费内存空间.</p><p>回忆前面从右往左的分析, 每个元素都会考量是否属于MSI<code>S</code>, 所以我们可以把<code>forwardMSI</code>中算好的<code>msi</code>数组从右往左依次判断一遍, 已决定是否把<code>a</code>对应位置的元素加入到<code>S</code>中.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">backwardMSI</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; s = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = msi.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msi[i - <span class="number">1</span>] &gt;= msi[i - <span class="number">2</span>] + a[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.add(a[i - <span class="number">1</span>]);</span><br><span class="line">            i -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进一步优化，我们可以用类似<code>backward</code>的算法一次过(<code>O(n)</code>)计算出MSI的集合和MSI的值, 对<code>backward</code>算法稍作改动, 在<code>a</code>表开头插入<code>0</code>（或者让<code>a[-1] = 0</code>）, 然后从右往左依次判断一遍, 直接用<code>a</code>表自身的值来判断, 得到一个Backward算法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">backwardMSII</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; s = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = get(a, i);</span><br><span class="line">        <span class="keyword">if</span> (get(a, i - <span class="number">1</span>) &gt;= get(a, i - <span class="number">2</span>) + x) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.add(x);</span><br><span class="line">            sum += x;</span><br><span class="line">            i -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结动态规划的解法：</p><ul><li>定义合适的子问题集合: 这些子问题应该尽可能小，数量尽可能少。因为即使在最好的情况下，也要花费 constant time 来解决每个子问题，因此子问题的数量和大小就是整个算法运行时间的下限。</li><li>归纳转移方程：系统地解决从最小的子问题开始的所有子问题后，如何转向越来越大的子问题。</li><li>通过<strong>记忆</strong>减少重复的递归调用计算: 要求前面子问题的解决方案能够用来快速计算当前子问题。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在解决问题中，有很多经典的方法，如 divide-and-conquer, graph exploration, and greedy。这些方法虽然很有效，但尤其自身的局限性。某些问题（Advanced problem: the knapsack problem, sequence alignment, and optimal binary search trees）需要其他思路解决，如 Dynamic programing 和 linear programming。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://people.eecs.berkeley.edu/~vazirani/algorithms/chap6.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://people.eecs.berkeley.edu/~vazirani/algorithms/chap6.pdf&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Dynamic Programming" scheme="http://shukebeta.me/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 基础的位运算</title>
    <link href="http://shukebeta.me/bits-operations-02/"/>
    <id>http://shukebeta.me/bits-operations-02/</id>
    <published>2018-08-29T16:00:00.000Z</published>
    <updated>2018-09-30T09:03:10.193Z</updated>
    
    <content type="html"><![CDATA[<p>一些常规的操作， 参考<a href="https://www.youtube.com/watch?v=7jkIUgLC29I" target="_blank" rel="noopener">这个视频</a>。<br><a id="more"></a></p><h2 id="基本位操作"><a href="#基本位操作" class="headerlink" title="基本位操作"></a>基本位操作</h2><p>把某一位变为<code>1</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_bit</span><span class="params">(x, position)</span>:</span></span><br><span class="line">    mask = <span class="number">1</span> &lt;&lt; position</span><br><span class="line">    <span class="keyword">return</span> x | mask</span><br><span class="line"></span><br><span class="line">bin(set_bit(<span class="number">0b110</span>, <span class="number">0b101</span>))</span><br></pre></td></tr></table></figure></p><p>输出<code>0b100110</code>. 因为<code>x = 0b110 = 6</code>, 翻转第五位，就用<code>position = 0b101 = 5</code>， 得到<code>mask = 0b00100000</code>, 用<code>|</code>把第五位变为<code>1</code>.</p><p>清除某一位（<code>1</code>变<code>0</code>)：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clear_bit</span><span class="params">(x, position)</span>:</span></span><br><span class="line">    mask = <span class="number">1</span> &lt;&lt; position</span><br><span class="line">    <span class="keyword">return</span> x &amp; ~mask</span><br></pre></td></tr></table></figure></p><p>通过XOR<code>^</code>和<code>1</code>来翻转某一位：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flip_bit</span><span class="params">(x, position)</span>:</span></span><br><span class="line">    mask = <span class="number">1</span> &lt;&lt; position</span><br><span class="line">    <span class="keyword">return</span> x ^ mask</span><br></pre></td></tr></table></figure></p><p>通过<code>&amp;1</code>可以作为取位操作, 来判断某一位是否是<code>1</code>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_bit_set</span><span class="params">(x, position)</span>:</span></span><br><span class="line">    shifted = x &gt;&gt; position</span><br><span class="line">    <span class="keyword">return</span> shifted &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p><code>0b1100110 &gt;&gt; 0b101</code> = <code>0b11</code>, <code>0b11 &amp; 0b01</code> = <code>1</code></p><p>根据参数<code>state</code>来控制修改某一位, 如果参数是<code>1</code>那么就是set, 如果是<code>0</code>那么就是clear:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify_bit</span><span class="params">(x, position, state)</span>:</span></span><br><span class="line">    mask = <span class="number">1</span> &lt;&lt; position</span><br><span class="line">    <span class="keyword">return</span> (x &amp; ~mask) | (-state &amp; mask)</span><br></pre></td></tr></table></figure></p><p>如果<code>state = 0b1</code>, <code>-state = 0b11111111</code><br>如果<code>state = 0b0</code>, <code>-state = 0b0</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些常规的操作， 参考&lt;a href=&quot;https://www.youtube.com/watch?v=7jkIUgLC29I&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个视频&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 二进制操作符</title>
    <link href="http://shukebeta.me/bits-operations-01/"/>
    <id>http://shukebeta.me/bits-operations-01/</id>
    <published>2018-08-20T16:00:00.000Z</published>
    <updated>2018-10-07T03:55:46.079Z</updated>
    
    <content type="html"><![CDATA[<p>在很多语言中，字符<code>char</code>类型是八位, 那么可能取值有256种(<code>-128 ~ -1, 0 ~ 127</code>). 但是用二进制表示为<code>0000 0000 ~ 1111 1111</code>, 无符号整数的全部位都表示数值，而有符号数的最高位是符号位（0表示正数，1表示负数），所以实际表达数值的只剩下<code>n-1</code>位。这样理论上<code>char</code>的取值应该是<code>1111 1111 = -127</code>到<code>0111 1111 = 127</code>. 而<code>-128 = 1 1000 0000</code>需要9位来表达, 所以<code>char</code>是如何仅仅通过八位表达<code>-128</code>?<br><a id="more"></a></p><p>首先, 因为计算机只能做加法, 所以减法操作要转化为加法, <code>1-1</code>就转化为<code>1 + (-1)</code>, 用二进制表达为<code>0000 0001 + 1000 0001 = -2</code>, 很明显是错的.</p><p>为了避免这种错误, 引入<strong>反码</strong>(反码是原码除最高位其余位取反), 用<code>1</code>的反码<code>1111 1110</code>来表达<code>-1</code>, 这样<code>0000 0001 + 1111 1110 = 1111 1111</code>, 转为原码<code>1000 0000 = -0</code>.</p><p>但因为<code>-0 = 0</code>, 为了解决<code>1000 0000 = 0000 0000</code>, 又引入<strong>补码</strong>( 也就是<code>反码 + 1</code>, 正数的补码是其本身，负数的补码为其反码加1). 这样减法操作转化为加补码<code>1+(-1) = 0000 0001 + 1111 1111 = 1 0000 0000</code>, <code>char</code>定义为8位, 故第九位舍弃, 得到正确的结果<code>0</code>.</p><blockquote><p>补码（two’s complement）是一种用二进制表示有号数的方法，也是一种将数字的正负号变号的方式，<br>8-bits 补码: 在表示正数和零时，补码数字和一般二进制一样，唯一的不同是在补码系统中，正数的最高比特恒为0<br>0     1     1     1     1     1     1     1     =     127<br>0     0     0     0     0     0     1     0     =     2<br>0     0     0     0     0     0     0     1     =     1<br>0     0     0     0     0     0     0     0     =     0<br>1     1     1     1     1     1     1     1     =     −1<br>1     1     1     1     1     1     1     0     =     −2<br>1     0     0     0     0     0     0     1     =     −127<br>1     0     0     0     0     0     0     0     =     −12<br>二进制补码运算是加法逆运算。补码系统的最大优点是可以在加法或减法处理中，不需因为数字的正负而使用不同的计算方式。只要一种加法电路就可以处理各种有号数加法，而且减法可以用一个数加上另一个数的补码来表示，因此只要有加法电路及补码电路即可完成各种有号数加法及减法。</p></blockquote><p>所以, <code>-0 = 1000 0000</code>的补码为<code>1 0000 0000 = 0000 0000 = 0</code>, <code>0 = 0000 0000</code>的补码为<code>1000 0000 = -0</code>. 鉴于<code>0</code>的非负非正特性, 仅仅使用<code>0000 0000</code>来表达<code>0</code>和其补码就足够了. 这样<code>1000 0000</code>就可以挪作他用,用来表达<code>-128</code>. 之所以用来表达<code>-128</code>是有其合理性的. 因为<code>-128 = 1 1000 0000</code>的补码也刚好是<code>1 1000 0000</code>, 放进<code>char</code>的八位空间中, 需要把第九位截断, 得到的刚好是<code>1000 0000</code>.</p><p>所以总的原因就是因为<code>-0</code>的多余存在, 把<code>-0</code>的二进制表达给了<code>-128</code>. <code>int</code> 同理<code>-32768~32767</code>，因为在16位中，<code>-32768</code>为原码为17位，丢弃最高位剩下的16和<code>-0</code>的原码相同。</p><h2 id="Bitwise-operators"><a href="#Bitwise-operators" class="headerlink" title="Bitwise operators"></a>Bitwise operators</h2><p>Bitwise NOT - <code>~</code>, or complement: <code>0</code> become <code>1</code>, <code>1</code> become <code>0</code>.</p><blockquote><p>The bitwise complement is equal to the <strong>two’s complement</strong> of the value minus one. <code>~x = -x − 1</code></p></blockquote><p>也就是通过<code>-x = ~x + 1</code>得到一个数的负数, 得到的负数也就是该二进制数字的补码:</p><p>Bitwise AND - <code>&amp;</code>: <code>1 &amp; 1 = 1</code>, <code>1 &amp; 0 = 0</code>, <code>0 &amp; 0 = 0</code>.</p><blockquote><p>performs the logical AND operation on each pair of the corresponding bits, which is equivalent to multiplying them. Thus, if both bits in the compared position are 1, the bit in the resulting binary representation is 1 (1 × 1 = 1); otherwise, the result is 0 (1 × 0 = 0 and 0 × 0 = 0).</p></blockquote><p>Bitwise OR - <code>|</code>: <code>1 | 1 = 1</code>, <code>1 | 0 = 1</code>, <code>0 | 0 = 0</code></p><blockquote><p>takes two bit patterns of equal length and performs the logical inclusive OR operation on each pair of corresponding bits. The result in each position is 0 if both bits are 0, while otherwise the result is 1.</p></blockquote><p>Bitwise XOR - <code>^</code>: <code>1 ^ 1 = 0</code>, <code>1 ^ 0 = 1</code>, <code>0 ^ 0 = 0</code></p><blockquote><p>takes two bit patterns of equal length and performs the logical exclusive OR operation on each pair of corresponding bits. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1. In this we perform the comparison of two bits, being 1 if the two bits are different, and 0 if they are the same.</p></blockquote><h2 id="Bit-shifts"><a href="#Bit-shifts" class="headerlink" title="Bit shifts"></a>Bit shifts</h2><p>Java中有三种<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html" target="_blank" rel="noopener">移位运算符</a>.</p><ul><li><code>&lt;&lt;</code>: 左移运算符，<code>num &lt;&lt; n</code>, 把<code>num</code>的二进制左移<code>n</code>位, 右边的空位用<code>0</code>补上, 每一次移位相当于<code>num * 2</code>(除非overflow)</li><li><code>&gt;&gt;</code>: 右移运算符，<code>num &gt;&gt; n</code>, 右移<code>n</code>, 每次移位相当于<code>num / 2</code><ul><li>如果是无符号数值，也就是<code>&gt;&gt;&gt;</code>，左边空缺用<code>0</code>补上,</li><li>如果是有符号数值，则用数字的符号位填补最左边的<code>n</code>位<ul><li>如果是正数, 则右移后在最左边补<code>n</code>个<code>0</code></li><li>如果原先是负数, 则右移后在最左边补<code>n</code>个<code>1</code></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在很多语言中，字符&lt;code&gt;char&lt;/code&gt;类型是八位, 那么可能取值有256种(&lt;code&gt;-128 ~ -1, 0 ~ 127&lt;/code&gt;). 但是用二进制表示为&lt;code&gt;0000 0000 ~ 1111 1111&lt;/code&gt;, 无符号整数的全部位都表示数值，而有符号数的最高位是符号位（0表示正数，1表示负数），所以实际表达数值的只剩下&lt;code&gt;n-1&lt;/code&gt;位。这样理论上&lt;code&gt;char&lt;/code&gt;的取值应该是&lt;code&gt;1111 1111 = -127&lt;/code&gt;到&lt;code&gt;0111 1111 = 127&lt;/code&gt;. 而&lt;code&gt;-128 = 1 1000 0000&lt;/code&gt;需要9位来表达, 所以&lt;code&gt;char&lt;/code&gt;是如何仅仅通过八位表达&lt;code&gt;-128&lt;/code&gt;?&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
</feed>
