<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>计算机科学与人工智能</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-21T00:42:47.533Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>舒克贝塔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法与数据结构 09 - Java | 双向链表 Doubly Linked List - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-09-java-doubly-linked-list/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-09-java-doubly-linked-list/</id>
    <published>2018-01-13T00:00:00.000Z</published>
    <updated>2018-01-21T00:42:47.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="双向链表-Doubly-Linked-List"><a href="#双向链表-Doubly-Linked-List" class="headerlink" title="双向链表 Doubly Linked List"></a>双向链表 Doubly Linked List</h2><p>前面介绍过单向链表，不过单向链表有几个缺点. 第一个就是它的<code>addLast</code>操作非常慢。单向链表只有一个变量保存列表头的地址, 以及每个节点对后面节点的单向引用(链接). 对于很长的列表，<code>addLast</code>方法必须遍历整个列表, 一直到找到列表末尾才能执行插入操作. 那么如何解决呢?</p><p>最直观的解决方案就是加个’车尾’, 如图<img src="/images/sllist_last_pointer.png" alt="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/sllist_last_pointer.png"> 这样我们就可以直接通过<code>last.next</code>引用末尾位置.<br>不过另一个问题并没有解决, 就是删除列表最后一项<code>removeLast</code>这个操作还是很慢。因为在目前的结构设计下, 我们需要先找到倒数第二项，然后将其下一个指针设置为<code>null</code>。而要找到倒数第二节点, 我们就得先找到倒数第三个节点…… 以此类推。也就是说，对于删除末尾的操作，还是要几乎遍历整个列表。</p><h3 id="反方向的链接"><a href="#反方向的链接" class="headerlink" title="反方向的链接"></a>反方向的链接</h3><p>基于前面单向链表构建双向链表, 一个比较有效的方法是额外为每个节点添加一个指向前面节点的链接/指针.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> OneNode prev; <span class="comment">//指向前</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">public</span> OneNode next; <span class="comment">//指向后</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>增加这些额外的指针会导致额外的代码复杂度, 以及额外的内存开销, 这就是追求时间效率的代价.</p><h3 id="Sentinel-与尾节点"><a href="#Sentinel-与尾节点" class="headerlink" title="Sentinel 与尾节点"></a>Sentinel 与尾节点</h3><p>双向链表的一个设计初衷，就是为了解决单向链表针对列表末尾位置的操作效率不高的问题，除了sentinel和反方向的链接还不够，我们还需要一个节点（指针）能够直接帮我们定位到列表末端。可以考虑添加一个的尾节点<code>last</code>，<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_basic_size_0.png" alt="fig source https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_basic_size_0.png"> <img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_basic_size_2.png" alt="fig source https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_basic_size_2.png"> 这样的列表就可以支持<code>O(1)</code>复杂度的<code>addLast</code>,<code>getLast</code> 和 <code>removeLast</code>操作了。</p><h2 id="循环双端链表"><a href="#循环双端链表" class="headerlink" title="循环双端链表"></a>循环双端链表</h2><p>上面的尾节点设计虽然没什么错误，但有点瑕疵：最后一个尾节点指针有时指向前哨节点，有时指向一个真正的节点。更好的方法是使双向链表首尾相连, 构成一个循环，即前后节点共享唯一的一个前哨节点。<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_0.png" alt="fig source https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_0.png"> <img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_2.png" alt="fig source https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_2.png"><br>这样的设计相对更整洁，更美观(主观上的), sentinel的<code>prev</code>就指向列表最后一个节点, sentinel的<code>next</code>指向列表第一个节点.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDeque</span>&lt;<span class="title">GType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">OneNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> OneNode prev; <span class="comment">//sentinel's forward link always points to the last element</span></span><br><span class="line">        <span class="keyword">public</span> GType item;</span><br><span class="line">        <span class="keyword">public</span> OneNode next; <span class="comment">//sentinel's backward link always points to the first element</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OneNode</span><span class="params">(OneNode p, GType i, OneNode n)</span> </span>&#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            item = i;</span><br><span class="line">            next = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后修改构造函数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Creates an empty deque. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedListDeque</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sentinel = <span class="keyword">new</span> OneNode(<span class="keyword">null</span>,<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    sentinel.prev = sentinel;</span><br><span class="line">    sentinel.next = sentinel;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Creates a deque with x  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedListDeque</span><span class="params">(GType x)</span></span>&#123;</span><br><span class="line">    sentinel = <span class="keyword">new</span> OneNode(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    sentinel.next = <span class="keyword">new</span> OneNode(sentinel, x,sentinel);</span><br><span class="line">    sentinel.prev = sentinel.next;</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果是初始化空列表, 那么其实就是一个自己指向自己的<code>sentinel</code>节点. 如果是非空列表, 那么<code>sentinel</code>节点和真实的节点就构成了一个最简单的二元循环体.</p><h3 id="针对列表末尾位置的操作"><a href="#针对列表末尾位置的操作" class="headerlink" title="针对列表末尾位置的操作"></a>针对列表末尾位置的操作</h3><p>双端链表结构优雅，虽然某些操作如<code>addFirst</code>等编码复杂度会提高, 但不影响速度. 更重要的是, 相比单向链表, 它反而使得<code>addLast, moveLast</code>等方法的代码实现变得简单了, 而且还进一步提升了运行速度(<code>O(n)到O(c)</code>).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Adds an item to the back of the Deque.</span></span><br><span class="line"><span class="comment"> * O(c) */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(GType x)</span></span>&#123;</span><br><span class="line">    OneNode oldBackNode = sentinel.prev;</span><br><span class="line">    OneNode newNode = <span class="keyword">new</span> OneNode(oldBackNode, x, sentinel);</span><br><span class="line">    sentinel.prev = newNode;</span><br><span class="line">    oldBackNode.next = newNode;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes and returns the item at the front of the Deque.</span></span><br><span class="line"><span class="comment"> * If no such item exists, returns null.O(c). */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GType <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OneNode oldFrontNode = sentinel.next;</span><br><span class="line">    sentinel.next = oldFrontNode.next;</span><br><span class="line">    oldFrontNode.next.prev = sentinel;</span><br><span class="line">    size -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldFrontNode.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;双向链表-Doubly-Linked-List&quot;&gt;&lt;a href=&quot;#双向链表-Doubly-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;双向链表 Doubly Linked List&quot;&gt;&lt;/a&gt;双向链表 Doubly Linke
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 08 - Java | 单向链表 Singly Linked List - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-08-java-singly-linked-list/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-08-java-singly-linked-list/</id>
    <published>2018-01-12T00:00:00.000Z</published>
    <updated>2018-01-20T23:34:46.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表 Linked List"></a>链表 Linked List</h2><p>前面有介绍以array为基础搭建的列表，支持自动扩容, 各种插入，删除速度都很快.<br>这里再介绍另一种方案, 链表, 也可以实现列表自动扩容.</p><h3 id="带链接的节点"><a href="#带链接的节点" class="headerlink" title="带链接的节点"></a>带链接的节点</h3><p>链表的核心组成是带链接的节点, 每个节点就像火车车厢, 有钩子连接下一节车厢.</p><p><img src="/images/408px-Singly-linked-list.png" alt=""><br>以int节点为例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">public</span> IntNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntNode</span><span class="params">(<span class="keyword">int</span> i, IntNode n)</span> </span>&#123;</span><br><span class="line">        item = i;</span><br><span class="line">        next = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>next</code>就是这个链接, 每一个节点就是其上一个节点的<code>next</code>.<br><a id="more"></a></p><h3 id="嵌套类-Nested-static-class"><a href="#嵌套类-Nested-static-class" class="headerlink" title="嵌套类 Nested static class"></a>嵌套类 Nested static class</h3><p>这个节点作为一个相对独立的数据结构, 我们更希望让他单独作为一个类来维护. 再另外创建一个名为<code>LinkedList</code>的class与用户进行交互. 这样还有另一个好处就是提供一个命名为<code>LinkedList</code>的类给用户交互，用户更直观地知道自己是在调用链表。如果直接与node类交互，用户可能会困扰. 但同时考虑到这个node类只有<code>LinkedList</code>会调用，所以我们可以把node类嵌套进<code>LinkedList</code>中，也就是嵌套类，在类中定义类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">XXX</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">OneNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> XXX item;</span><br><span class="line">        <span class="keyword">public</span> OneNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OneNode</span><span class="params">(XXX i, OneNode n)</span> </span>&#123;</span><br><span class="line">            item = i;</span><br><span class="line">            next = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OneNode first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(XXX x)</span> </span>&#123;</span><br><span class="line">        first = <span class="keyword">new</span> OneNode(x, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面是各种方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上定义使用了<a href="/NOTE-CS61B-data-structures-05-java-variable-types#通用数据类型-Generic">泛型</a>。声明<code>OneNode</code>实例<code>first</code>为私有变量, 是为了防止用户错误地摆弄链接指向，<code>private</code>和<code>public</code>的使用<a href="/NOTE-CS61B-data-structures-07-java-array-based-list#公共-vs-私有-Public-vs.-Private">参考</a>.</p><h4 id="静态与非静态嵌套类"><a href="#静态与非静态嵌套类" class="headerlink" title="静态与非静态嵌套类"></a>静态与非静态嵌套类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticNestedClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果嵌套类不需要使用<code>LinkedList</code>的任何实例方法或变量，那可以声明嵌套类为static。像静态类方法一样，静态嵌套类不能直接引用其外部类中定义的实例变量或方法, 只能通过实例对象引用来使用它们。同时外部类不能直接访问静态嵌套类的成员变量，但可以通过静态嵌套类来访问。</p><p>非静态嵌套类一般叫做内部类inner class。与实例方法和变量一样，内部类与其外部类的实例关联，并且可以直接访问该对象的方法和变量。另外，因为内部类与一个实例相关联，所以它不能自己定义任何静态成员。一个内部类的实例作为成员存在于其外部类的实例中, <code>InnerClass</code>的一个实例只能存在于<code>OuterClass</code>的一个实例中，并且可以直接访问它的外部实例的方法和变量。</p><p>作为OuterClass的成员，嵌套类可以声明为private，public，protected或package private。外部类只能声明为public或package private。更多详情<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html" target="_blank" rel="noopener">参考官网</a>.</p><h3 id="补充必要的实例方法"><a href="#补充必要的实例方法" class="headerlink" title="补充必要的实例方法"></a>补充必要的实例方法</h3><p>插入的操作核心是改变链接指向， 比如原来是<code>A-&gt;B-&gt;D</code>, 要插入C, 则把<code>C.next</code>指向D,然后把<code>B.next</code>改为指向C, 变为<code>A-&gt;B-&gt;C-&gt;D</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 在列表开头插入 x. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(XXX x)</span> </span>&#123;</span><br><span class="line">    first = <span class="keyword">new</span> OneNode(x, first);</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回列表第一个元素. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> XXX <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first.item; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 在列表末尾插入 x. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(XXX x)</span> </span>&#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    OneNode p = first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把 p 当做指针顺藤摸瓜一直挪到列表末尾. */</span></span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.next = <span class="keyword">new</span> OneNode(x, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 删除列表末尾的元素. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//自行补充...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，如果用户不小心把某节点x指回自己<code>x.next=x</code>,那就会进入死循环，所以我们需要把<code>OnoNode</code>实例<code>first</code>声明为私有变量已提供必要的保护。</p><h3 id="超载-overloading"><a href="#超载-overloading" class="headerlink" title="超载 overloading"></a>超载 overloading</h3><p>如果想初始化一个空列表, 可以:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 构造一个空列表. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fist = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即使原来已经有一个带参数x的构造器了, 这里再加一个同名构造器也没问题. 因为Java允许有不同参数的方法重名, 叫超载 overloading.</p><h3 id="程序不变条件-invariants"><a href="#程序不变条件-invariants" class="headerlink" title="程序不变条件 invariants"></a>程序不变条件 invariants</h3><p>上面超载了一个初始化空列表的构造器,加入初始化一个空列表，然后直接调用<code>addLast</code>，程序会报错, 因为<code>null</code>没有<code>next</code>.</p><p>有几种修改方法, 比如用<code>if else</code>这种加特例的方法. 这个方案虽然可以能解决问题，但是必要时应该避免加入特例代码, 毕竟有特例就意味着增加了复杂性和额外的代码特例记忆需求, 而人记忆是有限的.</p><p>一个更简洁（尽管不太显而易见）的解决方案是修改数据结构本身，让所有<code>LinkedList</code>，维护起来都没有差别，即使是空的。<br>如果把列表比做拉货的火车，那么货物就是列表承载的数据。一列火车如果只有车厢而没有车头（或者车尾）的话是没有意义的，因为没有动力。所以不管火车有没有拉货，有车厢还是没车厢，要称之为火车我们至少需要一个火车头。<br>我们可以通过创建一个特殊节点, 称为前哨节点 sentinel。前哨节点将保存一个值，具体数值我们不关心，它只是作为火车头，不装货。<br><img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig22/three_item_sentenlized_SLList.png" alt="图片链接https://joshhug.gitbooks.io/"><br>所以我们要修改<code>LinkedList</code>为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第一个元素 （假如有的话）就是 sentinel.next. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">XXX</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">OneNode</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OneNode sentinel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造一个空列表. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> OneNode(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造一个初始元素为x的列表. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(XXX x)</span> </span>&#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> OneNode(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> OneNode(x, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于像<code>LinkedList</code>这样简单的数据结构来说，特例不多我们也许可以hold住, 一旦后续遇到像树tree等更复杂的数据结构，控制特例数量就显得极为重要了。所以现在就要培养自己的这方面的习惯，保持程序不变条件成立 Invariants。所谓 invariants 就是指数据结构任何情况下都是不会出错（除非程序有bug）.</p><p>具有前哨节点的<code>LinkedList</code>至少具有以下 invariants：</p><ul><li>列表默认存在前哨节点。</li><li>列表第一个元素（如果非空的话）总是在<code>sentinel.next.item</code>。</li><li>size变量始终是已添加的元素总数。</li></ul><p>不变条件使得代码的推敲变得更加容易，同时给程序员提供了能够确保代码正常工作的具体目标。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;链表-Linked-List&quot;&gt;&lt;a href=&quot;#链表-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;链表 Linked List&quot;&gt;&lt;/a&gt;链表 Linked List&lt;/h2&gt;&lt;p&gt;前面有介绍以array为基础搭建的列表，支持自动扩容, 各种插入，删除速度都很快.&lt;br&gt;这里再介绍另一种方案, 链表, 也可以实现列表自动扩容.&lt;/p&gt;
&lt;h3 id=&quot;带链接的节点&quot;&gt;&lt;a href=&quot;#带链接的节点&quot; class=&quot;headerlink&quot; title=&quot;带链接的节点&quot;&gt;&lt;/a&gt;带链接的节点&lt;/h3&gt;&lt;p&gt;链表的核心组成是带链接的节点, 每个节点就像火车车厢, 有钩子连接下一节车厢.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/408px-Singly-linked-list.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;以int节点为例:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IntNode&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; item;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; IntNode next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IntNode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, IntNode n)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        item = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        next = n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;next&lt;/code&gt;就是这个链接, 每一个节点就是其上一个节点的&lt;code&gt;next&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>Git Bash 直接启动 sublime 或 atom 等编辑器以打开或新建文件</title>
    <link href="http://yoursite.com/Launch-editor-in-Gitbash/"/>
    <id>http://yoursite.com/Launch-editor-in-Gitbash/</id>
    <published>2018-01-01T00:00:00.000Z</published>
    <updated>2018-01-06T22:45:03.611Z</updated>
    
    <content type="html"><![CDATA[<p>程序员或者其他需要码字多的人，经常要使用编辑器如sublime、atom 和 Typora等。如果每次都要用鼠标点击才能用sublime打开文件，或者在编辑器中新建文件，那么就会有点麻烦！但你可以用一句命令解决！</p><p>配置在Git Bash中用各种文本编辑器打开文件或者直接新建文件。这里以atom为例。</p><h2 id="常规步骤"><a href="#常规步骤" class="headerlink" title="常规步骤"></a>常规步骤</h2><ol><li>打开Git Bash并<code>cd</code>到你的目标文件夹, 或者直接在目标文件中右键打开Git Bash.</li><li><code>atom xxx.md</code> 就会在弹出的atom窗口中打开名为<code>xxx.md</code>的markdown文件, 如果没有这个文件, 会自动创建一个.</li><li>适用于其他类型文件, 如<code>.java</code>等.</li><li>如果想用sublime, 可以用<code>subl xxx.java</code>, 同理notepad++ 可以用 <code>notepad++ xxx.java</code>等。 (若出现错误,看下面)</li></ol><h2 id="若系统无法识别命令"><a href="#若系统无法识别命令" class="headerlink" title="若系统无法识别命令"></a>若系统无法识别命令</h2><p>一般使用sublime或者notepad++的用户, 可能会出现<code>error: 系统无法识别命令...</code>之类的, 可以这么解决:</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>新建一个文件命名为<code>subl</code>（注意不能有后缀名），内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">&quot;D:\Sublime Text 3\sublime_text.exe&quot; $1 &amp;</span><br></pre></td></tr></table></figure></p><p>第一行指明这是个 shell 脚本.<br>第二行的字符串是sublime的安装目录, 示例只是我电脑的目录, 注意这里要改为你自己的目录,<br>第二行的$1 是取的命令之后输入的参数<br>第二行的&amp;是此命令在后台打开，这样sublime打开之后，就不会阻塞你的git bash</p><p>文件保存到 <code>C:\Program Files (x86)\Git\mingW32\bin</code> 目录下(你的git目录可能与我的不一样，注意改成你自己的)</p><p>同理适用于其他编辑器，比如用<code>chrome</code>打开<code>.html</code>文件等。如果不想每次都新建一个文件，可以用下面的方法2。</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><ol><li>找到 <code>C:\Users\你的计算机名</code>目录，如果你的计算机名是Administrator，那么你就要去<code>C:\Users\Administrator</code>目录下, 这里一般存放着windows系统的<code>我的文档, 桌面</code>等文件夹.</li><li>在该目录下用Git Bash输入<code>notepad .bashrc</code>, 这会用windows记事本新建并打开一个文件<code>.bashrc</code>，这个文件没有名称只有后缀名。<code>.bashrc</code>里面可以给Git Bash设置命令的别名, 设置路径等。</li><li>在.bashrc文件加入下面一行文本<code>alias notepad++=&quot;/D/Notepad++/notepad++.exe&quot;</code>, 这里你需要修改为你电脑的安装路径。<code>alias</code>就是别名的意思，当我们执行<code>notepad++</code>的时候，实际执行的是<code>=</code>后面的语句.</li><li>重新打开Git Bash, 设置才能生效，如果不想关掉在打开的话，可以直接在bash下输入<code>source ~/.bashrc</code>就可以立刻加载修改后的设置，设置立即生效。<br>现在在bash下输入<code>notepad++ test.py</code>, 就直接打开了notepad++并创建了这个叫test的Python文件。这里的别名不一定非要取<code>notepad++</code>，随你想叫什么都行。</li></ol><p>同理也可以扩展到别的文本编辑器，<code>alias atom=&quot;atom的路径&quot;</code>, <code>alias sublime=&quot;sublime的路径&quot;</code>等. 最后还要注意一点，上面所说的路径最好不要有空格，括号等，否则会造成命令无效.</p><p><code>.bashrc</code>还有很多有用的配置,可以根据需要进行扩展. 比如很多程序猿会选择修改删除命令<code>rm</code>(此命令不加任何参数的话，会直接删除文件, 可能会造成误删的后果)。这个时候可以给rm加个参数-i，意为在删除的时候给出提示。在文件<code>.bashrc</code>里添加这行代码<code>alias rm=&quot;rm -i&quot;</code>。但这里不建议这么做，因为<code>rm=&quot;rm -i&quot;</code>是一个定时炸弹，在使用它之后，习惯了之后, 你会本能地期望<code>rm</code>在删除文件之前会提示你。但是，总有一天你可能会用一个没有rm alias 别名的系统, 这时若你也直接随手一甩<code>rm</code>, 本以为会有提示, 结果发现数据真的被删除了。</p><p>在任何情况下，预防文件丢失或损坏的好方法就是进行备份。</p><p>所以如果你想个性化删除命令, 最好不要动<code>rm</code>，而是创建属于你的命令，比如<code>trash, myrm, delete</code>等, 用<code>alias trash=&#39;/bin/rm -irv&#39;</code>会创建一条把文件放入垃圾回收站的命令.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;程序员或者其他需要码字多的人，经常要使用编辑器如sublime、atom 和 Typora等。如果每次都要用鼠标点击才能用sublime打开文件，或者在编辑器中新建文件，那么就会有点麻烦！但你可以用一句命令解决！&lt;/p&gt;
&lt;p&gt;配置在Git Bash中用各种文本编辑器打开文
      
    
    </summary>
    
      <category term="提高效率" scheme="http://yoursite.com/categories/%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="Sublime" scheme="http://yoursite.com/tags/Sublime/"/>
    
      <category term="Atom" scheme="http://yoursite.com/tags/Atom/"/>
    
      <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="Git Bash" scheme="http://yoursite.com/tags/Git-Bash/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 07 - Java | 用数组构建数据列表 list - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-07-java-array-based-list/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-07-java-array-based-list/</id>
    <published>2017-12-29T00:00:00.000Z</published>
    <updated>2018-01-12T11:11:36.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="列表-List"><a href="#列表-List" class="headerlink" title="列表 List"></a>列表 List</h2><p>前面说到Java的数组无法更改长度，那么也就无法实现插入或者删除数组成员。Java提供了功能更丰富的数据结构 - 列表（<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" target="_blank" rel="noopener">list</a>）。所谓列表，即有序的集合（序列），用户可以精确地控制每个元素插入到列表中的哪个位置。用户可以通过整数索引（列表中的位置）来访问元素，并搜索列表中的元素（详细可进一步参考<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" target="_blank" rel="noopener">oracle官网</a>）。</p><p>这里我们尝试以java的array为基础实现一个列表，目标是实现自动扩容 (Java中的<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html" target="_blank" rel="noopener">ArrayList</a>不仅仅有自动扩容, 也继承了[List]的其他功能)。在探索的过程中, 可以顺带学习很多相关的内容.<br>使用自上而下的设计思想搭建一个框架:<br>先写出最基础的部分, 也就是一个构造器，前面学过了整数数组，我们直接拿来用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Array based list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// index   0 1  2 3 4 5 6 7</span></span><br><span class="line"><span class="comment">// items: [6 9 -1 2 0 0 0 0 ...]</span></span><br><span class="line"><span class="comment">// size: 5</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造一个初始容量100的数组，初始有效数据成员为0. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 下面添加其他方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>然后思考我们需要什么功能，把功能需求转化为实例方法instance method的形式，先把方法的外壳描绘出来，注释上该方法的功能（目的），输入值，返回值是什么之类的。具体的功能实现可以先空着，之后一步步丰富。</p><h3 id="公共-vs-私有-Public-vs-Private"><a href="#公共-vs-私有-Public-vs-Private" class="headerlink" title="公共 vs 私有 Public vs. Private"></a>公共 vs 私有 Public vs. Private</h3><p>在上面的代码块中，可以看到 items 和 size 都被声明为 private 私有变量, 这样就只能被所在的java文件内调用.</p><p>私有变量和方法的设计初衷是服务于程序的内部功能实现, 而不是用来和外部程序(用户)进行交互的. 设置成私有, 可以避免这些变量和方法被外部程序直接调用, 避免用户通过不恰当/容易出错的方式修改某些变量. 在程序说明文档中, 一般也会明确说明程序提供什么公共变量和方法给用户调用.</p><p>因此我们这里也提供几个 public 方法让用户调用, 这样用户就能按照我们设计的方式来访问数据。分别是<code>getLast()</code> - 访问列表最后一个元素，<code>get(int i)</code>访问第<code>i</code>个元素, 和<code>size()</code>访问列表的大小.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 程序内的方法可以访问 private 变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回列表末尾的值. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items[size - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回第 i 个值 (0 是第一个). */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回列表元素长度. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>我们不仅希望我们的列表可以存整数，也可以存其他类型的数据，可以通过泛型解决，泛型的介绍参考<a href="/NOTE-CS61B-data-structures-05-java-variable-types#通用数据类型-Generic">这篇文章</a>.</p><p>泛型数组跟前面介绍的泛型示例有一个重要的语法差异：Java不允许我们创建一个通用对象的数组，原因这里不细展开。</p><p>假如我们用<code>Item</code>来标识泛型, 那么在上面的列表类中构建泛型数组时, 我们不能用<code>items = new Item[8];</code>, 而要用<code>items = (Item []) new Object[8];</code>, 即使这样也会产生一个编译警告，但先忍着, 后面会更详细地讨论这个问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AList</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造一个初始容量100的数组，初始有效数据成员为0.  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        items = (Item[]) <span class="keyword">new</span> Object[<span class="number">100</span>]; <span class="comment">//会有编译警告, 暂时不管, 后面会解释</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数组扩容-Resize"><a href="#数组扩容-Resize" class="headerlink" title="数组扩容 Resize"></a>数组扩容 Resize</h3><p>一个列表应该支持基本的插入和删除数据的操作，但是因为数组本身无法更改长度，所以我们就需要一个方法，在给数组在插入新数据时，先检查长度容量是否足够，如果不够，那么就要增加长度。<br>我们考虑简单的情况, 即需要在数组末尾插入或者删除数据怎么办</p><p>插入元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 把 X 插入到列表末尾. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Item x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 检查长度容量是否足够，如果不够，那么就要增加长度 */</span></span><br><span class="line">    <span class="keyword">if</span> (size == items.length) &#123;</span><br><span class="line">            Item[] temp = (Item[]) <span class="keyword">new</span> Object[size + <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(items, <span class="number">0</span>, temp, <span class="number">0</span>, size);</span><br><span class="line">            items = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        items[size] = x;</span><br><span class="line">        size = size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建新array并把旧数据复制过去的过程通常称为“resizing”。其实用词不当，因为数组实际上并没有改变大小，只是把小数组上的数据复制到大数组上而已。</p><p>为了让代码更易于维护，可以把上面的代码中负责大小调整的部分包装在一个独立的method中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 改变列表容量, capacity为改变后的容量. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    Item[] temp = (Item[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    System.arraycopy(items, <span class="number">0</span>, temp, <span class="number">0</span>, size);</span><br><span class="line">    items = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 把 X 插入到列表末尾. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Item x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == items.length) &#123;</span><br><span class="line">        resize(size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    items[size] = x;</span><br><span class="line">    size = size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">```java</span><br><span class="line"><span class="comment">/** 删去列表最后一个值，并返回该值  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Item x = getLast();</span><br><span class="line">    items[size - <span class="number">1</span>] = <span class="keyword">null</span>; <span class="comment">// 曾经引用“删除”的元素的内存地址被清空</span></span><br><span class="line">    size = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事实上即使没有<code>items[size - 1] = null;</code>,也可以达到删除元素的目的.<br>删除对改存储的对象的引用, 是为了避免“loitering”。所谓 loitering，可以理解为占着茅坑不拉屎的对象，它们已经没啥用了，却还是占用着内存。如果这个对象是些几十兆的高清图片，那么就会很消耗内存。这也是为什么安卓手机越用越慢的一个原因。</p><p>当引用/内存地址丢失时，Java会销毁对象。如果我们不清空引用，那么Java将不会垃圾回收这些本来预计要删除的对象, 因为它们实际还被列表引用着。</p><h4 id="扩容效率分析"><a href="#扩容效率分析" class="headerlink" title="扩容效率分析"></a>扩容效率分析</h4><p>我们直觉也会感觉到，如果按照现在的设计，即每插入一个新元素，就重新复制一遍数组，这样随着数组越来越大，效率肯定会越来越差。事实上也是这样，如果数组目前长度是100个内存块，那么插入1000次，需要创建并填充大约50万个内存块（等差数列求和N(N+1)/2，101+102+…+1000 ≈ 500000）。但假如我们第一次就扩容到1000，那么就省却了很多运算消耗。可惜我们不知道用户需要插入多少数据，所以要采取其他方法-几何调整。也就是与其按照<code>size + FACTOR</code>这样的速率增加容量, 不如按照<code>size * RFACTOR</code>成倍扩容, 前者的增加速率为1, 后者为 RFACTOR, 只要设置 RFACTOR 大于1, 就能减少扩容的次数.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 把 X 插入到列表末尾. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Item x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == items.length) &#123;</span><br><span class="line">        resize(size * RFACTOR); <span class="comment">//用 RFACTOR 作为因子扩容数组,</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    items[size] = x;</span><br><span class="line">    size = size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>目前我们解决了时间效率问题, 但代价是需要更大的内存空间, 也就是空间效率下降了. 假设我们插入了十亿个item，然后再删去九亿九千万个项目。在这种情况下，我们将只使用10,000,000个内存块，剩下99％完全没有使用到。</p><p>为了解决这个问题，我们可以在数组容量利用率比较低时把容量降下来. 定义利用率 R 为列表的大小除以items数组的长度。一般当R下降到小于0.25时，我们将数组的大小减半。</p><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>比如排序等, 在后面介绍链表的文章中再讨论.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;列表-List&quot;&gt;&lt;a href=&quot;#列表-List&quot; class=&quot;headerlink&quot; title=&quot;列表 List&quot;&gt;&lt;/a&gt;列表 List&lt;/h2&gt;&lt;p&gt;前面说到Java的数组无法更改长度，那么也就无法实现插入或者删除数组成员。Java提供了功能更丰富的数据结构 - 列表（&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;list&lt;/a&gt;）。所谓列表，即有序的集合（序列），用户可以精确地控制每个元素插入到列表中的哪个位置。用户可以通过整数索引（列表中的位置）来访问元素，并搜索列表中的元素（详细可进一步参考&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;oracle官网&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;这里我们尝试以java的array为基础实现一个列表，目标是实现自动扩容 (Java中的&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ArrayList&lt;/a&gt;不仅仅有自动扩容, 也继承了[List]的其他功能)。在探索的过程中, 可以顺带学习很多相关的内容.&lt;br&gt;使用自上而下的设计思想搭建一个框架:&lt;br&gt;先写出最基础的部分, 也就是一个构造器，前面学过了整数数组，我们直接拿来用&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** Array based list.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// index   0 1  2 3 4 5 6 7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// items: [6 9 -1 2 0 0 0 0 ...]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// size: 5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AList&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] items;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/** 构造一个初始容量100的数组，初始有效数据成员为0. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        items = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        size = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/** 下面添加其他方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 06 - Java | array 数组 - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-06-java-array/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-06-java-array/</id>
    <published>2017-12-27T00:00:00.000Z</published>
    <updated>2018-01-04T20:46:01.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h2><p>数组是一种特殊的对象，有一个固定的数组长度参数N，由一连串（N个）连续的带编号的内存块组成，每个都是相同的类型(不像Python可以包含不同类型)，索引从0到N-1编号。A[i]获得数组A的第i个元素。这与普通的类实例不同，类实例有具体变量名命名的内存块。</p><h3 id="数组实例化，包含对象的数组-Array-Instantiation-Arrays-of-Objects"><a href="#数组实例化，包含对象的数组-Array-Instantiation-Arrays-of-Objects" class="headerlink" title="数组实例化，包含对象的数组 Array Instantiation, Arrays of Objects"></a>数组实例化，包含对象的数组 Array Instantiation, Arrays of Objects</h3><p>要创建最简单的整数数组, 有三种方式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>]; <span class="comment">//创建一个指定长度的数组，并用默认值（0）填充每个内存块。</span></span><br><span class="line">y = <span class="keyword">new</span> <span class="keyword">int</span> [] &#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;; <span class="comment">//创建一个合适大小的数组，以容纳指定的初始值</span></span><br><span class="line"><span class="keyword">int</span> [] z = &#123;<span class="number">9</span>，<span class="number">10</span>，<span class="number">11</span>，<span class="number">12</span>，<span class="number">13</span>&#125;; <span class="comment">//省略了new，只能结合变量声明使用。</span></span><br></pre></td></tr></table></figure></p><p>创建一组实例化对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* Create an array of two dogs. */</span></span><br><span class="line">        Dog[] dogs = <span class="keyword">new</span> Dog[<span class="number">2</span>];</span><br><span class="line">        dogs[<span class="number">0</span>] = <span class="keyword">new</span> Dog(<span class="number">8</span>);</span><br><span class="line">        dogs[<span class="number">1</span>] = <span class="keyword">new</span> Dog(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">/* Yipping will result, since dogs[0] has weight 8. */</span></span><br><span class="line">        dogs[<span class="number">0</span>].makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意到new有两种不同的使用方式：一种是创建一个可以容纳两个Dog对象的数组，另外两个创建各个实际的Dog实例。</p><p>数组复制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">99</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line">System.arraycopy(b, <span class="number">0</span>, x, <span class="number">3</span>, <span class="number">2</span>); <span class="comment">//效果类似于Python的`x[3:5] = b[0:2]`</span></span><br></pre></td></tr></table></figure></p><p><code>System.arraycopy</code>的五个参数分别代表：</p><ol><li>待复制的数组(源)</li><li>源数组复制起点</li><li>目标数组</li><li>目标数组粘贴起点</li><li>有多少项要复制</li></ol><p>2D数组<br>Java的二维数组实质上是一数组的数组, 即每一个数组元素里面也是一个数组。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] matrix; <span class="comment">//声明一个引用数组的数组</span></span><br><span class="line">matrix = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][]; <span class="comment">//创建四个内存块, 用默认null值填充, 之后用于储存对整数数组的引用, 即地址,</span></span><br><span class="line"><span class="keyword">int</span>[] rowZero = matrix[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 实例化整数数组, 把其地址/引用分别赋值给/储存到 matrix 的第N个内存块*/</span></span><br><span class="line">matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>&#125;;</span><br><span class="line">matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] rowTwo = matrix[<span class="number">2</span>];</span><br><span class="line">rowTwo[<span class="number">1</span>] = -<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 创建四个内存块, 其中每个被引用的整数数组长度为4,每个元素都是0.*/</span></span><br><span class="line">matrix = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] matrixAgain = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组-Array&quot;&gt;&lt;a href=&quot;#数组-Array&quot; class=&quot;headerlink&quot; title=&quot;数组 Array&quot;&gt;&lt;/a&gt;数组 Array&lt;/h2&gt;&lt;p&gt;数组是一种特殊的对象，有一个固定的数组长度参数N，由一连串（N个）连续的带编号的内存块组成，
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 05 - Java | 数据类型 - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-05-java-variable-types/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-05-java-variable-types/</id>
    <published>2017-12-26T00:00:00.000Z</published>
    <updated>2018-01-04T17:09:34.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><a href="https://zh.wikibooks.org/zh-hans/Java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">数据类型</a>是程序设计语言描述事物、对象的方法。Java数据类型分为基本类型（内置类型）和引用类型(扩展类型）两大类。基本类型就是Java语言本身提供的基本数据类型，比如，整型数，浮点数，字符，布尔值等等。而引用类型则是Java语言根据基本类型扩展出的其他类型，Java要求所有的引用扩展类型都必须包括在类定义里面，这就是Java为什么是面向对象编程语言的原因…</p><p>上面的定义有点抽象，要理解数据类型，需要先理解一个问题: 神秘的海象问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 尝试预测下面的代码运行时会发生什么。</span></span><br><span class="line"><span class="comment">b的变化是否会影响a？提示：类似Python。 */</span></span><br><span class="line">Walrus a = <span class="keyword">new</span> Walrus(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br><span class="line">Walrus b;</span><br><span class="line">b = a;</span><br><span class="line">b.weight = <span class="number">5</span>;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 同样尝试预测下面的代码运行时会发生什么。</span></span><br><span class="line"><span class="comment">x的改变是否影响y？ */</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">y = x;</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">System.out.println(<span class="string">"x is: "</span> + x);</span><br><span class="line">System.out.println(<span class="string">"y is: "</span> + y);</span><br></pre></td></tr></table></figure><p>首先给出答案, b的变化会影响a, 但x的改变不影响y，具体见<a href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+PollQuestions+%7B%0A+++public+static+void+main%28String%5B%5D+args%29+%7B%0A++++++Walrus+a+%3D+new+Walrus%281000,+8.3%29%3B%0A++++++Walrus+b%3B%0A++++++b+%3D+a%3B%0A++++++b.weight+%3D+5%3B%0A++++++System.out.println%28a%29%3B%0A++++++System.out.println%28b%29%3B++++++%0A%0A++++++int+x+%3D+5%3B%0A++++++int+y%3B%0A++++++y+%3D+x%3B%0A++++++x+%3D+2%3B%0A++++++System.out.println%28%22x+is%3A+%22+%2B+x%29%3B%0A++++++System.out.println%28%22y+is%3A+%22+%2B+y%29%3B++++++%0A+++%7D%0A+++%0A+++public+static+class+Walrus+%7B%0A++++++public+int+weight%3B%0A++++++public+double+tuskSize%3B%0A++++++%0A++++++public+Walrus%28int+w,+double+ts%29+%7B%0A+++++++++weight+%3D+w%3B%0A+++++++++tuskSize+%3D+ts%3B%0A++++++%7D%0A%0A++++++public+String+toString%28%29+%7B%0A+++++++++return+String.format%28%22weight%3A+%25d,+tusk+size%3A+%25.2f%22,+weight,+tuskSize%29%3B%0A++++++%7D%0A+++%7D%0A%7D&amp;mode=edit" target="_blank" rel="noopener">可视化过程</a>.<br>这里的差别虽然微妙, 但其背后的原理对于数据结构的效率来说是非常重要的，对这个问题的深入理解也将引导我们写出更安全，更可靠的代码。<br><a id="more"></a></p><h3 id="基本类型-Primative-Types"><a href="#基本类型-Primative-Types" class="headerlink" title="基本类型 Primative Types"></a>基本类型 Primative Types</h3><p>计算机中的所有信息都以一系列1和0的形式存储在内存中，这些二进制的0和1就是比特位（bits）。比如72和“H”在内存一般以01001000的形式存储，对他们的形式是一样的。一个引申问题就是：Java代码如何解释01001000，怎么知道应该解释为72还是“H”？ 通过类型types，预先定义好类型即可, 以下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> x = <span class="string">'H'</span>;</span><br><span class="line"><span class="keyword">int</span> y = x;</span><br><span class="line">System.out.println(x);</span><br><span class="line">System.out.println(y);</span><br></pre></td></tr></table></figure></p><p>会分别得到“H”和72. 在这种情况下，x和y变量都包含几乎相同的bits，但是Java解释器在输出时对它们进行了不同的处理。</p><p>Java有8种基本类型：byte，short，int，long，float，double，boolean和char。</p><h4 id="变量声明-Declaring-Variables"><a href="#变量声明-Declaring-Variables" class="headerlink" title="变量声明 Declaring Variables"></a>变量声明 Declaring Variables</h4><p>计算机的内存可以视为包含大量用于存储信息的内存比特位，每个位都有一个唯一的地址。现代计算机可以使用许多这样的位。 当你声明一个特定类型的变量时，Java会用一串<strong>连续</strong>的内存位存储它。例如，如果你声明一个int，你会得到一个长度32的内存list，里面有32bits。Java中的每个数据类型都有不同的比特数。</p><p>除了留出内存空间外，Java解释器还会在一个内部表中创建一个条目，将每个变量名称映射到内存块中第一个位置（表头list head）。 例如，如果声明了int x和double y，那么Java可能会决定使用计算机内存的352到384位来存储x，而20800到20864位则用来存储y。然后解释器将记录int x从352开始，y从20800开始。</p><p>在Java语言里无法知道变量的具体内存位置，例如你不能以某种方式发现x在位置352。不像C++这样的语言，可以获取一段数据的确切地址。Java的这个特性是一个折衷！隐藏内存位置自然意味着程序猿的控制权更少，就无法做<a href="http://www.informit.com/articles/article.aspx?p=2246428&amp;seqNum=5" target="_blank" rel="noopener">某些类型的优化</a>。但是，它也避免了一大类非常棘手的<a href="http://www.informit.com/articles/article.aspx?p=2246428&amp;seqNum=1" target="_blank" rel="noopener">编程错误</a>。在现在计算成本如此低廉的时代，不成熟的优化还不如少点bug。</p><p>当声明一个变量时，Java不会在预留的内存位置中写入任何内容, 也即没有默认值。因此，如果没有赋值, Java编译器会阻止你使用变量。</p><p>以上只是内存分配的简要说明, 堆和栈的介绍可以参考我的CS106B C++笔记。</p><h3 id="引用类型-Reference-Types"><a href="#引用类型-Reference-Types" class="headerlink" title="引用类型 Reference Types"></a>引用类型 Reference Types</h3><p>所有基本数据类型之外的类型都是引用类型。<br>引用类型顾名思义，就是对对象的引用。在java中内存位置是不开放给程序员的, 但我们可以通过引用类型访问内存中某处对象。所有引用类型都是 java.lang.Object 类型的子类。</p><h4 id="对象实例化-Object-Instantiation"><a href="#对象实例化-Object-Instantiation" class="headerlink" title="对象实例化 Object Instantiation"></a>对象实例化 Object Instantiation</h4><p>对象实例化：当我们使用new（例 new Dog）实例化对象时，Java首先为类的每个实例变量分配一串长度合适的bits位，并用缺省值填充它们。然后，构造函数通常（但不总是）用其他值填充每个位置.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Walrus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> tuskSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Walrus</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">double</span> ts)</span> </span>&#123;</span><br><span class="line">          weight = w;</span><br><span class="line">          tuskSize = ts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用<code>new Walrus(1000, 8.3)</code>创建一个Walrus实例后, 我们得到分别由一个32位(int weight = 1000)和一个64位(double tuskSize = 8.3)的内存块组成的实例：<br>通过程序<a href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+PollQuestions+%7B%0A+++public+static+void+main%28String%5B%5D+args%29+%7B%0A++++++Walrus+a+%3D+new+Walrus%281000,+8.3%29%3B%0A++++++Walrus+b%3B%0A++++++b+%3D+a%3B%0A++++++b.weight+%3D+5%3B%0A++++++System.out.println%28a%29%3B%0A++++++System.out.println%28b%29%3B++++++%0A%0A++++++int+x+%3D+5%3B%0A++++++int+y%3B%0A++++++y+%3D+x%3B%0A++++++x+%3D+2%3B%0A++++++System.out.println%28%22x+is%3A+%22+%2B+x%29%3B%0A++++++System.out.println%28%22y+is%3A+%22+%2B+y%29%3B++++++%0A+++%7D%0A+++%0A+++public+static+class+Walrus+%7B%0A++++++public+int+weight%3B%0A++++++public+double+tuskSize%3B%0A++++++%0A++++++public+Walrus%28int+w,+double+ts%29+%7B%0A+++++++++weight+%3D+w%3B%0A+++++++++tuskSize+%3D+ts%3B%0A++++++%7D%0A%0A++++++public+String+toString%28%29+%7B%0A+++++++++return+String.format%28%22weight%3A+%25d,+tusk+size%3A+%25.2f%22,+weight,+tuskSize%29%3B%0A++++++%7D%0A+++%7D%0A%7D&amp;mode=edit" target="_blank" rel="noopener">可视化过程</a>)来更好地理解. 当然在Java编程语言的实际实现中，实例化对象时都有一些额外的内存开销, 这里不展开.</p><p>通过 new 实例化对象，new 会返回该对象的内存地址给我们，但假如我们没有用一个变量去接收这个地址，那么我们就无法访问这个对象。之后该对象会被作为垃圾回收。</p><h4 id="引用变量声明-Reference-Variable-Declaration"><a href="#引用变量声明-Reference-Variable-Declaration" class="headerlink" title="引用变量声明 Reference Variable Declaration"></a>引用变量声明 Reference Variable Declaration</h4><p>前面有提到，我们需要声明变量来接受实例化的对象在内存中的地址。当声明任何引用类型的变量（比如array, 前面的Dog类等）时，Java都会分配一串64位的内存位置. 这个64位的内存块仅用于记录变量的内存<strong>地址</strong>, 所谓内存地址, 可以理解为内存(房子)的编号(地址), 一般是内存块的表头位置的64位表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Walrus someWalrus; <span class="comment">// 创建一个64位的内存位置</span></span><br><span class="line">someWalrus = <span class="keyword">new</span> Walrus(<span class="number">1000</span>, <span class="number">8.3</span>); <span class="comment">//创建一个新的实例</span></span><br><span class="line"><span class="comment">/** 内存地址由 new 返回, 并被复制/赋值给 someWalrus 对应的内存位置</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>比如, 假设weight是从内存位5051956592385990207开始存储的，后面连续跟着其他实例变量，那么就可以把5051956592385990207存储在Dog变量中。5051956592385990207由64位的二进制0100011000011100001001111100000100011101110111000001111000111111表达，这样smallDog的内存就可以抽象的理解为一个表<br><code>smallDog: 0100011000011100001001111100000100011101110111000001111000111111 -&gt; 具体存放实例的内存(Walrus: weight=1000, tuskSize=8.3)</code><br>‘-&gt;’可以理解为指针.</p><p><a href="array-instantiation-arrays-of-objects">实例化数组</a>在前面有介绍过，数组array是引用类型，是对象，故数组变量只是存储内存位置。</p><p>前面有提到，如果丢失了引用变量存储的内存地址，那么该地址对应的对象就找不回来了。例如，如果一个特定的 Walrus 地址的唯一副本存储在x中，那么<code>x = null</code>这行代码将删去地址，我们则丢失了这个 Walrus 对象。这也不一定是坏事，很多时候在完成了一个对象后就不在需要了，只需简单地丢弃这个参考地址就可以了。</p><h3 id="Java-等值规则-Rule-of-Equals"><a href="#Java-等值规则-Rule-of-Equals" class="headerlink" title="Java 等值规则 Rule of Equals"></a>Java 等值规则 Rule of Equals</h3><p><strong>对于<code>y = x</code>，Java解释器会将x的位拷贝到y中</strong>,这个规则适用于java中任何使用<code>=</code>赋值的语法, 是理解开头的”神秘的海象”问题的关键.</p><ul><li><p>基本类型变量的位, 存储赋值的值（基本类型）在内存中值(具体位数取决于具体的类型)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>; <span class="comment">// 此时是把内存中的某一个地址 p 复制给 x</span></span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">y = x; <span class="comment">// y 也指向 p</span></span><br><span class="line">x = <span class="number">2</span>; <span class="comment">// 把一个新的内存地址 new p 复制给x, 但y还是指向原来的p</span></span><br></pre></td></tr></table></figure><p>  x的位存储的是基本类型<code>int 5</code>(32 bits), <code>x = 2</code>是把新的基本类型<code>int 2</code>复制给x, 但y还是指向原来的<code>int 5</code>， 所以y没变化。</p></li><li><p>引用类型 reference type 变量的位, 存储赋值的值（引用类型）在内存中的地址(固定的64 bits)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dog a = <span class="keyword">new</span> Dog(<span class="number">5</span>); <span class="comment">// 创建一个64位的内存位, 并赋值一个新的实例 p</span></span><br><span class="line">Dog b; <span class="comment">// 仅创建一个64位的内存位, 没有引用内存地址(null)</span></span><br><span class="line">b = a; <span class="comment">// 把a的位（是实例 p 的内存地址）复制给b, 这样 b 也是指向实例 p</span></span><br><span class="line">b.weight = <span class="number">21</span>; <span class="comment">// 此时修改b, 会改写b指向的内存实例 p</span></span><br></pre></td></tr></table></figure><p>  a和b只存储地址, 而它们的地址都指向相同的实例；<br>  如果对 b 的修改本质是对 p的修改, 那么输出<code>a.weight</code>的时候, 就会变成<code>21</code>.</p></li></ul><h3 id="参数传递-Parameter-Passing"><a href="#参数传递-Parameter-Passing" class="headerlink" title="参数传递 Parameter Passing"></a>参数传递 Parameter Passing</h3><p>给函数传递参数，本质上也是赋值操作，参考上面的等值规则，也即复制这些参数的bits给函数，也称之为pass by value。Java的参数传递都是pass by value。至于传递过去的参数会不会因为函数内部的操作而更改，其判断原理在上面的<a href="java-等值规则-rule-of-equals">等值规则</a>已经阐明。</p><h3 id="通用数据类型-Generic"><a href="#通用数据类型-Generic" class="headerlink" title="通用数据类型 Generic"></a>通用数据类型 Generic</h3><p>在定义类的时候，有时候我们可能希望这个类能够接受任何类型的数据，而不仅仅是限定了基本类型中的任何一种。比如我们想实现一个类似PPT的类，自然需要这个PPT类能够接收各种类型的字符，数字，并呈现出来。这个时候就需要使用泛型 Generic, 也即通用数据类型。</p><p>在2004年，Java的设计者在语言中加入了泛型，使​​我们能够创建包含任何引用类型的数据结构（引用类型和基本类型的解释参考<a href="/NOTE-CS61B-data-structures-05-java-variable-types#引用类型-Reference-Types">另一篇文章</a>, ）。方法就是在类声明的类名后面，使用一个任意的占位符，并用尖括号括住<code>&lt;随便什么字符&gt;</code>。然后，在任何你想使用泛型的地方，改用占位符。<br>比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PPT</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PPT</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> item;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>改为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PPT</span>&lt;<span class="title">xxx</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PPT</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> xxx item;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>&lt;xxx&gt;</code>里面的名称并不重要, 改成其他也行, 只是一个标识符, 用来接受参数, 当用户实例化这个类时, 必须使用特殊的语法<code>PPT&lt;String&gt; d = new PPT&lt;&gt;(&quot;hello&quot;);</code></p><p>由于泛型仅适用于引用类型，因此我们不能将基本类型<code>int</code>等放在尖括号内。相反，我们使用基本类型的引用版本，比如对于int, 用 Integer，<code>PPT&lt;Integer&gt; d = new PPT&lt;&gt;(&quot;10&quot;);</code></p><p>总结使用方法:</p><ul><li>在一个实现某数据结构的<code>.java</code>文件中，在类名后面, 只指定泛型类型一次。</li><li>在其他使用该数据结构的java文件中，声明实例变量时要指定所需的类型。</li><li>如果您需要在基本类型上实例化泛型，请使用<code>Integer, Double, Character, Boolean, Long, Short, Byte, Float</code>，而不是其基本类型。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikibooks.org/zh-hans/Java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据类型&lt;/a&gt;是程序设计语言描述事物、对象的方法。Java数据类型分为基本类型（内置类型）和引用类型(扩展类型）两大类。基本类型就是Java语言本身提供的基本数据类型，比如，整型数，浮点数，字符，布尔值等等。而引用类型则是Java语言根据基本类型扩展出的其他类型，Java要求所有的引用扩展类型都必须包括在类定义里面，这就是Java为什么是面向对象编程语言的原因…&lt;/p&gt;
&lt;p&gt;上面的定义有点抽象，要理解数据类型，需要先理解一个问题: 神秘的海象问题&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** 尝试预测下面的代码运行时会发生什么。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;b的变化是否会影响a？提示：类似Python。 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Walrus a = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Walrus(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8.3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Walrus b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b = a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b.weight = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(b);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** 同样尝试预测下面的代码运行时会发生什么。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;x的改变是否影响y？ */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;x is: &quot;&lt;/span&gt; + x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;y is: &quot;&lt;/span&gt; + y);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先给出答案, b的变化会影响a, 但x的改变不影响y，具体见&lt;a href=&quot;http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+PollQuestions+%7B%0A+++public+static+void+main%28String%5B%5D+args%29+%7B%0A++++++Walrus+a+%3D+new+Walrus%281000,+8.3%29%3B%0A++++++Walrus+b%3B%0A++++++b+%3D+a%3B%0A++++++b.weight+%3D+5%3B%0A++++++System.out.println%28a%29%3B%0A++++++System.out.println%28b%29%3B++++++%0A%0A++++++int+x+%3D+5%3B%0A++++++int+y%3B%0A++++++y+%3D+x%3B%0A++++++x+%3D+2%3B%0A++++++System.out.println%28%22x+is%3A+%22+%2B+x%29%3B%0A++++++System.out.println%28%22y+is%3A+%22+%2B+y%29%3B++++++%0A+++%7D%0A+++%0A+++public+static+class+Walrus+%7B%0A++++++public+int+weight%3B%0A++++++public+double+tuskSize%3B%0A++++++%0A++++++public+Walrus%28int+w,+double+ts%29+%7B%0A+++++++++weight+%3D+w%3B%0A+++++++++tuskSize+%3D+ts%3B%0A++++++%7D%0A%0A++++++public+String+toString%28%29+%7B%0A+++++++++return+String.format%28%22weight%3A+%25d,+tusk+size%3A+%25.2f%22,+weight,+tuskSize%29%3B%0A++++++%7D%0A+++%7D%0A%7D&amp;amp;mode=edit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;可视化过程&lt;/a&gt;.&lt;br&gt;这里的差别虽然微妙, 但其背后的原理对于数据结构的效率来说是非常重要的，对这个问题的深入理解也将引导我们写出更安全，更可靠的代码。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 04 - Java | 类 class 02 类与实例 - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-04-java-class-02-class-instance/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-04-java-class-02-class-instance/</id>
    <published>2017-12-25T00:00:00.000Z</published>
    <updated>2017-12-31T15:40:23.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>前面提到，类的方法和变量细分为静态的和非静态的. 静态就是可以被类调用，所以静态方法/变量也称之为类方法/变量；<br>非静态只能由实例调用，所以也称之为实例方法/变量。</p><h3 id="类方法-vs-实例方法-Class-Methods-vs-Instance-Methods"><a href="#类方法-vs-实例方法-Class-Methods-vs-Instance-Methods" class="headerlink" title="类方法 vs 实例方法 Class Methods vs. Instance Methods"></a>类方法 vs 实例方法 Class Methods vs. Instance Methods</h3><p>参考<a href="/NOTE-CS61B-data-structures-04-java-class-01-intro.html#实例变量和对象实例化-instance-variables-and-object-instantiation">上一篇文章的例子</a>，类方法由类调用<code>Dog.makeNoise();</code>. 实例方法只能由实例调用<code>bigDog.makeNoise();</code>. 同理可推, 类方法无法调用实例变量.</p><p>可以看到实例方法更具体, 更贴近实体世界, 那我们仍需要类方法, 因为:</p><ul><li>有些类不需要实例化, 毕竟我们也经常需要处理抽象的概念, 这些抽象概念在人类认知范畴内是统一的, 比如数学计算, 我们需要计算某个数值的平方根, <code>x = Math.sqrt(100);</code>, 拿来就用, 不需要先实例化. 这点在Python中体现得很好.</li><li><p>有些类有静态方法, 是有实际作用的。例如，若想比较一个类里面的不同实例, 比如两只狗的重量。比较简单的方法就是使用一个比较狗的重量的类方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title">maxDog</span><span class="params">(Dog d1, Dog d2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d1.weight &gt; d2.weight) &#123;</span><br><span class="line">        <span class="keyword">return</span> d1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d2;</span><br><span class="line">&#125;</span><br><span class="line">Dog d = <span class="keyword">new</span> Dog(<span class="number">15</span>);</span><br><span class="line">Dog d2 = <span class="keyword">new</span> Dog(<span class="number">100</span>);</span><br><span class="line">Dog.maxDog(d, d2);</span><br></pre></td></tr></table></figure><ul><li>这个时候, 若使用实例方法也可以, 但没那么直观：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 我们使用关键字this来引用当前对象d。*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dog <span class="title">maxDog</span><span class="params">(Dog d2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.weight &gt; d2.weight) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d2;</span><br><span class="line">&#125;</span><br><span class="line">Dog d = <span class="keyword">new</span> Dog(<span class="number">15</span>);</span><br><span class="line">Dog d2 = <span class="keyword">new</span> Dog(<span class="number">100</span>);</span><br><span class="line">d.maxDog(d, d2);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="类变量-vs-实例变量-Class-Variables-vs-Instance-Variables"><a href="#类变量-vs-实例变量-Class-Variables-vs-Instance-Variables" class="headerlink" title="类变量 vs 实例变量 Class Variables vs. Instance Variables"></a>类变量 vs 实例变量 Class Variables vs. Instance Variables</h3><p>静态变量的也是有用处的。这些变量一般是类本身固有的属性。例如，我们可能需要用狗类的另一种生物学的统称“犬科”来作为类的说明， 这个时候可以用<code>public static String binomen = &quot;犬科&quot;;</code>，这个变量理论上是由类来访问的。<br>虽然Java在技术上允许使用实例名称来访问静态变量，但是这有时候可能会令人困惑， 所以还是少用为好。</p><h3 id="构造器-Constructors-in-Java"><a href="#构造器-Constructors-in-Java" class="headerlink" title="构造器 Constructors in Java"></a>构造器 Constructors in Java</h3><p>与上面的<code>DogLauncher</code>实例化对象的方式相比, 我们更希望实例化可以带参数的，那样可以为我们节省手动给实例变量赋值的麻烦。为了启用这样的语法，我们只需把如下的构造函数直接添加进Dog类中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**注意：构造函数与class类同名</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        weight = w;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>然后在<code>DogLauncher</code>里实例化一只狗时, 直接<code>Dog d = new Dog(20);</code>即可.  </p><p>在以上代码的基础上, 后续当我们想使用new和参数创建一只狗时，可以随时调用<code>public Dog(int w)</code>构造函数。对于熟悉Python的人来说，你可以理解java的构造函数为Python的<code>__init__</code>。</p><p>一些术语:</p><ul><li>声明(declaration): <code>Dog smalldog;</code>声明一个类作为一个变量在内存中占位</li><li>实例化: <code>new Dog(20)</code>, 如果没有把它作为值赋给一个类声明变量,那么这个实例化的值会被垃圾回收.</li><li>声明, 实例化并赋值: <code>Dog smalldog = new Dog(5)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Class&quot;&gt;&lt;a href=&quot;#Class&quot; class=&quot;headerlink&quot; title=&quot;Class&quot;&gt;&lt;/a&gt;Class&lt;/h2&gt;&lt;p&gt;前面提到，类的方法和变量细分为静态的和非静态的. 静态就是可以被类调用，所以静态方法/变量也称之为类方法/变量；&lt;b
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 04 - Java | 类 class 01 变量和方法 - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-04-java-class-01-intro/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-04-java-class-01-intro/</id>
    <published>2017-12-24T00:00:00.000Z</published>
    <updated>2017-12-31T15:40:03.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>Java的语法是为了更容易地模拟真实世界而设计的. 比如用程序实现一只狗, 可以用定义一个类class来描述它.</p><p>类class里面包括变量Variable，方法method（可以理解为Python的函数function）。变量可以储存数据，方法可以处理数据。变量必须在类中声明(即不能离开类独立存在)，不像Python或Matlab这样的语言可以在运行时添加新的变量。类的方法和变量又细分为静态的和非静态的.</p><p>静态就是可以被类调用，所以静态方法/变量也称之为类方法/变量；<br>非静态只能由实例调用，所以也称之为实例方法/变量。实例instance的概念后面会解释。</p><h3 id="类（静态）变量和方法-Class-Static-Variables-and-Methods"><a href="#类（静态）变量和方法-Class-Static-Variables-and-Methods" class="headerlink" title="类（静态）变量和方法 Class(Static) Variables and Methods"></a>类（静态）变量和方法 Class(Static) Variables and Methods</h3><p>静态变量和方法的特征就是有<code>static</code>字符在前面.<br>以下代码定义了一个类来模拟狗，包含一个类变量作为这个类的说明，一个类方法用于发出叫声：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String instruction = <span class="string">"狗类实例"</span>; <span class="comment">//类变量, 说明</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeNoise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里没有定义main(), 在这种情况下如何直接运行这个类(<code>java Dog</code>), 程序是会报错的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误: 在类 Dog 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">否则 JavaFX 应用程序类必须扩展javafx.application.Application`.</span></span><br></pre></td></tr></table></figure></p><p>你可以选择在里面添加一个<code>main()</code>方法. 但这次我们选择不定义具体的<code>main()</code>. 具体要如何运行, 我们可以另写一个类定义一个main()方法来调用这个类.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogLauncher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这两种方式(在类A内部定义好main() vs. 在其他类B定义main()来调用A)没有优劣之分, 二者有不同的适用情况. 随着不断深入学习，二者的区分将变得更清晰。</p><p>注意到, 类变量和方法是有局限性的。现实世界中, 并不是所有的狗都是一样的特征，仅仅靠类这个概念是无法区分不同个体的狗, 除非你为不同的狗定义不同的类（以及里面的变量和方法）, 那么就会很繁琐痛苦. 也就是说，用类来模拟个体是低效的，我们要使用实例.</p><h3 id="实例变量和对象实例化-Instance-Variables-and-Object-Instantiation"><a href="#实例变量和对象实例化-Instance-Variables-and-Object-Instantiation" class="headerlink" title="实例变量和对象实例化 Instance Variables and Object Instantiation"></a>实例变量和对象实例化 Instance Variables and Object Instantiation</h3><a id="more"></a><p>Java的类定义就像定义一张蓝图, 我们可以在这个蓝图的基础上, 生成不同的实例instance. 实例是概念性的说法，本质上在Java里就是对象object。这样的特性提供了一个很自然而然地在java中模拟生成实体世界的方法：定义一个狗的类，在这个类的基础上，通过不同的特征参数实例化不同特征的狗（instances），并使类方法的输出取决于特定实例的狗的属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 一只狗的类:*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeNoise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (weight &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"嘤嘤嘤!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weight &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"汪汪汪"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"嗷呜!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的方法和变量没有<code>static</code>, 所以是实例（非静态）方法和变量. 如果直接用 Dog 类来调用这些方法, 会报错:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogLauncher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog.weight = <span class="number">21</span>;</span><br><span class="line">        Dog.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DogLauncher.java:<span class="number">3</span>: 错误: 无法从静态上下文中引用非静态 变量 weight</span><br><span class="line">        Dog.weight = <span class="number">21</span>;</span><br><span class="line">           ^</span><br><span class="line">DogLauncher.java:<span class="number">4</span>: 错误: 无法从静态上下文中引用非静态 方法 makeNoise()</span><br><span class="line">        Dog.makeNoise();</span><br><span class="line">           ^</span><br></pre></td></tr></table></figure><p>这个时候, 你需要实例化一只狗, 让这个实例来调用非静态变量和方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogLauncher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog biglDog = <span class="keyword">new</span> Dog();</span><br><span class="line">        biglDog.weight = <span class="number">5</span>;</span><br><span class="line">        biglDog.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行时，这个程序将会创建一个重量为5的狗，这个狗就会“嗷呜”叫。</p><p>总的来说，之所以需要实例方法和变量，是因为我们需要模拟个体，一只具体的狗，并让它发出声音。这个weight和makeNoise()只能由具体的狗调用。狗类不能调用，也没有调用的意义, 毕竟每只狗的重量和声音都不同的. 在设计程序时, 如果其中一个方法我们只打算让特定的实例来调用它(而不让类去调用它), 那么这个方法应该设计成实例方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Class&quot;&gt;&lt;a href=&quot;#Class&quot; class=&quot;headerlink&quot; title=&quot;Class&quot;&gt;&lt;/a&gt;Class&lt;/h2&gt;&lt;p&gt;Java的语法是为了更容易地模拟真实世界而设计的. 比如用程序实现一只狗, 可以用定义一个类class来描述它.&lt;/p&gt;
&lt;p&gt;类class里面包括变量Variable，方法method（可以理解为Python的函数function）。变量可以储存数据，方法可以处理数据。变量必须在类中声明(即不能离开类独立存在)，不像Python或Matlab这样的语言可以在运行时添加新的变量。类的方法和变量又细分为静态的和非静态的.&lt;/p&gt;
&lt;p&gt;静态就是可以被类调用，所以静态方法/变量也称之为类方法/变量；&lt;br&gt;非静态只能由实例调用，所以也称之为实例方法/变量。实例instance的概念后面会解释。&lt;/p&gt;
&lt;h3 id=&quot;类（静态）变量和方法-Class-Static-Variables-and-Methods&quot;&gt;&lt;a href=&quot;#类（静态）变量和方法-Class-Static-Variables-and-Methods&quot; class=&quot;headerlink&quot; title=&quot;类（静态）变量和方法 Class(Static) Variables and Methods&quot;&gt;&lt;/a&gt;类（静态）变量和方法 Class(Static) Variables and Methods&lt;/h3&gt;&lt;p&gt;静态变量和方法的特征就是有&lt;code&gt;static&lt;/code&gt;字符在前面.&lt;br&gt;以下代码定义了一个类来模拟狗，包含一个类变量作为这个类的说明，一个类方法用于发出叫声：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Dog&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; String instruction = &lt;span class=&quot;string&quot;&gt;&quot;狗类实例&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//类变量, 说明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;makeNoise&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;汪!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里没有定义main(), 在这种情况下如何直接运行这个类(&lt;code&gt;java Dog&lt;/code&gt;), 程序是会报错的&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;错误: 在类 Dog 中找不到 main 方法, 请将 main 方法定义为:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;否则 JavaFX 应用程序类必须扩展javafx.application.Application`.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你可以选择在里面添加一个&lt;code&gt;main()&lt;/code&gt;方法. 但这次我们选择不定义具体的&lt;code&gt;main()&lt;/code&gt;. 具体要如何运行, 我们可以另写一个类定义一个main()方法来调用这个类.&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DogLauncher&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Dog.makeNoise();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这两种方式(在类A内部定义好main() vs. 在其他类B定义main()来调用A)没有优劣之分, 二者有不同的适用情况. 随着不断深入学习，二者的区分将变得更清晰。&lt;/p&gt;
&lt;p&gt;注意到, 类变量和方法是有局限性的。现实世界中, 并不是所有的狗都是一样的特征，仅仅靠类这个概念是无法区分不同个体的狗, 除非你为不同的狗定义不同的类（以及里面的变量和方法）, 那么就会很繁琐痛苦. 也就是说，用类来模拟个体是低效的，我们要使用实例.&lt;/p&gt;
&lt;h3 id=&quot;实例变量和对象实例化-Instance-Variables-and-Object-Instantiation&quot;&gt;&lt;a href=&quot;#实例变量和对象实例化-Instance-Variables-and-Object-Instantiation&quot; class=&quot;headerlink&quot; title=&quot;实例变量和对象实例化 Instance Variables and Object Instantiation&quot;&gt;&lt;/a&gt;实例变量和对象实例化 Instance Variables and Object Instantiation&lt;/h3&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 03 - Java | 代码风格 注释 Javadoc - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-03-java-code-style-comments/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-03-java-code-style-comments/</id>
    <published>2017-12-21T00:00:00.000Z</published>
    <updated>2018-01-04T20:46:16.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代码风格与注释-Code-style-and-comments"><a href="#代码风格与注释-Code-style-and-comments" class="headerlink" title="代码风格与注释 Code style and comments"></a>代码风格与注释 Code style and comments</h3><p>在学习和实践过程中，我们应该努力保持代码可读性。良好的编码风格的一些最重要的特点是：</p><ul><li>一致的风格（间距，变量命名，缩进风格等）</li><li>大小（线不太宽，源文件不要太长）</li><li>描述性命名（变量，函数，类），例如变量或函数名称为年份或getUserName而不是x或f。让代码本身提供可解读性。</li><li>避免重复的代码：几乎不会有两个重要的代码块几乎相同，除了一些改变。</li><li>适当的评论, 使其他读者也能轻松理解你的代码<ul><li>行注释: <code>//</code>分隔符开头行被当做注释。</li><li>Block（又名多行注释）注释: <code>/*</code>,  <code>*/</code>, 但我们更推荐javadoc形式的注释。</li></ul></li></ul><h3 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h3><p>Javadoc: <code>/ **</code>，<code>*/</code>, 可以（但不总是）包含描述性标签。 借助<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/windows/javadoc.html" target="_blank" rel="noopener">javadoc工具</a>可以生成HTML格式的API文档。<br>第一段是方法的描述。描述下面是不同的<a href="https://en.wikipedia.org/wiki/Javadoc" target="_blank" rel="noopener">描述性标签</a>, 比如参数 <code>@param</code>， 返回值 <code>@return</code>， 可能抛出的任何异常 <code>@throws</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>   名字，邮箱&lt;address @ example.com&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>     1.6 版本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;代码风格与注释-Code-style-and-comments&quot;&gt;&lt;a href=&quot;#代码风格与注释-Code-style-and-comments&quot; class=&quot;headerlink&quot; title=&quot;代码风格与注释 Code style and comment
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 02 - Java | 语法基础 - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-02-java-basic-syntax/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-02-java-basic-syntax/</id>
    <published>2017-12-20T00:00:00.000Z</published>
    <updated>2018-01-04T20:46:21.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基本语法"><a href="#Java基本语法" class="headerlink" title="Java基本语法"></a>Java基本语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序由一个类声明组成，该声明使用关键字<code>public class</code>声明。</p><ul><li>Java所有的代码都应该包含在class里面。</li><li>真正负责运行的代码，是一个名为main的method，它声明为<code>public static void main(String[] args)</code>。<ul><li>public：公共的，大部分方法都是以这个关键字开始的，后面会进一步解释。</li><li>static：这是一个静态方法，不与任何特定的实例关联，后面会解释。</li><li>void：它没有返回类型。</li><li>main：这是方法的名称。</li><li><code>String [] args</code>：这是传递给main方法的参数。</li></ul></li><li>使用大括号<code>{ }</code>来表示一段代码的开始和结束。</li><li>声明必须以分号结尾</li></ul><h2 id="静态分类-Static-Typing"><a href="#静态分类-Static-Typing" class="headerlink" title="静态分类 Static Typing"></a>静态分类 Static Typing</h2><p>程序语言静态与动态的分类，可以参考oracle的<a href="https://docs.oracle.com/cd/E57471_01/bigData.100/extensions_bdd/src/cext_transform_typing.html" target="_blank" rel="noopener">说明文件</a>，它解释了动态和静态类型之间的区别, 帮助你理解由程序的错误提示信息。<br>两个主要区别:<br>1. 动态类型语言在运行时执行类型检查，而静态类型语言在编译时执行类型检查。这意味如果以静态类型语言（如Java）编写的脚本包含错误，则在编译错误之前将无法编译. 而用动态类型语言编写的脚本可以编译，即使它们包含会阻止脚本正常运行（如果有的话）的错误。<br>2. 静态类型语言要求你在使用它们之前声明变量的数据类型，而动态类型语言则不需要。<br>考虑以下两个代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">num = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line">num = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>这两段代码都创建一个名为num的变量并赋值为5. 不同之处在于Java需要将num的数据类型明确定义为int。因为Java是静态类型的，因此它期望变量在被赋值之前被声明。</p><p>Python是动态类型的，不需要定义类型, Python根据变量的值确定其数据类型。动态类型语言更加灵活，在编写脚本时可以节省时间和空间。但是，这可能会导致运行时出现问题。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line">number = <span class="number">5</span></span><br><span class="line">numbr = (number + <span class="number">15</span>) / <span class="number">2</span>  <span class="comment">#注意错字</span></span><br></pre></td></tr></table></figure></p><p>上面的代码本应创建一个值为5的可变数字，然后将其加上15并除以2以得到10. 但是，<code>number</code>在第二行的开头拼写错误。由于Python不需要声明变量，因此会不由分说直接创建一个名为<code>numbr</code>的新变量，并把本应分配给<code>number</code>的值分配给它。这段代码会很顺利编译，但是如果程序试图用<code>number</code>来做某事，程序员假设它的值是10，那么后续就无法产生期望的结果,而且还很难注意到问题。</p><p>Java的compiler其中一个关键作用是进行静态类型检查（static type check）。若前面定义了 <code>int x = 0;</code>, 那么后面若给x赋值其他的类型值<code>x = &#39;horse&#39;;</code>, compiler就会报错. 这样就保证了程序不会出现类型错误.</p><p>除了错误检查外, static types 也可以让程序媛/猿知道自己处的是什么对象.</p><p>总而言之，静态类型具有以下优点：</p><ul><li>编译器确保所有类型都是兼容的，这使得程序员更容易调试他们的代码。</li><li>由于代码保证没有类型错误，所以编译后程序的用户将永远不会遇到类型错误。例如，Android应用程序是用Java编写的，通常仅以.class文件的形式分发，即以编译的格式。因此，这样的应用程序不应该由于类型错误而崩溃。</li><li>每个变量，参数和函数都有一个声明的类型，使程序员更容易理解和推理代码。</li></ul><h2 id="Code-Style-Comments-Javadoc"><a href="#Code-Style-Comments-Javadoc" class="headerlink" title="Code Style, Comments, Javadoc"></a>Code Style, Comments, Javadoc</h2><p>在学习和实践过程中，我们应该努力保持代码可读性。良好的编码风格的一些最重要的特点是：</p><ul><li>一致的风格（间距，变量命名，缩进风格等）</li><li>大小（线不太宽，源文件不要太长）</li><li>描述性命名（变量，函数，类），例如变量或函数名称为年份或getUserName而不是x或f。让代码本身提供可解读性。</li><li>避免重复的代码：几乎不会有两个重要的代码块几乎相同，除了一些改变。</li><li>适当的评论, 使其他读者也能轻松理解你的代码<ul><li>行注释: <code>//</code>分隔符开头行被当做注释。</li><li>Block（又名多行注释）注释: <code>/*</code>,  <code>*/</code>, 但我们更推荐javadoc形式的注释。</li></ul></li><li>Javadoc: <code>/ **</code>，<code>*/</code>, 可以（但不总是）包含描述性标签。 借助<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/windows/javadoc.html" target="_blank" rel="noopener">javadoc工具</a>可以生成HTML格式的API文档。<br>第一段是方法的描述。描述下面是不同的<a href="https://en.wikipedia.org/wiki/Javadoc" target="_blank" rel="noopener">描述性标签</a>, 比如参数 <code>@param</code>， 返回值 <code>@return</code>， 可能抛出的任何异常 <code>@throws</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>   名字，邮箱&lt;address @ example.com&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>     1.6 版本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java基本语法&quot;&gt;&lt;a href=&quot;#Java基本语法&quot; class=&quot;headerlink&quot; title=&quot;Java基本语法&quot;&gt;&lt;/a&gt;Java基本语法&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HelloWorld&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Hello world!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的程序由一个类声明组成，该声明使用关键字&lt;code&gt;public class&lt;/code&gt;声明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java所有的代码都应该包含在class里面。&lt;/li&gt;
&lt;li&gt;真正负责运行的代码，是一个名为main的method，它声明为&lt;code&gt;public static void main(String[] args)&lt;/code&gt;。&lt;ul&gt;
&lt;li&gt;public：公共的，大部分方法都是以这个关键字开始的，后面会进一步解释。&lt;/li&gt;
&lt;li&gt;static：这是一个静态方法，不与任何特定的实例关联，后面会解释。&lt;/li&gt;
&lt;li&gt;void：它没有返回类型。&lt;/li&gt;
&lt;li&gt;main：这是方法的名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String [] args&lt;/code&gt;：这是传递给main方法的参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用大括号&lt;code&gt;{ }&lt;/code&gt;来表示一段代码的开始和结束。&lt;/li&gt;
&lt;li&gt;声明必须以分号结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;静态分类-Static-Typing&quot;&gt;&lt;a href=&quot;#静态分类-Static-Typing&quot; class=&quot;headerlink&quot; title=&quot;静态分类 Static Typing&quot;&gt;&lt;/a&gt;静态分类 Static Typing&lt;/h2&gt;&lt;p&gt;程序语言静态与动态的分类，可以参考oracle的&lt;a href=&quot;https://docs.oracle.com/cd/E57471_01/bigData.100/extensions_bdd/src/cext_transform_typing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;说明文件&lt;/a&gt;，它解释了动态和静态类型之间的区别, 帮助你理解由程序的错误提示信息。&lt;br&gt;两个主要区别:&lt;br&gt;1. 动态类型语言在运行时执行类型检查，而静态类型语言在编译时执行类型检查。这意味如果以静态类型语言（如Java）编写的脚本包含错误，则在编译错误之前将无法编译. 而用动态类型语言编写的脚本可以编译，即使它们包含会阻止脚本正常运行（如果有的话）的错误。&lt;br&gt;2. 静态类型语言要求你在使用它们之前声明变量的数据类型，而动态类型语言则不需要。&lt;br&gt;考虑以下两个代码示例：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;num = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 01 - Java | 安装 - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-01-java-install/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-01-java-install/</id>
    <published>2017-12-18T00:00:00.000Z</published>
    <updated>2018-01-19T19:01:41.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>本系列资料来源于伯克利 Josh Hug 的 <a href="datastructur.es/sp17/">cs61b spring 2017</a>.</p><h2 id="Java安装与配置"><a href="#Java安装与配置" class="headerlink" title="Java安装与配置"></a>Java安装与配置</h2><p>安装Java，前往<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">Oracle</a>下载java sdk，我用的是Java SE 8u151/ 8u152 版本。安装sdk时会同时安装sdr。</p><p>Windows系统配置:</p><ul><li>推荐安装<a href="http://git-scm.com/download/" target="_blank" rel="noopener">git bash</a>, 一切按照默认安装就好.</li><li>更新系统环境变量: 直接在<code>运行</code>中搜索<code>Environment Variables</code>, 选择<code>编辑系统环境变量</code>, 在弹出的框中选择<code>高级-&gt;环境变量</code>, 在弹出的框中<code>系统变量</code>里面<ul><li>新建变量: 变量名 = <code>JAVA_HOME</code>, 变量值 = 你的jdk路径,如<code>C:\Program Files\Java\jdk1.8.0_151</code></li><li>编辑Path: 在前面加入<code>%JAVA_HOME%\bin;%PYTHON_HOME%;</code>(请注意，不能有空格.)</li></ul></li></ul><p>OS X系统配置:</p><ul><li>安装Homebrew，一个非常好用的包管理工具。要安装，请在terminal终端输入<code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code>(注意：在此过程中，可能会提示输入密码。当输入密码时，终端上不会显示任何内容，但计算机还是会记录你的密码的。这是一个安全措施, 让其他人在屏幕上看不到你的密码。只需输入您的密码，然后按回车。)</li><li>然后，通过输入以下命令来检查brew系统是否正常工作<code>brew doctor</code>. 如果遇到警告，要求下载命令行工具，则需要执行此操作。请参考这个<a href="http://stackoverflow.com/questions/9329243/xcode-4-4-and-later-install-%20%20command-line-tools" target="_blank" rel="noopener">StackOverflow</a>。</li><li>安装git：输入<code>brew install git</code></li></ul><p>安装并配置好java后，测试是否成功:<br>随便在你喜欢的文件夹里新建一个java文件<code>HelloWorld.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以选择用sublime来快速新建文件, 直接在你选择的文件里右键 git bash, 在git bash 里面键入<code>subl HelloWorld.java</code>, 还自动启动sublime并新建一个空白的<code>HelloWorld.java</code>文件, 把上面的代码复制进去并保存即可. (若出现类似提示: 找不到subl command, 解决办法请参考博文<a href="/Launch-editor-in-Gitbash">在Gitbash中直接启动sublime或atom等编辑器以打开或新建文件</a> )<br>开始真正的测试。直接在之前打开的git bash中输入:</p><ol><li><code>ls</code>, 会看到<code>HelloWorld.java</code>这个文件, <code>ls</code>会列出这个目录中的文件/文件夹</li><li><code>javac HelloWorld.java</code>, 理论上这一步不会有任何输出，有的话可能是设置有问题。现在，如果你继续<code>ls</code>，会看到多了一个<code>HelloWorld.class</code>文件， 这是javac创建的。</li><li><code>java HelloWorld</code> (注意没有<code>.java</code>), 会看到输出<code>Hello World</code>, 表明你的Java设置没有问题</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h1&gt;&lt;p&gt;本系列资料来源于伯克利 Josh Hug 的 &lt;a href=&quot;da
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>人工智能AI入门到进阶</title>
    <link href="http://yoursite.com/ai/"/>
    <id>http://yoursite.com/ai/</id>
    <published>2017-12-17T18:25:12.138Z</published>
    <updated>2018-01-13T13:14:35.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>记录学习AI的学习笔记，内容包含基础知识的总结以及编程实现的整理。</p><h3 id="Language"><a href="#Language" class="headerlink" title="Language:"></a>Language:</h3><p><a href="https://github.com/ShootingSpace/Guide-to-Computer-Science/blob/master/readme.md" target="_blank" rel="noopener">English</a>  </p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#人工智能">人工智能</a><ul><li><a href="#机器学习">机器学习</a></li><li><a href="#深度学习">深度学习</a></li><li><a href="#自然语言处理">自然语言处理</a></li><li><a href="#计算机视觉">计算机视觉</a></li><li><a href="#机器人">机器人</a></li></ul></li><li><a href="#大数据">大数据</a><ul><li><a href="#mapreduce">MapReduce</a></li></ul></li></ul><a id="more"></a><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><ul><li><a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">Coursera Machine Learning， 吴恩达的简化版机器学习</a></li><li><a href="https://see.stanford.edu/Course/CS229" target="_blank" rel="noopener">Machine Learning, 吴恩达的机器学习课程</a> 这个比较深入</li><li><a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener">Deep Learning, 吴恩达的深度学习课程</a></li><li><a href="https://www.coursera.org/learn/neural-networks" target="_blank" rel="noopener">Neural Networks for Machine Learning, Hinton的神经网络课程</a></li></ul><h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><ul><li><a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener">Deep learning, Coursera</a></li><li><a href="https://github.com/CSTR-Edinburgh/mlpractical/tree/mlp2017-8/master" target="_blank" rel="noopener">Machine Learning Practical: DNN, CNN, RNN</a> 每个lab的答案在下一个lab branch里，即lab1的答案可以在lab2 branch里面看到。这个代码全部用Python class，比coursera的难度高点。</li></ul><h4 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h4><ul><li><a href="https://www.youtube.com/playlist?list=PL6397E4B26D00A269" target="_blank" rel="noopener">自然语言处理, 斯坦福</a></li><li><a href="https://github.com/ShootingSpace/Self-to-Computer-Science-and-Artificial-Intelligence/blob/master/Note%20-%20AI125%20Accelerated%20Natural%20Language%20Processing%20UoE.md" target="_blank" rel="noopener">加速自然语言处理, 爱丁堡大学</a></li><li><a href="http://cs224d.stanford.edu/" target="_blank" rel="noopener">深度学习处理自然语言，斯坦福</a></li></ul><h4 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h4><ul><li><a href="https://www.youtube.com/watch?v=6niqTuYFZLQ&amp;list=PLe7764SJVnV10-Nr7e0sBlC9J0LRf4sQo" target="_blank" rel="noopener">图像识别：卷积神经网络，李飞飞，斯坦福</a></li></ul><h4 id="机器人"><a href="#机器人" class="headerlink" title="机器人"></a>机器人</h4><ul><li><a href="https://see.stanford.edu/Course/CS223A" target="_blank" rel="noopener">机器人入门，斯坦福</a></li></ul><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><ul><li><a href="https://classroom.udacity.com/courses/ud617" target="_blank" rel="noopener">Hadoop和MapReduce入门，优达学城</a></li><li><a href="http://www.inf.ed.ac.uk/teaching/courses/exc/" target="_blank" rel="noopener">MapReduce极限计算，爱丁堡大学</a></li><li><a href="http://web.stanford.edu/class/cme213/" target="_blank" rel="noopener">并行计算入门：MPI, openMP, and CUDA, 斯坦福</a></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h3><p><a href="https://www.google.com/about/careers/students/guide-to-technical-development.html" target="_blank" rel="noopener">Guide to technical development from Google education</a><br><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="noopener">OS Free Programming Books</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;记录学习AI的学习笔记，内容包含基础知识的总结以及编程实现的整理。&lt;/p&gt;
&lt;h3 id=&quot;Language&quot;&gt;&lt;a href=&quot;#Language&quot; class=&quot;headerlink&quot; title=&quot;Language:&quot;&gt;&lt;/a&gt;Language:&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ShootingSpace/Guide-to-Computer-Science/blob/master/readme.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;English&lt;/a&gt;  &lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#人工智能&quot;&gt;人工智能&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#机器学习&quot;&gt;机器学习&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#深度学习&quot;&gt;深度学习&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#自然语言处理&quot;&gt;自然语言处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#计算机视觉&quot;&gt;计算机视觉&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#机器人&quot;&gt;机器人&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#大数据&quot;&gt;大数据&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#mapreduce&quot;&gt;MapReduce&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="人工智能" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="人工智能" scheme="http://yoursite.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="自然语言处理" scheme="http://yoursite.com/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>CS入门到进阶</title>
    <link href="http://yoursite.com/cs/"/>
    <id>http://yoursite.com/cs/</id>
    <published>2017-12-16T22:31:52.836Z</published>
    <updated>2017-12-21T12:01:23.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>记录学习CS的学习笔记，内容包含基础知识的总结以及编程实现的整理。</p><h3 id="Language"><a href="#Language" class="headerlink" title="Language:"></a>Language:</h3><p><a href="https://github.com/ShootingSpace/Guide-to-Computer-Science/blob/master/readme.md" target="_blank" rel="noopener">English</a>  </p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#cs入门">CS入门</a></li><li><a href="#面向对象编程语言">学习编写(至少)一种面向对象编程语言(C ++，Java®，Python®)</a></li><li><a href="#其他编程语言">学习其他编程语言</a></li><li><a href="#测试你的代码">测试你的代码</a></li><li><a href="#逻辑推理和离散数学">逻辑推理和离散数学</a></li><li><a href="#算法和数据结构">深入了解算法和数据结构</a></li><li><a href="#操作系统">了解计算机操作系统</a></li></ul><a id="more"></a><h3 id="CS入门"><a href="#CS入门" class="headerlink" title="CS入门"></a>CS入门</h3><p>现在的入门课基本都是用Python语言。</p><ul><li><a href="https://www.udacity.com/course/cs101" target="_blank" rel="noopener">计算机科学导论，优达学城</a></li><li><a href="https://cs50.harvard.edu/" target="_blank" rel="noopener">CS50x 哈佛，语言包括C，Python，SQL和JavaScript加CSS和HTML</a></li></ul><h3 id="面向对象编程语言"><a href="#面向对象编程语言" class="headerlink" title="面向对象编程语言"></a>面向对象编程语言</h3><p>一般而言，建议先学Java，Python，再学C++。 这三种语言都基本掌握后，再根据自身的职业需求，选择其中一个语言（或者其他语言）进一步深入练习。因为学校课程主要以Python为主，所以目前我还是主要深入学习Python，这是我的<a href="https://github.com/ShootingSpace/Self-to-Computer-Science-and-Artificial-Intelligence/blob/master/Note%20-%20Python%20digest.md" target="_blank" rel="noopener">Python学习笔记</a>。</p><h4 id="面向初学者程序员的在线资源："><a href="#面向初学者程序员的在线资源：" class="headerlink" title="面向初学者程序员的在线资源："></a>面向初学者程序员的在线资源：</h4><ul><li><a href="https://see.stanford.edu/Course/CS106A" target="_blank" rel="noopener">编程方法学，斯坦福CS106A，Java</a></li><li><a href="http://www-inst.eecs.berkeley.edu/~cs61a/sp14/" target="_blank" rel="noopener">伯克利大学CS 61A计算机程序的结构与解读，Python</a></li><li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-092-introduction-to-programming-in-java-january-iap-2010/index.htm" target="_blank" rel="noopener">Java编程简介，MIT</a></li><li><a href="https://developers.google.com/edu/python/" target="_blank" rel="noopener">Google的Python Class</a></li><li><a href="https://developers.google.com/edu/c++/" target="_blank" rel="noopener">Google的C ++类</a></li></ul><h4 id="面向有经验的程序员的在线资源："><a href="#面向有经验的程序员的在线资源：" class="headerlink" title="面向有经验的程序员的在线资源："></a>面向有经验的程序员的在线资源：</h4><ul><li><a href="http://datastructur.es/sp16/" target="_blank" rel="noopener">数据结构，伯克利大学 CS 61B，Java</a></li><li><a href="https://www.udacity.com/course/design-of-computer-programs--cs212" target="_blank" rel="noopener">计算机程序设计，Udacity，Python</a></li><li><a href="https://see.stanford.edu/Course/CS106B" target="_blank" rel="noopener">抽象编程，斯坦福 CS106B，C ++</a><br>最新作业：<a href="http://web.stanford.edu/class/cs106b/" target="_blank" rel="noopener">http://web.stanford.edu/class/cs106b/</a></li><li><a href="https://book.douban.com/subject/1909336/" target="_blank" rel="noopener">《数据结构与算法分析:C++描述》, Mark A. Weiss</a></li></ul><h3 id="其他编程语言"><a href="#其他编程语言" class="headerlink" title="其他编程语言"></a>其他编程语言</h3><p>根据实际需要自行选择一种或多种学习：</p><ul><li><a href="#javascript">JavaScript®</a>  </li><li><a href="#CSS-HTML">CSS＆HTML</a>  </li><li><a href="#ruby">Ruby®</a>  </li><li><a href="#lua">Lua</a>  </li><li><a href="#php">PHP®</a>  </li><li><a href="#haskell">Haskell</a>  </li><li>Perl®  </li><li><a href="#go">Go</a>  </li><li>Shell®脚本  </li><li>Lisp®  </li><li>Scheme®  </li></ul><p>一些在线资源：  </p><ul><li><a href="https://cs50.harvard.edu/" target="_blank" rel="noopener">CS50x 哈佛，语言包括C，Python，SQL和JavaScript加CSS和HTML</a>  </li><li><a href="https://www.codecademy.com/learn" target="_blank" rel="noopener">Codecademy</a></li></ul><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><ul><li><a href="https://bento.io/topic/javascript" target="_blank" rel="noopener">Bento JavaScript Learning Track</a>(Bento)</li><li><a href="https://egghead.io" target="_blank" rel="noopener">Egghead.io</a></li><li><a href="https://www.learnhowtoprogram.com/javascript" target="_blank" rel="noopener">学习如何编程：JavaScript</a> - Epicodus Inc.</li><li><a href="https://learnquery.infinum.co" target="_blank" rel="noopener">学习：查询</a></li></ul><h4 id="CSS-＆-HTML"><a href="#CSS-＆-HTML" class="headerlink" title="CSS ＆ HTML"></a>CSS ＆ HTML</h4><ul><li><a href="https://bento.io/topic/css" target="_blank" rel="noopener">Bento CSS Learning Track</a>(Bento)</li><li><a href="https://bento.io/topic/html" target="_blank" rel="noopener">Bento HTML Learning Track</a>(Bento)</li><li><a href="https://dash.generalassemblyly" target="_blank" rel="noopener">用破折号建立个人网站</a></li><li><a href="https://www.bloc.io/tutorials/webflow-tutorial-design-responsive-sites-with-webflow" target="_blank" rel="noopener">使用Webflow构建响应式网站</a></li><li><a href="https://www.bloc.io/tutorials/jottly-a-beginner-s-guide-to-html-css-skeleton-and-animate-css" target="_blank" rel="noopener">使用骨架构建SaaS着陆页</a></li><li><a href="http://cs75.tv/2010/fall/" target="_blank" rel="noopener">建立动态网站</a></li><li><a href="http://www.thefirehoseproject.com/lessons/splash-page" target="_blank" rel="noopener">在1小时内编写个人启动页面：实用HTML和CSS简介</a></li><li><a href="https://www.learnhowtoprogram.com/css" target="_blank" rel="noopener">学习如何编程：CSS</a> - Epicodus Inc.</li><li><a href="https://www.udemy.com/learn-html5-programming-from-scratch/" target="_blank" rel="noopener">从头开始学习HTML5编程</a></li></ul><h4 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h4><ul><li><a href="https://www.learnhowtoprogram.com/ruby" target="_blank" rel="noopener">学习如何编程：Ruby</a> - Epicodus Inc.</li><li><a href="https://rubymonk.com" target="_blank" rel="noopener">RubyMonk - 交互式Ruby教程</a></li></ul><h4 id="Haskell"><a href="#Haskell" class="headerlink" title="Haskell"></a>Haskell</h4><ul><li><a href="http://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals" target="_blank" rel="noopener">C9：功能编程基础知识</a> - Erik Meijer</li><li><a href="http://www.seas.upenn.edu/~cis194/" target="_blank" rel="noopener">CIS 194：Haskell简介</a> -  Brent Yorgey</li><li><a href="http://www.scs.stanford.edu/11au-cs240h/notes/" target="_blank" rel="noopener">CS240h：Haskell的功能系统</a> - Bryan O’Sullivan</li><li><a href="https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0" target="_blank" rel="noopener">edX：功能编程简介</a> - Erik Meijer</li><li><a href="https://videoag.fsmpi.rwth-aachen.de/?course=12ss-funkprog" target="_blank" rel="noopener">亚琛大学：功能编程</a> - JürgenGiesl</li></ul><h4 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h4><ul><li><a href="http://luatut.com/crash_course.html" target="_blank" rel="noopener">Lua Interactive Crash Course</a></li><li><a href="http://www.tutorialspoint.com/lua/" target="_blank" rel="noopener">Lua Tutorial</a></li></ul><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><ul><li><a href="https://www.learnhowtoprogram.com/php" target="_blank" rel="noopener">学习如何编程：PHP</a> - Epicodus Inc.</li></ul><h4 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h4><ul><li><a href="http://www.tutorialspoint.com/go/index.htm" target="_blank" rel="noopener">Go Tutorial</a></li></ul><h3 id="测试你的代码"><a href="#测试你的代码" class="headerlink" title="测试你的代码"></a>测试你的代码</h3><p>了解如何捕获错误，创建测试和破解软件.  </p><ul><li><a href="https://www.udacity.com/course/software-testing--cs258" target="_blank" rel="noopener">软件测试，Udacity</a>  </li><li><a href="https://www.udacity.com/course/software-debugging--cs259" target="_blank" rel="noopener">软件调试，Udacity</a></li></ul><h3 id="逻辑推理和离散数学"><a href="#逻辑推理和离散数学" class="headerlink" title="逻辑推理和离散数学"></a>逻辑推理和离散数学</h3><ul><li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/index.HTM" target="_blank" rel="noopener">数学计算机科学，麻省理工学院</a></li><li><a href="https://www.coursera.org/learn/mathematical-thinking" target="_blank" rel="noopener">数学思考导论，斯坦福大学，Coursera</a></li><li><a href="https://www.coursera.org/course/pgm" target="_blank" rel="noopener">概率图形模型，斯坦福大学，Coursera</a></li><li><a href="https://www.coursera.org/course/gametheory" target="_blank" rel="noopener">博弈论，斯坦福大学和不列颠哥伦比亚大学，Coursera</a></li></ul><h3 id="算法和数据结构"><a href="#算法和数据结构" class="headerlink" title="算法和数据结构"></a>算法和数据结构</h3><p>了解基本数据类型(堆栈，队列和袋子)，排序算法(快速排序，合并，堆栈)，数据结构(二叉搜索树，红黑树，哈希表)和Big O.  </p><ul><li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/" target="_blank" rel="noopener">算法简介，麻省理工学院，2011秋季</a>  </li><li><a href="https://www.coursera.org/course/algs4partI" target="_blank" rel="noopener">算法，普林斯顿大学，Part 1</a> ＆ <a href="https://www.coursera.org/learn/algorithms-part2" target="_blank" rel="noopener">Part2</a>  </li><li><a href="https://www.coursera.org/specializations/algorithms" target="_blank" rel="noopener">算法：设计和分析，斯坦福大学</a>  </li><li><a href="http://algs4.cs.princeton.edu/home/" target="_blank" rel="noopener">算法，第4版，by Robert Sedgewick and Kevin Wayne</a></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h3><p><a href="https://www.google.com/about/careers/students/guide-to-technical-development.html" target="_blank" rel="noopener">Guide to technical development from Google education</a><br><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="noopener">OS Free Programming Books</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;记录学习CS的学习笔记，内容包含基础知识的总结以及编程实现的整理。&lt;/p&gt;
&lt;h3 id=&quot;Language&quot;&gt;&lt;a href=&quot;#Language&quot; class=&quot;headerlink&quot; title=&quot;Language:&quot;&gt;&lt;/a&gt;Language:&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ShootingSpace/Guide-to-Computer-Science/blob/master/readme.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;English&lt;/a&gt;  &lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#cs入门&quot;&gt;CS入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#面向对象编程语言&quot;&gt;学习编写(至少)一种面向对象编程语言(C ++，Java®，Python®)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#其他编程语言&quot;&gt;学习其他编程语言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#测试你的代码&quot;&gt;测试你的代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#逻辑推理和离散数学&quot;&gt;逻辑推理和离散数学&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#算法和数据结构&quot;&gt;深入了解算法和数据结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#操作系统&quot;&gt;了解计算机操作系统&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
</feed>
