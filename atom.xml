<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Computer Science &amp; AI</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shukebeta.me/"/>
  <updated>2018-12-17T13:03:50.845Z</updated>
  <id>http://shukebeta.me/</id>
  
  <author>
    <name>Cong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>概率图模型 - 朴素贝叶斯 - 隐马尔科夫 - 条件随机场 - 逻辑回归</title>
    <link href="http://shukebeta.me/NLP-HMM-CRF/"/>
    <id>http://shukebeta.me/NLP-HMM-CRF/</id>
    <published>2018-12-15T16:00:00.000Z</published>
    <updated>2018-12-17T13:03:50.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="词性标注（Part-of-Speech-Tagging）"><a href="#词性标注（Part-of-Speech-Tagging）" class="headerlink" title="词性标注（Part-of-Speech-Tagging）"></a>词性标注（Part-of-Speech-Tagging）</h2><p>POS任务是指根据观察得到的序列, 推断出对应的词性标注, 比如<code>Bob drank coffee at Starbucks</code>, 标注可能为<code>Bob (NOUN) drank (VERB) coffee (NOUN) at (PREPOSITION) Starbucks (NOUN)</code>.</p><p>除此之外, 还有命名实体识别, 以及其他涉及到需要根据观察序列推断隐含状态的问题, 都可以考虑用隐马尔可夫模型(Hidden Markov Model, HMM)或者条件随机场(conditional random fields, CRF)来处理.</p><a id="more"></a><h2 id="概率图模型"><a href="#概率图模型" class="headerlink" title="概率图模型"></a>概率图模型</h2><p>Graphical Models, 用图的形式表示随机变量之间条件依赖关系的概率模型，是概率论与图论的结合。图中的节点表示随机变量，缺少边表示条件独立假设。<br>G = (V, E). 其中 V: vertex, 顶点/节点, 表示随机变量. E: edge, 边/弧. 如果两个节点不存在边, 则二者条件独立.<br><img src="/images/probabilistic_graphical_models.png" alt="" title="image from: Probabilistic Graphical Models Principles and Techniques"><br>从图上可以看到, 贝叶斯网络(Bayesian Networks, BNs)是有向图, 每个节点的条件概率分布表示为<code>P(当前节点 | 父节点)</code>.</p><p>而马尔可夫网络则是无向图, 包含了一组具有马尔可夫性质的随机变量. 马尔可夫随机场(Markov Random Fields, MRF)是由参数$λ=(S, π, A)$表示, 其中S是状态的集合，π是初始状态的概率, A是状态间的转移概率。一阶马尔可夫链就是假设t时刻的状态只依赖于前一时刻的状态，与其他时刻的状态和观测无关。这个性质可以用于简化概率链的计算。使用类似性质作为假设的模型还有2-gram语言模型等.</p><h3 id="朴素贝叶斯分类器与隐马尔可夫模型"><a href="#朴素贝叶斯分类器与隐马尔可夫模型" class="headerlink" title="朴素贝叶斯分类器与隐马尔可夫模型"></a>朴素贝叶斯分类器与隐马尔可夫模型</h3><p>朴素贝叶斯分类器(NBs)假设条件独立性(朴素贝叶斯假设, Hand and Yu, 2001)：$p(x_i | y, x_j) = p(x_i | y)$, 在给定目标值 y 时，x的属性值之间相互条件独立。这样, 计算可以简化为 $$p(y | \overrightarrow{x}) \propto p(y, \overrightarrow{x}) = p(y) \prod_{i=1} p(x_i | y).$$</p><p>朴素贝叶斯模型只考虑了单个输出变量y。如果要为一个观察序列$\overrightarrow{x} =(x_1, …, x_n)$预测对应的分类序列$\overrightarrow{y} =（y_1, …, y_n)$ ，一个简单的序列模型可以表示为多个NBs的乘积。此时不考虑序列单个位置之间的相互依赖。$$p(\overrightarrow{y}, \overrightarrow{x}) = \prod^n_{i=1} p(y_i) p(x_i | y_i).$$<br>此时每个观察值$x_i$仅取决于对应序列位置的类变量$y_i$。由于这种独立性假设，从一个步骤到另一个步骤的转换概率不包括在该模型中。然而这种假设在实践中几乎不会符合，这导致这种模型的性能很有限。</p><p>因此，比较合理的假设是观测序列在连续相邻位置间的观测值存在依赖。要模拟这种依赖关系, 就要引入状态转移概率$p(y_i | y_{i-1})$, 由此引出著名的隐马尔可夫模型 Hidden Markov model, HMM, Rabiner (1989):<br>$$p(\overrightarrow{y}, \overrightarrow{x}) = \prod^n_{i=1} p(y_i | y_{i-1}) p(x_i | y_i).$$ $$p(\overrightarrow{x}) = \sum_{y\in \mathcal{Y}} \prod^n_{i=1} p(y_i | y_{i-1}) p(x_i | y_i).$$</p><p>HMM参数$λ= (Y, X, π, A, B)$ ，其中 Y是隐状态（输出变量）的集合，X是观察值（输入）集合，π是初始状态的概率，A是状态转移概率矩阵$p(y_i | y_{i-1})$，B是输出观察值概率矩阵$p(x_i | y_{i})$。在POS任务中, X就是观察到的句子, Y就是待推导的标注序列, 因为词性待求的, 所以人们称之为<strong>隐含状态</strong>.</p><p>HMM的缺陷是其基于观察序列中的每个元素都相互条件独立的假设。即在任何时刻观察值仅仅与状态（即要标注的标签）有关。对于简单的数据集，这个假设倒是合理。但大多数现实世界中的真实观察序列是由多个相互作用的特征和观察序列中较长范围内的元素之间的依赖而形成的。而条件随机场(conditional random fiel, CRF)恰恰就弥补了这个缺陷.</p><h2 id="条件随机场"><a href="#条件随机场" class="headerlink" title="条件随机场"></a>条件随机场</h2><p>随机场, 可以看成是一组随机变量的集合（这组随机变量对应同一个样本空间）。当给每一个位置按照某种分布随机赋予一个值之后，其全体就叫做随机场。这些随机变量之间可能有依赖关系，一般来说，也只有当这些变<br>量之间有依赖关系的时候，我们将其单独拿出来看成一个随机场才有实际意义。</p><p>如果给定的MRF中每个随机变量下面还有观察值，我们要确定的是给定观察集合下，这个MRF的分布，也就是条件分布，那么这个MRF就称为 conditional random fields (CRF)。它的条件分布形式完全类似于MRF的分布形式，只不过多了一个观察集合X。所以, CRF本质上是给定了条件(观察值observations)集合的MRF</p><p>1.特征函数的选择: 特征函数的选取直接关系模型的性能。<br>2.参数估计: 从已经标注好的训练数据集学习条件随机场模型的参数，即各特征函数的权重向量λ。<br>3.模型推断: 在给定条件随机场模型参数λ下，预测出最可能的状态序列。</p><h3 id="CRF特征函数"><a href="#CRF特征函数" class="headerlink" title="CRF特征函数"></a>CRF特征函数</h3><p>在CRF中，首先需要定义特征函数. 特征函数的定义非常灵活, 可以是：</p><ol><li>一个句子 s</li><li>句子中单词的位置 i</li><li>当前单词的标签$l_i$</li><li>前一个单词的标签$l_{i-1}$ (如果仅限于相邻位置的单词, 那么就是 linear-chain CRF).</li><li>任意其他单词的标签$l_{j}$</li></ol><p>然后为每个特征函数$f_{j}$分配权重$\lambda_j$, 权重是从数据中学习而来. 对$j$个特征方程求和, 对序列每个位置$i$求和:<br>$$ score(l | s) = \sum_{j = 1}^m \sum_{i = 1}^n \lambda_j f_j(s, i, l_i, l_{i-1})$$<br>CRF的每个特征函数都是一个输入的函数, 对应的输出是一个实数值（只是0或1）。例如, 选择特征函数$f_1(s, i, l_i, l_{i-1}) = 1$, 当且仅当$l_i =$ ADVERB, 且第i个单词以“-ly”结尾; 否则为0. 如果与此特征相关的权重$\lambda_j$很大且为正，那么这个特征等同于说模型倾向于把以-ly结尾的单词标记为ADVERB。</p><p>通过指数化和归一化把这些得分转换为概率值:<br>$$p(l | s) = \frac{exp[score(l|s)]}{\sum_{l^\prime} exp[score(l^\prime|s)]} = \frac{exp[\sum_{j = 1}^m \sum_{i = 1}^n \lambda_j f_j(s, i, l_i, l_{i-1})]}{\sum_{l’} exp[\sum_{j = 1}^m \sum_{i = 1}^n \lambda_j f_j(s, i, l^\prime_i, l^\prime_{i-1})]} $$</p><h3 id="CRF与HMM"><a href="#CRF与HMM" class="headerlink" title="CRF与HMM"></a>CRF与HMM</h3><p>只需要在CRF的对数线性形式中, 设置权重为对应HMM取对数后的二元转换和发射概率: $\log p(l,s) = \log p(l_0) + \sum_i \log p(l_i | l_{i-1}) + \sum_i \log p(w_i | l_i)$</p><ul><li>对于HMM的每个状态转换概率$p(l_i = y | l_{i-1} = x)$, CRF定义一组特征函数为$f_{x,y}(s, i, l_i, l_{i-1}) = 1 如果 l_i = y 且 l_{i-1} = x$, 为这些特征赋予权重$w_{x,y} = \log p(l_i = y | l_{i-1} = x)$</li><li>类似的, 对于HMM的每个发射概率$p(w_i = z | l_{i} = x)$, CRF定义一组特征函数为$g_{x,y}(s, i, l_i, l_{i-1}) = 1 如果 w_i = z 且 l_i = x$, 赋予权重$w_{x,z} = \log p(w_i = z | l_i = x)$.</li></ul><p>如此, CRF计算的分值$p(l|s)$就精确地正比于对应的HMM, 也就是说, 任意的HMM都可以由CRF表达出来.</p><p>CRF比HMM更强大, 更广泛</p><ol><li>CRF可以定义更广泛的特征函数：HMM受限于相邻位置的状态转换（二元转换）和发射概率函数，迫使每个单词仅依赖于当前标签，并且每个标签仅依赖于前一个标签。而CRF可以使用更多样的全局特征。例如，如果句子的结尾包含问号，则可以给给CRF模型增加一个特征函数，记录此时将句子的第一个单词标记为VERB的概率。这使得CRF可以使用长距离依赖的特征。</li><li>CRF可以有任意的权重值：HMM的概率值必须满足特定的约束， $0 &lt;= p(w_i | l_i) &lt;= 1, \sum_w p(w_i = w | l_1) = 1)$, 而CRF的权重值是不受限制的。</li></ol><h3 id="CRF与Logistic-Regression"><a href="#CRF与Logistic-Regression" class="headerlink" title="CRF与Logistic Regression"></a>CRF与Logistic Regression</h3><p>CRF的概率计算与Logistic Regression (LR)的形式类似，<br>$$CRF: p(l | s) = \frac{exp[\sum_{j = 1}^m \sum_{i = 1}^n \lambda_j f_j(s, i, l_i, l_{i-1})]}{\sum_{l’} exp[\sum_{j = 1}^m \sum_{i = 1}^n \lambda_j f_j(s, i, l^\prime_i, l^\prime_{i-1})]} $$<br>$$LR: P(y|x) = \frac{\exp \bigg( \sum\limits_{i=1}^{N} w_{i} \cdot f_{i}(x,y) \bigg)} {\sum\limits_{y’ \in Y} \exp \bigg( \sum\limits_{i=1}^{N} w_{i} \cdot f_{i}(x,y’) \bigg)}$$<br>在LR中, $f_i(y, x)$是一个特征，$w_i$是与该特征相关的权重。提取的特征是二元特征，取值0或1，通常称为指示函数。这些特征中的每一个都由与输入$x$和分类$y$相关联的函数计算。</p><p>实际上，CRF基本上就是逻辑回归的序列化：与逻辑回归是用于分类的对数线性模型不同，CRF是标签序列的对数线性模型。</p><h2 id="生成式模型和判别式模型"><a href="#生成式模型和判别式模型" class="headerlink" title="生成式模型和判别式模型"></a>生成式模型和判别式模型</h2><p>从朴素贝叶斯, 到HMM; 从Logistic Regression到CRF, 这些概率图模型有如下转换关系:<br><img src="/images/relationship_nbs_hmm_lr_crf.png" alt="" title="Diagram of the relationship between naive Bayes, logistic regression, HMMs, linear-chain CRFs, generative models, and general CRFs. image from: An Introduction to Conditional Random Fields, by Charles Sutton and Andrew McCallum"></p><p>而在朴素贝叶斯与Logistic Regression, 以及HMM和CRF之间, 又有生成式和判别式的区别.</p><p>生成式模型描述标签向量y如何有概率地<strong>生成</strong>特征向量x, 即尝试构建x和y的联合分布$p(y, x)$, 典型的模型有HMM，贝叶斯模型，MRF。生成式模型</p><p>而判别模型直接描述如何根据特征向量x判断其标签y, 即尝试构建$p(y | x)$的条件概率分布, 典型模型如如LR, SVM，CRF，MEMM等.</p><p>原则上，任何类型的模型都可以使用贝叶斯规则转换为另一种类型，但实际上这些方法是不同的. 生成模型和判别模型都描述了$p(y, x)$的概率分布，但努力的方向不同。生成模型，例如朴素贝叶斯分类器和HMM，是一类可以因式分解为$p(y, x) = p(y)p(x|y)$的联合分布, 也就是说，它们描述了如何为给定标签的特征采样或“生成”值。生成式模型从统计的角度表示数据的分布情况，能够反映同类数据本身的相似度，不关心判别边界。它的优点是:<br>• 实际上带的信息要比判别模型丰富， 研究单类问题比判别模型灵活性强<br>• 能更充分的利用先验知识<br>• 模型可以通过增量学习得到<br>缺点也很明显: • 学习过程比较复杂; • 在目标分类问题中准确度不高</p><p>而判别式模型, 比如 LR, 是一系列条件分布$p(y | x)$. 也就是说，分类规则是直接建模的。原则上，判别模型也可通过为输入提供边际分布$p(x)$来获得联合分布$p(y, x)$，但很少需要这样。条件分布$p(y | x)$不包括$p(x)$的模型，在分类任务中无论如何都用不到。对$p(x)$建模的困难之处在于它通常包含许多建模难度较高的有高度依赖性的特征。判别式模型寻找不同类别之间的最优分类面，反映的是异类数据之间的差异。优点是:<br>• 分类边界更灵活，比使用纯概率方法或生产模型得到的更高级。<br>• 能清晰的分辨出多类或某一类与其他类之间的差异特征<br>• 在聚类、viewpoint changes, partial occlusion and scale variations中的效果较好<br>•适用于较多类别的识别<br>缺点是：• 不能反映训练数据本身的特性。• 能力有限，可以分类, 但无法把整个场景描述出来。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.echen.me/2012/01/03/introduction-to-conditional-random-fields/" target="_blank" rel="noopener">http://blog.echen.me/2012/01/03/introduction-to-conditional-random-fields/</a><br>Classical probabilistic models and conditional random fields<br><a href="http://homepages.inf.ed.ac.uk/csutton/publications/crftut-fnt.pdf" target="_blank" rel="noopener">An Introduction to Conditional Random Fields</a>, by Charles Sutton and Andrew McCallum</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;词性标注（Part-of-Speech-Tagging）&quot;&gt;&lt;a href=&quot;#词性标注（Part-of-Speech-Tagging）&quot; class=&quot;headerlink&quot; title=&quot;词性标注（Part-of-Speech-Tagging）&quot;&gt;&lt;/a&gt;词性标注（Part-of-Speech-Tagging）&lt;/h2&gt;&lt;p&gt;POS任务是指根据观察得到的序列, 推断出对应的词性标注, 比如&lt;code&gt;Bob drank coffee at Starbucks&lt;/code&gt;, 标注可能为&lt;code&gt;Bob (NOUN) drank (VERB) coffee (NOUN) at (PREPOSITION) Starbucks (NOUN)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;除此之外, 还有命名实体识别, 以及其他涉及到需要根据观察序列推断隐含状态的问题, 都可以考虑用隐马尔可夫模型(Hidden Markov Model, HMM)或者条件随机场(conditional random fields, CRF)来处理.&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>信息抽取</title>
    <link href="http://shukebeta.me/NLP-information-extraction/"/>
    <id>http://shukebeta.me/NLP-information-extraction/</id>
    <published>2018-11-10T16:00:00.000Z</published>
    <updated>2018-12-17T13:07:21.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息抽取"><a href="#信息抽取" class="headerlink" title="信息抽取"></a>信息抽取</h2><p>1997年MUC会议（MUC-7） 召开时，评测任务已经增加到5个：<br>① 场景模板（scenario template, ST）填充：定义了描述场景的模板及槽填充规范；<br>② 命名实体（named entity, NE）识别：识别出文本中出现的专有名称和有意义的数量短语， 并加以归类；<br>③ 共指（coreference, CR）关系确定：识别出给定文本中的参照表达（ referring expressions），并确定这些表达之间的共指关系；<br>④ 模板元素（template element, TE）填充：类似于人名和组织机构名识别，但是要求系统必须识别出实体的描述和名字，如果一个实体在文本中被提到了多次，使用了几种可能的描述和不同的名字形式，要求系统都要把它们识别出来，一个文本中的每个实体只有一个模板元素［Grishman and Sundheim, 1996］；<br>⑤ 模板关系（template relation, TR）：确定实体之间与特定领域无关的关系。<br><a id="more"></a></p><p>1999年起美国NIST组织了自动内容抽取（automatic content extraction, ACE）评测会议，旨在研究和<br>开发自动内容技术以支持对三种不同来源文本（普通文本、经语音识别后得到的文本、 由OCR识别得到的文本）的自动处理，以实现新闻语料中出现的实体、关系、事件等内容的自动抽取。评测任务设计:<br>实体检测与跟踪（entity detection and tracking, EDT）、数值检测与识别（value detection and recognition, VDR）、时间识别和规范化（time expression recognition and normalization, TERN）、关系检测与描述（relation detection and characterization, RDC）、事件检测与描述（event detection and characterization, EDC）和实体翻译（entity translation, ET）等。</p><h3 id="TF-IDF-关键词抽取"><a href="#TF-IDF-关键词抽取" class="headerlink" title="TF-IDF 关键词抽取"></a>TF-IDF 关键词抽取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba.analyse</span><br><span class="line">jieba.analyse.extract_tags(sentence, topK=<span class="number">20</span>, withWeight=<span class="keyword">False</span>, allowPOS=())</span><br></pre></td></tr></table></figure><p><code>sentence</code> 为待提取的文本<br><code>topK</code> 为返回几个 TF/IDF 权重最大的关键词，默认值为 <code>20</code><br><code>withWeight</code> 为是否一并返回关键词权重值，默认值为 <code>False</code><br><code>allowPOS</code> 仅包括指定词性的词，默认值为空，即不筛选. 如电商评论指定要形容词</p><p>关键词提取所使用逆向文件频率（IDF）文本语料库可以切换成自定义语料库的路径, 用法： <code>jieba.analyse.set_idf_path(file_name) # file_name为自定义语料库的路径</code><br>自定义语料库示例见 <a href="https://github.com/fxsjy/jieba/blob/master/extra_dict/idf.txt.big" target="_blank" rel="noopener">https://github.com/fxsjy/jieba/blob/master/extra_dict/idf.txt.big</a><br>用法示例见 <a href="https://github.com/fxsjy/jieba/blob/master/test/extract_tags_idfpath.py" target="_blank" rel="noopener">https://github.com/fxsjy/jieba/blob/master/test/extract_tags_idfpath.py</a></p><p>关键词提取所使用停止词（Stop Words）文本语料库可以切换成自定义语料库的路径, 用法： <code>jieba.analyse.set_stop_words(file_name) # file_name为自定义语料库的路径</code><br>自定义语料库示例见 <a href="https://github.com/fxsjy/jieba/blob/master/extra_dict/stop_words.txt" target="_blank" rel="noopener">https://github.com/fxsjy/jieba/blob/master/extra_dict/stop_words.txt</a><br>用法示例见 <a href="https://github.com/fxsjy/jieba/blob/master/test/extract_tags_stop_words.py" target="_blank" rel="noopener">https://github.com/fxsjy/jieba/blob/master/test/extract_tags_stop_words.py</a></p><p>关键词一并返回关键词权重值 <a href="https://github.com/fxsjy/jieba/blob/master/test/extract_tags_with_weight.py" target="_blank" rel="noopener">https://github.com/fxsjy/jieba/blob/master/test/extract_tags_with_weight.py</a></p><h3 id="TextRank"><a href="#TextRank" class="headerlink" title="TextRank"></a>TextRank</h3><p>论文：<a href="http://web.eecs.umich.edu/~mihalcea/papers/mihalcea.emnlp04.pdf" target="_blank" rel="noopener">TextRank: Bringing Order into Texts</a>.</p><ul><li>将待抽取关键词的文本进行分词</li><li>以固定窗口大小(默认为5，通过span属性调整)，词之间的共现关系，构建图</li><li>计算图中节点的PageRank，是无向带权图</li><li>数据量越大，构建的图越精准</li></ul><p><code>jieba.analyse.textrank(sentence, topK=20, withWeight=False, allowPOS=(&#39;ns&#39;, &#39;n&#39;, &#39;vn&#39;, &#39;v&#39;))</code> 默认过滤词性。<code>jieba.analyse.TextRank()</code> 新建自定义实例</p><h2 id="开放式信息抽取"><a href="#开放式信息抽取" class="headerlink" title="开放式信息抽取"></a>开放式信息抽取</h2><p>处理的文本领域不再限定于规范的新闻文本或者某一领域文本，而是不限定领域的网络文本, 不仅需要考虑文本<br>特征，同时需要综合考虑网页结构特征和用户行为特征等。</p><h3 id="开放式实体抽取"><a href="#开放式实体抽取" class="headerlink" title="开放式实体抽取"></a>开放式实体抽取</h3><p>开放式实体抽取关注的是从海量、冗余、不规范的网络数据源上抽取出符合某个语义类的实体列表，侧重于抽取。</p><p>基于这样的假设：同类实体在网络上具有相似的网页结构或者相似的上下文特征。因此可以根据给出的特定语义类的若干实体（“种子”），找出该语义类包含的其他实体，其中特定语义类的标签可能是显式，也可能是隐式给出的。如给出“中国、美国、俄罗斯”这三个实体，要求找出“国家”这个语义类的其他实体诸如“德国、法国、日本”等。</p><p>训练步骤包含两部分：候选实体获取和候选实体置信度计算和排序。</p><p>具体训练过程：通常从种子实体出发，通过分析种子实体在语料中的上下文特征得到模板，根据模板得到更多候选实体，选取置信度高的候选实体作为新种子进行迭代，满足一定条件后停止迭代， 返回<br>历次置信度高的候选实体作为结果输出。</p><p>抽取比识别在任务上更加底层，实体抽取的结果可以作为列表支撑实体的识别。</p><p>对于中文而言，当不存在网页结构特征时，实体抽取任务变得更加困难，其中一个重要原因来自汉语分词，未知实体往往在分词过程中被分开。</p><h3 id="实体消歧"><a href="#实体消歧" class="headerlink" title="实体消歧"></a>实体消歧</h3><p>Entity disambiguation的难点在于指称项多样性（name variation）和指称项歧义（name ambiguity）。<br>指称项多样性指一个实体概念可以用多种命名性指称项指称，如全称、别称、简称、拼写错误、多语言名称等。</p><p>单语言的实体消歧问题的主要方法：</p><ol><li>实体聚类消歧法：对每一个实体指称项抽取其上下文特征（包括词、实体等），并将其表示成特征向量；然后计算实体指称项之间的相似度；计算基于指称项之间的相似度时，可采用一定聚类算法将其聚类，将每个类看作一个实体概念。这种方法的核心任务是计算实体指称项之间的相似度，<ul><li>传统的方法是利用上下文的词信息建立词袋模型（bag-of-words, BOW）。</li><li>针对人名消歧，采用基于图的算法，利用社会化关系的传递性考虑隐藏的实体关系知识。</li><li>利用知识资源，如Wikipedia、Web上的链接信息、命名实体的同现信息、领域特定语料库等，来提升实体消歧的效果。</li></ul></li><li>实体链接消歧法：实体链接（entity linking）也称实体分辨或实体解析（entity resolution），或记录链接（record linkage）。基于实体链接消歧法的目的是解决基于聚类的实体消歧法不能显式地给出实体语义信息的问题，其基本任务是：给定一个实体指称项，将其链接到知识库中的实体概念上。实体链接的核心任务仍是计算实体指称项和候选实体之间的相似度，选择相似度最大的候选实体作为链接的目标实体。</li></ol><p>实体消歧仍面临很多难题，包括空目标实体问题（NIL entity problem）（即实体知识库中不包含某指称项的目标实体）、知识库覆盖度有限、来自互联网的知识源可靠性差和知识库使用方法单一（集中于使用单文档特征）等。</p><h3 id="开放式实体关系抽取"><a href="#开放式实体关系抽取" class="headerlink" title="开放式实体关系抽取"></a>开放式实体关系抽取</h3><p>实体关系通常采用采用三元组表示：<code>(Arg1, Pred, Arg2)</code>， 其中，<code>Arg1</code>表示实体，<code>Arg2</code>表示实体关系值，通常也是实体，<code>Pred</code>表示关系名称，通常为动词、名词或者名词短语。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;信息抽取&quot;&gt;&lt;a href=&quot;#信息抽取&quot; class=&quot;headerlink&quot; title=&quot;信息抽取&quot;&gt;&lt;/a&gt;信息抽取&lt;/h2&gt;&lt;p&gt;1997年MUC会议（MUC-7） 召开时，评测任务已经增加到5个：&lt;br&gt;① 场景模板（scenario template, ST）填充：定义了描述场景的模板及槽填充规范；&lt;br&gt;② 命名实体（named entity, NE）识别：识别出文本中出现的专有名称和有意义的数量短语， 并加以归类；&lt;br&gt;③ 共指（coreference, CR）关系确定：识别出给定文本中的参照表达（ referring expressions），并确定这些表达之间的共指关系；&lt;br&gt;④ 模板元素（template element, TE）填充：类似于人名和组织机构名识别，但是要求系统必须识别出实体的描述和名字，如果一个实体在文本中被提到了多次，使用了几种可能的描述和不同的名字形式，要求系统都要把它们识别出来，一个文本中的每个实体只有一个模板元素［Grishman and Sundheim, 1996］；&lt;br&gt;⑤ 模板关系（template relation, TR）：确定实体之间与特定领域无关的关系。&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Information Retrieval" scheme="http://shukebeta.me/tags/Information-Retrieval/"/>
    
  </entry>
  
  <entry>
    <title>Java BitMap 和 Bloom Filter</title>
    <link href="http://shukebeta.me/java-BitMap/"/>
    <id>http://shukebeta.me/java-BitMap/</id>
    <published>2018-10-18T16:00:00.000Z</published>
    <updated>2018-12-05T09:31:24.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bit-Map"><a href="#Bit-Map" class="headerlink" title="Bit Map"></a>Bit Map</h2><p>Bit-map用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。<br><a id="more"></a><br>假设我们要对0-7内的5个元素<code>4,7,2,5,3</code>排序（假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），</p><ol><li>首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0，<code>0 0 0 0 0 0 0 0</code>.</li><li>然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置设为1, <code>p+(i/8)|(0x01&lt;&lt;(i%8))</code>, 这里默认为Big-ending, <code>0 0 0 0 1 0 0 0</code>.</li><li>然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态<code>0 0 1 1 1 1 0 1</code></li><li>遍历一遍Bit区域，把<code>1</code>的索引依次输出（<code>2，3，4，5，7</code>），这样就达到了排序的目的。</li></ol><p>算法的关键是如何确定十进制的数映射到二进制bit位的map图。算法占用很少内存，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M。缺点是不能有重复数据。</p><h3 id="Map映射表"><a href="#Map映射表" class="headerlink" title="Map映射表"></a>Map映射表</h3><p>假设需要排序或者查找的总数<code>N=10000000</code>，那么我们需要申请内存空间的大小为<code>int a[1 + N/32]</code>，其中：<code>a[0]</code>在内存中占32位, 可以对应十进制数0-31，依次类推：<br>bitmap表为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a[0]---------&gt;0-31</span><br><span class="line">a[1]---------&gt;32-63</span><br><span class="line">a[2]---------&gt;64-95</span><br><span class="line">a[3]---------&gt;96-127</span><br><span class="line">..........</span><br></pre></td></tr></table></figure></p><p>十进制数需要转换为对应的bit位</p><h3 id="位移转换"><a href="#位移转换" class="headerlink" title="位移转换"></a>位移转换</h3><p>将十进制数转换为对应的bit位, 申请一个<code>int</code>一维数组，作为32列的二维数组，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a[0]    |0000000000000000000000000000000000000|</span><br><span class="line"></span><br><span class="line">int a[1]    |0000000000000000000000000000000000000|</span><br><span class="line"></span><br><span class="line">………………</span><br><span class="line"></span><br><span class="line">int a[N]    |0000000000000000000000000000000000000|</span><br></pre></td></tr></table></figure></p><p>例如十进制0，对应在<code>a[0]</code>第一位： <code>00000000000000000000000000000001</code></p><ol><li>求十进制<code>0-N</code>对应在数组<code>a</code>的索引：十进制<code>0-31</code>，对应<code>a[0]</code>，先由十进制数n转换为与32的余可转化为对应在数组<code>a</code>中的索引<code>0</code>。比如n=24,那么 n/32=0，则24对应<code>a[0]</code>。又比如n=60, 那么n/32=1，则60对应<code>a[1]</code>。</li><li>求<code>0-N</code>对应<code>0-31</code>中的数：十进制0-31就对应0-31，而32-63则对应也是0-31，即给定一个数n可以通过模32求得对应0-31中的数。</li><li>利用移位0-31使得对应32bit位为1. 找到对应0-31的数为M, 左移M位：即<code>2 ^ M</code>, 置1.</li></ol><h3 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h3><p>为了降低键值冲突的概率，Bloom Filter使用了多个哈希函数：创建一个m位BitSet，先将所有位初始化为0，然后选择k个不同的哈希函数。第i个哈希函数对字符串str哈希的结果记为<code>h(i, str)</code>，且<code>h(i, str)</code>的范围是0到m-1 。</p><p>对于字符串<code>str</code>，分别计算<code>h(1, str), h(2, str), ... h(k, str)</code>, 以这些哈希值作为索引, 将BitSet的对应位置的位设为1, 这样就把<code>str</code>映射到BitSet的k个二进制位了.<img src="/images/bloom_filter.png" alt=""></p><p>如果要检查某<code>string</code>是否已经被记录在BitSet中, 只需要计算其哈希值数组, 并检查BitSet上对应位置的值是否为<code>1</code>, 若对应位置中有任何一个不是<code>1</code>, 那么该字符串<strong>一定</strong>没有被记录过, 若全部对应位置都为<code>1</code>, 那么按照<strong>false positive</strong>认为该字符串已经被记录过了(但不是100%肯定).</p><p>删除操作会影响到其他字符串。如果需要删除字符串的功能，使用Counting bloomfilter(CBF)，这是一种Bloom Filter的变体，CBF将Bloom Filter每一个Bit改为一个计数器，这样就可以实现删除字符串的功能了。</p><p>Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。</p><p>所以Bloom Filter适用以下几个特点：</p><ol><li>只要返回数据不存在，则肯定不存在。</li><li>返回数据存在，但只能是大概率存在。</li><li>不能清除其中的数据。</li></ol><p>BloomFilter的应用很多，比如数据库、爬虫（用爬虫抓取网页时对网页url去重）、防缓存击穿等。特别是需要精确知道某个数据不存在时做点什么事情就非常适合布隆过滤。 Goolge在BigTable中就使用了BloomFilter，以避免在硬盘中寻找不存在的条目。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Java实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">作者：crossoverJie</span><br><span class="line">链接：https:<span class="comment">//zhuanlan.zhihu.com/p/50926087</span></span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilters</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> arraySize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BloomFilters</span><span class="params">(<span class="keyword">int</span> arraySize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arraySize = arraySize;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[arraySize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = hashcode_1(key);</span><br><span class="line">        <span class="keyword">int</span> second = hashcode_2(key);</span><br><span class="line">        <span class="keyword">int</span> third = hashcode_3(key);</span><br><span class="line"></span><br><span class="line">        array[first % arraySize] = <span class="number">1</span>;</span><br><span class="line">        array[second % arraySize] = <span class="number">1</span>;</span><br><span class="line">        array[third % arraySize] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断数据是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = hashcode_1(key);</span><br><span class="line">        <span class="keyword">int</span> second = hashcode_2(key);</span><br><span class="line">        <span class="keyword">int</span> third = hashcode_3(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> firstIndex = array[first % arraySize];</span><br><span class="line">        <span class="keyword">if</span> (firstIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> secondIndex = array[second % arraySize];</span><br><span class="line">        <span class="keyword">if</span> (secondIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> thirdIndex = array[third % arraySize];</span><br><span class="line">        <span class="keyword">if</span> (thirdIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash 算法1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hashcode_1</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; key.length(); ++i) &#123;</span><br><span class="line">            hash = <span class="number">33</span> * hash + key.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(hash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash 算法2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hashcode_2</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> p = <span class="number">16777619</span>;</span><br><span class="line">        <span class="keyword">int</span> hash = (<span class="keyword">int</span>) <span class="number">2166136261L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length(); i++) &#123;</span><br><span class="line">            hash = (hash ^ data.charAt(i)) * p;</span><br><span class="line">        &#125;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">17</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(hash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  hash 算法3</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hashcode_3</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash, i;</span><br><span class="line">        <span class="keyword">for</span> (hash = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; key.length(); ++i) &#123;</span><br><span class="line">            hash += key.charAt(i);</span><br><span class="line">            hash += (hash &lt;&lt; <span class="number">10</span>);</span><br><span class="line">            hash ^= (hash &gt;&gt; <span class="number">6</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hash += (hash &lt;&lt; <span class="number">3</span>);</span><br><span class="line">        hash ^= (hash &gt;&gt; <span class="number">11</span>);</span><br><span class="line">        hash += (hash &lt;&lt; <span class="number">15</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.abs(hash);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Guava 实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">guavaTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> star = System.currentTimeMillis();</span><br><span class="line">    BloomFilter&lt;Integer&gt; filter = BloomFilter.create(</span><br><span class="line">            Funnels.integerFunnel(),</span><br><span class="line">            <span class="number">10000000</span>,</span><br><span class="line">            <span class="number">0.01</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        filter.put(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Assert.assertTrue(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">    Assert.assertTrue(filter.mightContain(<span class="number">2</span>));</span><br><span class="line">    Assert.assertTrue(filter.mightContain(<span class="number">3</span>));</span><br><span class="line">    Assert.assertFalse(filter.mightContain(<span class="number">10000000</span>));</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"执行时间："</span> + (end - star));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造方法有两个比较重要的参数，一个是预计存放多少数据，一个是可以接受的误报率。Guava 会通过你预计的数量以及误报率帮你计算出你应当会使用的数组大小 numBits 以及需要计算几次 Hash 函数 <code>numHashFunctions</code> 。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp, Strategy strategy)</span> </span>&#123;</span><br><span class="line">  checkNotNull(funnel);</span><br><span class="line">  checkArgument(</span><br><span class="line">      expectedInsertions &gt;= <span class="number">0</span>, <span class="string">"Expected insertions (%s) must be &gt;= 0"</span>, expectedInsertions);</span><br><span class="line">  checkArgument(fpp &gt; <span class="number">0.0</span>, <span class="string">"False positive probability (%s) must be &gt; 0.0"</span>, fpp);</span><br><span class="line">  checkArgument(fpp &lt; <span class="number">1.0</span>, <span class="string">"False positive probability (%s) must be &lt; 1.0"</span>, fpp);</span><br><span class="line">  checkNotNull(strategy);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (expectedInsertions == <span class="number">0</span>) &#123;</span><br><span class="line">    expectedInsertions = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * TODO(user): Put a warning in the javadoc about tiny fpp values, since the resulting size</span></span><br><span class="line"><span class="comment">   * is proportional to -log(p), but there is not much of a point after all, e.g.</span></span><br><span class="line"><span class="comment">   * optimalM(1000, 0.0000000000000001) = 76680 which is less than 10kb. Who cares!</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">long</span> numBits = optimalNumOfBits(expectedInsertions, fpp);</span><br><span class="line">  <span class="keyword">int</span> numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BloomFilter&lt;T&gt;(<span class="keyword">new</span> LockFreeBitArray(numBits), numHashFunctions, funnel, strategy);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Could not create BloomFilter of "</span> + numBits + <span class="string">" bits"</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>put</code>有不同的策略，如<code>MURMUR128_MITZ_64()</code>策略根据 <code>murmur3_128</code> 方法的到一个 <code>128</code> 位长度的 <code>byte[]</code>。分别取高低 8 位的到两个 hash 值(<code>lowerEight, upperEight</code>)。再根据初始化时的到的执行 hash 的次数进行 hash 运算。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This strategy uses all 128 bits of &#123;<span class="doctag">@link</span> Hashing#murmur3_128&#125; when hashing. It looks different</span></span><br><span class="line"><span class="comment"> * than the implementation in MURMUR128_MITZ_32 because we're avoiding the multiplication in the</span></span><br><span class="line"><span class="comment"> * loop and doing a (much simpler) += hash2. We're also changing the index to a positive number by</span></span><br><span class="line"><span class="comment"> * AND'ing with Long.MAX_VALUE instead of flipping the bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MURMUR128_MITZ_64() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">put</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, LockFreeBitArray bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> bitSize = bits.bitSize();</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = Hashing.murmur3_128().hashObject(object, funnel).getBytesInternal();</span><br><span class="line">    <span class="keyword">long</span> hash1 = lowerEight(bytes);</span><br><span class="line">    <span class="keyword">long</span> hash2 = upperEight(bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> bitsChanged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">long</span> combinedHash = hash1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numHashFunctions; i++) &#123;</span><br><span class="line">      <span class="comment">// Make the combined hash positive and indexable</span></span><br><span class="line">      bitsChanged |= bits.set((combinedHash &amp; Long.MAX_VALUE) % bitSize);</span><br><span class="line">      combinedHash += hash2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bitsChanged;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>LockFreeBitArray</code>就是真正存放数据的底层数据结构。利用了一个 <code>AtomicLongArray data</code> 来存放数据。所以 <code>set()</code> 时候也是对这个 <code>data</code> 做处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Models a lock-free array of bits.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;We use this instead of java.util.BitSet because we need access to the array of longs and we</span></span><br><span class="line"><span class="comment"> * need compare-and-swap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LockFreeBitArray</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LONG_ADDRESSABLE_BITS = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">final</span> AtomicLongArray data;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LongAddable bitCount;</span><br><span class="line"></span><br><span class="line">  LockFreeBitArray(<span class="keyword">long</span> bits) &#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> <span class="keyword">long</span>[Ints.checkedCast(LongMath.divide(bits, <span class="number">64</span>, RoundingMode.CEILING))]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Used by serialization</span></span><br><span class="line">  LockFreeBitArray(<span class="keyword">long</span>[] data) &#123;</span><br><span class="line">    checkArgument(data.length &gt; <span class="number">0</span>, <span class="string">"data length is zero!"</span>);</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">new</span> AtomicLongArray(data);</span><br><span class="line">    <span class="keyword">this</span>.bitCount = LongAddables.create();</span><br><span class="line">    <span class="keyword">long</span> bitCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> value : data) &#123;</span><br><span class="line">      bitCount += Long.bitCount(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.bitCount.add(bitCount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns true if the bit changed value. */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> bitIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (get(bitIndex)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> longIndex = (<span class="keyword">int</span>) (bitIndex &gt;&gt;&gt; LONG_ADDRESSABLE_BITS);</span><br><span class="line">    <span class="keyword">long</span> mask = <span class="number">1L</span> &lt;&lt; bitIndex; <span class="comment">// only cares about low 6 bits of bitIndex</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> oldValue;</span><br><span class="line">    <span class="keyword">long</span> newValue;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      oldValue = data.get(longIndex);</span><br><span class="line">      newValue = oldValue | mask;</span><br><span class="line">      <span class="keyword">if</span> (oldValue == newValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!data.compareAndSet(longIndex, oldValue, newValue));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We turned the bit on, so increment bitCount.</span></span><br><span class="line">    bitCount.increment();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <code>set()</code> 之前先通过 <code>get()</code> 判断这个数据是否存在于集合中，如果已经存在则直接返回告知客户端写入失败。接下来就是通过位运算进行位或赋值。<code>get()</code> 方法的计算逻辑和 <code>set()</code> 类似，只要判断为 0 就直接返回存在该值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Bit-Map&quot;&gt;&lt;a href=&quot;#Bit-Map&quot; class=&quot;headerlink&quot; title=&quot;Bit Map&quot;&gt;&lt;/a&gt;Bit Map&lt;/h2&gt;&lt;p&gt;Bit-map用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 08 - 数据压缩 - 哈夫曼编码</title>
    <link href="http://shukebeta.me/NLP-08-data-compression-huffman-compression/"/>
    <id>http://shukebeta.me/NLP-08-data-compression-huffman-compression/</id>
    <published>2018-10-11T16:00:00.000Z</published>
    <updated>2018-12-17T13:06:05.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="避免歧义的编码"><a href="#避免歧义的编码" class="headerlink" title="避免歧义的编码"></a>避免歧义的编码</h2><p>在构建压缩编码的对应关系时，我们使用不同的数量的位来编码不同的字符.<br><a id="more"></a><br>比如摩斯密码<img src="/images/Morse_Code.png" alt="" title="Chart of the Morse code letters and numerals.">. 如果单纯使用这种对应关系，会出现一些问题， 如<code>•••−−−•••</code>会产生歧义: <code>SOS</code>? <code>V7</code>? <code>IAMIE</code>? <code>EEWNI</code>? 所以在实际使用中, 密码使用一些间隔来分隔代码字。</p><p>那么对于不同的压缩编码, 有什么常用方法来避免歧义？<br>方法是确保没有一个编码是另一个编码的前缀。比如</p><ul><li>使用固定长度编码。</li><li>为每个编码添加特殊的stop char。</li><li><strong>使用一种具备广泛使用性的prefix-free编码</strong>。</li></ul><p>用什么数据结构来设计prefix-free编码?</p><h3 id="用Trie构造编码"><a href="#用Trie构造编码" class="headerlink" title="用Trie构造编码"></a>用Trie构造编码</h3><p>一个二叉(<code>0, 1</code>)Trie: 叶节点是字符, 根节点到叶节点的路径就是编码.<img src="/images/huffman_trie.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"></p><p>压缩:<br>方法1：从叶开始; 按照路径到达根; 反向打印bits。<br>方法2：创建<code>键-值</code>对的符号表。</p><p>解压:</p><ol><li>从根节点开始, 根据位值是0还是1在Trie图上游走, 直到走到叶节点，则解压出一个字符</li><li>返回根节点, 继续第一步, 直到跑完所有编码.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> ch;   <span class="comment">// used only for leaf nodes</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> freq;  <span class="comment">// used only for compress</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> freq, Node left, Node right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.ch    = ch;</span><br><span class="line">      <span class="keyword">this</span>.freq  = freq;</span><br><span class="line">      <span class="keyword">this</span>.left  = left;</span><br><span class="line">      <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compare Nodes by frequency</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node that)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="keyword">return</span> <span class="keyword">this</span>.freq - that.freq;  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Runtime - Linear in input size N</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       Node root = readTrie(); <span class="comment">// read in encoding trie</span></span><br><span class="line">       <span class="keyword">int</span> N = BinaryStdIn.readInt(); <span class="comment">// read in number of chars</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">       &#123;</span><br><span class="line">          Node x = root;</span><br><span class="line">          <span class="keyword">while</span> (!x.isLeaf())</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="keyword">if</span> (!BinaryStdIn.readBoolean())</span><br><span class="line">                x = x.left;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                x = x.right;</span><br><span class="line">          &#125;</span><br><span class="line">          BinaryStdOut.write(x.ch, <span class="number">8</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       BinaryStdOut.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何读取一个Trie：根据Trie的前序遍历序列重构.<img src="/images/preorder_traversal_trie.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">readTrie</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (BinaryStdIn.readBoolean())</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">char</span> c = BinaryStdIn.readChar(<span class="number">8</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(c, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   Node x = readTrie();</span><br><span class="line">   Node y = readTrie();</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">'\0'</span>, <span class="number">0</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如何把Trie写为序列：以前序遍历的方式写Trie；额外用一个位标记是否叶节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTrie</span><span class="params">(Node x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (x.isLeaf())</span><br><span class="line">   &#123;</span><br><span class="line">      BinaryStdOut.write(<span class="keyword">true</span>);</span><br><span class="line">      BinaryStdOut.write(x.ch, <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   BinaryStdOut.write(<span class="keyword">false</span>);</span><br><span class="line">   writeTrie(x.left);</span><br><span class="line">   writeTrie(x.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="用哈夫曼算法构建最优编码"><a href="#用哈夫曼算法构建最优编码" class="headerlink" title="用哈夫曼算法构建最优编码"></a>用哈夫曼算法构建最优编码</h3><p>就是用Huffman算法. Huffman算法是把最短的编码赋给出现频率最高的字符, 把最长的编码留给出现频率较低的字符. 在Trie上的效果就变成频率最高的字符路径最短, 长路径都留给频率低的字符. 这样总的效果就是使用了更少的数据位来表达同样的信息.</p><ol><li>统计输入的各个字符的频率<code>freq[i]</code>。</li><li>为每个<code>char i</code>构建一个具有权重<code>freq[i]</code>的Trie(子节点为null), 从此节点开始</li><li>重复以下过程直到融合为一个trie(根节点)：<ul><li>选择当前权重最小的两Tries, <code>freq[i]</code>和<code>freq[j]</code>, 其中<code>i &lt;= j, freq[i] &lt;= freq[j]</code></li><li>给它们创建父节点, 权重为<code>freq[i] + freq[j]</code>, 两个子Trie和其父节点合并为一个Trie, 而且路径0(左边)总是指向较小的子Trie, 路径1(右边)指向较大的.</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">buildTrie</span><span class="params">(<span class="keyword">int</span>[] freq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinPQ&lt;Node&gt; pq = <span class="keyword">new</span> MinPQ&lt;Node&gt;();</span><br><span class="line">    <span class="comment">// initialize PQ with singleton tries</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="number">0</span>; i &lt; R; i++)</span><br><span class="line">       <span class="keyword">if</span> (freq[i] &gt; <span class="number">0</span>)</span><br><span class="line">          pq.insert(<span class="keyword">new</span> Node(i, freq[i], <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;  <span class="comment">// merge two smallest tries</span></span><br><span class="line">       Node x = pq.delMin();</span><br><span class="line">       Node y = pq.delMin();</span><br><span class="line">       Node parent = <span class="keyword">new</span> Node(<span class="string">'\0'</span>, x.freq + y.freq, x, y);</span><br><span class="line">       pq.insert(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.delMin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个算法, 可以保证频率最高(权重最大)的字符的叶节点就是最左叶节点, 一般编码为<code>0</code>, 其他依次类推. 可以证明Huffman算法生成的最优prefix-free编码.</p><p><a href="https://algs4.cs.princeton.edu/55compression/Huffman.java.html" target="_blank" rel="noopener">完整代码见</a></p><p>Implementation.<br>・Pass 1:  tabulate char frequencies and build trie.<br>・Pass 2:  encode file by traversing trie or lookup table</p><p>Running time. Using a binary heap ⇒ <code>N + R log R</code>. N input size, R alphabet size.</p><p>对于具有n个叶子节点的哈夫曼树，一共需要<code>2*n-1</code>个节点: 二叉树有三种类型节点，即子节点数为2的节点，为1的节点和为0的叶节点。而哈夫曼树的非叶子节点是由两个节点生成的，因此不能出现只有单子节点的节点，如果叶子节点个数为n, 那么非叶子节点的个数为<code>n-1</code>.</p><p>哈夫曼编码广泛应用于jpeg, pdf, MP3, MP4等文件编码中.</p><p>在神经网络中, 哈夫曼树也被用于构建层级Softmax.</p><p>一个使用Huffman Encoding的实例：<br><a href="https://github.com/congchan/cs106b-programming-abstraction/tree/master/HW6_Huffman%20Encoding/Huffman/src" target="_blank" rel="noopener">https://github.com/congchan/cs106b-programming-abstraction/tree/master/HW6_Huffman%20Encoding/Huffman/src</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;避免歧义的编码&quot;&gt;&lt;a href=&quot;#避免歧义的编码&quot; class=&quot;headerlink&quot; title=&quot;避免歧义的编码&quot;&gt;&lt;/a&gt;避免歧义的编码&lt;/h2&gt;&lt;p&gt;在构建压缩编码的对应关系时，我们使用不同的数量的位来编码不同的字符.&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Information Retrieval" scheme="http://shukebeta.me/tags/Information-Retrieval/"/>
    
      <category term="Data Compression" scheme="http://shukebeta.me/tags/Data-Compression/"/>
    
      <category term="Huffman Compression" scheme="http://shukebeta.me/tags/Huffman-Compression/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 07 - 数据压缩</title>
    <link href="http://shukebeta.me/NLP-07-data-compression-introduction/"/>
    <id>http://shukebeta.me/NLP-07-data-compression-introduction/</id>
    <published>2018-10-09T16:00:00.000Z</published>
    <updated>2018-12-17T13:06:31.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><p>压缩数据以节省储存空间，节省传输时间。同时很多文件都有很多冗余信息，这为压缩提供了很多可能性。<br><a id="more"></a><br>通用文件压缩<br>·文件：GZIP，BZIP，7z<br>·Archivers：PKZIP<br>·文件系统：NTFS，HFS +，ZFS</p><p>多媒体<br>·图像：GIF，JPEG<br>·声音：MP3<br>·视频：MPEG，DivX™，HDTV</p><p>通讯<br>·ITU-T T4 Group 3 Fax<br>·V.42bis调制解调器<br>·Skype</p><p>数据库</p><h3 id="压缩率"><a href="#压缩率" class="headerlink" title="压缩率"></a>压缩率</h3><p><code>Compression ratio = Bits in Compressed B / bits in B</code>.</p><blockquote><p>自然语言的压缩率为50-75％或更高.</p></blockquote><h3 id="读写二进制"><a href="#读写二进制" class="headerlink" title="读写二进制"></a>读写二进制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BinaryStdIn &#123;</span><br><span class="line">    boolean readBoolean() // read 1 bit of data and return as a boolean value</span><br><span class="line">    char readChar() // read 8 bits of data and return as a char value</span><br><span class="line">    char readChar(int r) // read r bits of data and return as a char value</span><br><span class="line">    // similar methods for byte (8 bits); short (16 bits); int (32 bits); long and double (64 bits)</span><br><span class="line">    boolean isEmpty() // is the bitstream empty?</span><br><span class="line">    void close() // close the bitstream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BinaryStdOut &#123;</span><br><span class="line">    void write(boolean b) // write the specified bit</span><br><span class="line">    void write(char c) // write the specified 8-bit char</span><br><span class="line">    void write(char c, int r) // write the r least significant bits of the specified char</span><br><span class="line">    // similar methods for byte (8 bits); short (16 bits); int (32 bits); long and double (64 bits)</span><br><span class="line">    void close() // close the bitstream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如使用三种方法表达<code>12/31/1999</code><br>1, A character stream (StdOut),<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StdOut.print(month + <span class="string">"/"</span> + day + <span class="string">"/"</span> + year);</span><br></pre></td></tr></table></figure></p><p><code>00110001</code> 1<br><code>00110010</code> 2<br><code>00101111</code> /<br><code>00110111</code> 3<br><code>00110001</code> 1<br><code>00101111</code> /<br><code>00110001</code> 1<br><code>00111001</code> 9<br><code>00111001</code> 9<br><code>00111001</code> 1<br>共 80bits<br>2, Three ints (BinaryStdOut)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BinaryStdOut.write(month);</span><br><span class="line">BinaryStdOut.write(day);</span><br><span class="line">BinaryStdOut.write(year);</span><br></pre></td></tr></table></figure></p><p><code>00000000 00000000 00000000 00001100</code> 12<br><code>00000000 00000000 00000000 00011111</code> 31<br><code>00000000 00000000 00000111 11001111</code> 1999<br>共96bits<br>3，A 4-bit field, a 5-bit field, and a 12-bit field (BinaryStdOut)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BinaryStdOut.write(month, <span class="number">4</span>);</span><br><span class="line">BinaryStdOut.write(day, <span class="number">5</span>);</span><br><span class="line">BinaryStdOut.write(year, <span class="number">12</span>);</span><br></pre></td></tr></table></figure></p><p><code>1100</code> 12<br><code>11111</code> 13<br><code>0111110 01111</code> 1999<br>共21bits</p><h3 id="通用数据压缩算法？"><a href="#通用数据压缩算法？" class="headerlink" title="通用数据压缩算法？"></a>通用数据压缩算法？</h3><p>不存在的，因为假如真的存在一种可以压缩所有比特串的算法，那么该算法就可以继续压缩已经被它压缩过的数据，那意味着所有比特串可以被压缩为0比特.</p><h2 id="Run-length-encoding"><a href="#Run-length-encoding" class="headerlink" title="Run-length encoding"></a>Run-length encoding</h2><p>Simple type of redundancy in a bitstream. Long runs of repeated bits：<br><code>0000000000000001111111000000011111111111</code><br>Compression, 4-bit counts to represent alternating runs of 0s and 1s: 15 0s, then 7 1s, then 7 0s, then 11 1s.<br><code>1111 0111 0111 1011</code><br><!-- more --><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunLength</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// maximum run-length count</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> R    = <span class="number">256</span>;</span><br><span class="line">   <span class="comment">// number of bits per count</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> LG_R = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads a sequence of bits from standard input; compresses</span></span><br><span class="line"><span class="comment">     * them using run-length coding with 8-bit run lengths; and writes the</span></span><br><span class="line"><span class="comment">     * results to standard output.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> run = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> old = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!BinaryStdIn.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> b = BinaryStdIn.readBoolean();</span><br><span class="line">            <span class="keyword">if</span> (b != old) &#123;</span><br><span class="line">                BinaryStdOut.write(run, LG_R);</span><br><span class="line">                run = <span class="number">1</span>;</span><br><span class="line">                old = !old;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 如果长度超过最大值, 写入0</span></span><br><span class="line">                <span class="keyword">if</span> (run == R-<span class="number">1</span>) &#123;</span><br><span class="line">                    BinaryStdOut.write(run, LG_R);</span><br><span class="line">                    run = <span class="number">0</span>;</span><br><span class="line">                    BinaryStdOut.write(run, LG_R);</span><br><span class="line">                &#125;</span><br><span class="line">                run++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryStdOut.write(run, LG_R);</span><br><span class="line">        BinaryStdOut.close();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads a sequence of bits from standard input (that are encoded</span></span><br><span class="line"><span class="comment">     * using run-length encoding with 8-bit run lengths); decodes them;</span></span><br><span class="line"><span class="comment">     * and writes the results to standard output.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> bit = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">while</span> (!BinaryStdIn.isEmpty())</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">int</span> run = BinaryStdIn.readInt(lgR);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; run; i++)</span><br><span class="line">            BinaryStdOut.write(bit);</span><br><span class="line">         bit = !bit;</span><br><span class="line">      &#125;</span><br><span class="line">      BinaryStdOut.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据压缩&quot;&gt;&lt;a href=&quot;#数据压缩&quot; class=&quot;headerlink&quot; title=&quot;数据压缩&quot;&gt;&lt;/a&gt;数据压缩&lt;/h2&gt;&lt;p&gt;压缩数据以节省储存空间，节省传输时间。同时很多文件都有很多冗余信息，这为压缩提供了很多可能性。&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Information Retrieval" scheme="http://shukebeta.me/tags/Information-Retrieval/"/>
    
      <category term="Data Compression" scheme="http://shukebeta.me/tags/Data-Compression/"/>
    
  </entry>
  
  <entry>
    <title>众数问题 - Boyer–Moore majority vote algorithm</title>
    <link href="http://shukebeta.me/algorithms-majority-element/"/>
    <id>http://shukebeta.me/algorithms-majority-element/</id>
    <published>2018-10-02T16:00:00.000Z</published>
    <updated>2018-10-17T09:15:10.517Z</updated>
    
    <content type="html"><![CDATA[<p>数组中有一个数字出现的次数超过数组长度的一半，例如输入一个长度为9的数组<code>1,2,3,2,2,2,5,4,2</code>。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。因为这个数出现次数超过了数组长度一半以上, 那么它就是数组中出现次数最多的数, 故谓之<strong>众数</strong>.<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        most = numbers[<span class="number">0</span>]</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> item == most:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count &lt; <span class="number">0</span>:</span><br><span class="line">                    most = item</span><br><span class="line">                    count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> numbers.count(most) &lt;= len(numbers) / <span class="number">2</span> <span class="keyword">else</span> most</span><br></pre></td></tr></table></figure></p><h2 id="众数问题"><a href="#众数问题" class="headerlink" title="众数问题"></a>众数问题</h2><p>众数问题可以推广泛化：给定大小为<code>n</code>的整数数组，找到所有出现超过<code>n / m</code>次的元素。这种问题可以使用 Boyer-Moore 算法解决.</p><blockquote><p>The Boyer–Moore majority vote algorithm is an algorithm for finding the majority of a sequence of elements using linear time and constant space. It is named after Robert S. Boyer and J Strother Moore, who published it in 1981, and is a prototypical example of a streaming algorithm.</p></blockquote><p>如果存在众数元素，该算法会找到众数元素：对于出现次数一半以上的元素。但是，如果没有众数，算法将不会检测到该事实，并且仍将输出其中一个元素。</p><p>这个时候需要第二次遍历数据, 验证在第一次通过中找到的元素是否真正占众数。</p><p>比如找到所有出现超过<code>n / 3</code>次的元素, 最多只可能有2个, 可以用长度为2的数据结构(这里选择map)来记录众数.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = <span class="number">2</span></span><br><span class="line">        cand = [<span class="number">0</span>] * m</span><br><span class="line">        freq = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> len(freq) &lt; m:</span><br><span class="line">                freq[item] = <span class="number">1</span> + freq.get(item, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span> item <span class="keyword">in</span> freq:</span><br><span class="line">                freq[item] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> list(freq):</span><br><span class="line">                    freq[k] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> freq[k] &lt;= <span class="number">0</span>:</span><br><span class="line">                        freq.pop(k)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [k <span class="keyword">for</span> k <span class="keyword">in</span> freq <span class="keyword">if</span> nums.count(k) &gt; len(nums) // (m + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组中有一个数字出现的次数超过数组长度的一半，例如输入一个长度为9的数组&lt;code&gt;1,2,3,2,2,2,5,4,2&lt;/code&gt;。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。因为这个数出现次数超过了数组长度一半以上, 那么它就是数组中出现次数最多的数, 故谓之&lt;strong&gt;众数&lt;/strong&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Dynamic Programming" scheme="http://shukebeta.me/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>机器阅读理解 - 自注意力机制</title>
    <link href="http://shukebeta.me/NLP-attention-03-self-attention/"/>
    <id>http://shukebeta.me/NLP-attention-03-self-attention/</id>
    <published>2018-10-02T16:00:00.000Z</published>
    <updated>2018-10-24T10:19:11.963Z</updated>
    
    <content type="html"><![CDATA[<p>计算注意力主要分为三个步骤。</p><ol><li>计算query和每个key之间的相似性以获得权重。常用的相似性函数包括点积，拼接，检测器等。</li><li>然后通常是使用softmax函数来正则化这些权重。</li><li>最后将这些权重与相应的value一起加权并获得最终的注意力。</li></ol><a id="more"></a><p>在大部分NLP任务中，key一般就是value。</p><p>在前面的介绍中， 注意力机制一般都是附加于seq2seq或者encoder-decoder架构中。但这篇2017 NIPS的文章<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Attention is all you need</a>提出了自注意力机制. 与过去流行的使用基于RNN的Seq2Seq模型框架不同:</p><ol><li>文章中使用注意机制完全取代了RNN来构建整个模型框架。</li><li>Multi-Headed Attention Mechanism: 在编码器和解码器中使用 Multi-Headed self-attention。</li><li>比LSTM更快的计算速度。</li></ol><p>文章的实验数据暂且不论，其提出的核心想法很重要，就是LSTM这种时序模型速度实在是太慢了，很难应用到超大规模的数据和线上的应用中。Google因其自身业务的大规模性质，本身是很工程化的。所以他们非常反感需要繁琐特征提取的任务，所以他们早早就转投了神经网络。也非常不看好繁琐的神经网络，特别是那些无法并行化计算的。</p><p>近些年来，RNN（及其变种 LSTM, GRU）已成为很多nlp任务如机器翻译的经典网络结构。RNN从左到右或从右到左的方式顺序处理语言。RNN的按顺序处理的性质也使得其更难以充分利用现代快速计算设备，例如GPU等优于并行而非顺序处理的计算单元。虽然卷积神经网络（CNN）的时序性远小于RNN，但CNN体系结构如ByteNet或ConvS2S中，糅合远距离部分的信息所需的步骤数仍随着距离的增加而增长。</p><p>因为一次处理一个单词，RNN需要处理多个时序的单词来做出依赖于长远离单词的决定。但各种研究和实验逐渐表明，决策需要的步骤越多，循环网络就越难以学习如何做出这些决定。而本身LSTM就是为了解决long term dependency问题，但是解决得并不好。很多时候还需要额外加一层注意力层来处理long term dependency。</p><p>所以这次他们直接在编码器和解码器之间直接用attention，这样句子单词的依赖长度最多只有1，减少了信息传输路径。他们称之为Transformer。Transformer只执行一小段constant的步骤（根据经验选择）。在每个步骤中，应用self-attention机制，直接模拟句子中所有单词之间的关系，不管它们之间的位置如何。比如子“I arrived at the bank after crossing the river”，要确定“bank”一词是指河岸而不是金融机构，Transformer可以学会立即关注“river”这个词并在一步之内做出这个决定。</p><h3 id="Transformer总体架构"><a href="#Transformer总体架构" class="headerlink" title="Transformer总体架构"></a>Transformer总体架构</h3><p>Seq2seq神经网络通常包含读取输入句子并生成其表达的编码器。具体地说，为了计算给定单词的下一个表示 - 例如“bank” - Transformer将其与句子中的所有其他单词进行比较。这些比较的结果就是其他单词的注意力权重。这些注意力权重决定了其他单词应该为“bank”的下一个表达做出多少贡献。在计算“bank”的新表示时，能够消除歧义的“river”可以获得跟高的关注。将注意力权重用来加权平均所有单词的表达，然后将加权平均的表达喂给一个全连接网络以生成“bank”的新表达，以反映出该句子正在谈论的是“河岸”。<img src="/images/transform20fps.gif" alt="" title="image from: https://ai.googleblog.com/2017/08/transformer-novel-neural-network.html"><br>Transformer的解码阶段概括起来就是：首先为每个单词生成初始表达或embeddings。这些由空心圆表示。然后，使用自我注意力，聚合来自所有其他单词的信息，生成参考了整个上下文的每个单词的新表达，由实心球表示。不断对每个单词并行地重复这个步骤多次，连续地生成新的表达。</p><p>解码器操作类似，只是从左到右依次生成一个字。它不仅关注先前生成的单词，而且还参考编码器生成的最终表示。</p><p><img src="/images/transformer.png" alt="" title="单层编码器（左）和解码器（右），由 N = 6 个相同的层构建。"><br><code>N = 6</code>实际超过6层。这些“层”中的每一个实际上由两层组成：position-wise FNN 和一个（编码器），或两个（解码器），基于注意力的子层。其中每个还包含4个线性投影和注意逻辑。</p><p>编码器:</p><ol><li>Stage 1 - 输入编码: 序列的顺序信息是非常重要的。由于没有循环，也没有卷积，因此使用“位置编码”表示序列中每个标记的绝对（或相对）位置的信息。<ul><li>位置编码信息 + embedded input</li></ul></li><li>Stage 2 – Multi-head attention 和 Stage 3 – position-wise FFN. 两个阶段都是用来残差连接, 接着正则化输出层</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stage1_out = Embedding512 + TokenPositionEncoding512</span><br><span class="line">Stage2_out = layer_normalization(multihead_attention(Stage1_out) + Stage1_out)</span><br><span class="line">Stage3_out = layer_normalization(FFN(Stage2_out) + Stage2_out)</span><br><span class="line"></span><br><span class="line">out_enc = Stage3_out</span><br></pre></td></tr></table></figure><p>解码器的架构类似，但它在第3阶段采用了附加层, 在输出层上的 mask multi-head attention:</p><ol><li>Stage 1 – 输入解码: 输入 output embedding，偏移一个位置以确保对位置<code>i</code>的预测仅取决于<code>&lt; i</code>的位置。</li><li>Stage 2 - Masked Multi-head attention: 稍作修改以防止注意到后续位置。</li></ol><p>阶段2,3和4同样使用了残差连接，然后在输出使用归一化层。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Stage1_out = OutputEmbedding512 + TokenPositionEncoding512</span><br><span class="line"></span><br><span class="line">Stage2_Mask = masked_multihead_attention(Stage1_out)</span><br><span class="line">Stage2_Norm1 = layer_normalization(Stage2_Mask) + Stage1_out</span><br><span class="line">Stage2_Multi = multihead_attention(Stage2_Norm1 + out_enc) +  Stage2_Norm1</span><br><span class="line">Stage2_Norm2 = layer_normalization(Stage2_Multi) + Stage2_Multi</span><br><span class="line"></span><br><span class="line">Stage3_FNN = FNN(Stage2_Norm2)</span><br><span class="line">Stage3_Norm = layer_normalization(Stage3_FNN) + Stage2_Norm2</span><br><span class="line"></span><br><span class="line">out_dec = Stage3_Norm</span><br></pre></td></tr></table></figure></p><p>可以利用开源的<a href="https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/transformer.py" target="_blank" rel="noopener">Tensor2Tensor</a>，通过调用几个命令来训练Transformer网络进行翻译和解析。</p><h3 id="各个技术细节"><a href="#各个技术细节" class="headerlink" title="各个技术细节"></a>各个技术细节</h3><h3 id="Positional-Encoding"><a href="#Positional-Encoding" class="headerlink" title="Positional Encoding"></a>Positional Encoding</h3><p>在解码时序信息时，跟RNN和FNN不同，Transformer提出了一种把时序解码为正弦波的方法。这些信号作为额外的信息加入到输入和输出中以表达时间的流逝.<br>$$ \begin{eqnarray} PE_{(pos,2i)} = sin(pos/10000^{2i/d_{model}}) \end{eqnarray} $$<br>$$ \begin{eqnarray} PE_{(pos,2i+1)} = cos(pos/10000^{2i/d_{model}})\end{eqnarray} $$</p><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><h4 id="Scaled-Dot-Product-Attention"><a href="#Scaled-Dot-Product-Attention" class="headerlink" title="Scaled Dot-Product Attention"></a>Scaled Dot-Product Attention</h4><h4 id="Multi-head-attention"><a href="#Multi-head-attention" class="headerlink" title="Multi-head attention"></a>Multi-head attention</h4><h4 id="Self-Attention-SA"><a href="#Self-Attention-SA" class="headerlink" title="Self-Attention (SA)"></a>Self-Attention (SA)</h4><h3 id="Position-wise-FFN"><a href="#Position-wise-FFN" class="headerlink" title="Position-wise FFN"></a>Position-wise FFN</h3><h3 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h3><p>作者已经进行了一系列测试（论文表3），其中他们讨论N = 6层的建议，模型大小为512，基于h = 8个heads，键值维度为64，使用100K步。</p><p>还指出，由于模型质量随着$d_k$（行B）的减小而降低，因此可以进一步优化点积兼容性功能。</p><p>其声称提出的固定正弦位置编码，与学习到的位置编码相比，产生几乎相等的分数。</p><h3 id="算法适合哪些类型的问题？"><a href="#算法适合哪些类型的问题？" class="headerlink" title="算法适合哪些类型的问题？"></a>算法适合哪些类型的问题？</h3><ul><li>序列转导（语言翻译）</li><li>语法选区解析的经典语言分析任务 syntactic constituency parsing</li><li>共指消解 coreference resolution</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://research.googleblog.com/2017/08/transformer-novel-neural-network.html" target="_blank" rel="noopener">https://research.googleblog.com/2017/08/transformer-novel-neural-network.html</a><br><a href="https://research.googleblog.com/2017/06/accelerating-deep-learning-research.html" target="_blank" rel="noopener">https://research.googleblog.com/2017/06/accelerating-deep-learning-research.html</a><br><a href="https://mchromiak.github.io/articles/2017/Sep/12/Transformer-Attention-is-all-you-need/" target="_blank" rel="noopener">https://mchromiak.github.io/articles/2017/Sep/12/Transformer-Attention-is-all-you-need/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算注意力主要分为三个步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算query和每个key之间的相似性以获得权重。常用的相似性函数包括点积，拼接，检测器等。&lt;/li&gt;
&lt;li&gt;然后通常是使用softmax函数来正则化这些权重。&lt;/li&gt;
&lt;li&gt;最后将这些权重与相应的value一起加权并获得最终的注意力。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 06 - 不同树结构的字符串符号表</title>
    <link href="http://shukebeta.me/NLP-06-string-symbol-table-other-Trie/"/>
    <id>http://shukebeta.me/NLP-06-string-symbol-table-other-Trie/</id>
    <published>2018-09-30T16:00:00.000Z</published>
    <updated>2018-10-09T15:20:32.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="各种树的变种"><a href="#各种树的变种" class="headerlink" title="各种树的变种"></a>各种树的变种</h2><p>为了适应不同的应用场景, 人们使用不同的树结构来实现符号表.</p><h3 id="九宫格输入法"><a href="#九宫格输入法" class="headerlink" title="九宫格输入法"></a>九宫格输入法</h3><p>对于手机的九宫格输入法, 简单的实现方式是多次敲击: 通过反复按键输入一个字母，直到出现所需的字母。<br><a id="more"></a><br>但 <a href="http://www.t9.com/" target="_blank" rel="noopener">http://www.t9.com/</a> 的 T9 texting 支持更高效的输入方法:<br>・Find all words that correspond to given sequence of numbers.<br>・Press 0 to see all completion options.<br><img src="/images/t9.png" alt=""><br>Ex. hello<br>・多次敲击: 4 4 3 3 5 5 5 5 5 5 6 6 6<br>・T9: 4 3 5 5 6</p><p>可以使用 8-way trie 来实现.</p><h3 id="三元搜索Trie"><a href="#三元搜索Trie" class="headerlink" title="三元搜索Trie"></a>三元搜索Trie</h3><p><code>R</code>较大的R-way trie的空间效率不高，读取比较大的文件往往导致内存不足。但弊端是开辟出的数组内存利用率其实不高。现在很多系统都使用Unicode，分支可高达<code>65,536</code>. 所以需要更高效的方法。</p><p>Ternary search tries:<br>・Store characters and values in nodes (not keys).<br>・Each node has 3 children: smaller (left), equal (middle), larger (right).<br><img src="/images/tst.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br>Search in a TST: Follow links corresponding to each character in the key.<br>・If less, take left link; if greater, take right link.<br>・If equal, take the middle link and move to the next key character.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TST</span>&lt;<span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Value val;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">private</span> Node left, mid, right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Value val)</span></span></span><br><span class="line"><span class="function">    </span>&#123; root = put(root, key, val, <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, String key, Value val, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123; x = <span class="keyword">new</span> Node(); x.c = c; &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; x.c) x.left = put(x.left, key, val, d);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; x.c) x.right = put(x.right, key, val, d);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; key.length() - <span class="number">1</span>) x.mid = put(x.mid, key, val, d+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> x.val = val;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> get(key) != <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node x = get(root, key, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">get</span><span class="params">(Node x, String key, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">         <span class="keyword">if</span> (c &lt; x.c) <span class="keyword">return</span> get(x.left, key, d);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; x.c) <span class="keyword">return</span> get(x.right, key, d);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; key.length() - <span class="number">1</span>) <span class="keyword">return</span> get(x.mid, key, d+<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>TSTs比hashing更快（特别是对于搜索缺失键的情况）。</p><h3 id="基数树"><a href="#基数树" class="headerlink" title="基数树"></a>基数树</h3><p>Radix Tree, 也叫 Patricia trie (Practical Algorithm to Retrieve Information Coded in Alphanumeric), crit-bit tree, 压缩前缀树:<br>・Remove one-way branching.<br>・Each node represents a sequence of characters.<br>・Implementation: one step beyond this course.<br><img src="/images/radix_trie.png" alt="" title="put(&quot;shells&quot;, 1); put(&quot;shellfish&quot;, 2); image from: https://algs4.cs.princeton.edu/"><br>对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。</p><p>Applications.<br>・Database search.<br>・P2P network search.<br>・IP routing tables: find longest prefix match.<br>・Compressed quad-tree for N-body simulation.<br>・Efficiently storing and querying XML documents.</p><h3 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h3><p>后缀树（Suffix tree）指字符串后缀的基数树: 一个<code>String S</code>的后缀树是一个边（edge）被标记为字符串的树。因此每一个<code>S</code>的后缀都唯一对应一条从根节点到叶节点的路径。这样就形成了一个<code>S</code>的后缀的基数树。<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Suffix_tree_BANANA.svg/250px-Suffix_tree_BANANA.svg.png" alt="" title="image from: https://en.wikipedia.org/"></p><p>Applications.<br>・Linear-time: longest repeated substring, longest common substring, longest palindromic substring, substring search, tandem repeats, ….<br>・Computational biology databases (BLAST, FASTA).</p><h2 id="字符符号表总结"><a href="#字符符号表总结" class="headerlink" title="字符符号表总结"></a>字符符号表总结</h2><p>Red-black BST.<br>・Performance guarantee: log N key compares.<br>・Supports ordered symbol table API.</p><p>Hash tables.<br>・Performance guarantee: constant number of probes.<br>・Requires good hash function for key type.</p><p>Tries. R-way, TST.<br>・Performance guarantee: log N characters accessed.<br>・Supports character-based operations.<br><img src="/images/string_symbol_table_cost_sum.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"></p><blockquote><p>You can get at anything by examining 50-100 bits</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;各种树的变种&quot;&gt;&lt;a href=&quot;#各种树的变种&quot; class=&quot;headerlink&quot; title=&quot;各种树的变种&quot;&gt;&lt;/a&gt;各种树的变种&lt;/h2&gt;&lt;p&gt;为了适应不同的应用场景, 人们使用不同的树结构来实现符号表.&lt;/p&gt;
&lt;h3 id=&quot;九宫格输入法&quot;&gt;&lt;a href=&quot;#九宫格输入法&quot; class=&quot;headerlink&quot; title=&quot;九宫格输入法&quot;&gt;&lt;/a&gt;九宫格输入法&lt;/h3&gt;&lt;p&gt;对于手机的九宫格输入法, 简单的实现方式是多次敲击: 通过反复按键输入一个字母，直到出现所需的字母。&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Trie" scheme="http://shukebeta.me/tags/Trie/"/>
    
      <category term="Information Retrieval" scheme="http://shukebeta.me/tags/Information-Retrieval/"/>
    
      <category term="Symbol table" scheme="http://shukebeta.me/tags/Symbol-table/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 05 - 字符串符号表和三元搜索Trie</title>
    <link href="http://shukebeta.me/NLP-05-string-symbol-table-Trie/"/>
    <id>http://shukebeta.me/NLP-05-string-symbol-table-Trie/</id>
    <published>2018-09-29T16:00:00.000Z</published>
    <updated>2018-09-30T09:02:12.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><blockquote><p>在计算机科学中，符号表是一种用于语言翻译器（例如编译器和解释器）中的数据结构。在符号表中，程序源代码中的每个标识符都和它的声明或使用信息绑定在一起，比如其数据类型、作用域以及内存地址。<br>常用哈希表来实现.</p></blockquote><p>符号表的应用非常广泛, 可用于实现Set, Dictionary, 文件索引, 稀疏向量/矩阵等数据结构和相关的运算操作, 还有其他如过滤查询(Exception filter), 一致性查询(concordance queries)等操作.</p><p>字符符号表就是专门针对字符操作的符号表, API:<br>Prefix match - Keys with prefix <code>sh</code>: <code>she</code>, <code>shells</code>, and <code>shore</code>.<br>Wildcard match - Keys that match <code>.he</code>: <code>she</code> and <code>the</code>.<br>Longest prefix - Key that is the longest prefix of <code>shellsort</code>: <code>shells</code>.<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StringST</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    StringST(); create a symbol table with string keys</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Value val)</span></span>; put key-value pair into the symbol table</span><br><span class="line">    <span class="function">Value <span class="title">get</span><span class="params">(String key)</span></span>; value paired with key</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(String key)</span></span>; delete key and corresponding value</span><br><span class="line">    <span class="function">Iterable&lt;String&gt; <span class="title">keys</span><span class="params">()</span></span>; all keys</span><br><span class="line">    <span class="function">Iterable&lt;String&gt; <span class="title">keysWithPrefix</span><span class="params">(String s)</span></span>; keys having s as a prefix</span><br><span class="line">    <span class="function">Iterable&lt;String&gt; <span class="title">keysThatMatch</span><span class="params">(String s)</span></span>; <span class="function">keys that match <span class="title">s</span> <span class="params">(where . is a wildcard)</span></span></span><br><span class="line"><span class="function">    String <span class="title">longestPrefixOf</span><span class="params">(String s)</span></span>; longest key that is a prefix of s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="以Trie为基础的字符符号表"><a href="#以Trie为基础的字符符号表" class="headerlink" title="以Trie为基础的字符符号表"></a>以Trie为基础的字符符号表</h3><p>algs4中提供了用 R-way trie 来实现符号表(symbol table)例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieST</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">256</span>; <span class="comment">// extended ASCII</span></span><br><span class="line">    <span class="keyword">private</span> Node root = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object value;</span><br><span class="line">        <span class="keyword">private</span> Node[] next = <span class="keyword">new</span> Node[R];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Value val)</span> </span>&#123;</span><br><span class="line">        root = put(root, key, val, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, String key, Value val, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) x = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="keyword">if</span> (d == key.length()) &#123; x.value = val; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        x.next[c] = put(x.next[c], key, val, d+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String key)</span> </span>&#123; <span class="keyword">return</span> get(key) != <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Node x = get(root, key, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> (Value) x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">get</span><span class="params">(Node x, String key, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (d == key.length()) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        <span class="keyword">return</span> get(x.next[c], key, d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按顺序迭代所有键：<br>·中序遍历trie，找到的键添加到队列中<br>·维护从根到当前节点路径的字符序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">keys</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> Queue&lt;String&gt;();</span><br><span class="line">    collect(root, <span class="string">""</span>, queue);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Node x, String prefix, Queue&lt;String&gt; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x.val != <span class="keyword">null</span>) q.enqueue(prefix);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">        collect(x.next[c], prefix + c, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="前缀匹配"><a href="#前缀匹配" class="headerlink" title="前缀匹配"></a>前缀匹配</h3><p>Find all keys in a symbol table starting with a given prefix.<br>Ex. Autocomplete in a cell phone, search bar, text editor, or shell.<br>・User types characters one at a time.<br>・System reports all matching strings.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">keysWithPrefix</span><span class="params">(String prefix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> Queue&lt;String&gt;();</span><br><span class="line">    Node x = get(root, prefix, <span class="number">0</span>);</span><br><span class="line">    collect(x, prefix, queue);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最长前缀"><a href="#最长前缀" class="headerlink" title="最长前缀"></a>最长前缀</h3><p>Find longest key in symbol table that is a prefix of query string.<br>Ex. To send packet toward destination IP address, router chooses IP address in routing table that is longest prefix match.</p><p>・Search for query string.<br>・Keep track of longest key encountered.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPrefixOf</span><span class="params">(String query)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = search(root, query, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> query.substring(<span class="number">0</span>, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Node x, String query, <span class="keyword">int</span> d, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> length;</span><br><span class="line">    <span class="keyword">if</span> (x.val != <span class="keyword">null</span>) length = d;</span><br><span class="line">    <span class="keyword">if</span> (d == query.length()) <span class="keyword">return</span> length;</span><br><span class="line">    <span class="keyword">char</span> c = query.charAt(d);</span><br><span class="line">    <span class="keyword">return</span> search(x.next[c], query, d+<span class="number">1</span>, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;符号表&quot;&gt;&lt;a href=&quot;#符号表&quot; class=&quot;headerlink&quot; title=&quot;符号表&quot;&gt;&lt;/a&gt;符号表&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在计算机科学中，符号表是一种用于语言翻译器（例如编译器和解释器）中的数据结构。在符号表中，程序源代码中的每个标识符都和它的声明或使用信息绑定在一起，比如其数据类型、作用域以及内存地址。&lt;br&gt;常用哈希表来实现.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;符号表的应用非常广泛, 可用于实现Set, Dictionary, 文件索引, 稀疏向量/矩阵等数据结构和相关的运算操作, 还有其他如过滤查询(Exception filter), 一致性查询(concordance queries)等操作.&lt;/p&gt;
&lt;p&gt;字符符号表就是专门针对字符操作的符号表, API:&lt;br&gt;Prefix match - Keys with prefix &lt;code&gt;sh&lt;/code&gt;: &lt;code&gt;she&lt;/code&gt;, &lt;code&gt;shells&lt;/code&gt;, and &lt;code&gt;shore&lt;/code&gt;.&lt;br&gt;Wildcard match - Keys that match &lt;code&gt;.he&lt;/code&gt;: &lt;code&gt;she&lt;/code&gt; and &lt;code&gt;the&lt;/code&gt;.&lt;br&gt;Longest prefix - Key that is the longest prefix of &lt;code&gt;shellsort&lt;/code&gt;: &lt;code&gt;shells&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Trie" scheme="http://shukebeta.me/tags/Trie/"/>
    
      <category term="Information Retrieval" scheme="http://shukebeta.me/tags/Information-Retrieval/"/>
    
      <category term="Symbol table" scheme="http://shukebeta.me/tags/Symbol-table/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 04 - “和谐” - 多模式匹配算法 - AC自动机</title>
    <link href="http://shukebeta.me/NLP-04-string-match-algorithm-ac-automaton/"/>
    <id>http://shukebeta.me/NLP-04-string-match-algorithm-ac-automaton/</id>
    <published>2018-09-28T16:00:00.000Z</published>
    <updated>2018-09-30T09:02:18.827Z</updated>
    
    <content type="html"><![CDATA[<p>虽然KMP可以用于<a href="/NLP-01-string-searching-algorithm-01-kmp">单模式匹配问题</a>，但如果是多模式问题, KMP的性能就得不到保证。比如根据墙内法律要求, 墙内的搜索引擎需要过滤敏感词后才能合法运营。敏感词的数量不少, 如果要求包含敏感词的网页不能被搜索到, 那么搜索引擎在爬取网页信息时, 就要标记网页的文本中是否包含任意个敏感词.<br><a id="more"></a></p><p>这就是典型的多模匹配问题. 这种情况下如果使用Trie，那么需要遍历网页的每一个字符位置，对每一个位置进行Trie前缀匹配。如果词典的词语数量为N，每个词语长度为L，文章的长度为M，那么需要进行的计算次数是在<code>N*M*L</code>这个级别的. 即使把词语的长度L简化为常数级别的, 整个算法的复杂度也至少是$O(n^2)$.</p><h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>可以看到，KMP算法可以避免back up（在检查字符的过程中不需要回头），而Trie可以存储多个模式的信息。如果把二者结合在一起，也许能从性能上解决多模式（任意位置）匹配问题。这就是Aho–Corasick算法（AC自动机）。</p><blockquote><p>Aho–Corasick算法是由Alfred V. Aho和Margaret J.Corasick 发明的字符串搜索算法，用于在输入的一串字符串中匹配有限组字典中的子串。它与普通字符串匹配的不同点在于同时与所有字典串进行匹配。算法均摊情况下具有近似于线性的时间复杂度，约为字符串的长度加所有匹配的数量。</p></blockquote><p>所以算法的关键就是通过Trie把多个模式构建为一个DFA（Deterministic finite state automaton），然后让模式串末尾对应的状态作为一个DFA的终止节点。这样，对于一个要检查的长字符串（如一段网页内容），让这个字符串在DFA上跑一趟，每一个字符表示一种跳转方式，如果这段字符能够跳到任何一个终结节点, 那么就表明这段字符串匹配了至少一个模式, 如果整段字符跑完都没到达终结节点, 那么这个网页就是”和谐的”.</p><p>在单模式匹配中, 用KMP构建的DFA是比较简单的, 从左到右, 开头的状态就是开始状态, 结尾的状态就是结束状态:<br><img src="/images/build_dfa.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br>而多模式匹配中, 在Trie的结构基础上构建出来的DFA更像一个DFA的样子:<br><img src="/images/ushers_dfa.png" alt="" title="经典的ushers自动机，模式串是he/ she/ his /hers, 忽略了部分到根节点的转移边. image from: https://baike.baidu.com/pic"><br>Trie中的节点, 就类似于DFA中的状态. 如果让字符串<code>shis</code>在上面跑, 假如仅仅是靠Trie(也即是没有虚线标识的转移), 那么第一次从字符串的第一个字符<code>s</code>开始转移, 经过转移路径<code>0 - 85 - 90</code>之后就转不动了, 因为Trie记录的模式中没有<code>shi</code>, 这个时候得back up, 从第二个位置<code>h</code>开始再匹配一遍. 这个过程中就产生重复匹配, 而参考KMP的思路, 在匹配<code>shi</code>的过程中, 其实已经挖掘出了<code>hi</code>这个子串了, 而这个子串是跟模式<code>his</code>对应的, 如果有办法不回头继续匹配下去就能提高性能了.</p><p>而DFA中虚线的失败转移就是用来解决这个问题的: 当走到状态<code>90</code>时, 前面有了小部分子串<code>h</code>刚好对应状态<code>74</code>, 这个时候用虚线作为失败转移, 转移到<code>74</code>, 在状态<code>74</code>中寻找下一个转移<code>i</code>, 这样就实现了不回头继续匹配了.</p><p>因为AC自动机是在Trie的基础上添加边, 用于指示各个节点经过不同字符后跳转到哪个节点, 结果就变成了图, 所以也叫做<strong>Trie图</strong>.</p><p>要构建AC自动机:</p><ol><li>首先要把所有模式都吃进一个Trie中(最近看多进击的巨人了), 构建出一个由不同实线串联起来的状态机, 其中代表更好吻合一个模式的状态标记为终结节点(如上图绿色节点)</li><li>然后补全其他字符的转移(失败转移), 用虚线表示. 补全了所有字符的转移方式, 才能让字符串永不回头地匹配下去, 避免了back up, 保证性能.</li></ol><p>问题的关键在如何补全所有的状态转移.</p><h3 id="补全状态转移"><a href="#补全状态转移" class="headerlink" title="补全状态转移"></a>补全状态转移</h3><p><img src="/images/ushers_dfa.png" alt="" title="经典的ushers自动机，模式串是he/ she/ his /hers, 忽略了部分到根节点的转移边. image from: https://baike.baidu.com/pic"><br>这里要在Trie结构中定义一个<a href="https://hihocoder.com/problemset/problem/1036" target="_blank" rel="noopener">后缀节点</a>的概念: Trie中对应路径(已有模式)去掉部分前缀字符后剩余的后缀字符在Trie中对应的结点. 比如上图中, <code>h</code>作为<code>sh</code>的一个后缀, <code>h</code>对应的Trie节点<code>74</code>就是<code>sh</code>对应节点<code>90</code>的后缀节点. 等于说, <strong>节点和其后缀节点对应的模式有一部分后缀是相同</strong>.</p><p>如果知道了每一个节点的后缀节点, 那么在匹配的过程中, 在任一位置匹配失败, 都可以通过失败转移的方式转移到后缀节点, 继续进行后续匹配, 而不会遗漏, 因为后缀节点对应这个目前为止已匹配字符的某一部分后缀. 等于说, 后缀节点告诉我们, 在字符串中出现与模式不同的字符串时(匹配失败), 如何转移到其他状态.</p><p>所以问题的关键又变成了如何求后缀节点.</p><h3 id="求后缀节点"><a href="#求后缀节点" class="headerlink" title="求后缀节点"></a>求后缀节点</h3><p>观察Trie结构可以发现两个要点</p><ol><li>字符串任何一个位置对应的状态节点，一定比它的后缀节点更深，比如前面例子中状态节点<code>90</code>在第二层, 而其后缀节点<code>74</code>在第一层. 这点也是理所当然的, 毕竟后缀比较短. 从动态规划的角度考虑, 字符串任一位置<code>i</code>对应的状态节点的后缀节点一定是<code>k&lt;i</code>的节点中的某一个.</li><li>因为每一个状态<code>i</code>都是由其父节点<code>j</code>通过某一个字符<code>c</code>转移而来, 那么<code>i</code>的后缀节点一定是<code>j</code>的后缀节点通过同样的字符<code>c</code>转移而来. 或者说, 如果<code>j</code>的后缀节点是<code>jj</code>, 那么<code>j</code>和<code>jj</code>有着相同的后缀, 它们通过同样的转移字符<code>c</code>转移后, 二者到达的节点也一定有着相同的后缀.</li></ol><p>比如上面Ushers自动机例子中, 如果用字符串<code>sshis</code>来跑, 那么<code>ssh</code>对应的状态<code>90</code>, 是由前缀<code>ss</code>通过字符<code>h</code>转移而来. 因为<code>ssh</code>的后缀节点, 同样是某一个有共同后缀的字符(<code>h</code>或者<code>sh</code>)对应的状态(在这里是<code>h</code>对应的<code>74</code>). 可以发现<code>74</code>是由根节点<code>0</code>通过同样的字符<code>h</code>转移而来的. 反过来说, 节点<code>0</code>就是节点<code>90</code>的父节点<code>85</code>的后缀节点.</p><p>在多个模式中, 如果有某模式的前缀刚好是另一模式的子串(后缀). 比如上面Ushers自动机例子中, 模式<code>her</code>(或者<code>he</code>)的前缀<code>he</code>就是模式<code>she</code>的子串, 则会二者存在失败转移的关联. 如果没有, 那么就跳回初始状态节点.</p><p>所以补全所有状态转移的具体实现方法就是运用动态规划的原理:</p><ul><li>从Trie根节点开始, 逐层往下补全每一层的状态转移, 也就是宽度优先遍历(BFS), 这样下层的状态转移就可以利用上层的结果. 动态规划的转移方程可以描述为: <strong>每一个通过字符<code>c</code>转移而来的状态节点<code>i</code>的后缀节点 = <code>i</code>的父节点的后缀节点通过<code>c</code>转移到的状态节点</strong></li><li>初始状态包含两部分:<ul><li>一个是根节点(初始状态<code>0</code>), 它的后缀节点就是它自己,</li><li>另一个是第一层的状态节点, 如<code>85, 74</code>, 因为它们对应的是长度为<code>1</code>的字符, 没有后缀, 所以它们的后缀节点也是根节点<code>0</code>.</li></ul></li></ul><p>在实现中还要注意, <strong>后缀结点为标记结点的结点也需要被标记</strong>. 因为在状态转移过程中, 如果某个虚线转移刚好转移到终结节点, 但在字符串遍历的过程中, 并没有选择走这一条线, 就会忽略了这个终结节点, 导致匹配失败, 或者多走了更多的路. 比如在上面的例子中, 如果把模式<code>she</code>改为<code>shee</code>, <code>91</code>不再是终结节点, 而是延伸到<code>92</code>为终结节点, <code>91</code>的后缀节点是<code>76</code>. 如果用字符串<code>sshe</code>来跑这个DFA, 就会出现走到最后字符<code>e</code>时, 在节点<code>91</code>结束, 匹配失败. 所以需要把<code>91</code>也标记为终结节点.</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 把字典通过insert把所有单词插入Trie树，</span></span><br><span class="line"><span class="comment"> * 然后通过setSuffix()构建出对应的Trie图，</span></span><br><span class="line"><span class="comment"> * 然后从Trie图的根节点开始，沿着文章str的每一个字符，走出对应的边，</span></span><br><span class="line"><span class="comment"> * 直到遇到一个标记结点或者整个str都遍历完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode trie;</span><br><span class="line">    Queue&lt;TrieNode&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        trie = <span class="keyword">new</span> TrieNode(<span class="keyword">null</span>, <span class="string">' '</span>);</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode curNode = trie;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x : word.toCharArray()) &#123;</span><br><span class="line">            curNode = insert(curNode, x);</span><br><span class="line">        &#125;</span><br><span class="line">        curNode.setLast(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** insert char x, means create a new node in the x edge.</span></span><br><span class="line"><span class="comment">     * return created node  */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">insert</span><span class="params">(TrieNode node, <span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.get(x) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.set(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.get(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** BFS on the trie */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue.add(trie);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">/** poll() removes the present head.</span></span><br><span class="line"><span class="comment">             http://www.tutorialspoint.com/java/util/linkedlist_poll.htm */</span></span><br><span class="line">            TrieNode node = queue.poll();</span><br><span class="line">            setSuffix(node);</span><br><span class="line">            complementDFA(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Set node's suffix, complement lacking edge</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">setSuffix</span><span class="params">(TrieNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.root == <span class="keyword">null</span>) &#123; <span class="comment">// Trie root</span></span><br><span class="line">            node.suffix = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.root.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.suffix = node.root.suffix;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.suffix = node.root.suffix.get(node.fromIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.suffix.isLast) &#123;</span><br><span class="line">            node.isLast = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Complement DFA according to suffix */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">complementDFA</span><span class="params">(TrieNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.isLast) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node.edges.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.edges[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.edges[i] = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.edges[i] = node.suffix.edges[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.add(node.edges[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> contains = <span class="keyword">false</span>;</span><br><span class="line">        TrieNode curNode = trie;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> x = s.charAt(i);</span><br><span class="line">            curNode = curNode.get(x);</span><br><span class="line">            <span class="keyword">if</span> (curNode.isLast) &#123;</span><br><span class="line">                contains = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> contains;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATO0 = <span class="number">97</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isLast;</span><br><span class="line">        TrieNode[] edges;</span><br><span class="line">        TrieNode root;</span><br><span class="line">        <span class="keyword">char</span> fromIndex;</span><br><span class="line">        TrieNode suffix;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(TrieNode root, <span class="keyword">char</span> from)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.root = root;</span><br><span class="line">            fromIndex = from;</span><br><span class="line">            edges = <span class="keyword">new</span> TrieNode[R];</span><br><span class="line">            isLast = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> edges[ch - ATO0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** instantiate the ch child in edges */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            edges[ch - ATO0] = <span class="keyword">new</span> TrieNode(<span class="keyword">this</span>, ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLast</span><span class="params">(<span class="keyword">boolean</span> isLast)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isLast = isLast;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Trie t = <span class="keyword">new</span> Trie();</span><br><span class="line">        String[] X = &#123;<span class="string">"sb"</span>, <span class="string">"dsb"</span>, <span class="string">"cjdsb"</span>, <span class="string">"qnmlgb"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String x : X) &#123;</span><br><span class="line">            t.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t.setSuffix();</span><br><span class="line">        String s = <span class="string">"aadbaaadaaac"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t.search(s)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"YES"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然KMP可以用于&lt;a href=&quot;/NLP-01-string-searching-algorithm-01-kmp&quot;&gt;单模式匹配问题&lt;/a&gt;，但如果是多模式问题, KMP的性能就得不到保证。比如根据墙内法律要求, 墙内的搜索引擎需要过滤敏感词后才能合法运营。敏感词的数量不少, 如果要求包含敏感词的网页不能被搜索到, 那么搜索引擎在爬取网页信息时, 就要标记网页的文本中是否包含任意个敏感词.&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Trie图" scheme="http://shukebeta.me/tags/Trie%E5%9B%BE/"/>
    
      <category term="AC自动机" scheme="http://shukebeta.me/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 03 - 单模式匹配与拼写检查 - Trie</title>
    <link href="http://shukebeta.me/NLP-03-string-match-algorithm-Trie/"/>
    <id>http://shukebeta.me/NLP-03-string-match-algorithm-Trie/</id>
    <published>2018-09-27T16:00:00.000Z</published>
    <updated>2018-09-30T09:02:24.563Z</updated>
    
    <content type="html"><![CDATA[<p>Trie 也称字典树，名称来源于Re<font color="red">trie</font>val，支持$O(n)$插入和查询操作，以空间换取时间的数据结构. 用于词频统计和输入统计领域, 可以高效地存储大规模的字典数据, 也可以用于模糊匹配, 搜索最长前缀词等.</p><blockquote><p>A <strong>trie</strong>, also called <strong>digital tre</strong>e, <strong>radix tree</strong> or <strong>prefix tree</strong> is a kind of search tree - an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings. Unlike a binary search tree, no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the string associated with that node, and the root is associated with the empty string. Keys tend to be associated with leaves, though some inner nodes may correspond to keys of interest. Hence, keys are not necessarily associated with every node.</p></blockquote><a id="more"></a><p><img src="/images/Trie_example.png" alt="" title="A trie for keys &quot;A&quot;,&quot;to&quot;, &quot;tea&quot;, &quot;ted&quot;, &quot;ten&quot;, &quot;i&quot;, &quot;in&quot;, and &quot;inn&quot;. Image from https://en.wikipedia.org/wiki/Trie"></p><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>Trie没有规定每一个节点的分支数量, 用<strong>R-way Trie</strong>来表示分支数量为<code>R</code>的Trie. 对于不同的应用, 可以设置不同的<code>R</code>.</p><h3 id="字符（模糊）匹配与拼写检查"><a href="#字符（模糊）匹配与拼写检查" class="headerlink" title="字符（模糊）匹配与拼写检查"></a>字符（模糊）匹配与拼写检查</h3><p>应用例子是在一本字典中查找特定前缀的所有单词. 简化的例子是在英文字典中, 根据查询前缀, 返回相同前缀的所有单词数. 同样的结构可以用来检查拼写错误.</p><p>那么只需要在每一个节点存储该节点以下所有单词数就行了. 每一个节点包含一个长度26的数组，以方便快速定位对应的26个字母, 类似B-tree:<img src="/images/b_tree.png" alt="" title="image from https://www.coursera.org/learn/algorithms-part1"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字母本身可以用来作为索引：a - 97, z - 122</span></span><br><span class="line"><span class="comment"> * Color 是备用属性， 用于标记该节点是否为单词结尾，这里暂时用不到。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALPHABET = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATO0 = <span class="number">97</span>;</span><br><span class="line">    <span class="keyword">int</span> color;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    Trie[] node;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        node = <span class="keyword">new</span> Trie[ALPHABET];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String words)</span> </span>&#123;</span><br><span class="line">        Trie[] curNode = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x : words.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = x - ATO0;</span><br><span class="line">            insert(curNode, index);</span><br><span class="line">            curNode = curNode[index].node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Trie[] curNode, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            curNode[index] = <span class="keyword">new</span> Trie(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curNode[index].n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Trie[] curNode = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = x - ATO0;</span><br><span class="line">            <span class="keyword">if</span> (curNode[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count = curNode[index].n;</span><br><span class="line">            curNode = curNode[index].node;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果要问题扩展为返回所有相同前缀的单词，那么就要在插入字典时，在对应单词结尾的节点标记颜色。</p><h3 id="提高扩展性"><a href="#提高扩展性" class="headerlink" title="提高扩展性"></a>提高扩展性</h3><p>用固定长度为26的数组来处理英文，好处是数组内存占用小，索引时也不需要搜索，直接用字符码作为索引。也可以根据ASCII码进一步扩大数组长度以支持更多字符。</p><p>为了提高可扩展性，可以考虑用其他更灵活的数据结构来替代数组，比如HashMap，同时把HashMap放进一个TrieNode类。这样以后要修改核心的存储结构，只需要改动TrieNode即可，其余的接口不用改。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode node;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode curNode = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x : word.toCharArray()) &#123;</span><br><span class="line">            curNode = curNode.set(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode curNode = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curNode.get(x) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode.get(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curNode.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, TrieNode&gt; map;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(Character val)</span> </span>&#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.value = val;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TrieNode <span class="title">set</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            TrieNode t = map.get(ch);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                t = <span class="keyword">new</span> TrieNode(ch);</span><br><span class="line">                <span class="keyword">this</span>.map.put(ch, t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>HashMap的寻址虽然会靠字符码作为地址的数组慢一点点，但也是非常快的:$O(\log N)$。但HashMap本身是比较耗内存的数据结构, 所以如果知道要处理的数据是在特定范围内的, 比如节点就是在256个字符中, 那么还是不要不用HashMap.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Trie 也称字典树，名称来源于Re&lt;font color=&quot;red&quot;&gt;trie&lt;/font&gt;val，支持$O(n)$插入和查询操作，以空间换取时间的数据结构. 用于词频统计和输入统计领域, 可以高效地存储大规模的字典数据, 也可以用于模糊匹配, 搜索最长前缀词等.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;trie&lt;/strong&gt;, also called &lt;strong&gt;digital tre&lt;/strong&gt;e, &lt;strong&gt;radix tree&lt;/strong&gt; or &lt;strong&gt;prefix tree&lt;/strong&gt; is a kind of search tree - an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings. Unlike a binary search tree, no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the string associated with that node, and the root is associated with the empty string. Keys tend to be associated with leaves, though some inner nodes may correspond to keys of interest. Hence, keys are not necessarily associated with every node.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Trie" scheme="http://shukebeta.me/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 02 - 字符搜索匹配算法 02 - Boyer-Moore(BM) 和 Rabin-Karp(RK)</title>
    <link href="http://shukebeta.me/NLP-02-string-searching-algorithm-02-bm-rk/"/>
    <id>http://shukebeta.me/NLP-02-string-searching-algorithm-02-bm-rk/</id>
    <published>2018-09-26T16:00:00.000Z</published>
    <updated>2018-10-07T07:44:44.008Z</updated>
    
    <content type="html"><![CDATA[<p>字符串搜索/匹配算法中, Boyer-Moore(BM)比前面的<a href="/NLP-01-string-searching-algorithm-kmp">Knuth–Morris–Pratt(KMP)</a>更高效. BM算法从右到左扫描模式中的字符。当匹配的字符在模式中不存在时，可以跳过最多达M个字符.<img src="/images/bm.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br><a id="more"></a></p><h2 id="BM"><a href="#BM" class="headerlink" title="BM"></a>BM</h2><p>在决定要跳过多少字符时, 分几种情况考虑:<br>1, mismatch character <code>T</code> not in pattern: increment <code>i</code> one character beyond <code>T</code><br>2.1, Mismatch character in pattern: mismatch character <code>N</code> in pattern, align text <code>N</code> with rightmost pattern <code>N</code><br>2.2, Mismatch character in pattern (but heuristic no help): mismatch character <code>E</code> in pattern, align text <code>E</code> with rightmost pattern <code>E</code>? 还是 increment i by 1? 无法确定, 需要辅助信息.</p><p>需要预先计算模式各个字符在模式最右边出现的索引(若无则<code>-1</code>):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">right = <span class="keyword">new</span> <span class="keyword">int</span>[R];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">right[c] = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)</span><br><span class="line">right[pat.charAt(j)] = j;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = txt.length();</span><br><span class="line"><span class="keyword">int</span> M = pat.length();</span><br><span class="line"><span class="keyword">int</span> skip;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N-M; i += skip)</span><br><span class="line">&#123;</span><br><span class="line">skip = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = M-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pat.charAt(j) != txt.charAt(i+j))</span><br><span class="line">&#123;</span><br><span class="line">skip = Math.max(<span class="number">1</span>, j - right[txt.charAt(i+j)]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (skip == <span class="number">0</span>) <span class="keyword">return</span> i; <span class="comment">// match</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Substring search with the Boyer-Moore mismatched character heuristic takes about <code>~ N / M</code> character compares to search for a pattern of length <code>M</code> in a text of length <code>N</code>.<br>Worst-case. Can be as bad as <code>~ M N</code>.</p></blockquote><p>Boyer-Moore变种: 通过添加类似KMP的规则来防止重复模式，可以将最坏情况改善为<code>~3 N</code>字符比较。</p><h2 id="RK"><a href="#RK" class="headerlink" title="RK"></a>RK</h2><p>Rabin-Karp 基于 modular hashing：<br>・Compute a hash of pattern characters <code>0</code> to <code>M - 1</code>.<br>・For each <code>i</code>, compute a hash of text characters <code>i</code> to <code>M + i - 1</code>.<br>・If pattern hash = text substring hash, check for a match.</p><p>所以算法的关键在于如何高效地计算哈希值：Horner’s method - 用于评估M阶多项式的线性时间方法<br><img src="/images/horner_method.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute hash for M-digit key</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(String key, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)</span><br><span class="line">h = (R * h + key.charAt(j)) % Q;</span><br><span class="line"><span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>给定$x_i$，如何计算$x_{i+1}$：<br>$$x_i = t_i R^{M-1} + T_{i+1}R^{M-2} + … + t_{i+M-1}R^0$$<br>$$x_{i+1} = t_{i+1}R^{M-1} + T_{i+2}R^{M-2} + … + t_{i+M}R^0$$<br>$$x_{i+1} = (x_i - t_i R^{M-1}) R + t_{i+M}$$<br>M-digit, base-R integer, modulo Q，$R^{M-1}$是可以预先计算的.<br><img src="/images/rk.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabinKarp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> patHash; <span class="comment">// pattern hash value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> M; <span class="comment">// pattern length</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> Q; <span class="comment">// modulus</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> R; <span class="comment">// radix</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> RM; <span class="comment">// R^(M-1) % Q</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RabinKarp</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">M = pat.length();</span><br><span class="line">R = <span class="number">256</span>;</span><br><span class="line">Q = longRandomPrime(); <span class="comment">// a large prime (but avoid overflow)</span></span><br><span class="line"></span><br><span class="line">RM = <span class="number">1</span>; <span class="comment">// precompute R^&#123;M – 1&#125; (mod Q)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M-<span class="number">1</span>; i++)</span><br><span class="line">RM = (R * RM) % Q;</span><br><span class="line">patHash = hash(pat, M);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(String key, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* as before */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** check for hash collision using rolling hash function */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = txt.length();</span><br><span class="line"><span class="keyword">int</span> txtHash = hash(txt, M);</span><br><span class="line"><span class="keyword">if</span> (patHash == txtHash) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">txtHash = (txtHash + Q - RM*txt.charAt(i-M) % Q) % Q;</span><br><span class="line">txtHash = (txtHash*R + txt.charAt(i)) % Q;</span><br><span class="line"><span class="keyword">if</span> (patHash == txtHash) <span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有两种方式判断是否匹配：</p><ul><li>Monte Carlo version. Return match if hash match.<ul><li>Always runs in linear time. Extremely likely to return correct answer (but not always!).</li></ul></li><li>Las Vegas version. Check for substring match if hash match; continue search if false collision.<ul><li>Always returns correct answer. Extremely likely to run in linear time (but worst case is M N).</li></ul></li></ul><blockquote><p>In theory, if <code>Q</code> is a sufficiently large random prime (about $M N^2$), then the probability of a false collision is about <code>1 / N</code>.<br>In practice, choose <code>Q</code> to be a large prime (but not so large to cause overflow). Under reasonable assumptions, probability of a collision is about <code>1 / Q</code>.</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/substring_search_cost_summary.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br>算法可以拓展到二维模式匹配, 多模式匹配等问题.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字符串搜索/匹配算法中, Boyer-Moore(BM)比前面的&lt;a href=&quot;/NLP-01-string-searching-algorithm-kmp&quot;&gt;Knuth–Morris–Pratt(KMP)&lt;/a&gt;更高效. BM算法从右到左扫描模式中的字符。当匹配的字符在模式中不存在时，可以跳过最多达M个字符.&lt;img src=&quot;/images/bm.png&quot; alt=&quot;&quot; title=&quot;image from: https://www.coursera.org/learn/algorithms-part2/&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Boyer-Moore" scheme="http://shukebeta.me/tags/Boyer-Moore/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 01 - 字符搜索匹配算法 01 - KMP</title>
    <link href="http://shukebeta.me/NLP-01-string-searching-algorithm-01-kmp/"/>
    <id>http://shukebeta.me/NLP-01-string-searching-algorithm-01-kmp/</id>
    <published>2018-09-25T16:00:00.000Z</published>
    <updated>2018-10-07T07:57:01.029Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>In computer science, string-searching algorithms, sometimes called string-matching algorithms, are an important class of string algorithms that try to find a place where one or several strings (also called patterns) are found within a larger string or text.</p></blockquote><p>字符串搜索/匹配算法在大规模文本应用中有非常重要的作用，比如文章敏感词搜索，多关键词过滤搜索等。如果使用暴力搜索，则时间复杂度很高（若 m 为关键字的长度， n 为要待搜索的字符串长度， k为关键字数量，则复杂度为$O(n \times m \times k)$。而好的算法可以让这些问题的时间复杂度大大降低。</p><p>常用的算法有Knuth–Morris–Pratt(KMP), Boyer-Moore(BM), Rabin-Karp(RK), Trie, Trie图, AC自动机等.<br><a id="more"></a></p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>Knuth–Morris–Pratt 算法在每次搜索匹配前，预处理模式字符串，记录模式字符串自身重复的情况，即包含左临界的子字符串和包含右临界的子字符串的重复长度，以此来作为后续匹配的参考。当实际去匹配带搜索字符串时，想象是我们拿着模式字符串从左到右匹配过去。任何时候，如果发现匹配不上的时，不是简单地右移一位继续重新匹配，而是在已匹配部分的范围内，直接跳过k个字符，右移到与模式开头部分重复的位置，并接着重复部分后面继续开始匹配（重复的部分证明已经匹配过）。</p><p>一个很好解释<a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">参考</a><br><img src="/images/kmp1.png" alt=""><img src="/images/kmp2.png" alt="" title="https://blog.csdn.net/v_july_v/article/details/7041827"><br>KMP算法的理论基础基于确定性有限状态自动机 DFA（Deterministic finite state automaton）。DFA可以理解为抽象的字符搜索机：</p><ul><li>有限数量的<strong>状态</strong>（包括开始和停止）。</li><li>字母表每个字符对应一个状态转换。</li><li>只接受能通往停止状态的转换序列。</li></ul><p><img src="/images/kmp_dfa.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br>如<code>ABCAABABABAB</code>对应<code>0→1→2→0→1→1→2→3→4→5→4→5→4</code></p><p>可以看出KMP算法的几个要点:</p><ul><li>状态State: 表示模式中已匹配的字符数。<code>pattern[]</code>最长前缀(同时是<code>txt[0..i]</code>的后缀)的长度.</li><li>需要预先从<code>pattern</code>中计算<code>dfa[][]</code></li><li>字符串遍历指针只会前进不会后退</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, N = txt.length();</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; N &amp;&amp; j &lt; M; i++)</span><br><span class="line">j = dfa[txt.charAt(i)][j];</span><br><span class="line"><span class="keyword">if</span> (j == M) <span class="keyword">return</span> i - M;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Running time: at most N character accesses to Simulate DFA on text.</p><h3 id="使用DFA"><a href="#使用DFA" class="headerlink" title="使用DFA"></a>使用DFA</h3><p>用状态<code>state j</code>表示模式<code>pat</code>的前<code>j</code>个字符已经匹配. 用<code>dfa[c][j]</code>表示在状态<code>state j</code>时, 遇到下一个字符<code>c</code>, 应该转移到什么状态.</p><p>在状态<code>state j</code>：<br>· 如果匹配成功，<code>char c == pat.charAt(j)</code>，则转移到<code>state j+1</code>: <code>dfa[pat.charAt(j)][j] = j+1</code>.<br>· 如果失败，则从<code>pat[1..j-1]</code>对应的DFA状态<code>X</code>，向着<code>c</code>方向转移：<code>copy dfa[][X] to dfa[][j]</code>.<br>・Update <code>X</code>.<br><img src="/images/build_dfa.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.pat = pat;</span><br><span class="line">M = pat.length();</span><br><span class="line">dfa = <span class="keyword">new</span> <span class="keyword">int</span>[R][M];</span><br><span class="line">dfa[pat.charAt(<span class="number">0</span>)][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> X = <span class="number">0</span>, j = <span class="number">1</span>; j &lt; M; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">dfa[c][j] = dfa[c][X]; <span class="comment">// copy mismatch cases</span></span><br><span class="line">dfa[pat.charAt(j)][j] = j+<span class="number">1</span>;</span><br><span class="line">X = dfa[pat.charAt(j)][X];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Running time. M character accesses (but space/time proportional to R M).</p><h3 id="NEXT数组"><a href="#NEXT数组" class="headerlink" title="NEXT数组"></a>NEXT数组</h3><p>假设现在文本串<code>S</code>匹配到<code>i</code>位置，模式串<code>P</code>匹配到<code>j</code>位置:<br><img src="https://img-blog.csdn.net/20140812223633281" alt="" title="image from: https://blog.csdn.net/v_july_v/article/details/7041827"><br>首先第一位NEXT值<code>next[0]</code>一定是<code>-1</code>, 后面的第<code>j+1</code>个值<code>next[j]</code>代表<code>[0, j-1]</code>部分有多少重复前后缀. 可以根据前一位的<code>next[j-1]</code>值<code>k</code>推断:</p><ul><li>如果<code>P[j] == P[k]</code>, 则意味着重复前后缀长度<code>+1</code>, 那么<code>next[j] = next[j-1] + 1 = k + 1</code>.</li><li>如果<code>P[j] != P[k]</code>, 则意味着前面重复前后缀无法继续下去. 此时不能简单地判定<code>next[j] = 0</code>, 需要继续往前看是否有更短小的重复前后缀. 又因为重复前后缀意味着前后端相同, 因此可以直接匹配<code>P[j] ?= P[k&#39;], k&#39; = next[k]</code>, 以此循环下去直到<code>k&#39; = -1</code>为止.</li></ul><p>以上算法还可以进一步优化: 当<code>P[j] != S[i]</code>时，下次必然匹配<code>P[next [j]] ?= S[i]</code>，此时如果<code>P[j] == P[next[j]]</code>，则意味着匹配必然失败. 这样就出现了冗余匹配。所以如果出现<code>P[j] == P[next[j]]</code>，则令<code>next[j] = next[next[j]] = next[next[j-1] + 1] = next[k + 1]</code>.<img src="http://hi.csdn.net/attachment/201106/14/8394323_13080758591kyV.jpg" alt="" title="image from: https://blog.csdn.net/v_july_v/article/details/7041827"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span>[] p, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; p.length - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line"><span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[++j] != p[++k])</span><br><span class="line">                next[j] = k;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">next[j] = next[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>对于优化后的next数组可以发现一点：如果模式串的后缀跟前缀相同，那么它们的next值也是相同的，例如模式串abcabc，它的前缀后缀都是abc，其优化后的next数组为：-1 0 0 -1 0 0，前缀后缀abc的next值都为-1 0 0.</p></blockquote><h3 id="基于NEXT数组的KMP算法"><a href="#基于NEXT数组的KMP算法" class="headerlink" title="基于NEXT数组的KMP算法"></a>基于NEXT数组的KMP算法</h3><p>基于前面求出的NEXT数组, 可以根据以下步骤实现KMP算法:</p><ul><li>假设现在文本串<code>S</code>匹配到<code>i</code>位置，模式串<code>P</code>匹配到<code>j</code>位置<ul><li>if <code>j = -1</code>, or <code>S[i] == P[j]</code>(当前字符匹配成功), then <code>i++, j++</code></li><li>else, <code>j = next[j]</code>。当失配时，模式串<code>P</code>相对于文本串<code>S</code>向右移动<code>j - next[j]</code>位(大于等于1)。</li></ul></li></ul><p><img src="https://img-blog.csdn.net/20150812214857858" alt="" title="image from: https://img-blog.csdn.net/20150812214857858"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 返回模式串第一次在文本串中出现的位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">char</span>[] p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; s.length &amp;&amp; j &lt; p.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == -<span class="number">1</span> || s[i] == p[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="KMP应用"><a href="#KMP应用" class="headerlink" title="KMP应用"></a>KMP应用</h3><p>判断一段文字（原串）里面是否存在敏感词（模式串）。原题地址 <a href="http://hihocoder.com/problemset/problem/1015?sid=1368409：" target="_blank" rel="noopener">http://hihocoder.com/problemset/problem/1015?sid=1368409：</a></p><p>输入：第一行一个整数N，表示测试数据组数。接下来的N*2行，每两行表示一个测试数据。在每一个测试数据中，第一行为模式串，由不超过10^4个大写字母组成，第二行为原串，由不超过10^6个大写字母组成。其中N&lt;=20.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">HA</span><br><span class="line">HAHAHA</span><br><span class="line">WQN</span><br><span class="line">WQN</span><br><span class="line">ADA</span><br><span class="line">ADADADA</span><br><span class="line">BABABB</span><br><span class="line">BABABABABABABABABB</span><br><span class="line">DAD</span><br><span class="line">ADDAADAADDAAADAAD</span><br></pre></td></tr></table></figure></p><p>输出: 对于每一个测试数据，按照它们在输入中出现的顺序输出一行Ans，表示模式串在原串中出现的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>这里是需要找出出现的次数，因此不仅仅是找到第一个，还要继续遍历原串统计剩余出现的次数，同时要考虑重叠的部分。关键的功能代码可以复制上面的，但是需要作出一些改动。</p><p>首先，因为部分重叠情况也是要统计的，比如<code>ADADADA</code>这个原串, 包含3个<code>ADA</code>. 所以要考虑即使匹配成功后, 模式串的索引<code>j</code>能够跳回前面的重复前缀位置. 考虑使用未优化过的NEXT计算方法.</p><p>除此之外, 通过额外计算多一位NEXT值, 记录完整的模式串的重复前后缀长度, 以协助索引.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span>[] p, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; p.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k]) &#123;</span><br><span class="line">            next[++j] = ++k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于<code>ADA</code>, 原来未优化过的NEXT是<code>-1,0,0</code>, 现在是<code>-1,0,0,1</code>, 最后一位<code>1</code>表示<code>ADA</code>这个模式串的重复前后缀是长度为<code>1</code>的<code>A</code>.</p><p>借助额外长度的NEXT, 只需要小小地改动KMP计算逻辑, 最重要的是当<code>j</code>到达<code>NEXT</code>的额外位置时, 通过<code>j = next[j];</code>把<code>j</code>后拨到重复前缀的位置, 以方便进行后面的搜索.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 返回模式串在原串中出现的次数 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">char</span>[] p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[p.length + <span class="number">1</span>]; <span class="comment">// 额外多计算一位</span></span><br><span class="line">    GetNext(p, next);</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || s[i] == p[j]) &#123;</span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line">            c++;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;In computer science, string-searching algorithms, sometimes called string-matching algorithms, are an important class of string algorithms that try to find a place where one or several strings (also called patterns) are found within a larger string or text.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;字符串搜索/匹配算法在大规模文本应用中有非常重要的作用，比如文章敏感词搜索，多关键词过滤搜索等。如果使用暴力搜索，则时间复杂度很高（若 m 为关键字的长度， n 为要待搜索的字符串长度， k为关键字数量，则复杂度为$O(n \times m \times k)$。而好的算法可以让这些问题的时间复杂度大大降低。&lt;/p&gt;
&lt;p&gt;常用的算法有Knuth–Morris–Pratt(KMP), Boyer-Moore(BM), Rabin-Karp(RK), Trie, Trie图, AC自动机等.&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Trie" scheme="http://shukebeta.me/tags/Trie/"/>
    
      <category term="KMP" scheme="http://shukebeta.me/tags/KMP/"/>
    
      <category term="Aho–Corasick algorithm" scheme="http://shukebeta.me/tags/Aho%E2%80%93Corasick-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 快速幂</title>
    <link href="http://shukebeta.me/bits-operations-07/"/>
    <id>http://shukebeta.me/bits-operations-07/</id>
    <published>2018-09-25T16:00:00.000Z</published>
    <updated>2018-10-22T09:18:06.806Z</updated>
    
    <content type="html"><![CDATA[<p>如何实现快速的幂运算？<br><a id="more"></a></p><p>要求$c = a^b$, 按照朴素算法把<code>a</code>连乘<code>b</code>次的时间复杂度是$O(n)$. 而快速幂能做到$O(\log n)$。把<code>b</code>转换为二进制, 二进制数第<code>i</code>位的权为$2^{i-1}$，就可以把二进制拆分为若干个以<code>2</code>为底的真数, 然后利用幂数的性质，例如用朴素算法求$a^{11}$要求乘<code>11</code>次. 考虑到<code>11</code>的二进制为<code>1011</code>, 如果把$a^{11}$拆分为:<br>$$a^{11} = a^{a_0 2^0 + a_1 2^1 + a_2 0 + a_3 2^3} = a^1 a^2 a^8$$<br>可以看到每一个因子都是上一个因子的平方，利用$a^2 a^2$求出$a^4$, 同样利用$a^4$的平方求出$a^8$, 每次计算只需要用到上一次计算出来的结果, 所以总的运算次数是<code>4</code>次. 任何一个数<code>b</code>最多能写成长度为$O(\log b)$的二进制, 因此这个算法就是$O(\log n)$.</p><p>在程序设计中是根据<code>b</code>的二进制中是否为<code>1</code>来控制是否乘以上一次翻倍的积</p><ul><li>不断右移<code>b</code>, 直到<code>b</code>不再有<code>1</code>：<ul><li>根据当前位的权重（当前<code>b</code>最后一位）是否为<code>1</code>来决定<code>c</code>是否乘以最新的<code>a</code></li><li>把<code>a</code>平方，用于下一位计算</li></ul></li></ul><p>在Java中要考虑极端值INT_MIN<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> temp = myPow(x, n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> ==<span class="number">0</span>) <span class="keyword">return</span> temp * temp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>) <span class="keyword">return</span> x*temp*temp;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (temp*temp) / x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        n = -(n+<span class="number">1</span>); <span class="comment">// 处理极端值</span></span><br><span class="line">        x = <span class="number">1</span>/x;</span><br><span class="line">        ans *= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) ans *= x;</span><br><span class="line">        x *= x;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂取余"><a href="#快速幂取余" class="headerlink" title="快速幂取余"></a>快速幂取余</h3><p>求<code>a^b mod c</code>.<br>如果<code>b</code>是偶数, <code>a^b mod c</code> = $(a^2)^{b/2} \% c$<br>如果<code>b</code>是奇数, <code>a^b mod c</code> = $((a^2)^{b/2} \times a) \% c$</p><p>又因为取余有性质:<code>a^b mod c = (a mod c)^b</code></p><p>引理：<code>(a * b) mod c = [( a mod c ) * (b mod c) ] mod c</code></p><p>证明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设 a mod c =d，b mod c= e;</span><br><span class="line">       则：a=t*c + d ;  b=k*c + e ;</span><br><span class="line">       (a*b)mod c = (t*c+d)(t*c+e)</span><br><span class="line">                 = (tk c^2 + ( te+dk ) *c + d*e) mod c</span><br><span class="line">                 = de mod c</span><br></pre></td></tr></table></figure></p><p>即积的取余等于取余的积的取余.</p><p>利用快速幂的思想, 令<code>k = (a * a) mod c</code>，所要求的最终结果即为 <code>k^(b/2) mod c</code>, 这个过程可以迭代下去, 如果b是奇数, 或多出一项<code>a mod c</code>. 当<code>b = 0</code>时, 所有因子已经相乘, 迭代结束, 复杂度为<code>O(log b)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span>  <span class="title">PowerMod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  ans = <span class="number">1</span>;</span><br><span class="line">    a = a % c;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b % <span class="number">2</span> = = <span class="number">1</span>)</span><br><span class="line">            ans = (ans * a) % c;</span><br><span class="line">        b = b/<span class="number">2</span>;       <span class="comment">//   b&gt;&gt;=1;</span></span><br><span class="line">        a = (a * a) % c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何实现快速的幂运算？&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 汉明距离</title>
    <link href="http://shukebeta.me/bits-operations-06/"/>
    <id>http://shukebeta.me/bits-operations-06/</id>
    <published>2018-09-24T16:00:00.000Z</published>
    <updated>2018-10-10T03:26:37.010Z</updated>
    
    <content type="html"><![CDATA[<p>求两个整数的汉明距离 hamming distance<br><a id="more"></a><br><a href="https://leetcode.com/problems/hamming-distance/description/" target="_blank" rel="noopener">Leetcode 461</a><br>两个整数之间的汉明距离是该两个数之间不同的位数。 给定两个整数x和y，计算汉明距离。问题也可以理解为对于两个整数<code>m</code>和<code>n</code>, 需要改变<code>m</code>的二进制多少位才能得到<code>n</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Use Brian Kernighan's way to count bits */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = x ^ y;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        y++;</span><br><span class="line">        x &amp;= x - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(x ^ y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样用到Brian Kernighan算法：</p><blockquote><p>Lets say that the bit at index n is 1 and that the bits in indexes 0 up to <code>n-1</code> are all 0 (we’ll use little endianess - so index 0 is 1, index 1 is 2, index 2 is 4, index 3 is 8 and so on).</p></blockquote><blockquote><p><code>v-1</code> subtracts from index 0 - but it’s 0, so it converts it to 1 and subtracts from index 1 - but it’s also 0, so it converts it to 1 and subtracts from index 2 - and so on until we reach index n. Since index n is 1 it can subtract from it and turn it to 0 - and there it stops: <code>1101000 - 1 = 1100111</code></p></blockquote><blockquote><p>So, <code>v-1</code> is like <code>v</code> except there are <code>n</code> 0 that became 1 and one 1 that became 0. In <code>v &amp; v - 1</code> all the other bits remain as is, the <code>n</code> zeros that where turned to ones remain 0 (because <code>0 &amp; 1 == 0</code>), and the one 1 that was turned to 0 turns to 0(because <code>1 &amp; 0 == 0</code>). So overall - only a single bit was changed in the iteration, and this change was from 1 to 0: <code>1101000 &amp; 1100111 = 1100000</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;求两个整数的汉明距离 hamming distance&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 找出只出现一次的数 - 及类似问题</title>
    <link href="http://shukebeta.me/bits-operations-04/"/>
    <id>http://shukebeta.me/bits-operations-04/</id>
    <published>2018-09-23T16:00:00.000Z</published>
    <updated>2018-10-16T10:30:09.411Z</updated>
    
    <content type="html"><![CDATA[<p>“找出只出现一次的数”， “找出唯二的只出现M次的数”， “找出缺失的数”等等，都可以利用异或操作的特性， 即一个整数和自己进行异或运算会归0的性质。</p><h2 id="找出唯一一个仅出现M次的数"><a href="#找出唯一一个仅出现M次的数" class="headerlink" title="找出唯一一个仅出现M次的数"></a>找出唯一一个仅出现M次的数</h2><p>在一个非空整数数组，找出那个只出现了一次的元素，已知其余每个元素均出现两次。<br><a id="more"></a><br>要达到O(n)复杂度需要利用<strong>位异或</strong>. 位异或运算能够把二进制相同的数化为0. 把数组所有的数都异或, 出现两次的数就会互相抵消为0, 剩余的就是那个只出现了一次的数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums)</span><br><span class="line">        output ^= i;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但如果把问题扩展为“其余每个元素均出现三次”， 这样就无法直接利用异或抵消的性质了。剑指Offer的解法是用一个长度<code>32</code>的数组<code>bitSum</code>, 把原数组所有整数的二进制每一位分别累加到<code>bitSum</code>里面, 这样就可以通过判断<code>bitSum</code>哪些位不可以被3整除来找出那个数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bitSum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> bitMask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> b = nums[i] &amp; bitMask;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="number">0</span>)</span><br><span class="line">                bitSum[j] += <span class="number">1</span>;</span><br><span class="line">            bitMask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        res += bitSum[i] % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为<code>bitSum</code>的长度是常数, 所以该方法复杂度还是O(N). 该方法可以进一步扩展问题为求唯一一个元素出现M次，其他所有元素出现K次的问题。</p><p>除此之外, 还有其他更精简的通用的方法来解决此类问题.</p><h3 id="构造状态转移表"><a href="#构造状态转移表" class="headerlink" title="构造状态转移表"></a>构造状态转移表</h3><p>方法来自<a href="https://leetcode.com/problems/single-number-ii/discuss/43296/An-General-Way-to-Handle-All-this-sort-of-questions." target="_blank" rel="noopener">An General Way to Handle All this sort of questions</a>, 这个方法核心思想是建立一个记录状态的变量, 该变量代表某个数字出现一次后的状态. 目标就是使得一个数字重复出现K次后状态刚好归0.</p><p>对于<code>K=2</code>, 就要使两次叠加后归0, 需要两种状态, 从信息论的角度看待, 只需要一个位(<code>0</code>,<code>1</code>)来表达，状态<code>0</code>对应着两种等价的情况: 一个数字完全没出现过, 或者出现了2次后一起抵消重置. 状态<code>1</code>对应着仅仅出现一次的情况. 在这里数字和状态概念等价，构建一个状态转移表（真值表）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">状态 输入 输出</span><br><span class="line">a    c    a</span><br><span class="line">0    0    0</span><br><span class="line">1    0    1</span><br><span class="line">0    1    1</span><br><span class="line">1    1    0</span><br></pre></td></tr></table></figure></p><p>可以看到，不管是状态1还是0，如果输入相同数字，就会变为0；如果输入不同的数字，就会变为1. 根据表写出逻辑表达式为异或运算.</p><p>根据真值表写出逻辑式的基本套路是: 只看输出结果为1的转移, 凡取值为1的变量写成原变量，取值为0的变量写成反变量, 得出对应的表达式, 再把所有转移方程的表达式加起来. 如输出为1的是<code>0 &amp; 1 = 1, 1 &amp; 0 = 1</code>, 表达式就是<code>(~a &amp; c) | (a &amp; ~c)</code>, 这个本质上就是<code>a ^ c</code></p><p>对于<code>K = 3, M = 1(or 2)</code>, 需要三种状态, 那么至少需要两个位(<code>00</code>, <code>01</code>, <code>10</code>)来表达. 让状态<code>00</code>对应”假”输出, 对应两种等价的情况: 一个数字完全没出现过, 或者出现了3次后一起抵消重置. 再定义<code>01</code>为出现了一次的状态, <code>10</code>为出现了2次, 这两种状态都对应着”真”输出, 也就是我们想要的答案, 得出状态转移为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">状态      输入      输出</span><br><span class="line">(a, b)    (c)      (a,b)</span><br><span class="line">0, 0   0   0, 0</span><br><span class="line">0, 1   0   0, 1</span><br><span class="line">1, 0   0   1, 0</span><br><span class="line">0, 0   1   0, 1</span><br><span class="line">0, 1   1   1, 0</span><br><span class="line">1, 0   1   0, 0</span><br></pre></td></tr></table></figure></p><p>得出<code>a = (a &amp; ~b &amp; ~c) | (~a &amp; b &amp; c)</code>, <code>b = (~a &amp; b &amp; ~c) | (~a &amp; ~b &amp; c)</code>.<br>只要把数组所有数按照这个逻辑分别叠加到<code>a</code>和<code>b</code>上面, 最后答案就是<code>a | b</code>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = (a &amp; ~b &amp; ~c) | (~a &amp; b &amp; c);</span><br><span class="line">        b = (~a &amp; b &amp; ~c) | (~a &amp; ~b &amp; c);</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (a | b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上只是一种通用的套路，对于每一种特定的<code>K, M</code>组合, 可能会有不同的特殊最优方案.</p><h3 id="通过不同集合收录不同数字"><a href="#通过不同集合收录不同数字" class="headerlink" title="通过不同集合收录不同数字"></a>通过不同集合收录不同数字</h3><p>同上面的问题，LeetCode某大神给出一个<a href="https://leetcode.com/problems/single-number-ii/discuss/43294/Challenge-me-thx" target="_blank" rel="noopener">目前为止最优的方案</a>, 并放言”Challenge me”, 草鸡们看了瑟瑟发抖：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        ones = (ones ^ c) &amp; ~twos;</span><br><span class="line">        twos = (twos ^ c) &amp; ~ones;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原理是利用两个数<code>ones</code>和<code>twos</code>作为一种概念上的集合<code>set</code>，通过异或操作来收录分别出现了1次和2次的数, <code>set ^ val</code>有两种结果:</p><ul><li>如果<code>set</code>里面没有<code>val</code>, 把<code>val</code>异或进去, 如<code>a ^ 0 = a</code></li><li>如果<code>set</code>之前已经收录了<code>val</code>, 那么亦或操作就会在<code>set</code>中移除这个<code>val</code>, 如 <code>a ^ a = 0</code></li></ul><p>按照上面的定义来理解:</p><ul><li><code>(ones ^ c) &amp; ~twos</code>: 当且仅当<code>c</code>没有收录在<code>twos</code>中, 把<code>ones</code>收录<code>c</code>，否则移除<code>c</code>。这样的话，任何第一次出现的数都会被收入<code>ones</code>中, 而任何第二次出现的数会从<code>ones</code>中移出.<br>So, effectively anything that appears for the first time will be in the set. Anything that appears a second time will be removed. We’ll see what happens when an element appears a third time (thats handled by the set “twos”).</li><li>紧接着, <code>(twos ^ c) &amp; ~ones</code>用同样的逻辑更新<code>twos</code>. 这样意味着<ul><li><code>twos</code>不会收录第一次出现的数;</li><li>但对于第二次出现的数, 因为上一步已经把这个数从<code>ones</code>中移除, 那么这个数就会被收录进<code>twos</code>中,</li><li>对于第三次出现的数, 因为<code>twos</code>中已经收录了, 所以<code>ones</code>不会再收录, 而异或操作会把<code>twos</code>中的这个数移除.</li></ul></li></ul><p>最后的结果就是, <code>ones</code>仅保留出现了1次的数, <code>twos</code>仅保留出现了2次的数, 而那些出现了3次的数都被移除了.</p><p>这种方法可以扩展为通用方法, 适用于任何仅存在一个只出现了<code>M</code>次的数, 其他数都出现了<code>K</code>次的数组, 如<code>K = 4, M = 3</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>, threes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        ones = (ones ^ c) &amp; ~twos &amp; ~threes;</span><br><span class="line">        twos = (twos ^ c) &amp; ~ones &amp; ~threes;</span><br><span class="line">        threes = (threes ^ c) &amp; ~twos &amp; ~ones;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> threes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    System.out.println(singleNumber(nums)); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="找出唯二的仅出现M次的数"><a href="#找出唯二的仅出现M次的数" class="headerlink" title="找出唯二的仅出现M次的数"></a>找出唯二的仅出现M次的数</h2><p><a href="https://leetcode.com/problems/single-number-iii/" target="_blank" rel="noopener">LeetCode原题</a>:给定一个整数数组<code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。跟前面的问题类似, 我们需要再次使用XOR来解决这个问题。通过分割数组, 把出现一次的两个数, 划分到不同的数组中, 问题就转化为寻找唯一的出现一次的数问题. 所以关键就是如何拆分数组.</p><p>具体需要两次遍历：</p><ul><li>第一次遍历，对数组所有元素进行异或，获得要找的两个数字的XOR。由于两个数字是不同的，因此在XOR结果中必定有一个<code>set bit</code>, 即位值为’1’的位。</li><li>找出任意<code>set bit</code>（如最右边的）。</li><li>第二次遍历，将所有数字分成两组: 一组为具有上述<code>set bit</code>的数, 另一组没有。按照这种方法分组, 相同的数字一定会被分配到同一组中, 而两个只出现一次的数会分配到不同数组中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**代码来自: https://leetcode.com/problems/single-number-iii/discuss/68900/Accepted-C%2B%2BJava-O(n)-time-O(1)-space-Easy-Solution-with-Detail-Explanations</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// Pass 1 :</span></span><br><span class="line">        <span class="comment">// Get the XOR of the two numbers we need to find</span></span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            diff ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Get its last set bit</span></span><br><span class="line">        diff &amp;= -diff;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pass 2 :</span></span><br><span class="line">        <span class="keyword">int</span>[] rets = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">// this array stores the two numbers we will return</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; diff) == <span class="number">0</span>) <span class="comment">// the bit is not set</span></span><br><span class="line">            &#123;</span><br><span class="line">                rets[<span class="number">0</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// the bit is set</span></span><br><span class="line">            &#123;</span><br><span class="line">                rets[<span class="number">1</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找出缺失的数"><a href="#找出缺失的数" class="headerlink" title="找出缺失的数"></a>找出缺失的数</h2><p>给定一个包含n个不同数字的数组，取自<code>0,1,2,...,n</code>，找到数组中缺少的数字。把所有数字和索引<code>0 ~ n</code>取异或, 索引是完整的, 但数字缺失了一个, 最后得到的就一定是那个缺失的数.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> miss = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        miss ^= (nums[i] ^ i);</span><br><span class="line">    <span class="keyword">return</span> miss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外也可以通过求等差数列和， 然后减去实际的数组和，得出缺失的数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“找出只出现一次的数”， “找出唯二的只出现M次的数”， “找出缺失的数”等等，都可以利用异或操作的特性， 即一个整数和自己进行异或运算会归0的性质。&lt;/p&gt;
&lt;h2 id=&quot;找出唯一一个仅出现M次的数&quot;&gt;&lt;a href=&quot;#找出唯一一个仅出现M次的数&quot; class=&quot;headerlink&quot; title=&quot;找出唯一一个仅出现M次的数&quot;&gt;&lt;/a&gt;找出唯一一个仅出现M次的数&lt;/h2&gt;&lt;p&gt;在一个非空整数数组，找出那个只出现了一次的元素，已知其余每个元素均出现两次。&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 不使用加减符号求和整数</title>
    <link href="http://shukebeta.me/bits-operations-05/"/>
    <id>http://shukebeta.me/bits-operations-05/</id>
    <published>2018-09-22T16:00:00.000Z</published>
    <updated>2018-10-16T03:13:41.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不使用加减符号求和整数"><a href="#不使用加减符号求和整数" class="headerlink" title="不使用加减符号求和整数"></a>不使用加减符号求和整数</h2><p>不能使用<code>+</code>和<code>-</code>, 仅通过<code>^</code>和<code>&amp;</code>操作来求和两个整数<code>a</code>.<br><a id="more"></a><br>参考<a href="https://www.cnblogs.com/kiven-code/archive/2012/09/15/2686922.html" target="_blank" rel="noopener"></a><br>每位相加可能会产生进位(carry), 所以可以把相加拆分为两部分, 如<code>759 + 674</code>可以拆分为不考虑进位的部分<code>323</code>和仅考虑进位的部分<code>1110</code>, 故<code>759 + 674 = 323 + 1110 = 1433</code>.</p><p>二进制的加法也是从低位开始逐步往高位计算:</p><ol><li>进行一位二进制的加法, 也就是暂不考虑进位的位相加: <code>0+0=0， 0+1=1, 1+0=1， 1+1=0</code>, 那么就是<code>^</code>操作. 所得的和作为新的<code>a</code>.</li><li>求进位: 通过<code>a &amp; b</code>判断是否进位, 因为只有两个位均为<code>1</code>才会进位. 所得的进位左移一位作为新的<code>b</code>.</li><li>不断重复这个过程, 把低位的进位传递到高位, 累加到<code>a</code>中, 直到进位为<code>0</code>, 最后得到的<code>a</code>就是答案.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123; <span class="comment">// 关键在于判断终止的时机</span></span><br><span class="line"><span class="keyword">int</span> c = a &amp; b; <span class="comment">//carry</span></span><br><span class="line">a ^= b; <span class="comment">//add</span></span><br><span class="line">b = c &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及的运算就是一个多位二进制加法真值表：(对应于硬件中的全加器)</p><blockquote><p>全加器（full adder）将两个一位二进制数相加，并根据接收到的低位进位信号，输出和、进位输出。全加器的三个输入信号为两个加数A、B和低位进位Cin。全加器通常可以通过级联（cascade）的方式，构成多位（如8位、16位、32位）二进制数加法器的基本部分。全加器的输出和半加器类似，包括向高位的进位信号Cout和本位的和信号S，相加结果的总和表达为 ${\displaystyle \mathrm {sum} =2\times C_{out}+S}$。</p></blockquote><p><img src="/images/full_adder.png" alt="" title="image from https://en.wikipedia.org/wiki/Adder_(electronics)"><br>规则是<br><code>s = (x ^ y) ^ Cin</code><br><code>Cout = (x &amp; y) | (y &amp; Cin) | (x &amp; Cin)</code></p><p>更简单的版本:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : getSum(a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="不使用缓存交换整数"><a href="#不使用缓存交换整数" class="headerlink" title="不使用缓存交换整数"></a>不使用缓存交换整数</h2><p>利用一个整数和自己进行异或运算会归0的性质<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] exchangeAB(<span class="keyword">int</span>[] AB) &#123;</span><br><span class="line">   AB[<span class="number">0</span>] = AB[<span class="number">0</span>] ^ AB[<span class="number">1</span>];</span><br><span class="line">   AB[<span class="number">1</span>] = AB[<span class="number">0</span>] ^ AB[<span class="number">1</span>]; <span class="comment">// 只剩下AB[0]</span></span><br><span class="line">   AB[<span class="number">0</span>] = AB[<span class="number">0</span>] ^ AB[<span class="number">1</span>]; <span class="comment">// 只剩下AB[1]</span></span><br><span class="line">   <span class="keyword">return</span> AB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以使用加减法来操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] exchangeAB(<span class="keyword">int</span>[] AB) &#123;</span><br><span class="line">   AB[<span class="number">0</span>] = AB[<span class="number">0</span>] + AB[<span class="number">1</span>];</span><br><span class="line">   AB[<span class="number">1</span>] = AB[<span class="number">0</span>] - AB[<span class="number">1</span>]; <span class="comment">// 只剩下AB[0]</span></span><br><span class="line">   AB[<span class="number">0</span>] = AB[<span class="number">0</span>] - AB[<span class="number">1</span>]; <span class="comment">// 只剩下AB[1]</span></span><br><span class="line">   <span class="keyword">return</span> AB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;不使用加减符号求和整数&quot;&gt;&lt;a href=&quot;#不使用加减符号求和整数&quot; class=&quot;headerlink&quot; title=&quot;不使用加减符号求和整数&quot;&gt;&lt;/a&gt;不使用加减符号求和整数&lt;/h2&gt;&lt;p&gt;不能使用&lt;code&gt;+&lt;/code&gt;和&lt;code&gt;-&lt;/code&gt;, 仅通过&lt;code&gt;^&lt;/code&gt;和&lt;code&gt;&amp;amp;&lt;/code&gt;操作来求和两个整数&lt;code&gt;a&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 风骚的走位操作</title>
    <link href="http://shukebeta.me/bits-operations-03/"/>
    <id>http://shukebeta.me/bits-operations-03/</id>
    <published>2018-09-21T16:00:00.000Z</published>
    <updated>2018-10-10T09:45:33.617Z</updated>
    
    <content type="html"><![CDATA[<p>通过位移实现很多风骚的操作， 参考<a href="https://www.youtube.com/watch?v=7jkIUgLC29I" target="_blank" rel="noopener">这个视频</a>。<br><a id="more"></a><br>检查一个数是否是偶数, 本质上就是取最后一位来判断, 如果是1那么就一定是奇数, 反之则为偶数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x &amp; <span class="number">1</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>Check if power of two:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x &amp; x - <span class="number">1</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>因为如果数<code>x</code>是以2底的真数, 那么其二进制一定只有一个位置是<code>1</code>, 如<code>0b1000</code>, 那么<code>x-1</code>就会变成只有该位置是<code>0</code>其右边所有位变为<code>1</code>, 即<code>0b0111</code>, 也就是说这种情况下<code>x</code>和<code>x-1</code>所有位置都互异. 那么它们的位与运算就是<code>x &amp; x - 1 = 0b0000</code>.</p><p><code>x &amp; x - 1</code>的广义用途是求<code>x</code>二进制中<code>1</code>的个数, <a href="https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan" target="_blank" rel="noopener">Counting bits set</a>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned int v; // count the number of bits set in v</span><br><span class="line">unsigned int c; // c accumulates the total bits set in v</span><br><span class="line">for (c = 0; v; c++)</span><br><span class="line">&#123;</span><br><span class="line">  v &amp;= v - 1; // clear the least significant bit set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>Brian Kernighan’s algorithm takes <code>O(log N)</code> to count set bits (1s) in an integer: each iteration sets the least significance bit that isn’t zero to zero - and only it. Since each iteration converts exactly bit from 1 to 0, it’ll take as many iterations as there are non-0 bits to convert all the bits to 0(and thus <code>v == 0</code> and the loop finishes). An integer n has <code>log(n)</code> bits, hence the worst case is <code>O(log(n))</code></p></blockquote><p>如果一个整数不为<code>0</code>, 那么其二进制就至少有一个<code>1</code>. 假设最右边一位是<code>1</code>, 那么减<code>1</code>就会把最后一位变为<code>0</code>, 前面所有位保持不变. 假如最后一位是<code>0</code>, 那么最靠右的<code>1</code>假设在<code>m</code>位置, 那么减去<code>1</code>, 该位置会变为<code>0</code>, 而其右边的所有<code>0</code>都会变为<code>1</code>, 其左边的所有位不变. <code>v &amp;= v - 1</code>把最右的<code>1</code>变为<code>0</code>.</p><p>获取二进制的最后一个<code>1</code>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last_set_bit</span><span class="params">(x)</span>:</span></span><br><span class="line">    y = ~(x - <span class="number">1</span>) <span class="comment"># = - (x - 1) - 1 = -x</span></span><br><span class="line">    <span class="keyword">return</span> x &amp; y</span><br></pre></td></tr></table></figure></p><p>假设最右边的<code>1</code>位于n, <code>-1</code>操作会把n右边所有<code>0</code>变为<code>1</code>, 而n位变为<code>0</code>. 接着<code>~</code>操作会把n左边所有位翻转, 而n及其右边的数会变为原来的样子, 也就是n为<code>1</code>, 右边全为<code>0</code>(或者没有右边). 最后<code>&amp;</code>操作就只剩下n位的<code>1</code>和右边的<code>0</code>(如果有的话).</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过位移实现很多风骚的操作， 参考&lt;a href=&quot;https://www.youtube.com/watch?v=7jkIUgLC29I&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个视频&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>Dynamic Programming 06 - Knapsack背包问题</title>
    <link href="http://shukebeta.me/algorithms-dynamic-programming-06/"/>
    <id>http://shukebeta.me/algorithms-dynamic-programming-06/</id>
    <published>2018-09-05T16:00:00.000Z</published>
    <updated>2018-10-15T09:28:32.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Knapsack背包问题"><a href="#Knapsack背包问题" class="headerlink" title="Knapsack背包问题"></a>Knapsack背包问题</h2><blockquote><p>背包问题（Knapsack problem）是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。<br>也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V。</p></blockquote><a id="more"></a><h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h3><p>最基础的背包问题：有N件物品和一个体积为V的背包, <strong>每种物品均只有一件</strong>, 第i件物品的大小/重量是<code>s[i]</code>，价值是<code>v[i]</code>. 求将哪些物品装入背包可使这些物品的体积总和不超过背包体积，且价值总和最大.</p><p>对于每一个物品，只有两种结果，放入或者不放入背包，那么<code>kn(i, j)</code>则表示背包容量剩余<code>j</code>时, 前<code>i</code>个物品能够达到的最大值:</p><ul><li><code>kn1 = kn(i-1, j-s(i)) + v(i)</code>表示物品<code>i</code>放入背包后的总价值, 为前<code>i-1</code>物品在第<code>i</code>个物品占用了背包容量<code>s(i)</code>后的的最优解加上第<code>i</code>个物品的价值<code>v(i)</code>.</li><li><code>kn2 = kn(i-1, j)</code>表示物品<code>i</code>并没有放入背包, 等于前<code>i-1</code>个物品在相同背包容量的最优价值.</li></ul><p>归纳出来的大小子问题间的关系(转移方程)为: <code>kn(i, j) = max(kn1, kn2) = max(kn(i-1, j-s(i)) + v(i), kn(i-1, j))</code>. 初始状态是对于不同背包剩余容量, 当没有物品可放时, 返回的最大价值一定是<code>0</code>. 所以背包问题, 就是二维的动态规划问题. 需要确定初始状态, 和哪些信息需要<strong>记忆</strong>.</p><p>可以简单地用一个二维数组记忆所有<code>kn(i, j)</code>, 但要考虑到当容量非常大, 物品非常多时, 这个二维数组是很大的, 比如当<code>(i, j) = (2000, 2000000)</code>, 会抛出<code>java.lang.OutOfMemoryError: Java heap space</code>. 特别是, 当每个物品的价值也比较大时, 二维数组的<code>j</code>维度其实利用率很低. 所以存在很多优化的空间.</p><p>优化的关键点在于减少记忆点. 注意到转移方程中:</p><ul><li><code>kn(i, *)</code>只需要用到<code>kn(i-1, *)</code>的值, 但我们又清楚地知道，物品在这里是没有顺序的意义的，所以这里的<code>i</code>仅仅是表示迭代的步骤, 只是为了遍历所有物品, 至于具体的顺序是不重要的, 所以不需要记录所有<code>i</code>对应的<code>kn(i, *)</code>, 仅仅记录最近一次计算值即可. 所以我们只需要至多两个数组用来记录<code>i-1</code>和<code>i</code>对应的<code>kn</code>值.</li><li><code>kn(i, j)</code>要用到<code>kn(i-1, k), k&lt;=j</code>的值, 具体要用到哪些<code>k</code>是取决于<code>i</code>. 所以<code>j</code>维度的值必须都要记录下来, 以防后续需要用到.</li><li>结合起来发现只需要一个一维数组<code>kn = new int[size + 1]</code>即可, <code>i</code>对应的值可以直接在数组上更新, 不需要额外的数组记录上一次迭代的值. 在实现中, 因为<code>kn(i, j)</code>要用到<code>kn(i-1, &lt;=j)</code>的值, 也就是<code>kn[&lt;j]</code>的值不能先于<code>kn[j]</code>更新, 所以<code>kn</code>的计算要从右往左(<code>j = size; j--</code>).</li><li>每次决定是否加入<code>i</code>物品之前, 如果剩余容量<code>j</code>小于<code>s[i]</code>, 那么肯定无法放入, 这个判断可以融合进<code>j</code>的遍历中, 因为<code>j</code>本身代表了剩余容量.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] values;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] sizes;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = values.length;</span><br><span class="line">    <span class="keyword">int</span>[] vs = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// items</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = size; j &gt;= sizes[i]; j--) &#123;</span><br><span class="line">            vs[j] = Math.max(vs[j - sizes[i]] + values[i], vs[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化以后空间复杂度由$\theta(NS)$降到$\theta(S)$。但时间复杂度不变.</p><p>对于0-1背包问题，如果问题变为求恰好装满时的最大值, 参考<a href="https://blog.csdn.net/liangbopirates/article/details/9750463" target="_blank" rel="noopener">这篇博文</a>: 此时只有容量为<code>0</code>的背包可能被价值为<code>0</code>的物品(无物品)恰好装满，初始化合法状态<code>kn[0] = 0</code>, <code>kn[j &gt; 0]</code>为负数. 反之, 如果要求的是恰好装满时的最小值，初始化为正无穷。要注意的是改变初始化以后最后一个值是恰好装满的最大值，如果不能恰好装满，那肯定是一个负数，而且对于恰好装满的的初始化情况的不要求满的最大值是0-v背包容量的最大值。即是最后一行的MAX。</p><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>Unbounded Knapsack: 有<code>N</code>种物品和一个体积为<code>S</code>的背包，每种物品都有无限件可用。第<code>i</code>件物品的体积是<code>s[i]</code>，价值是<code>value[i]</code>。求解将哪些物品装入背包可使这些物品的体积总和不超过背包体积，且价值总和最大。</p><p>0-1背包的问题中每一种物品在背包中的数量只有<code>0</code>和<code>1</code>两种, 而完全背包问题每一种物品在背包中的数量是<code>0</code>个到<code>k = S/s[i]</code>个. 使用与0-1背包类似的定义, <code>kn(i, j)</code>表示背包容量剩余<code>j</code>时, 放入任意个前<code>i</code>个物品能够达到的最大值, 这样转移方程变为: <code>kn(i, j) = max{kn(i-1, j-k*s(i)) + k*v(i)}, 0 &lt;= k &lt;= S/s[i]</code>。可以直接在0-1背包的代码中增加一个循环，这样时间复杂度就增加了。对于取多少也可以利用二进制拆分，取的时候取<code>1, 2, 4, ...</code>。</p><h4 id="完全背包的算法优化"><a href="#完全背包的算法优化" class="headerlink" title="完全背包的算法优化"></a>完全背包的算法优化</h4><p>注意到完全背包本身也包含0-1背包的情况, 0-1背包是完全背包的特例. 完全背包的<code>kn(i, j)</code>包含了第<code>i</code>种物品的数量在<code>0 - S/s[i]</code>所有可能选择, 并取其最大值:</p><ul><li>若至少放一个物品<code>i</code>进背包, 那么在对物品<code>i</code>的数量进行<code>0 - S/s[i]</code>的遍历时, 迭代方程变为<code>kn1 = kn(i, j-s(i)) + v(i)</code></li><li>若第<code>i</code>个物品不放入背包时, 情况和0-1背包的<code>kn2</code>一样, <code>kn2 = kn(i-1, j)</code></li></ul><p>所以0-1背包的迭代方程<code>vs[j] = Math.max(vs[j - sizes[i]] + values[i], vs[j]);</code>可以直接套用在完全背包上.</p><p>只是<code>kn</code>的计算要改为从左往右(<code>j = 0; j &lt;= size; j++</code>). 因为此时<code>kn1</code>用的不再是上一次迭代的<code>kn(i-1, j-s(i))</code>, 而是本次迭代的<code>kn(i, j-s(i))</code>. 即<code>kn(i, j)</code>要用到<code>kn(i, &lt;=j)</code>的值, 所以<code>kn[&lt;j]</code>的值要先于<code>kn[j]</code>更新.</p><p>同样, 每次决定是否加入<code>i</code>物品之前, 如果剩余容量<code>j</code>小于<code>s[i]</code>, 那么肯定无法放入, 这个判断可以融合进<code>j</code>的遍历中.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] values;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] sizes;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">unboundedKnapsack</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = values.length;</span><br><span class="line">    <span class="keyword">int</span>[] vs = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// items</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = sizes[i]; j &lt;= size; j++) &#123;</span><br><span class="line">            vs[j] = Math.max(vs[j - sizes[i]] + values[i], vs[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>优化后的时间复杂度为<code>O(NV)</code>.</p><p>在数据上也可以优化：如果物品<code>a</code>比<code>b</code>价值更高, 但体积更小, 那么完全可以不考虑物品<code>b</code>。对于随机生成的数据，这个方法往往会大大减少搜索空间。</p><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>有N种物品和一个体积为V的背包。第<code>i</code>种物品最多有<code>num[i]</code>件可用，每件体积是<code>sizes[i]</code>，价值是<code>value[i]</code>。求解将哪些物品装入背包可使这些物品的体积总和不超过背包体积，且价值总和最大。</p><p>多重背包问题可以采取基于0-1背包的算法基础上增加一层循环搜索<code>num[i]</code>. 但这样的时间复杂度是<code>O(NVC)</code>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// items</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= num[i]; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = size; j &gt;= sizes[i]; j--) &#123;</span><br><span class="line">            vs[j] = Math.max(vs[j - sizes[i]] + values[i], vs[j]);</span><br><span class="line">　　  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>多重背包问题其实包含0-1背包和完全背包，可以分类处理。</p><ul><li>如果满足<code>value[i]*num[i]&gt;=size</code>，这个时候就是完全背包问题, 而完全背包要比多重背包的复杂度低，是<code>O(NV)</code>。</li><li>如果满足<code>num[i]=1</code>就是0-1背包。</li></ul><h3 id="其他背包"><a href="#其他背包" class="headerlink" title="其他背包"></a>其他背包</h3><p>混合背包: 如果将0-1、完全、多重混合起来，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。需要分类求解，判断是哪一种，然后分别给出循环和循环顺序，分别调用状态转换方程。</p><p>其他还有二维费用背包，依赖背包，分组背包…</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Knapsack背包问题&quot;&gt;&lt;a href=&quot;#Knapsack背包问题&quot; class=&quot;headerlink&quot; title=&quot;Knapsack背包问题&quot;&gt;&lt;/a&gt;Knapsack背包问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;背包问题（Knapsack problem）是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。&lt;br&gt;也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Dynamic Programming" scheme="http://shukebeta.me/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>Dynamic Programming 05 - 跳台阶</title>
    <link href="http://shukebeta.me/algorithms-dynamic-programming-05/"/>
    <id>http://shukebeta.me/algorithms-dynamic-programming-05/</id>
    <published>2018-09-04T16:00:00.000Z</published>
    <updated>2018-10-15T09:27:31.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><p>跳上一个n级的台阶总共有多少种跳法，先后次序不同算不同的结果，限制条件是每次只能跳1级或者2级。<br><a id="more"></a><br>抽象出来的模型是：给定正整数<code>N</code>，有多少种累加方案，不同顺序当做不同方案，限制条件可以是给定的整数$n_0, n_1, …, n_k$作为可选累加元素.</p><p>对于限制条件为只有两种跳法, 即1阶或者2阶的, 问题可以分解为:</p><ul><li>假定第一次跳的是<code>1</code>阶，那么就剩下<code>n-1</code>个台阶，剩余跳法是<code>f(n-1)</code>;</li><li>假定第一次跳的是<code>2</code>阶，则剩下<code>n-2</code>个台阶，剩余跳法是<code>f(n-2)</code></li></ul><p>可以归纳出通用的公式: <code>f(n) = f(n-1) + f(n-2)</code>, 只有一阶的时候<code>f(1) = 1</code>, 只有两阶的时候可以有<code>f(2) = 2</code>, 刚好就是斐波那契数列. 所以这个简单的跳台阶问题就是计算斐波那契数列的问题。</p><p>反过来思考, 比如对于<code>8</code>个台阶, 有多少种回滚方案? 只有两种: 回滚1个台阶, 就到了<code>7</code>; 回滚2个台阶, 就到了<code>6</code>. 等于说: 假如有<code>f(7)</code>种方案跳到<code>7</code>, 有<code>f(6)</code>种方案跳到<code>6</code>，那么就有<code>f(7) + f(6)</code>种方案到达<code>8</code></p><p>从树结构来理解: 如果节点代表台阶数<code>n</code>对应的跳法<code>f(n)</code>, 节点与节点间的枝代表单次可以跳的阶数, 父节点的值就是其所有子节点的值和. 对于只有两种跳法限制问题, 父节点<code>f(n)</code>就只有两个子节点, 分别为<code>f(n-1)</code>和<code>f(n-2)</code>.</p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>举例：Fibonacci sequence: ${\displaystyle 0,\;1,\;1,\;2,\;3,\;5,\;8,\;13,\;21,\;34,\;55,\;89,\;144,\;\ldots }$<br>$$F_0 = 0, F_1 = 1, F_2 = 1, F_n = F_{n-1} + F_{n-2} (n&gt;2) $$</p><p>Fibonacci numbers grow almost as fast as the powers of 2.</p><p>Recursive solution is exponential algorithm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fib1(n):</span><br><span class="line">    if n = 0:  return 0</span><br><span class="line">    if n = 1:  return 1</span><br><span class="line">    return fib1(n - 1) + fib1(n - 2)</span><br></pre></td></tr></table></figure></p><p>因为每一个<code>fib1()</code>都会生成指数级数量的子分支计算, 所以这个算法复杂度是$O(2^n)$.</p><p>但是注意到斐波那契数列公式是$F_n = F_{n-1} + F_{n-2}$, 也就是只要知道n前面两个值, 就能计算出$f_n$. 又因为斐波那契数列天然的是从低往高算, 那么每次迭代只需要用到前两次的值$F_{n-1}, F_{n-2}$, 计算后更新它们即可. 用这个思路来计算斐波那契数列, 复杂度就是$O(n)$.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> target; &#125;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n0 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt;= target) &#123;</span><br><span class="line">        ways = n0 + n1;</span><br><span class="line">        n0 = n1;</span><br><span class="line">        n1 = ways;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h3><p>变态跳台阶就是是用来更复杂的限制条件, 比如可选单次跳阶数为<code>[1, ... n]</code>, 也就是无限制的情况, 也可以按照上面的思路推导.</p><p>比如从树结构的考虑, 就变成每个父节点<code>f(n)</code>可以有<code>n</code>个子节点, 就是<code>f(n-1), f(n-2), ..., f(n-n)</code>, 所以<code>f(n)</code>就是所有这些子节点的和. <code>f(n-n)</code>也就是<code>f(0)</code>意味着一次跳完所有阶数<code>n</code>, 所以<code>f(0) = 1</code>. 进一步归纳, <code>f(n-2) + ... + f(n-n) = f(n-1)</code>, 所以<code>f(n) = f(n-1) + f(n-1)</code>, 可以用递归或者动态规划来计算.</p><p>当然进一步归纳会发现$f(n) = 2^{n-1}$, 可以用位移来操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a &lt;&lt; (target - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只是要注意<code>int</code>是有范围的.</p><h3 id="大变态跳台阶"><a href="#大变态跳台阶" class="headerlink" title="大变态跳台阶"></a>大变态跳台阶</h3><p>再举一个更复杂的限制条件, 可选单次跳阶数为$2^0, 2^1, …, 2^k$, $2^k$要小于<code>n</code>. 那么相应的,<br>$$f(n) = f(n - 2^0) + f(n - 2^1)… + f(n - 2^k), \quad s.t. \quad 2^k &lt;= n,$$<br>这样就意味着对于每个<code>f(n)</code>, 需要用到的<code>f(k)</code>值数量是不同的, 就不能简单地用固定数量的变量来保留较小值了.</p><p>对于不同的<code>f(n)</code>, 它们的很多子分支计算是共享的, 比如<code>f(6)</code>和<code>f(5)</code>都用到了<code>f(4)</code>. 那么在递归的过程中，只要把每次计算出来的较小的<code>f(k)</code>储存到数组中, 后续其他<code>f(n)</code>要用到<code>f(n - 2^k)</code>时, 直接从内存中取值即可. 初始值取<code>f(0) = f(1) = 1</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorIII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[target];</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> jump(f, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[target] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= target; i++) &#123;</span><br><span class="line">            ways += jump(f, target - (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">        &#125;</span><br><span class="line">        f[target] = ways;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个代码适用于<code>n &lt;= 1024</code>的情况. 否则要改为循环。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;跳台阶&quot;&gt;&lt;a href=&quot;#跳台阶&quot; class=&quot;headerlink&quot; title=&quot;跳台阶&quot;&gt;&lt;/a&gt;跳台阶&lt;/h2&gt;&lt;p&gt;跳上一个n级的台阶总共有多少种跳法，先后次序不同算不同的结果，限制条件是每次只能跳1级或者2级。&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Dynamic Programming" scheme="http://shukebeta.me/tags/Dynamic-Programming/"/>
    
  </entry>
  
</feed>
