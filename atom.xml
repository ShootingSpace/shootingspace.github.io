<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Computer Science &amp; AI</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-27T17:22:30.555Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>舒克贝塔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法与数据结构 - Java | 对象 哈希 重写 override equals() hashcode()</title>
    <link href="http://yoursite.com/NOTE-Java-miscellaneous-hashcode-equals/"/>
    <id>http://yoursite.com/NOTE-Java-miscellaneous-hashcode-equals/</id>
    <published>2018-02-27T00:00:00.000Z</published>
    <updated>2018-02-27T17:22:30.555Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍：</p><ol><li>Hashcode（哈希码）与 equals（判断相等）的关系</li><li>Hashcode 方法的底层实现原理</li><li>开发中需要掌握的原则和方法</li></ol><h3 id="HashSet-HashMap-HashTable"><a href="#HashSet-HashMap-HashTable" class="headerlink" title="HashSet, HashMap, HashTable"></a>HashSet, HashMap, HashTable</h3><p>HashSet底层是调用HashMap. HashMap 使用hashCode和equals来进行对象比较。</p><p>拿HashSet和add()举例(其余的数据结构,和 remove, contains等方法类似):假设HashSet里面已经有了obj1, 那么当调用HashSet.add(obj2)时:</p><ol><li>if (obj1 == obj2), 那么没有必要调用 hashCode(), 已经有了这个对象, 没必要添加了</li><li>else, if hashCode 不同，那么可以直接添加了, 没必要进一步调用 obj1.equals(obj2) 来判断对象是否相等</li><li>else hashCode 相同，那么需要进一步调用obj1.equals(obj2)</li></ol><p>下面这段代码虽然 HashSet 只存了 a 对象，但当检查是否包含 b 对象时，返回true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; wordSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">String a = <span class="string">"hello"</span>;</span><br><span class="line">String b = <span class="string">"hello"</span>;</span><br><span class="line">wordSet.add(a);</span><br><span class="line"><span class="keyword">return</span> wordSet.contains(b); <span class="comment">// return true</span></span><br></pre></td></tr></table></figure></p><p>根据<a href="https://docs.oracle.com/javase/6/docs/api/java/util/Set.html#add%28E%29" target="_blank" rel="noopener">Javadoc for Set</a>.</p><pre><code>adds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)).</code></pre><p>根据<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#equals-java.lang.Object-" target="_blank" rel="noopener">Javadoc for String.equals</a></p><pre><code>Compares this string to the specified object. The result is true if and only if the argument is not null and is a String object that represents the same sequence of characters as this object.</code></pre><p>Java的set是使用它包含的元素（对象）的 <code>equals()</code>来比较 b 和 a 的。这里 String 类的<code>equals()</code>method 是比较字符串值是否相等(准确的说，是先检查是不是引用同一个对象，再看是不是同一个类，再比较值)，而不是引用的对象是否一样，故<code>b.equals(a)</code>是 true。</p><p>同样的，remove 和 add 也会先进行类似检查。</p><p>问题是，为何 hashCode 不同，就没有进一步调用 equals()的必要呢？因为有一个前提是代码遵守The hashCode contract。</p><h3 id="Hashcode-and-equals"><a href="#Hashcode-and-equals" class="headerlink" title="Hashcode and equals"></a>Hashcode and equals</h3><p>在Java中，每个对象都有一个hashCode，它有时容易被人遗忘或误用。有以下三点需要注意，避免掉入常见的陷阱。</p><h4 id="The-hashCode-contract"><a href="#The-hashCode-contract" class="headerlink" title="The hashCode contract"></a>The hashCode contract</h4><p>根据 The hashCode contract:</p><pre><code>Objects that are equal must have the same hash code within a running process.</code></pre><p>除了字面意思，也有其他隐含的意思: 不相等的对象的hashcode也可能一样; 具有相同 hash code 的对象不一定相等.</p><pre><code>You must override hashCode() in every class that overrides equals(). Failure to do so will result in a violation of the general contract for Object.hashCode(), which will prevent your class from functioning properly in conjunction with all hash-based collections, including HashMap, HashSet, and Hashtable. --- Effective Java, by Joshua Bloch</code></pre><p>根据这个contract，可以延伸出以下实践原则：</p><p><strong>一、 每当你 override equals 时，也要 override hashCode</strong><br>假如你需要使用不一样的equals判断标准，那么就需要重写equals。但假如仅仅重写equals，而不重写hashcode()，就可能会违背 The hashCode contract。</p><p>为什么？因为 hashCode method 需要同时适配真正使用到的 equals method 的判断标准。通过重写equals，我们重新声明了一种判断对象是否相等的标准，但原始的 hashCode method还是会将所有对象视为不同的对象。所以如果没有不重写hashcode，那么根据@Override equals 判断为相同的对象将拥有不同的hashcode（可能）。这样，即使已经有了这个object，在HashMap上调用 contains() 也会返回false。</p><p>例子：在Java的创建街道street这个类，在判断两条街道是否相同时，我们有自定义的规则 - 只要是在同一个城市，有同样的街道名，那么两个street就相等，即使他们是存放在不同内存位置的两个对象（Java 的 Object 原生的equals是根据引用的对象内存地址来比较判断的）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Street</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Street))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        Street rhs = (Street) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EqualsBuilder().</span><br><span class="line">            <span class="comment">// if deriving: appendSuper(super.equals(obj)).</span></span><br><span class="line">            append(name, rhs.name).</span><br><span class="line">            append(age, rhs.city).</span><br><span class="line">            isEquals();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashCodeBuilder(<span class="number">17</span>, <span class="number">31</span>). <span class="comment">// two randomly chosen prime numbers</span></span><br><span class="line">            <span class="comment">// if deriving: appendSuper(super.hashCode()).</span></span><br><span class="line">            append(name).</span><br><span class="line">            append(city).</span><br><span class="line">            toHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果没有重写hashCode()， 那么两个名字和所在城市一样的，但引用不同地址的street就会按照默认的 hashcode() 返回不一样的code，但是根据重写的equals(), 他们是一样的, 这样就违背了 hashCode contract。</p><p>为了安全起见，让Eclipse IDE 生成 equals 和 hashCode 函数：<code>Source &gt; Generate hashCode() and equals()...</code><br><img src="https://eclipsesource.com/wp-content/uploads/2012/09/generate-hashcode-equals.png" alt=""></p><p>为了提醒自己, 还可以配置Eclipse以检测是否有违反此规则的情况，并为仅重写了equals但没重写hashCode的情况显示错误：<code>Preferences &gt; Java &gt; Compiler &gt; Errors/Warnings, then use the quick filter to search for “hashcode”</code><br><img src="https://eclipsesource.com/wp-content/uploads/2012/09/hashcode-error-config.png" alt=""></p><h3 id="HashCode-collisions"><a href="#HashCode-collisions" class="headerlink" title="HashCode collisions"></a>HashCode collisions</h3><p>HashCode collisions 指两个不同的对象具有相同的hashcode这种情况, 这不是什么严重的问题. 只是会导致更多的搜索步骤，太多collisions就可能会降低系统性能</p><p>但是，如果将HashCode错误地用作对象的唯一句柄，例如将其用作Map中的key，那么有时会得到错误的对象。虽然collisions一般很少见，但却是不可避免的。例如，字符串“Aa”和“BB”产生相同的hashCode：2112. 因此衍生出第二个原则</p><p><strong>二、永远不要把hashcode当做key来使用</strong></p><p>Java中有4,294,967,296个（2<sup>32</sup>)可能的int值）。既然拥有40亿个插槽，collisions似乎几乎不可能对吧？</p><p>但事实上，也不是那么不可能。试想，一个房间里有23名随机人员。你如何估计里面有两个人生日一样的概率？很低？因为一年有365天？事实上，概率约为50％！这种现象被称为<a href="http://en.wikipedia.org/wiki/Birthday_paradox" target="_blank" rel="noopener">生日问题(悖论)</a>。</p><pre><code>如果一个房间里有23个或23个以上的人，那么至少有两个人的生日相同的概率要大于50%。</code></pre><p>问题的本质是”23人之中两两之间存在生日相同的概率””,而不是”其他22人与其中一个人的生日相同的概率”.</p><p>类比到hashcode里，这意味着有77,163个不同的对象，collisions概率是50%（假设有一个理想的hashCode函数，将对象均匀分布在所有可用的buckets中）。</p><h3 id="HashCodes-会变"><a href="#HashCodes-会变" class="headerlink" title="HashCodes 会变"></a>HashCodes 会变</h3><p>HashCode 不保证在不同的执行过程中总能返回相同的code。根据JavaDoc：Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. <strong>This integer need not remain consistent from one execution of an application to another execution</strong> of the same application.</p><p>这种情况并不常见，实际上，库中的某些类甚至指定了用于计算hashcode的精确公式（例如String）。对于这些类，hashcode总是相同的。但是，尽管大多数的hashCode方法提供了稳定的值，但我们不能依赖它。正如<a href="http://martin.kleppmann.com/2012/06/18/java-hashcode-unsafe-for-distributed-systems.html" target="_blank" rel="noopener">这篇文章</a>所指出的那样，Java库实际上在不同的进程中返回不同的hashCode值，这往往会让人们感到困惑。 Google的<a href="http://code.google.com/p/protobuf/" target="_blank" rel="noopener">Protocol Buffers</a>就是一个例子。 因此，您不应该在分布式应用程序中使用hash code。即使两者相等，远程对象的 hash code 也可能与本地的不同。</p><p><strong>三、不要在分布式应用程序中使用 hashCode</strong><br>此外，要意识到，hashCode函数的实现可能会随着版本的更改而改变。因此我们的代码最好不依赖任何特定的hash code 值。例如，你不应该使用hash code来保持某种状态，不然下次运行时，“相同”对象的hash code可能会不同。</p><p>所以最好的建议可能是：除非自己创建了基于 hashcode 算法，否则根本就不要使用 hashCode 呵呵……</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在依赖于 HashSet, HashMap, HashTable … 等数据结构的程序中：</p><ol><li>仅重写 equals()，会导致业务出错</li><li>仅重写 hashcode(), 在比较两个对象时不会强制Java忽略内存地址</li><li>如果不涉及对象比较(比如仅仅是iteration), 那么不需要hashCode and/or equals</li></ol><p>参考：<br><a href="https://eclipsesource.com/blogs/2012/09/04/the-3-things-you-should-know-about-hashcode/" target="_blank" rel="noopener">https://eclipsesource.com/blogs/2012/09/04/the-3-things-you-should-know-about-hashcode/</a><br><a href="https://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java" target="_blank" rel="noopener">https://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要介绍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hashcode（哈希码）与 equals（判断相等）的关系&lt;/li&gt;
&lt;li&gt;Hashcode 方法的底层实现原理&lt;/li&gt;
&lt;li&gt;开发中需要掌握的原则和方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;HashSet-HashMap-H
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 13 - Java | 实现继承 Implementation Inheritance - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-13-Implementation%20Inheritance/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-13-Implementation Inheritance/</id>
    <published>2018-02-24T00:00:00.000Z</published>
    <updated>2018-02-24T17:41:03.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Implementation-Inheritance"><a href="#Implementation-Inheritance" class="headerlink" title="Implementation Inheritance"></a>Implementation Inheritance</h2><p>实现继承是subclass从superclass继承实现的关系。</p><h3 id="default-method-缺省方法（从-Java-8开始）"><a href="#default-method-缺省方法（从-Java-8开始）" class="headerlink" title="default method 缺省方法（从 Java 8开始）"></a>default method 缺省方法（从 Java 8开始）</h3><p>除了signature之外，Java也允许subclass继承implementation。<br>我们可以在List中列出已实现的method。这些方法是 default method，定义了List hypernyms的一些默认行为：<code>default public void method() { ... }</code>.</p><p>我们可以自由调用interface中定义的方法，而不用操心具体的实现。default method 应该适用于实现接口的任何类型的对象！子类不必在任何地方重新实现 default method，可以直接调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过，我们仍然可以重写 default method，在子类中重新定义该方法。这样，只要我们在LinkedLList上调用<code>print()</code>，它就会调用这个方法，而不是List的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedList</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java是通过一个叫“dynamic method selection”的特性，来确定要调用 default method 还是已经被子类重写的method。<br>这个实例声明<code>List&lt;String&gt; l = new LinkedList&lt;String&gt;();</code>,指明<code>l</code>的类型是 List, 是 static type。由 new 生成的 object 本身是LinkedList类型，也从属于 List 类型。但是，因为这个对象本身是使用 LinkedList 构造函数实例化的，所以我们称之为 dynamic type。</p><pre><code>Dynamic type 的名称起源于: 当`l`被重新分配指向另一种类型的对象时，比如说一个 ArrayList 对象，`l`的动态类型现在就变为 ArrayList. 因为它根据当前引用的对象的类型而改变, 所以是动态的。Static vs. Dynamic Type:    Java 每个变量都有一个static type （compile-time type），这是变量声明时指定的类型，在编译时会检查。    每个变量也有一个 Dynamic Type（run-time type），此类型在变量实例化（new）时指定，并在运行时检查。等同于地址指向的对象的类型。</code></pre><p>当Java运行一个被overriden的方法时，它会在它的dynamic type 中搜索合适的 method signature 并运行。</p><p>注意，如果是overload:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">peek</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">peek</span><span class="params">(LinkedList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于上面的实例化的<code>l</code>, 当Java检查要调用哪个方法时，它会检查 static type (此时是List)并使用相同类型的参数调用该方法(也就是使用List作为签名的那个方法)。</p><h3 id="总结：区别-Interface-Inheritance-vs-Implementation-Inheritance"><a href="#总结：区别-Interface-Inheritance-vs-Implementation-Inheritance" class="headerlink" title="总结：区别 Interface Inheritance vs Implementation Inheritance"></a>总结：区别 Interface Inheritance vs Implementation Inheritance</h3><p>Interface Inheritance 接口继承（what）：指定 subclass 应该实现的功能，即只提供 method signature。</p><p>Implementation Inheritance 实现继承（how）：提供功能的实现方案，即提供 method implementation。允许代码再利用，也给subclass设计者提供了更多的自由度，由他们自行决定是否重写 default method。</p><p>Implementation inheritance 也有一些缺点：</p><ul><li>人会犯错。我们有可能忘了自己曾经重写过一个方法。</li><li>如果两个接口给出冲突的 default method，则可能很难解决冲突。</li><li>无形中鼓励代码复杂化。</li></ul><p>最后，注意从属和拥有的区别：subclass 和 superclass 是上下级从属分类，而不是拥有与被拥有的关系，不要跟 nested class 混淆。</p><p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/index.html" target="_blank" rel="noopener">Oracle</a>：<br>Interface Methods<br>Default methods and abstract methods in interfaces are inherited like instance methods. However, when the supertypes of a class or interface provide multiple default methods with the same signature, the Java compiler follows inheritance rules to resolve the name conflict. These rules are driven by the following two principles:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Implementation-Inheritance&quot;&gt;&lt;a href=&quot;#Implementation-Inheritance&quot; class=&quot;headerlink&quot; title=&quot;Implementation Inheritance&quot;&gt;&lt;/a&gt;Implemen
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 12 - Java | 接口继承 Interface Inheritance - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-12-Interface%20Inheritance/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-12-Interface Inheritance/</id>
    <published>2018-02-23T00:00:00.000Z</published>
    <updated>2018-02-24T16:58:30.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Interfaces-Inheritance"><a href="#Interfaces-Inheritance" class="headerlink" title="Interfaces Inheritance"></a>Interfaces Inheritance</h2><h3 id="Motivation-扩展代码适用性"><a href="#Motivation-扩展代码适用性" class="headerlink" title="Motivation:扩展代码适用性"></a>Motivation:扩展代码适用性</h3><p>我们前面创建的 <code>LinkedList</code> and <code>ArrayList</code> 其实很相似 - 所有的method都一样.</p><p>如果我们需要写一个需要用到 list 的类比如<code>WordUtils</code> class, 我们如何让它既可以使用<code>LinkedList</code>又可以用<code>ArrayList</code>？</p><p>简单的方法及时写两个同名不同参数的methods。即所谓<code>method overloading</code>。<br><code>public static String longest(LinkedList&lt;String&gt; list)</code><br><code>public static String longest(ArrayList&lt;String&gt; list)</code></p><p>但 overload 有几个缺点:</p><ul><li>超级重复，写两个几乎相同的代码块。</li><li>产生更多需要维护的代码，那意味着如果你想对的方法做一个小优化或debug，你需要在对应每种list的方法中改变它。</li><li>如果我们想要适配更多的列表类型，不得不复制每个新列表类的方法。</li></ul><p>另一种方法是使用 interface 接口。<br><a id="more"></a></p><h3 id="Hypernyms-Hyponyms-and-Interface-Inheritance-上位词，下义词和接口继承"><a href="#Hypernyms-Hyponyms-and-Interface-Inheritance-上位词，下义词和接口继承" class="headerlink" title="Hypernyms, Hyponyms, and Interface Inheritance 上位词，下义词和接口继承"></a>Hypernyms, Hyponyms, and Interface Inheritance 上位词，下义词和接口继承</h3><p>首先要理解，上位词和下位词是语言学的定义，直接沿用到编程语言中。就像狗是哈士奇的上位词，哈士奇是狗的下义词，在Java把这种关系形式化：如果<code>LinkedList</code>是List的Hyponyms，那么<code>LinkedList</code>类是List的subclass，而List类是<code>LinkedList</code>类的superclass(超类/父类)。</p><p>在Java中，为了表达这种层次结构，我们需要：</p><ol><li>为 hypernym - 通用列表 List 定义类型。</li><li>指定<code>LinkedList</code>和<code>ArrayList</code>是该类型的hyponyms。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Item x)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 List 是Java中的 interface 接口。本质上是一个指定list必须能够做什么的合约，具体如何做并不是它关心的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">Item</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 具体的执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Item x)</span> </span>&#123;</span><br><span class="line">        insert(x, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定ArrayList是List的hyponyms. <code>implements List&lt;Item&gt;</code>类似一种承诺，保证将拥有并定义在List interface 中制定的所有属性（变量）和行为（方法）。 List中指定的方法的具体实现过程就是在这种hyponyms中实现的。</p><p>这样就可以同时适配多种list：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordUtils</span> </span>&#123;</span><br><span class="line">   <span class="comment">/** Returns the length of the longest word. */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longest</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> list.get(maxDex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     ArrayList&lt;String&gt; someList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="comment">//or</span></span><br><span class="line">     LinkedList&lt;String&gt; someList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">     ...</span><br><span class="line">     System.out.println(longest(someList));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Overriding-重写"><a href="#Overriding-重写" class="headerlink" title="Overriding 重写"></a>Overriding 重写</h3><p>如果subclass和superclass有signature一样的method, 那么subclass就是在 override 重写这个方法。</p><pre><code>Override 要与 overloaded 区别开，重载的方法虽同名，却不同signature。</code></pre><p>在子类中实现合约指定的功能时，需要在method的signature顶部包含<code>@Override</code>标签。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Item x)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>值得注意的是，即使不包含这个<code>@Override</code>，仍然重写了这个方法。所以技术上讲，它不是必须的。但是，它可以作为一个保障, 提醒编译器我们打算重写此方法，就好像有一个校对员, 如果过程中出现问题, 编译器可以提醒。假设当我们想 override <code>addLast</code>，却不小心写成<code>addLsat</code>。此时如果不包含<code>@Override</code>，那么可能无法发现错误。如果有了<code>@Override</code>，编译器就会提示我们修复错误。</p><h3 id="总结：Interface-Inheritance"><a href="#总结：Interface-Inheritance" class="headerlink" title="总结：Interface Inheritance"></a>总结：Interface Inheritance</h3><p>接口继承是指subclass继承superclass的所有方法/行为的关系：</p><ul><li>子类继承父类</li><li>Interfaces 接口列出所有方法的签名，就像‘合约’，但没有具体的实现</li><li>根据‘合约’，由子类来实现且必须实现（override 重写）每一个method，否则无法通过编译</li><li>继承关系可以延续多代。例如，B可以继承A，C可以继承B.</li></ul><h3 id="GRoE"><a href="#GRoE" class="headerlink" title="GRoE"></a>GRoE</h3><p>根据Java的Golden Rule of Equals，每一个赋值a = b，本质上是把b中的bits拷贝到a中，着要求b和a的类型相同。</p><p>同理, 假设<code>public static String longest(List&lt;String&gt; list)</code>既接受List, 也接受ArrayList和LinkedList，但是由于ArrayList和List是不同的类，那怎么遵守GRoE呢？</p><p>因为ArrayList与List有着上下位包含的关系，这意味着ArrayList应该能够赋值给List的内存位中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; someList = <span class="keyword">new</span> SLList&lt;String&gt;();</span><br><span class="line">    someList.addFirst(<span class="string">"elk"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码运行时，会创建SLList并将其地址存储在someList变量中。然后将字符串“elk”插入到由addFirst引用的SLList中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Interfaces-Inheritance&quot;&gt;&lt;a href=&quot;#Interfaces-Inheritance&quot; class=&quot;headerlink&quot; title=&quot;Interfaces Inheritance&quot;&gt;&lt;/a&gt;Interfaces Inheritance&lt;/h2&gt;&lt;h3 id=&quot;Motivation-扩展代码适用性&quot;&gt;&lt;a href=&quot;#Motivation-扩展代码适用性&quot; class=&quot;headerlink&quot; title=&quot;Motivation:扩展代码适用性&quot;&gt;&lt;/a&gt;Motivation:扩展代码适用性&lt;/h3&gt;&lt;p&gt;我们前面创建的 &lt;code&gt;LinkedList&lt;/code&gt; and &lt;code&gt;ArrayList&lt;/code&gt; 其实很相似 - 所有的method都一样.&lt;/p&gt;
&lt;p&gt;如果我们需要写一个需要用到 list 的类比如&lt;code&gt;WordUtils&lt;/code&gt; class, 我们如何让它既可以使用&lt;code&gt;LinkedList&lt;/code&gt;又可以用&lt;code&gt;ArrayList&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;简单的方法及时写两个同名不同参数的methods。即所谓&lt;code&gt;method overloading&lt;/code&gt;。&lt;br&gt;&lt;code&gt;public static String longest(LinkedList&amp;lt;String&amp;gt; list)&lt;/code&gt;&lt;br&gt;&lt;code&gt;public static String longest(ArrayList&amp;lt;String&amp;gt; list)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但 overload 有几个缺点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超级重复，写两个几乎相同的代码块。&lt;/li&gt;
&lt;li&gt;产生更多需要维护的代码，那意味着如果你想对的方法做一个小优化或debug，你需要在对应每种list的方法中改变它。&lt;/li&gt;
&lt;li&gt;如果我们想要适配更多的列表类型，不得不复制每个新列表类的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另一种方法是使用 interface 接口。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理（快速入门） - Accelerated Natural Language Processing - University of Edinburgh</title>
    <link href="http://yoursite.com/Accelerated-Natural-Language-Processing-UoE/"/>
    <id>http://yoursite.com/Accelerated-Natural-Language-Processing-UoE/</id>
    <published>2018-01-31T00:00:00.000Z</published>
    <updated>2018-02-24T16:32:11.503Z</updated>
    
    <content type="html"><![CDATA[<p>自然语言处理入门，概念汇总。</p><p>References:<br><a href="http://www.inf.ed.ac.uk/teaching/courses/anlp/" target="_blank" rel="noopener">Accelerated natural language processing 爱丁堡大学</a><br><a href="https://www.inf.ed.ac.uk/teaching/courses/anlp/review/review_ay17.html" target="_blank" rel="noopener">ANLP revision guide</a><br><a href="https://web.stanford.edu/~jurafsky/NLPCourseraSlides.html" target="_blank" rel="noopener">JM NLP, Stanford</a><br><a id="more"></a></p><h2 id="概率模型-Probability-model"><a href="#概率模型-Probability-model" class="headerlink" title="概率模型 Probability model"></a>概率模型 Probability model</h2><p>概率模型是随机现象的数学表示，由样本空间，样本空间内的事件以及与每个事件相关的概率定义。目标是模拟给一个事件发生的概率</p><h3 id="估算概率-Probability-estimation"><a href="#估算概率-Probability-estimation" class="headerlink" title="估算概率 Probability estimation"></a>估算概率 Probability estimation</h3><p>相关频率/最大似然估计<br>Relative frequency / maximum likelihood estimation p(X) = Count(x)/N</p><h3 id="平滑-Smoothing"><a href="#平滑-Smoothing" class="headerlink" title="平滑 Smoothing"></a>平滑 Smoothing</h3><p>一般用于处理0概率的问题，比如在训练集中看不到, 但出现在测试集中的词。</p><h4 id="Add-alpha-smoothing"><a href="#Add-alpha-smoothing" class="headerlink" title="Add alpha smoothing"></a>Add alpha smoothing</h4><ul><li>Assign equal probability to all unseen events.</li><li>Applied in text classification, or domains where zeros probability is not common.</li></ul><h4 id="Backoff-smoothing"><a href="#Backoff-smoothing" class="headerlink" title="Backoff smoothing"></a>Backoff smoothing</h4><ul><li>Use information from lower order N-grams (shorter histories)</li><li>Back off to a lower-order N-gram if we have zero evidence for a higher-order interpolation N-gram.</li><li>Discount: In order for a backoff model to give a correct probability distribution, we have to discount the higher-order N-grams to save some probability mass for the lower order N-grams.</li></ul><h4 id="Interpolation-smoothing"><a href="#Interpolation-smoothing" class="headerlink" title="Interpolation smoothing"></a>Interpolation smoothing</h4><ul><li>Interpolation: mix the probability estimates from all the N-gram estimators, weighing and combining the trigram, bigram, and unigram counts</li><li>Simple interpolation: <code>P(w3|w1,w2)=1P(w3|w1,w2)+λ2P(w3|w2)+λ3P(w3)</code>, Σλ=1.</li><li>λ could be trianed/conditioned on training set/contest, choose λ that maximie the probability of held-out data</li></ul><h4 id="Kneser-Ney-smoothing"><a href="#Kneser-Ney-smoothing" class="headerlink" title="Kneser-Ney smoothing"></a>Kneser-Ney smoothing</h4><ul><li>Combine absolute discounting and interpolation: Extending interpolatation with an absolute discounting 0.75 for high order grams.</li><li>Use a better estimate for probabilities of lower-order unigrams, the continuation probability, P_continuatin(w) is how likely is w to appear as a novel continutaion.<ul><li>For each word w, count the number of bigram types it completes. Or count the number of word types seen to precede w.</li><li>Every bigram type was a novel continuation the first time it was seen.</li><li>normalized by the total number of word bigram types.</li></ul></li><li>To lower the probability of some fix bigram like “San Franscio”</li><li>For bigram, <code>Pkn(wi|wi-1)=max(count(wi-1,wi)-d, 0)/c(wi-1) +λ(wi-1)P_continuatin(wi), λ(wi-1) = d{w:count(wi-1,w)&gt;0}/c(wi-1)</code>, where {w:count(wi-1,w)&gt;0} is the number of word types that can follow wi-1, also is the # of word types we discounted, also is the # of times we applied normalized discount.</li><li>For general N-gram, <img src="/images/kneser-ney.png" alt=""></li></ul><h3 id="Probabilistic-Language-modeling"><a href="#Probabilistic-Language-modeling" class="headerlink" title="Probabilistic Language modeling"></a>Probabilistic Language modeling</h3><ul><li>What: To compute the probability of sentence /sequence of words P(w1, w2, w3…), or to predict upcomming words P(w|w1, w2, w3…)… a language model is also a probability model.</li><li>Why: the motivation is that probability is essential in identifying information in noisy, ambiguous inputs: speech recognition, machine translation, spelling correction…</li><li>How: rely on chain rule of probability, the products of a sequence of <strong>conditional</strong> probability.</li><li>Simplified by Markov Assumption: approximate the conditional probability by only accounting several prefixes,<br><code>P(the| water is so transparent that) ≈ P(the| that)</code></li><li><a href="#evaluation-concepts-and-methods">Evaluation</a>: how good is the model</li></ul><h2 id="GENERATIVE-PROBABILISTIC-MODELS"><a href="#GENERATIVE-PROBABILISTIC-MODELS" class="headerlink" title="GENERATIVE PROBABILISTIC MODELS"></a>GENERATIVE PROBABILISTIC MODELS</h2><p>Generative(joint) models palce probabilities P(c,d) over both observed data d and the hidden variables c (generate the obersved data from hidden stuff).</p><h3 id="N-Gram-Language-Model"><a href="#N-Gram-Language-Model" class="headerlink" title="N-Gram Language Model"></a>N-Gram Language Model</h3><ul><li>Unigram P(w1,w2,w3..) ≈ P(w1)*P(w2)*P(w3)</li><li>Bigram P(wn| w1,w2,w3..) ≈ P(wn| wn-1)</li><li>Estimate probability by counting:<br><code>P(wi| prefixes) = count(prefixes, wi)/count(prefixes)</code></li><li>In practice, use log space to avoid underflow, and adding is faster than multiplying.</li><li>Insufficient:<ul><li>long-distance dependencies</li><li>N-grams only work well for word prediction if the test corpus looks like the training corpus.</li></ul></li><li>To deal with 0 probability, commonly use <a href="#kneser-ney-smoothing">Kneser-Ney smoothing</a>, for very large N-grams like web, use stupid backoff.</li></ul><h3 id="Naive-Bayes-classifier"><a href="#Naive-Bayes-classifier" class="headerlink" title="Naive Bayes classifier"></a>Naive Bayes classifier</h3><ul><li>Application: <a href="#text-classification">Text classification</a>, to classify a text, we calculate each class probability given the test sequence, and choose the biggest one.</li><li>Evaluation: <a href="#precision-recall-f-measure">precision, recall, F-measure</a></li><li>Strength and Weakness: 高效, 快速, 但对于组合性的短语词组, 当这些短语与其组成成分的字的意思不同时, NB的效果就不好了</li></ul><h3 id="Text-classification"><a href="#Text-classification" class="headerlink" title="Text classification"></a>Text classification</h3><p>Or text categorization, method is not limited to NB, see <a href="http://www.inf.ed.ac.uk/teaching/courses/anlp/labs/lab7.html" target="_blank" rel="noopener">lab7</a>.<br>Spam email, gender/authorship/language identification, sentiments analysis,(opinion extraction, subjectivity analysis)…</p><h4 id="Sentiments-analysis"><a href="#Sentiments-analysis" class="headerlink" title="Sentiments analysis"></a>Sentiments analysis</h4><ul><li>For sentiment(or other text classification), word occurrence may matter more than word frequency. Thus it often improves performance to clip the word counts in each document at 1.<ul><li>This variant binary NB is called binary multinominal naive Bayes or binary NB.</li><li>Remove duplicates in each data sample - bag of words representation, boolean features. Binarized seems to work better than full word counts.</li></ul></li><li>Deal with negation: <code>like, not like</code>, A very simple baseline that is commonly used in sentiment to deal with negation is during text normalization to prepend the prefix NOT_ to every word after a token of logical negation</li><li>Sentiment lexicons: lists of words that are preannotated with positive or negative sentiment. To deal with insufficient labeled training data. A common way to use lexicons in the classifier is to use as one feature the total<br>count of occurrences of any words in the positive lexicon, and as a second feature the total count of occurrences of words in the negative lexicon. Using just two features results in classifiers that are much less sparse to small amounts of training data, and may generalize better. See <a href="http://www.inf.ed.ac.uk/teaching/courses/anlp/labs/lab8.html" target="_blank" rel="noopener">lab8</a>.</li></ul><h4 id="Naive-Bayes-Assumptions"><a href="#Naive-Bayes-Assumptions" class="headerlink" title="Naive Bayes Assumptions"></a>Naive Bayes Assumptions</h4><ul><li>Bags of words: a set of unordered words/features with its frequency in the documents, their order was ignored.</li><li>Conditional independence: the probabilities P(w|C) are independence given the class, thus a sequence of words(w1,w2,w3…) probability coculd be estimate via prducts of each P(wi|C) by walking through every pisition of the sequence, noted that the orders in the sequnce does not matter.</li></ul><h4 id="NB-Training"><a href="#NB-Training" class="headerlink" title="NB Training"></a>NB Training</h4><ul><li>Each classes’ prior probability P(C) is the percentage of the classes in the training set.</li><li>For the test set, its probability as a class j, is the products of its sequence probability P(w1, w2, w3…|Cj) and P(Cj), normalized by the sequence probability P(w1, w2, w3…), which could be calculated by summing all P(w1, w2, w3…|Cj)*P(Cj).</li><li>The joint features probability P(w1, w2, w3…|C) of each class is calculated by naively multiplying each word’s MLE given that class.</li><li>In practice, to deal with 0 probability, we dun use MLE, instead we use add alpha smoothing.<ul><li>Why 0 probability matters? Because it makes the whole sequence probability P(w1, w2, w3…|C) 0, then all the other features as evidence for the class are eliminated too.</li><li>How: first extract all the vocabulary V in the training set.</li><li>Then, for each feature/word k, its add alpha smoothing probability estimation within a class j is (Njk + alpha)/(Nj+V*alpha).</li><li>This is not the actual probability, but just the numerator.</li></ul></li></ul><h4 id="Naive-bayes-relationship-to-language-modelling"><a href="#Naive-bayes-relationship-to-language-modelling" class="headerlink" title="Naive bayes relationship to language modelling"></a>Naive bayes relationship to language modelling</h4><ul><li>When using all of the words as features for naive bayes, then each class in naive bayes is a unigram languange model.</li><li>For each word, assign probability P(word|C),</li><li>For each sentence, assign probability P(S|C) = P(w1,w2,w3…|C)</li><li>Running multiple languange models(classes) to assign probabilities, and pick out the highest language model.</li></ul><h3 id="Hidden-Markov-Model"><a href="#Hidden-Markov-Model" class="headerlink" title="Hidden Markov Model"></a>Hidden Markov Model</h3><ul><li>What: The HMM is a probabilistic sequence model: given a sequence of units (words, letters, morphemes, sentences, whatever), they compute a probability distribution over possible sequences of labels and choose the best label sequence.</li><li>parameter λ: A Transition probability matrix, B Emission probability</li><li>Application: part-of-speech tagging, name entity recognition(NEr), parse tree, speech recognition</li><li>Hidden: these tags, trees or words is not observed(hidden)</li><li>The three fundamental problems of HMM:<ul><li>decoding: discover the best hidden state sequnce via <a href="#viterbi-algorithm">Viterbi algorithm</a></li><li>Probability of the observation: Given an HMM with know parameters λ and an observation sequence O, determine the likelihood P(O| λ) (a language model regardless of tags) via <a href="#forward-algorithm">Forward algorithm</a></li><li>Learning: Given only the observed sequence, learn the best(MLE) HMM parameters λ via <a href="#forward-backward-algorithm">forward-backward algorithm</a>, thus <a href="#hmm-training">training a HMM</a> is an unsupervised learning task.</li></ul></li></ul><h4 id="Parts-of-speech-tagging"><a href="#Parts-of-speech-tagging" class="headerlink" title="Parts-of-speech tagging"></a>Parts-of-speech tagging</h4><ul><li>Parts-of-speech(POS), word classes, or syntactic categories, a description of eight parts-of-speech: noun, verb, pronoun, preposition, adverb, conjunction, participle, and article.</li><li>Motivation: Use model to find the best tag sequnce T for an untagged senetnce S: argmax P(T|S) -&gt; argmax P(S|T)*P(T), where P(T) is the  transition (prior) probabilities,  P(S|T) is the emission (likelihood) probabilities.</li><li>Parts-of-speech can be divided into two broad supercategories: <a href="#open-class-closed-class">closed class types and open class types</a></li><li>Search for the best tag sequnce: <a href="#viterbi-algorithm">Viterbi algorithm</a></li><li>evaluation: tag accuracy</li></ul><h5 id="Transition-probability-matrix"><a href="#Transition-probability-matrix" class="headerlink" title="Transition probability matrix"></a>Transition probability matrix</h5><ul><li>Tags or states</li><li>Each (i,j) represent the probability of moving from state i to j</li><li>When estimated from sequnces, should include beginning <s> and end<br></s> markers.</li><li>Tag transition probability matrix: the probability of tag i followed by j</li></ul><h5 id="Emission-probability"><a href="#Emission-probability" class="headerlink" title="Emission probability"></a>Emission probability</h5><ul><li>Also called observation likelihoods, each expressing the probability of an observation j being generated from a states i.</li><li>Word/symbol</li></ul><h5 id="Penn-Treebank"><a href="#Penn-Treebank" class="headerlink" title="Penn Treebank"></a>Penn Treebank</h5><p><img src="/images/Treebank.png" alt=""></p><h4 id="Viterbi-algorithm"><a href="#Viterbi-algorithm" class="headerlink" title="Viterbi algorithm"></a>Viterbi algorithm</h4><ul><li>Decoding task: the task of determining which sequence of variables is the underlying source of some sequence of observations.</li><li>Intuition: The probability of words w1 followed by w2 with tag/state i and j (i,j is index of all Tags), is the chain rule of the probability of i followed by j and the probability of i output wi P(w1|i) and P(w2 |j), then choose the maximum from all the possible i j. Then using chain rule to multiply the whole sequence of words.</li><li>The value of each cell Vt(j) is computed by recursively taking the most probable path that could lead us to this cell from left columns to right. See exampls in <a href="http://www.inf.ed.ac.uk/teaching/courses/anlp/labs/lab_solutions.html#Tutorial_2" target="_blank" rel="noopener">tutorial 2</a><br><img src="/images/viterbi.png" alt=""></li><li>Since HMM based on Markov Assumptions, so the present column Vt is only related with the nearby left column Vt-1.</li></ul><h4 id="Forward-algorithm"><a href="#Forward-algorithm" class="headerlink" title="Forward algorithm"></a>Forward algorithm</h4><ul><li>Compute the likelihood of a particular observation sequence.</li><li>Implementation is almost the same as Viterbi.</li><li>Yet Viterbi takes the max over the previous path probabilities whereas the forward algorithm takes the sum.</li></ul><h4 id="HMM-Training"><a href="#HMM-Training" class="headerlink" title="HMM Training"></a>HMM Training</h4><p>learning the parameters of an HMM</p><h5 id="Forward-backward-algorithm"><a href="#Forward-backward-algorithm" class="headerlink" title="Forward-backward algorithm"></a>Forward-backward algorithm</h5><ul><li>inputs: just the observed sequence</li><li>output: the converged λ(A,B).</li><li>For each interation k until λ converged:<ul><li>Compute expected counts using λ(k-1)</li><li>Set λ(k) using MLE on the expected counts.</li></ul></li></ul><h3 id="Context-free-grammar"><a href="#Context-free-grammar" class="headerlink" title="Context-free grammar"></a>Context-free grammar</h3><p>CFG(phrase-structure grammar) consists of a set of rules or productions, each of which expresses the ways that symbols of the language can be grouped and ordered toLexicon gether, and a lexicon of words and symbols.</p><h4 id="Probabilistic-Context-Free-Grammar"><a href="#Probabilistic-Context-Free-Grammar" class="headerlink" title="Probabilistic Context-Free Grammar"></a>Probabilistic Context-Free Grammar</h4><p>PCFG(Stochastic Context-Free Grammar SCFG (SCFG)), a probabilistic augmentation of context-free grammars in which each rule is associated with a probability.</p><ul><li>G = (T,N,S,R,P)<ul><li>T, N: Terminal and Non-terminal</li><li>S: starts symbol</li><li>R: Derive rule/grammar, N -&gt; N/C</li><li>P: a probability function, for a given N, ΣP(N-&gt;Ni/Ci)=1. Normally P(S-&gt;NP VP)=1, because this is the only rule for S.</li></ul></li><li>PCFG could generates a sentence/tree,<ul><li>thus it is a language model, assigns a probability to the string of words constituting a sentence</li><li>The probability of a tree t is the product of the probabilities of the rules used to generate it.</li><li>The probability of the string s is the sum of the probabilities of the trees/parses which have that string as their yield.</li><li>The probability of an ambiguous sentence is the sum of the probabilities of all the parse trees for the sentence.</li></ul></li><li>Application: Probabilistic parsing</li><li>Shortage: lack the lexicalization of a trigram model, i.e only a small fraction of the rules contains information about words. To solve this problem, use <a href="#lexicalization-of-pcfgs">lexicalized PCFGs</a></li></ul><h4 id="Lexicalization-of-PCFGs"><a href="#Lexicalization-of-PCFGs" class="headerlink" title="Lexicalization of PCFGs"></a>Lexicalization of PCFGs</h4><ul><li>The head word of phrase gives a good representation of the phrase’s structure and meaning</li><li>Puts the properties of words back into a PCFG</li><li>Word to word affinities are useful for certain ambiguities, because we know the probability of rule with words and words now, e.g. PP attachment ambiguity</li></ul><h4 id="Recursive-Descent-Parsing"><a href="#Recursive-Descent-Parsing" class="headerlink" title="Recursive Descent Parsing"></a>Recursive Descent Parsing</h4><ul><li>It is a top-down, depth-first parser:<ol><li>Blindly expand nonterminals until reaching a terminal (word).</li><li>If multiple options available, choose one but store current state<br>as a backtrack point (in a stack to ensure depth-first.)</li><li>If terminal matches next input word, continue; else, backtrack<br><img src="/images/Recursive_descent.png" alt=""></li></ol></li><li>can be massively inefficient (exponential in sentence length) if faced with local ambiguity</li><li>infinite loop</li></ul><h4 id="CKY-parsing"><a href="#CKY-parsing" class="headerlink" title="CKY parsing"></a>CKY parsing</h4><h5 id="Dynamic-programming"><a href="#Dynamic-programming" class="headerlink" title="Dynamic programming"></a>Dynamic programming</h5><h5 id="Well-formed-substring-table"><a href="#Well-formed-substring-table" class="headerlink" title="Well-formed substring table"></a>Well-formed substring table</h5><p>For parsing, subproblems are analyses of substrings, memoized in well-formed substring table(WFST, chart).</p><ul><li>Chart entries are indexed by start and end positions in the sentence, and correspond to:<ul><li>either a complete constituent (sub-tree) spanning those positions (if working bottom-up),</li><li>or a prediction about what complete constituent might be found (if working top-down).</li></ul></li><li>The chart is a matrix where cell [i, j] holds information about the word span from position i to position j:<ul><li>The root node of any constituent(s) spanning those words</li><li>Pointers to its sub-constituents</li><li>(Depending on parsing method,) predictions about what<br>constituents might follow the substring.</li></ul></li></ul><h5 id="Probability-CKY-parsing"><a href="#Probability-CKY-parsing" class="headerlink" title="Probability CKY parsing"></a>Probability CKY parsing</h5><p><img src="/images/CKY_proba1.png" alt=""><br><img src="/images/CKY_proba2.png" alt=""></p><h3 id="Noisy-channel-model"><a href="#Noisy-channel-model" class="headerlink" title="Noisy channel model:"></a>Noisy channel model:</h3><ul><li>The intuition of the noisy channel model is to treat the misspelled word as if a correctly spelled word had been “distorted” by being passed through a noisy communication channel.</li><li>a probability model using Bayesian inference, input -&gt; noisy/errorful encoding -&gt; output, see an observation x (a misspelled word) and our job is to find the word w that generated this misspelled word.</li><li><code>P(w|x) = P(x|w)\*P(w)/P(x)</code></li></ul><h4 id="Noisy-channel-model-of-spelling-using-naive-bayes"><a href="#Noisy-channel-model-of-spelling-using-naive-bayes" class="headerlink" title="Noisy channel model of spelling using naive bayes"></a>Noisy channel model of spelling using <a href="#nb-training">naive bayes</a></h4><ul><li>The noisy channel model is to maximize the product of likelihood(probability estimation) P(s|w) and the prior probability of correct words P(w). Intuitively it is modleing the noisy channel that turn a correct word ‘w’ to the misspelling.</li><li>The likelihood(probability estimation) P(s|w) is called the the channel/error model, telling if it was the word ‘w’, how likely it was to generate this exact error.</li><li>The P(w) is called the language model</li></ul><h2 id="DISCRIMINATIVE-PROBABILISTIC-MODELS"><a href="#DISCRIMINATIVE-PROBABILISTIC-MODELS" class="headerlink" title="DISCRIMINATIVE PROBABILISTIC MODELS"></a>DISCRIMINATIVE PROBABILISTIC MODELS</h2><p>Discriminative(conditional) models take the data as given, and put a probability over hidden structure given the data, P(c|d).</p><h3 id="Exponential-Log-linear-MaxEnt-Logistic-models"><a href="#Exponential-Log-linear-MaxEnt-Logistic-models" class="headerlink" title="Exponential (Log-linear, MaxEnt, Logistic) models"></a>Exponential (Log-linear, MaxEnt, Logistic) models</h3><p>Make probability model from the linear combination of weights λ and features f as votes, normalized by the total votes<img src="/images/softmax.png" alt="">.</p><ul><li>It is a probabilistic distribution: it estimates a probability for each class/label, aka Softmax.</li><li>It is a classifier, choose the highest probability label.</li><li>Application: dependency parsing actions prediction, text classification, <a href="#word-sense-disambiguation">Word sense disambiguation</a><br><img src="/images/discriminative.png" alt=""></li></ul><h4 id="Topics-categorization"><a href="#Topics-categorization" class="headerlink" title="Topics categorization"></a>Topics categorization</h4><h4 id="Training-discriminative-model"><a href="#Training-discriminative-model" class="headerlink" title="Training discriminative model"></a>Training discriminative model</h4><ul><li>Features in NLP are more general, they specify indicator function(a yes/no[0,1] boolean matching function) of properties of the input and each class.</li><li>Weights: low possibility features will associate with low/negative weight, vise versa.</li><li>Define features: Pick sets of data points d which are distinctive enough to deserve model parameters: related words, words contians #, words end with ing, etc.</li></ul><h4 id="Regularization-in-discriminative-model"><a href="#Regularization-in-discriminative-model" class="headerlink" title="Regularization in discriminative model"></a>Regularization in discriminative model</h4><p>The issue of scale:</p><ul><li>Lots of features</li><li>sparsity:<ul><li>easily overfitting: need smoothing</li><li>Many features seen in training never occur again in test</li></ul></li><li>Optimization problem: feature weights can be infinite, and iterative solvers can take a long time to get to those infinities. See <a href="http://www.inf.ed.ac.uk/teaching/courses/anlp/tutorials/anlp_t04-sol.pdf" target="_blank" rel="noopener">tutorial 4</a>.</li><li>Solution:<ul><li>Early stopping</li><li>Smooth the parameter via L2 regularization.</li><li>Smooth the data, like the add alpha smoothing, but hard to know what artificial data to create</li></ul></li></ul><h3 id="Generative-vs-Discriminative-Models"><a href="#Generative-vs-Discriminative-Models" class="headerlink" title="Generative vs. Discriminative Models"></a>Generative vs. Discriminative Models</h3><ul><li>Navie bayes models multi-count correlated evidence: each feature is multipled in, even when you have multiple features telling the same informaiton.</li><li>Maxent: solve this issue by weighting features so that model expectations match the observed(empirical) expectations.</li></ul><h2 id="LINGUISTIC-AND-REPRESENTATIONAL-CONCEPTS"><a href="#LINGUISTIC-AND-REPRESENTATIONAL-CONCEPTS" class="headerlink" title="LINGUISTIC AND REPRESENTATIONAL CONCEPTS"></a>LINGUISTIC AND REPRESENTATIONAL CONCEPTS</h2><h3 id="Regular-Expressions"><a href="#Regular-Expressions" class="headerlink" title="Regular Expressions"></a>Regular Expressions</h3><p>a language for specifying text search strings.</p><h3 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h3><ul><li>Parsing is a combination of recognizing an input string and assigning a <strong>correct</strong> linguistic structure/tree to it based on a grammar.</li><li>The Syntactic, Statistical parsing are constituent-based representations(context-free grammars).</li><li>The Dependency Parsing are based on dependency structure(dependency grammars).</li></ul><h4 id="Syntactic-Parsing"><a href="#Syntactic-Parsing" class="headerlink" title="Syntactic Parsing"></a>Syntactic Parsing</h4><p>Syntactic parsing, is the task of recognizing a sentence and assigning a correct syntactic structure to it.</p><ul><li>Syntactic parsing can be viewed as a search<ul><li>search space: all possible trees generated by the grammar</li><li>search guided by the structure of the space and the input.</li><li>search direction<ul><li>top-down: start with root category (S), choose expansions, build down to words.</li><li>bottom-up: build subtrees over words, build up to S.</li></ul></li><li>Search algorithm/strategy: DFS, BFS, Recursive descent parsing, CKY Parsing</li></ul></li><li>Challenge: Structual <a href="#ambiguity">Ambiguity</a></li></ul><h4 id="Statistical-Parsing"><a href="#Statistical-Parsing" class="headerlink" title="Statistical Parsing"></a>Statistical Parsing</h4><p>Or probabilistic parsing, Build probabilistic models of syntactic knowledge and use some of this probabilistic knowledge to build efficient probabilistic parsers.</p><ul><li>motivation: to solve the problem of disambiguation</li><li>algorithm: <a href="#probability-cky-parsing">probability CKY parsing</a></li><li>evaluation: Compare the output <strong>constituency</strong> parser with golden standard tree, a constituent(part of the output parser) marked as correct if it spans the same sentence positions with the corresponding constituent in golder standard tree. Then we get the <a href="#precision-recall-f-measure">precision, recall and F1 measure</a>.<ul><li>constituency: S-(0:10), NP-(0:2), VP-(0:9)…</li><li>Precission = (# correct constituents)/(# in parser output), recall = (# correct constituents)/(# in gold standard)</li><li>Not a good evaluation, because it higher order constituent is marked wrong simply it contains a lower level wrong constituent.</li></ul></li></ul><h4 id="Dependency-Parsing"><a href="#Dependency-Parsing" class="headerlink" title="Dependency Parsing"></a><a href="#dependency-parsing">Dependency Parsing</a></h4><h3 id="Constituency"><a href="#Constituency" class="headerlink" title="Constituency"></a>Constituency</h3><p>Phrase structure, organizes words into nested constituents. Groups of words behaving as a single units, or constituents.</p><ul><li>Noun phrase(NP), a sequence of words surrounding at least one noun. While the whole noun phrase can occur before a verb, this is not true of each of the individual words that make up a noun phrase</li><li>Preposed or Postposed constructions. While the entire phrase can be placed differently, the individual words making up the phrase cannot be.</li><li>Fallback: In languages with free word order, phrase structure<br>(constituency) grammars don’t make as much sense.</li><li>Headed phrase structure: many phrase has head, VP-&gt;VB, NP-&gt;NN, the other symbols excepct the head is modifyer.</li></ul><h3 id="Dependency"><a href="#Dependency" class="headerlink" title="Dependency"></a>Dependency</h3><ul><li>Dependency structure shows which words depend on (modify or are arguments of) which toehr words.</li><li>Motivation: In languages with free word order, phrase structure<br>(constituency) grammars don’t make as much sense. E.g. we may need both S → NP VP and S → VP NP, but could not tell too much information simply looking at the rule.</li><li>Dependencies: Identifies syntactic relations directly. The syntactic structure of a sentence is described solely in terms of the words (or lemmas) in a sentence and an associated set of directed binary grammatical relations that hold among the words.</li><li>Relation between phrase structure and dependency structure<ul><li>Convert phrase structure annotations to dependencies via head rules. (Convenient if we already have a phrase structure treebank.): For a given lexicalized constituency parse(CFG tree), remove the phrasal categories, remove the (duplicated) terminals,  and collapse chains of duplicates.</li><li>The closure of dependencies give constituency from a dependency tree</li></ul></li></ul><h4 id="Dependency-parsing"><a href="#Dependency-parsing" class="headerlink" title="Dependency parsing"></a>Dependency parsing</h4><ul><li>Motivation: find a final configuration where all the words have been accounted for and an appropriate dependency tree has been synthesized</li><li>Approach: Transition-based dependency parsing</li></ul><h4 id="Transition-based-dependency-parsing"><a href="#Transition-based-dependency-parsing" class="headerlink" title="Transition-based dependency parsing"></a>Transition-based dependency parsing</h4><p>transition-based systems use supervised machine learning methods to train classifiers that play the role of the oracle. Given appropriate training data, these methods learn a function that maps from configurations to transition operators(actions).</p><ul><li>Bottom up</li><li>Like shift-reduce parsing, but the ‘reduce’ actions are specialized to create dependencies with head on left or right.</li><li>configuration：consists of a stack, an input buffer of words or tokens, and a set of relations/arcs, a set of actions.</li><li>How to choose the next action: each action is predicted by a <a href="#discriminative-probability-models">discriminative classifier</a>(often SVM, could be maxent) over each legal move.<ul><li>features: a sequence of the correct (configuration, action) pairs f(c ; x).</li></ul></li><li>Evaluation: accuracy (# correct dependencies with or ignore label)).</li></ul><h4 id="Dependency-tree"><a href="#Dependency-tree" class="headerlink" title="Dependency tree"></a>Dependency tree</h4><ul><li>Dependencies from a CFG tree using heads, must be projective: There must not be any crossing dependency arcs when the words are laid out in their linear order, with all arcs above the words.</li><li>But dependency theory normally does allow non-projective structures to account for displaced constituents.</li></ul><h4 id="Bounded-and-unbounded-dependencies"><a href="#Bounded-and-unbounded-dependencies" class="headerlink" title="Bounded and unbounded dependencies"></a>Bounded and unbounded dependencies</h4><p>Unbounded dependency could be considered as long distance dependency</p><ul><li>Long-distance dependencies: contained in wh-non-subject-question, “What flights do you have from Burbank to Tacoma Washington?”, the Wh-NP <code>what flights</code> is far away from the predicate that it is semantically related to, the main verb <code>have</code> in the VP.</li></ul><h3 id="Ambiguity"><a href="#Ambiguity" class="headerlink" title="Ambiguity"></a>Ambiguity</h3><h4 id="Structural-ambiguity"><a href="#Structural-ambiguity" class="headerlink" title="Structural ambiguity"></a>Structural ambiguity</h4><p>Occurs when the grammar can assign more than one parse to a sentence.</p><h5 id="Attachment-ambiguity"><a href="#Attachment-ambiguity" class="headerlink" title="Attachment ambiguity"></a>Attachment ambiguity</h5><p>A sentence has an attachment ambiguity if a particular constituent can be attached to the parse tree at more than one place.</p><h5 id="Coordination-ambiguity"><a href="#Coordination-ambiguity" class="headerlink" title="Coordination ambiguity"></a>Coordination ambiguity</h5><p>different sets of phrases can be conjoined by a conjunction like and. E.g <code>green egg and bread</code>.</p><ul><li>Coordination: The major phrase types discussed here can be conjoined with conjunctions like <code>and, or, and but</code> to form larger constructions of the same type.</li></ul><h4 id="Global-and-local-ambiguity"><a href="#Global-and-local-ambiguity" class="headerlink" title="Global and local ambiguity"></a>Global and local ambiguity</h4><ul><li>global ambiguity: multiple analyses for a full sentence, like <code>I saw the man with the telescope</code></li><li>local ambiguity: multiple analyses for parts of sentence.<ul><li><code>the dog bit the child</code>: first three words could be NP (but aren’t).</li><li>Building useless partial structures wastes time.</li></ul></li></ul><h3 id="Morphology"><a href="#Morphology" class="headerlink" title="Morphology"></a>Morphology</h3><p>The study of wordforms and word formation.</p><h4 id="Challenge-of-rich-Morphology"><a href="#Challenge-of-rich-Morphology" class="headerlink" title="Challenge of rich Morphology"></a>Challenge of rich Morphology</h4><p>For a morphologically rich language, many issues would arise because of the morphological complexity.</p><ul><li>These productive word-formation processes result in a large vocabulary for these languages</li><li>Large vocabularies mean many unknown words, and these unknown words cause significant performance degradations in a wide variety of languages</li><li>For POS, augmentations become necessary when dealing with highly inflected or agglutinative languages with rich morphology like Czech, Hungarian and Turkish., part-of-speech taggers for morphologically rich languages need to label words with case and gender information. Tagsets for morphologically rich languages are therefore sequences of morphological tags rather than a<br>single primitive tag.</li><li>Dependency grammar is better than constituency in dealing with languages that are morphologically rich。</li></ul><h4 id="morphemes"><a href="#morphemes" class="headerlink" title="morphemes"></a>morphemes</h4><p>The way words are built up from smaller meaning-bearing units.</p><h4 id="Lemma"><a href="#Lemma" class="headerlink" title="Lemma"></a>Lemma</h4><ul><li>Lexeme, refers to the set of all the forms that have the same meaning,</li><li>lemma refers to the particular form that is chosen by convention to represent the lexeme.</li><li>E.g: <code>run, runs, ran, running</code> are forms of the same lexeme, with run as the lemma.</li></ul><h4 id="Affixes"><a href="#Affixes" class="headerlink" title="Affixes"></a>Affixes</h4><p>Adding additional meanings of various kinds. “+ed, un+”</p><ul><li>suffix : follow the stem<ul><li>Plural of nouns ‘cat+s’</li></ul><ol><li>Comparative and superlative of adjectives ‘small+er’ </li><li>Formation of adverbs ‘great+ly’</li><li>Verb tenses ‘walk+ed’ </li><li>All inflectional morphology in English uses suffixes</li></ol></li><li>Prefix: precede the stem<ul><li>In English: these typically change the meaning </li></ul><ol><li>Adjectives ‘un+friendly’, ‘dis+interested’</li><li>Verbs ‘re+consider’</li><li>Some language use prefixing much more widely</li></ol></li><li>Infix: inserted inside the stem</li><li>Circumfix: do both(follow, precede)</li></ul><h4 id="Morphological-parsing"><a href="#Morphological-parsing" class="headerlink" title="Morphological parsing"></a>Morphological parsing</h4><p>Method: Finite-state transducers</p><h5 id="Finite-state-transducers"><a href="#Finite-state-transducers" class="headerlink" title="Finite-state transducers"></a>Finite-state transducers</h5><p>FST, a transducer maps between one representation and another; It is a kind of FSA which maps between two sets of symbols.</p><h4 id="Root"><a href="#Root" class="headerlink" title="Root"></a>Root</h4><ul><li>Root, stem and base are all terms used in the literature to designate that part of a word that remains when all affixes have been removed.</li><li>The root word is the primary lexical unit of a word, and of a word family (this root is then called the base word), which carries the most significant aspects of semantic content and cannot be reduced into smaller constituents.</li><li>E.g: In the form ‘untouchables’ the root is ‘touch’, to which first the suffix ‘-able’, then the prefix ‘un-‘ and finally the suffix ‘-s’ have been added. In a compound word like ‘wheelchair’ there are two roots, ‘wheel’ and ‘chair’.</li></ul><h4 id="Stem"><a href="#Stem" class="headerlink" title="Stem"></a>Stem</h4><ul><li>Stem is of concern only when dealing with inflectional morphology</li><li>Stemming: reduce terms to their stems in info retrieval,</li><li>E.g: In the form ‘untouchables’ the stem is ‘untouchable’, ‘touched’ -&gt; ‘touch’; ‘wheelchairs’ -&gt; ‘wheelchair’.</li></ul><h4 id="Inflectional"><a href="#Inflectional" class="headerlink" title="Inflectional"></a>Inflectional</h4><ul><li>nouns for count (plural: +s) and for possessive case (+’s) </li><li>verbs for tense (+ed, +ing) and a special 3rd person singular present form (+s) </li><li>adjectives in comparative (+er) and superlative (+est) forms.</li></ul><h4 id="Derivational"><a href="#Derivational" class="headerlink" title="Derivational"></a>Derivational</h4><ul><li>Changing the part of speech, e.g. noun to verb: ‘word → wordify’</li><li>Changing the verb back to a noun</li><li>Nominalization: formation of new nouns, often verbs or adjectives</li></ul><h4 id="Inflectional-Morphology-vs-Derivational-Morphology"><a href="#Inflectional-Morphology-vs-Derivational-Morphology" class="headerlink" title="Inflectional Morphology vs. Derivational Morphology"></a>Inflectional Morphology vs. Derivational Morphology</h4><p>Inflectional:</p><ul><li>does not change basic meaning or part of speech</li><li>expresses grammatical features or relations between words </li><li>applies to all words of the same part of speech </li></ul><p>Derivational:</p><ul><li>may change the part of speech or meaning of a word</li><li>is not driven by syntactic relations outside the word </li><li>applies closer to the stem; whereas inflection occurs at word edges: govern+ment+s, centr+al+ize+d</li></ul><h3 id="Open-class-Closed-class"><a href="#Open-class-Closed-class" class="headerlink" title="Open-class Closed-class"></a>Open-class Closed-class</h3><h4 id="Closed"><a href="#Closed" class="headerlink" title="Closed"></a>Closed</h4><p>Closed classes are those with relatively fixed membership</p><ul><li>prepositions: on, under, over, near, by, at, from, to, with</li><li>determiners: a, an, the</li><li>pronouns: she, who, I, others</li><li>conjunctions: and, but, or, as, if, when</li><li>auxiliary verbs: can, may, should, are</li><li>particles: up, down, on, off, in, out, at, by</li><li>numerals: one, two, three, first, second, third</li></ul><h4 id="Open"><a href="#Open" class="headerlink" title="Open"></a>Open</h4><ul><li>Nouns, verbs, adjectives, adverbs</li></ul><h3 id="Word-sense"><a href="#Word-sense" class="headerlink" title="Word sense"></a>Word sense</h3><p>A discrete representation of an aspect of a word’s meaning.<br>How: <a href="#distributional-semantic-models">Distributional semantic models</a></p><h4 id="Word-sense-disambiguation"><a href="#Word-sense-disambiguation" class="headerlink" title="Word sense disambiguation"></a>Word sense disambiguation</h4><p>WSD, The task of selecting the correct sense for a word, formulated as a classification task.</p><ul><li>Chose features: Directly neighboring words, content words, syntactically related words, topic of the text, part-of-speech tag, surrounding part-of-speech tags, etc …</li></ul><h4 id="Collocation"><a href="#Collocation" class="headerlink" title="Collocation"></a>Collocation</h4><p>A sequence of words or terms that co-occur more often than would be expected by chance.</p><h4 id="Lexical-semantic-relationships"><a href="#Lexical-semantic-relationships" class="headerlink" title="Lexical semantic relationships"></a>Lexical semantic relationships</h4><p>Relations between word senses</p><h5 id="synonym"><a href="#synonym" class="headerlink" title="synonym"></a>synonym</h5><p>代名词, When two senses of two different words (lemmas) are identical, or nearly identical, the two senses are synonyms. E.g. couch/sofa vomit/throw up filbert/hazelnut car/automobile</p><h5 id="hyponym"><a href="#hyponym" class="headerlink" title="hyponym"></a>hyponym</h5><p>下义词, One sense is a hyponym of another sense if the first sense is more specific, denoting a subclass of the other. E.g. car is a hyponym of vehicle; dog is a hyponym of animal, and mango is a hyponym of fruit.</p><h5 id="hypernym"><a href="#hypernym" class="headerlink" title="hypernym"></a>hypernym</h5><p>Superordinate, 上位词, vehicle is a hypernym of car, and animal is a hypernym of dog.</p><h5 id="similarity"><a href="#similarity" class="headerlink" title="similarity"></a>similarity</h5><p>Or distance, a looser metric than synonymy.<br>Two ways to measure similarity:</p><ul><li>Thesaurus词库-based: are words nearby in hypernym hierarchy? Do words have similar definitions?</li><li>Distributional: do words have similar distributional contexts</li></ul><h3 id="Distributional-semantic-models"><a href="#Distributional-semantic-models" class="headerlink" title="Distributional semantic models"></a>Distributional semantic models</h3><p>Vector semantics(embeddings): The meaning of a word is represented as a vector.</p><ul><li>Two words are similar if they have similar word contexts vector.</li><li>Term-context matrix(Co-occurrence    Matrices): a word/term is defined by a vector over counts of context words. The row represent words, columns contexts.<ul><li>Problem: simple frequency isn’t the best measure of association between words. One problem is that raw frequency is very skewed and not very discriminative. “the” and “of” are very frequent, but maybe not the most discriminative.</li><li>Sulution: use <a href="#pointwise-mutual-information">Pointwise mutual information</a>. Then the Co-occurrence    Matrices is filled with PPMI, instead of raw counts.</li></ul></li><li>Measuring vectors similarity based on PPMI:<ul><li>Dot product(inner product): More frequent words will have higher dot products, which cause similarity sensitive to word frequency.</li><li>Cosine: normalized dot product <img src="/images/cos.png" alt="Cosine">, Raw frequency or PPMI is non-negative, so cosine range [0,1].</li></ul></li><li>Evaluation of similarity<ul><li>Intrinsic: <a href="#correlation">correlation</a> between algorithm and human word similarity ratings.</li><li>Check if there is <a href="#correlation">correlation</a> between similarity measures and word frequency.</li></ul></li><li>Application: sentiment analysis, see <a href="http://www.inf.ed.ac.uk/teaching/courses/anlp/labs/lab8.html" target="_blank" rel="noopener">lab8</a></li></ul><h4 id="Pointwise-mutual-information"><a href="#Pointwise-mutual-information" class="headerlink" title="Pointwise mutual information"></a>Pointwise mutual information</h4><p>PMI: do events x and y co-occur more than if they were independent?</p><ul><li>PMI between two words: <img src="/images/PMI.png" alt="PMI"></li><li>Compute PMI on a term-context matrix(using counts):<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PMI(x, y) = log2( N·C(x, y)/C(x)C(y) )</span><br><span class="line">p(w=information,c=data)= 6/19</span><br><span class="line">p(w=information) = 11/19</span><br><span class="line">p(c=data) = 7/19</span><br><span class="line">PMI(information,data) = log2(6\*19/(11\*7))</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/PMI_counts.png" alt="PMI"></p><ul><li>PMI is biased towards infrequent events, solution:<ul><li>Add-one smoothing<h5 id="PPMI"><a href="#PPMI" class="headerlink" title="PPMI"></a>PPMI</h5>Positive PMI, could better handle low frequencies<br><code>PPMI = max(PMI,0)</code></li></ul></li></ul><h4 id="t-test"><a href="#t-test" class="headerlink" title="t-test"></a>t-test</h4><p>The t-test statistic, like PMI, can be used to measure how much<br>more frequent the association is than chance.</p><ul><li>The t-test statistic computes the difference between observed and expected means, normalized by the variance.</li><li>The higher the value of t, the greater the likelihood that we can reject the null hypothesis.</li><li>Null hypothesis: the two words are independent, and hence P(a,b) = P(a)P(b) correctly models the relationship between the two words.<br><img src="/images/t_test.png" alt="t-test"></li></ul><h4 id="Minimum-Edit-Distance"><a href="#Minimum-Edit-Distance" class="headerlink" title="Minimum Edit Distance"></a>Minimum Edit Distance</h4><p>the minimum number of editing operations (operations like insertion, deletion, substitution) needed to transform one string into another.<br>Algorithm: searching the shortest path, use Dynamic programming to avoid repeating, (use BFS to search the shortest path?)</p><h4 id="WordNet"><a href="#WordNet" class="headerlink" title="WordNet"></a><a href="http://wordnetweb.princeton.edu/perl/webwn" target="_blank" rel="noopener">WordNet</a></h4><p>A hierarchically organizesd lexical database, resource for English sense relations</p><ul><li>Synset: The set of near-synonyms for a WordNet sense (for synonym set)</li></ul><h3 id="Topic-modelling"><a href="#Topic-modelling" class="headerlink" title="Topic modelling"></a>Topic modelling</h3><p>Instead of using supervised topic classification – rather not fix topics in advance nor do manual annotation, Use clustering to teases out the topics. Only the number of topics is specified in advance.</p><ul><li>Latent Dirichlet allocation(LDA): each document may be viewed as a mixture of various topics where each document is generated by LDA.</li><li>A topic is a distribution over words</li><li>generate document:<ol><li>Randomly choose a distribution over topics</li><li>For each word in the document<ol><li>randomly choose a topic from the distribution over topics</li><li>randomly choose a word from the corresponding topic (distribution over the vocabulary)</li></ol></li></ol></li><li>training: repeat until converge<ol><li>assign each word in each document to one of T topics.</li><li>For each document d, go through each word w in d and for each topic t, compute: p(t|d), P(w|t)</li><li>Reassign w to a new topic, where we choose topic t with probability P(w|t)xP(t|d)</li></ol></li></ul><h3 id="Meaning-representation-language"><a href="#Meaning-representation-language" class="headerlink" title="Meaning representation language"></a>Meaning representation language</h3><p>The symbols in our meaning representations correspond to objects, properties, and relations in the world.</p><ul><li>Qualifications of MRL:<ul><li>Canonical form: sentences with the same (literal) meaning should have the same MR.</li><li>Compositional: The meaning of a complex expression is a function of the meaning of its parts and of the rules by which they are combined.</li><li>Verifiable: Can use the MR of a sentence to determine whether the sentence is true with respect to some given model of the world.</li><li>Unambiguous: an MR should have exactly one interpretation.</li><li>Inference: we should be able to verify sentences not only directly, but also by drawing conclusions based on the input MR and facts in the knowledge base.</li><li>Expressivity: the MRL should allow us to handle a wide range of meanings and express appropriate relationships between the words in a sentence.</li></ul></li><li>Good MRL: First-order Logic</li></ul><h4 id="First-order-Logic"><a href="#First-order-Logic" class="headerlink" title="First-order Logic"></a>First-order Logic</h4><p>FOL, Predicate logic, meets all of the MRL qualifications except compositionality.</p><ul><li>Expressions are constructed from terms:<ul><li>constant and variable symbols that represent entities</li><li>function symbols that allow us to indirectly specify entities</li><li>predicate symbols that represent properties of entities and relations between entities</li></ul></li><li>Terms can be combined into predicate-argument structures<ul><li>Logical connectives: ∨ - or, ∧ - and, ¬, ⇒</li><li>Quantifiers: ∀ (universal quantifier, i.e., “for all”), ∃ (existential<br>quantifier, i.e. “exists”)</li></ul></li><li>Predicates in FOL<ul><li>Predicates with multiple arguments represent relations between entities: member-of(UK, EU)</li><li>“/N” to indicate that a predicate takes N arguments: member-of/2</li></ul></li><li>Variables in FOL<ul><li>An expression consisting only of a predicate with a variable among its arguments is interpreted as a set: likes(x, Gim) is the set of entities that like Gim.</li><li>A predicate with a variable among its arguments only has a truth value if it is bound by a quantifier: ∀x.likes(x, Gim) has an interpretation as either true or false.</li><li>Universal Quantifier (∀): Cats are mammals has MR ∀x.cat(x) ⇒ mammal(x)</li><li>Existential Quantifier (∃): Used to express that a property/relation is true of some entity, without specifying which one: Marie owns a cat has MR ∃x.cat(x) ∧ owns(Marie,x)</li></ul></li></ul><h4 id="Lambda-λ-Expression"><a href="#Lambda-λ-Expression" class="headerlink" title="Lambda λ Expression"></a>Lambda λ Expression</h4><p>Extend FOL, to work with ‘partially constructed’ formula, Compositionality.</p><ul><li>E.g.： λx.sleep(x) is the function that takes an entity x to the FOL expression sleep(x). λx.sleep(x)(Marie) -&gt; sleep(Marie)</li><li>Verbal (event) MRs： <code>λz. λy. λx. Giving1(x,y,z) (book)(Mary)(John) -&gt; Giving1(John, Mary, book) -&gt; John gave Mary a book</code></li><li>Problem:<ul><li>fixed arguments</li><li>Requires separate <code>Giving</code> predicate for each syntactic subcategorisation frame(number/type/position of arguments).</li><li>Separate predicates have no logical relation: if <code>Giving3(a, b, c, d, e)</code> is true, what about <code>Giving2(a, b, c, d)</code> and <code>Giving1(a, b, c)</code>.</li></ul></li><li>Solution: Reification of events 事件具象化</li></ul><h4 id="Reification-of-events"><a href="#Reification-of-events" class="headerlink" title="Reification of events"></a>Reification of events</h4><p><code>John gave Mary a book -&gt; ∃e, z. Giving(e) ∧ Giver(e, John) ∧ Givee(e, Mary)∧ Given(e,z) ∧ Book(z)</code></p><ul><li>Reify: to “make real” or concrete, i.e., give events the same status as<br>entities.</li><li>In practice, introduce variables for events, which we can quantify over</li><li>Entailment relations: automatically gives us logical entailment relations between events<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[John gave Mary a book on Tuesday] -&gt; [John gave Mary a book]</span><br><span class="line">∃ e, z. Giving(e) ∧ Giver(e, John) ∧ Givee(e, Mary) ∧ Given(e,z) ∧ Book(z) ∧ Time(e, Tuesday)</span><br><span class="line">-&gt;</span><br><span class="line">∃ e, z. Giving(e) ∧ Giver(e, John) ∧ Givee(e, Mary) ∧ Given(e,z) ∧ Book(z)</span><br></pre></td></tr></table></figure></li></ul><h3 id="Semantic-Parsing"><a href="#Semantic-Parsing" class="headerlink" title="Semantic Parsing"></a>Semantic Parsing</h3><p>Aka semantic analysis. Systems for mapping from a text string to any logical form.</p><ul><li>Motivation: deriving a meaning representation from a sentence.</li><li>Application: question answering</li><li>Method: Syntax driven semantic analysis with semantic attachments</li></ul><h4 id="Syntax-Driven-Semantic-Analysis"><a href="#Syntax-Driven-Semantic-Analysis" class="headerlink" title="Syntax Driven Semantic Analysis"></a>Syntax Driven Semantic Analysis</h4><ul><li>Principle of compositionality: the construction of constituent meaning is derived from/composed of the meaning of the constituents/words within that constituent, guided by word order and syntactic relations.</li><li>Build up the MR by augmenting CFG rules with semantic composition rules. Add semantic attachments to CFG rules.</li><li>Problem: encounter invalide FOL for some (base-form) MR, need type-raise.</li><li>Training</li></ul><h4 id="Semantic-attachments"><a href="#Semantic-attachments" class="headerlink" title="Semantic attachments"></a>Semantic attachments</h4><p>E.g<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VP → Verb NP : &#123;Verb.sem(NP.sem)&#125;</span><br><span class="line">Verb.sem = λy. λx. ∃e. Serving(e) ∧ Server(e, x) ∧ Served(e, y)</span><br><span class="line">NP.sem = Meat</span><br><span class="line">-&gt;</span><br><span class="line">VP.sem = λy. λx. ∃e. Serving(e) ∧ Server(e, x) ∧ Served(e, y) (Meat)</span><br><span class="line">= λx. ∃e. Serving(e) ∧ Server(e, x) ∧ Served(e, Meat)</span><br></pre></td></tr></table></figure></p><p>The MR for VP, is computed by applying the MR function to VP’s children.</p><p>Complete the rule:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S → NP VP : &#123;VP.sem(NP.sem)&#125;</span><br><span class="line">VP.sem = λx. ∃e. Serving(e) ∧ Server(e, x) ∧ Served(e, Meat)</span><br><span class="line">NP.sem = AyCaramba</span><br><span class="line">-&gt;</span><br><span class="line">S.sem = λx. ∃e. Serving(e) ∧ Server(e, x) ∧ Served(e, Meat) (AyCa.)</span><br><span class="line">= ∃e. Serving(e) ∧ Server(e, AyCaramba) ∧ Served(e, Meat)</span><br></pre></td></tr></table></figure></p><h4 id="Lexical-semantics"><a href="#Lexical-semantics" class="headerlink" title="Lexical semantics"></a>Lexical semantics</h4><p>the meaning of individual words.</p><h2 id="EVALUATION-CONCEPTS-AND-METHODS"><a href="#EVALUATION-CONCEPTS-AND-METHODS" class="headerlink" title="EVALUATION CONCEPTS AND METHODS"></a>EVALUATION CONCEPTS AND METHODS</h2><h3 id="Instrinsic-vs-extrinsic-evaluation"><a href="#Instrinsic-vs-extrinsic-evaluation" class="headerlink" title="Instrinsic vs. extrinsic evaluation"></a>Instrinsic vs. extrinsic evaluation</h3><h4 id="Extrinsic"><a href="#Extrinsic" class="headerlink" title="Extrinsic"></a>Extrinsic</h4><p>Use something external to measure the model. End-to-end evaluation, the best way to evaluate the performance of a language model is to embed it in an application and measure how much the application improves.</p><ol><li>Put each model in a task: spelling corrector, speech recognizer, MT system</li><li>Run the task, get an accuracy for A and for B<ul><li>How many misspelled words corrected properly</li><li>How many words translated correctly</li></ul></li><li>Compare accuracy for A and B</li></ol><p>Unfortunately, running big NLP systems end-to-end is often very expensive.</p><h4 id="Intrinsic"><a href="#Intrinsic" class="headerlink" title="Intrinsic"></a>Intrinsic</h4><p>Measures independenly to any application. Train the parameters of both models on the training set, and then compare how well the two trained models fit the test set. Which means whichever model assigns a higher probability to the test set</p><h3 id="Perplexity"><a href="#Perplexity" class="headerlink" title="Perplexity"></a>Perplexity</h3><ul><li>It is intrinsic.</li><li>Intuition based on Shannon game:The best language model is one that best predicts an unseen test set(e.g. next word), gives the highest P(sentence) to the word that actually occurs.</li><li>Definition： Perplexity is the inverse probability of the test set, normalized by the number of words(lie between 0-1).</li><li><img src="/images/perplexity.png" alt="Use log probability"></li><li>So minimizing perplexity is the same as maximizing probability</li><li>Cannot divide 0, so use <a href="#smoothing">smoothing</a>.</li><li>Bad approximation: unless the test data looks just like the training data, so generally only useful in pilot experiments.</li></ul><h3 id="Human-evaluation"><a href="#Human-evaluation" class="headerlink" title="Human evaluation"></a>Human evaluation</h3><p>E.g to know whether the email is actually spam or not, i.e. the human-defined labels for each document that we are trying to<br>gold labels match. We will refer to these human labels as the <strong>gold labels</strong>.</p><h3 id="Precision-Recall-F-measure"><a href="#Precision-Recall-F-measure" class="headerlink" title="Precision, Recall, F-measure"></a>Precision, Recall, F-measure</h3><ul><li>To deal with unbalanced lables</li><li>Application: <a href="#text-classification">text classification</a>, parsing.</li><li>Evaluation in text classification: the 2 by 2 contingency table<img src="/images/Contingency.png" alt="contingency table">, golden lable is true or false, the classifier output is positive or negative.</li></ul><h4 id="Precision"><a href="#Precision" class="headerlink" title="Precision"></a>Precision</h4><p>% of positive items that are golden correct, from the view of classifier</p><h4 id="Recall"><a href="#Recall" class="headerlink" title="Recall"></a>Recall</h4><p>% of golden correct items that are positive, from the view of test set.</p><h4 id="F-measure"><a href="#F-measure" class="headerlink" title="F-measure"></a>F-measure</h4><ul><li>Motivation: there is tradeoff between precision and recall, so we need a combined meeasure that assesses the P/R tradeoff.</li><li>The b parameter differentially weights the importance of recall and precision, based perhaps on the needs of an application. Values of b &gt; 1 favor recall, while values of b &lt; 1 favor precision.</li><li>Balanced F1 measure with beta =1, F = 2PR/(P+R)</li></ul><h4 id="Confusion-matrix"><a href="#Confusion-matrix" class="headerlink" title="Confusion matrix"></a>Confusion matrix</h4><p>Recalled that confusion matrix’s row represent golden label, column represent the classifier’s output, to anwser the quesion：for any pair of classes(c1,c2), how many test sample from c1 were incorrectly assigned to c2&gt;</p><ul><li>Recall: Fraction of samples in c1 classified correctly, CM(c1,c1)/sum(CM(c1,:))</li><li>Precision: fraction of samples assigned c1 that are actually c1, CM(c1,c1)/sum(CM(:,c1))</li><li>Accuracy: sum of diagnal / all</li></ul><h3 id="Correlation"><a href="#Correlation" class="headerlink" title="Correlation"></a>Correlation</h3><p>When two sets of data are strongly linked together we say they have a High Correlation.<br>Correlation is Positive when the values increase together, and Correlation is Negative when one value decreases as the other increases.</p><ul><li>Pearson correlation: covariance of the two variables divided by the product of their standard deviations.<img src="/images/Pearson.png" alt="Pearson"></li><li>Spearman correlation: the Pearson correlation between the rank values of the two variables</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自然语言处理入门，概念汇总。&lt;/p&gt;
&lt;p&gt;References:&lt;br&gt;&lt;a href=&quot;http://www.inf.ed.ac.uk/teaching/courses/anlp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Accelerated natural language processing 爱丁堡大学&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.inf.ed.ac.uk/teaching/courses/anlp/review/review_ay17.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ANLP revision guide&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://web.stanford.edu/~jurafsky/NLPCourseraSlides.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JM NLP, Stanford&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="人工智能" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 11 - Java | 测试 Testing - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-11-testing/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-11-testing/</id>
    <published>2018-01-29T00:00:00.000Z</published>
    <updated>2018-01-30T21:39:24.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>如何知道自己的程序是否真的在工作？在现实世界中，程序员相信他们的代码，因为代码通过了他们自己编写的测试。常用的测试有 Ad Hoc Testing， Unit test 和 Integration Testing。</p><p>Ad Hoc Testing，是指没有计划和记录的软件测试，除非发现缺陷，不然一般只运行一次。</p><h3 id="Unit-test"><a href="#Unit-test" class="headerlink" title="Unit test"></a>Unit test</h3><p>程序可分解为单元（或程序中可测试的最小部分），它严格测试代码的每个单元，最终确保项目正确运行。<br>好处是：</p><ol><li>Unit test 保证良好的代码结构（每个 method “只打一份工”），帮助我们较好地解析任务，</li><li>允许我们考虑每个方法的所有边界情况，并单独测试它们。</li><li>让我们每次只专注于一个单元，进行测试，debug，对准确度有信心后，再进行下一个单元的开发。相比于一次性写完所有代码，再测试debug，Unit test 减少了 debugging 时间。</li></ol><p>坏处是：</p><ol><li>测试也要花时间</li><li>测试本身也是有可能出错的，测试可能不全面，不规范，或者有bug</li><li>有些单元是依赖于其他单元的</li><li>Unit testing 无法保证各个模块的交互，无法保证整个系统作为一个整体是否正常工作。</li></ol><h4 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h4><p>JUnit是一个给Java做测试的框架，由Erich Gamma（Design Patterns）和Kent Beck（eXtreme Programming）编写。<br>JUnit使用Java的 reflection 功能（Java程序可以检查自己的代码）和注释。<br>JUnit允许我们：</p><ul><li>定义并执行测试和测试套件</li><li>使用测试作为规范的有效手段</li><li>使用测试来支持重构</li><li>将修改的代码集成到构建中<br>JUnit可用于多个IDE，例如BlueJ，JBuilder和Eclipse在一定程度上具有JUnit集成。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(&lt;expected&gt;, &lt;actual&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>assertEquals</code>测试一个变量的实际值是否等于它的期望值。<br>JUnit test 各个测试方法，必须是非静态的（JUnit的设计人员设计规定的）。</p><h3 id="Integration-Testing"><a href="#Integration-Testing" class="headerlink" title="Integration Testing"></a>Integration Testing</h3><p>鉴于 Unit testing 无法保证，有交互的多个模块，作为一个整体是否正常工作。<br>我们可能需要 integration testing，把各个模块合并，作为一个组合，进行测试（也可以把 Unit test 组合起来变成 integration testing）。</p><p>Integration testing 一般都比较麻烦，也不容易自动化，而且一般是在比较高的抽象层进行测试，可能会漏掉微小的错误。</p><p>当把所有模块都作为一个整体，也就是整个系统作为测试对象时，就是 system testing。</p><h3 id="Test-driven-development"><a href="#Test-driven-development" class="headerlink" title="Test driven development"></a>Test driven development</h3><p>TDD开发步骤：</p><ol><li>明确一项新功能需求。</li><li>为该功能编写 Unit test。</li><li>运行测试，<font color="red">按理应该无法通过测试</font>（因为还没写功能程序）。</li><li>编写通过实现该功能的代码，<font color="green">通过测试</font>。</li><li>可选：重构代码，使其更快，更整洁等等。</li></ol><p><img src="http://www.pathfindersolns.com/wp-content/uploads/2012/05/red-green-refactorFINAL2.png" alt="source from http://ryantablada.com/post/red-green-refactor---a-tdd-fairytale " title="image from: http://ryantablada.com/post/red-green-refactor---a-tdd-fairytale"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h2&gt;&lt;p&gt;如何知道自己的程序是否真的在工作？在现实世界中，程序员相信他们的代码，因为代码通过了他们自己编写的测试。常用的测试有 Ad Hoc Test
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 10 - Java | LinkedList 还是 ArrayList - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-10-java-which-list/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-10-java-which-list/</id>
    <published>2018-01-28T00:00:00.000Z</published>
    <updated>2018-01-29T15:28:10.619Z</updated>
    
    <content type="html"><![CDATA[<p>Java 提供了 <code>ArrayList</code>, <code>ArrayDeque</code> 和 <code>LinkedList</code> 几个API.<br>队列 queue, 通俗的含义, 就是不能插队, 只能在末尾插入.<br>Deque 就是双端队列 Double Ended Queue。双端队列是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩<a href="http://www.cplusplus.com/reference/deque/deque/" target="_blank" rel="noopener">（定义来源 cplusplus.com）</a>.</p><p>CS61b的<a href="http://sp18.datastructur.es/materials/proj/proj1a/proj1a" target="_blank" rel="noopener">project 1a</a>就是实现两种双端队列（array based 和 linkedklist based）.</p><p>不同的API, 在考虑什么时候应该用哪个时, 我们需要考虑它们的性能差异:</p><ul><li>搜索/定位：与<code>LinkedList</code>搜索操作相比，<code>ArrayList</code>搜索操作更快。 <code>ArrayList</code>的<code>get(int index)</code>性能是<code>O(1)</code>的，而LinkedList的性能是<code>O(n)</code>。因为<code>ArrayList</code>基于<code>array</code>数据结构，可以直接用靠 array index 索引元素。</li><li>删除/插入：<code>LinkedList</code> 操作性能是<code>O(1)</code>，而<code>ArrayList</code>的性能从<code>O(n)</code>（删除/插入第一个元素）到<code>O(n)</code>（最后一个元素）都有可能。因为<code>LinkedList</code>的每个元素都包含两个指向其相邻前后元素的指针（地址），因此仅需要改变，被删节点的<code>prev</code>和<code>next</code>指针位置。而在<code>ArrayList</code>中，需要移动剩余元素，来重新填充<code>array</code>空间。</li><li>内存开销：<code>LinkedList</code>的每个元素都有更多的内存开销(额外的指针), 而<code>ArrayLists</code>没有这个开销。但是，<code>ArrayLists</code>需要占用初始容量。一般<code>ArrayList</code>的默认初始容量非常小（Java 1.4 - 1.8使用10）。但是，往<code>ArrayLists</code>添加元素时， 它可能会适当地增大容量，所以如果添加了很多元素，则必须不断调整数组的大小，那样也可能会导致元素频繁挪动位置。</li></ul><p>综上所述：</p><ol><li>如果在应用中需要频繁插入和删除，那么选择<code>LinkedList</code>。</li><li>假如一开始，就知道后面要添加大量元素，那就使用较高的初始容量来构造<code>ArrayList</code>。</li><li>大部分用例中, 相比LinkedList, 人们更偏爱ArrayList以及ArrayDeque。如果你不确定应该选哪个, 那么就直接考虑ArrayList吧(<a href="https://stackoverflow.com/questions/322715/when-to-use-linkedlist-over-arraylist" target="_blank" rel="noopener">参考</a>).</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 提供了 &lt;code&gt;ArrayList&lt;/code&gt;, &lt;code&gt;ArrayDeque&lt;/code&gt; 和 &lt;code&gt;LinkedList&lt;/code&gt; 几个API.&lt;br&gt;队列 queue, 通俗的含义, 就是不能插队, 只能在末尾插入.&lt;br&gt;Deque 就
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>抽象编程 - C++ 算法与数据结构 Stanford cs106b</title>
    <link href="http://yoursite.com/NOTE-CS106B-Programming-Abstractions-Stanford/"/>
    <id>http://yoursite.com/NOTE-CS106B-Programming-Abstractions-Stanford/</id>
    <published>2018-01-23T00:00:00.000Z</published>
    <updated>2018-01-23T22:18:26.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Note-CS106B-Stanford-Programming-Abstractions"><a href="#Note-CS106B-Stanford-Programming-Abstractions" class="headerlink" title="Note CS106B Stanford Programming Abstractions"></a>Note <a href="https://see.stanford.edu/Course/CS106B" target="_blank" rel="noopener">CS106B Stanford Programming Abstractions</a></h2><h3 id="Topics"><a href="#Topics" class="headerlink" title="Topics:"></a>Topics:</h3><p>Recursion, algorithms analysis (sort/search/hash), dynamic data structures (lists, trees, heaps), data abstraction (stacks, queues, maps), implementation strategies/tradeoffs</p><h3 id="Purposes"><a href="#Purposes" class="headerlink" title="Purposes:"></a>Purposes:</h3><ol><li>become acquainted with the C++ programming language</li><li>learn more advanced programming techniques</li><li>explore classic data structures and algorithms</li><li>and apply these tools to solving complex problems<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3></li><li>Text Book: <a href="https://www.pearson.com/us/higher-education/program/Weiss-Data-Structures-and-Algorithm-Analysis-in-C-4th-Edition/PGM148299.html" target="_blank" rel="noopener">Data Structures &amp; Algorithm Analysis in C++, 4th ed, by Mark A. Weiss</a></li><li>Text Book: <a href="https://www.pearson.com/us/higher-education/program/Roberts-Programming-Abstractions-in-C/PGM80147.html" target="_blank" rel="noopener">Programming Abstractions in C++ 1st Edition by Eric Roberts</a></li><li>Text Book: <a href="http://algs4.cs.princeton.edu/home/" target="_blank" rel="noopener">Algorithms, 4th Edition</a></li><li>Blog: <a href="http://www.redblobgames.com/pathfinding/a-star/introduction.html" target="_blank" rel="noopener">Red Blob Games</a>, <a href="http://theory.stanford.edu/~amitp/GameProgramming/" target="_blank" rel="noopener">Amit’s A* Pages</a><a id="more"></a></li></ol><hr><h3 id="Coding-style"><a href="#Coding-style" class="headerlink" title="Coding style"></a>Coding style</h3><ul><li>Works correctly in all situations: Using a listing of specific test cases to exercise the program on.</li><li>The overall approach is straight-forward, data structure is cleanly organized, tasks are nicely decomposed, algorithms are clear and easy to follow, comments are helpful, layout is consistent.<h4 id="Commenting"><a href="#Commenting" class="headerlink" title="Commenting"></a>Commenting</h4>Examples of information you might include in comments:</li><li>General overview. What are the goals and requirements of this program? this function? The overview comment should also contain author and version information: who worked on this file and when.</li><li>Data structures. How is the data stored? How is it ordered, searched, accessed?</li><li>Design decisions. Why was a particular data structure or algorithm chosen? What other strategies were tried and rejected?</li><li>Error handling. How are error conditions handled? What assumptions are made? What happens if those assumptions are violated?</li><li>Nitty-gritty code details. Comments are invaluable for explaining the inner workings of particularly complicated (often labeled “clever”) paths of the code.</li><li>Planning for the future. How might one make modifications or extensions later?</li><li>And more… (This list is by no means exhaustive)</li></ul><h3 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h3><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>An abstract data type is a set of objects together with a set of operations. Abstract data types are mathematical abstractions; nowhere in an ADT’s definition is there any mention of how the set of operations is implemented.<br>Objects such as lists, sets, and graphs, along with their operations, can be viewed as ADTs.<br>Also there are search <a href="#tree">tree</a>, set, <a href="#hashing">hash table</a>, <a href="#priority-queues">priority queue</a>.</p><ul><li>Client uses class as abstraction<ul><li>Invokes public operations only</li><li>Internal implementation not relevant!</li></ul></li><li>Client can’t and shouldn’t muck with internals<ul><li>Class data should private</li></ul></li><li>Imagine a “wall” between client and implementor<ul><li>Wall prevents either from getting involved in other’s business</li><li>Interface is the “chink” in the wall</li><li>Conduit allows controlled access between the two</li></ul></li><li>Consider Lexicon<ul><li>Abstraction is a word list, operations to verify word/prefix</li><li>How does it store list? using array? vector? set? does it matter to client?</li></ul></li></ul><h4 id="Why-ADTs"><a href="#Why-ADTs" class="headerlink" title="Why ADTs?"></a>Why ADTs?</h4><ul><li>Abstraction: Client insulated from details, works at higher-level</li><li>Encapsulation: Internals private to ADT, not accessible by client</li><li>Independence: Separate tasks for each side (once agreed on interface)</li><li>Flexibility: ADT implementation can be changed without affecting client</li></ul><h4 id="Vector-and-list-in-the-STL"><a href="#Vector-and-list-in-the-STL" class="headerlink" title="Vector and list in the STL"></a>Vector and list in the STL</h4><p>The C++ language includes, in its library, an implementation of common data structures.<br>This part of the language is popularly known as the Standard Template Library (STL). In general, these data structures are called collections or containers.</p><h4 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h4><p>In the STL, a position is represented by a nested type, iterator.</p><ul><li>Getting an Iterator<ul><li><code>iterator begin( )</code> returns an appropriate iterator representing the first item in the<br>container.</li><li><code>iterator end( )</code> returns an appropriate iterator representing the endmarker in the<br>container (i.e., the position after the last item in the container).</li></ul></li><li>Iterator Methods<ul><li><code>itr++</code> and <code>++itr</code> advances the iterator itr to the next location. Both the prefix and postfix forms are allowable.</li><li><code>itr</code> returns a reference to the object stored at iterator itr’s location. The reference returned may or may not be modifiable (we discuss these details shortly).</li><li><code>itr1==itr2</code> returns true if iterators itr1 and itr2 refer to the same location and false otherwise.</li><li><code>itr1!=itr2</code> returns true if iterators itr1 and itr2 refer to a different location and false otherwise.</li></ul></li><li>Container Operations that require Iterators<br>The three most popular methods that require iterators are those that add or remove from the list (either a vector or list) at a specified position:<ul><li>iterator insert( iterator pos, const Object &amp; x ): adds x into the list, prior to the<br>position given by the iterator pos. This is a constant-time operation for list, but not for<br>vector. The return value is an iterator representing the position of the inserted item.</li><li>iterator erase( iterator pos ): removes the object at the position given by the iterator. This is a constant-time operation for list, but not for vector. The return value is the position of the element that followed pos prior to the call. This operation invalidates pos, which is now stale, since the container item it was viewing has been removed.</li><li>iterator erase( iterator start, iterator end ): removes all items beginning at position start, up to, but not including end. Observe that the entire list can be erased by the call c.erase( c.begin( ), c.end( ) )</li></ul></li><li><p>Range for loop<br>C++11 also allows the use of the reserved word auto to signify that the compiler will automatically infer the appropriate type,</p><ul><li><p>for simple data type:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> x : squares )</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; x;</span><br></pre></td></tr></table></figure></li><li><p>for complicate data type like map: Each element of the container is a <code>map&lt;K, V&gt;::value_type</code>, which is a typedef for <code>std::pair&lt;const K, V&gt;</code>. Consequently, you’d write this as</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : myMap) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; kv.first &lt;&lt; <span class="string">" has value "</span> &lt;&lt; kv.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h3><h4 id="Helper-Function"><a href="#Helper-Function" class="headerlink" title="Helper Function"></a>Helper Function</h4><ul><li>No clear definition of helper function</li><li>How to utilize helper function to help constructing recursion algarithm: construct a same-name recursive function  with extra parameters to pass in.</li><li>In some other cases, decomposition with several step into a function is itself a helper function, which help to make the main function simple and clean.</li></ul><h4 id="Exhaustive-recursion"><a href="#Exhaustive-recursion" class="headerlink" title="Exhaustive recursion"></a>Exhaustive recursion</h4><p>Permutations/subsets are about choice</p><ul><li>Both have deep/wide tree of recursive calls</li><li>Depth represents total number of decisions made</li><li>Width of branching represents number of available options per decision</li><li>Explores every possible option at every decision point, typically very expensive, N! permutations, 2N subsets</li></ul><h4 id="Recursive-Backtracking"><a href="#Recursive-Backtracking" class="headerlink" title="Recursive Backtracking"></a>Recursive Backtracking</h4><p>Partial exploration of exhaustive space. In the case that if we are interested in finding any solution, whichever one that works out first is fine. If we eventually reach our goal from here, we have no need to consider the paths not taken. However, if this choice didn’t work out and eventually leads to nothing but dead ends; when we backtrack to this decision point, we try one of the other alternatives.</p><ul><li>The back track based on the stacks of recursion, if a stack return false (or fail result), we back to previous stack and try another way(un-making choice).</li><li>Need something return(normally bool) to step out of the entire recursion once any one solution found.</li><li>One great tip for writing a backtracking function is to abstract away the details of managing the configuration (what choices are available, making a choice, checking for success, etc.) into other helper functions so that the body of the recursion itself is as clean as can be. This helps to make sure you have the heart of the algorithm correct and allows the other pieces to be developed, test, and debugged independently.</li></ul><h3 id="Pointer"><a href="#Pointer" class="headerlink" title="Pointer"></a>Pointer</h3><h4 id="lvalue"><a href="#lvalue" class="headerlink" title="lvalue"></a>lvalue</h4><p>In C++, any expression that refers to an internal memory location capable of storing data is called an lvalue (pronounced “ell-value”).<br><code>x = 1.0;</code></p><h4 id="Declaring-pointer-variables"><a href="#Declaring-pointer-variables" class="headerlink" title="Declaring pointer variables"></a>Declaring pointer variables</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     --------------------------------------------------</span><br><span class="line">     <span class="comment">// Declaration, in the stack</span></span><br><span class="line">     <span class="comment">// Not yet initialized!</span></span><br><span class="line">     <span class="keyword">int</span> num;</span><br><span class="line">     <span class="keyword">int</span> *p, *q;</span><br><span class="line">     <span class="comment">// If cout &lt;&lt; num &lt;&lt; p &lt;&lt; q &lt;&lt; endl;</span></span><br><span class="line">     <span class="comment">// There will be junk number, junk address.</span></span><br><span class="line">     <span class="comment">// If now *p=10, it may blow up, because what *p point to is an address points to somewhere around that could be invalid.</span></span><br><span class="line">     ---------------------------------------------------</span><br><span class="line">     <span class="comment">// new operator allocate memory from the heap, returns address</span></span><br><span class="line">     p = <span class="keyword">new</span> <span class="keyword">int</span>;     <span class="comment">// P -----&gt; [ int ] （heep 1000）</span></span><br><span class="line">     *p = <span class="number">10</span>;           <span class="comment">// P -----&gt; [ 10 ] （heep 1000）</span></span><br><span class="line">     q = <span class="keyword">new</span> <span class="keyword">int</span>;    <span class="comment">// P -----&gt; [ int ] （heep 1004）</span></span><br><span class="line">     *q = *p;           <span class="comment">// q -----&gt; [ 10 ]  （heep 1004）</span></span><br><span class="line">     q = p;              <span class="comment">// q -----&gt; [ 10 ] （heep 1000）</span></span><br><span class="line">     <span class="comment">// [ 10 ] （heep 1004） became orphan, and could not be reclaim back</span></span><br><span class="line">     ---------------------------------------------------</span><br><span class="line">     <span class="keyword">delete</span> p;          <span class="comment">// [ 10 ] （heep 1000）memory was reclaimed and free,</span></span><br><span class="line">                             <span class="comment">// and available for others as [  ]（heep 1000）,</span></span><br><span class="line">                             <span class="comment">// but p still hold the address</span></span><br><span class="line">     <span class="keyword">delete</span> q;          <span class="comment">// bad idea,  [ 10 ]（heep 1000） already been reclaimed!</span></span><br><span class="line">     q = <span class="literal">NULL</span>;         <span class="comment">// NULL is zero pointer, means the pointer does not hold any address,</span></span><br><span class="line">                              <span class="comment">// used as sentinel value, sometimes better than delete.</span></span><br><span class="line">     <span class="comment">// Accessing "deleted" memory has unpredictable consequences</span></span><br><span class="line">     ---------------------------------------------------</span><br><span class="line"></span><br><span class="line">     <span class="comment">// int *p  declaration reserves only a single word, which is large enough to hold a machine address.</span></span><br><span class="line">     <span class="comment">// ≠</span></span><br><span class="line">     <span class="comment">// int *p = NULL declare pointer p as nullptr</span></span><br><span class="line">     ---------------------------------------------------</span><br><span class="line">     (*newOne).name = name <span class="comment">// "." &gt; "*"</span></span><br><span class="line">     newOne-&gt;name = name</span><br></pre></td></tr></table></figure><h4 id="Use-of-pointer"><a href="#Use-of-pointer" class="headerlink" title="Use of pointer"></a>Use of pointer</h4><p>Big program that contains a certain amout of classes and objects that are share some relationship. Instead of copying data from each other, using pointer to point to specific data is better:</p><ul><li>Saves space by not repeating the same information.</li><li>If some objects gets new information to update, change in one place only!</li></ul><h4 id="Dynamic-allocation"><a href="#Dynamic-allocation" class="headerlink" title="Dynamic allocation"></a>Dynamic allocation</h4><ul><li>Request memory<br>To acquire new memory when you need it and to free it explicitly when it is no longer needed. Acquiring new storage when the program is running. While the program is running, you can reserve part of the unallocated memory, leaving the rest for subsequent allocations.<br>The pool of unallocated memory available to a program is called the <strong>heap</strong>.<br><code>int *p = new int;  //new operator to allocate memory from the heap</code><br>In its simplest form, the new operator takes a type and allocates space for a variable of that type located in the heap.<br>The call to new operator will return the address of a storage location in the heap that has been set aside to hold an integer.</li><li>Free occupied memory<br><code>Delete</code> which takes a pointer previously allocated by new and returns the memory associated with that pointer to the heap.</li></ul><h3 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h3><h4 id="Tree-terminology"><a href="#Tree-terminology" class="headerlink" title="Tree terminology"></a>Tree terminology</h4><ul><li>Node, tree, subtree, parent, child, root, edge, leaf</li><li>For any node ni, the depth of ni is the length of the unique path from the root to ni. The height of ni is the length of the longest path from ni to a leaf</li><li>Rules for all trees<ul><li>Recursive branching structure</li><li>Single root node</li><li>Every node reachable from root by unique path</li></ul></li></ul><h4 id="Binary-tree"><a href="#Binary-tree" class="headerlink" title="Binary tree"></a>Binary tree</h4><p>Each node has at most 2 children.</p><ul><li>Binary search tree<ul><li>All nodes in left subtree are less than root, all nodes in right subtree are greater.</li><li>Arranged for efficient search/insert.</li><li>It is the basis for the implementation of two library collections classes, set and map.</li><li>Most operations’ average running time is O(log N).</li></ul></li></ul><h4 id="Operating-on-trees"><a href="#Operating-on-trees" class="headerlink" title="Operating on trees"></a>Operating on trees</h4><ul><li>Many tree algorithms are recursive<ul><li>Handle current node, recur on subtrees</li><li>Base case is empty tree (NULL)</li></ul></li><li>Tree traversals to visit all nodes, order of traversal:<ul><li>Pre: cur, left, right</li><li>In: left, cur, right</li><li>Post: left, right, cur</li><li>Others: level-by-level, reverse orders, etc</li></ul></li></ul><h4 id="Balanced-Search-Trees"><a href="#Balanced-Search-Trees" class="headerlink" title="Balanced Search Trees"></a><a href="http://algs4.cs.princeton.edu/33balanced/" target="_blank" rel="noopener">Balanced Search Trees</a></h4><p>Binary search tree have poor worst-case performance.<br>To make costs are guaranteed to be logarithmic, no matter what sequence of keys is used to construct them, the ideal is to keep binary search trees perfectly balanced. Unfortunately, maintaining perfect balance for dynamic insertions is too expensive. So consider data structure that slightly relaxes the perfect balance requirement to provide guaranteed logarithmic performance not just for the insert and search operations, but also for all of the ordered operations (except range search).</p><h5 id="AVL-tree"><a href="#AVL-tree" class="headerlink" title="AVL tree"></a>AVL tree</h5><p>Adelson-Velskii and Landis tree is a binary search tree with a <strong>balance condition</strong>.</p><ul><li>Track balance factor for each node: Height of right subtree - height of left subtree information is kept for each node (in the node structure)</li><li>For every node in the tree, the height of the left and right subtrees can differ by at most 1 (Balance factor = 0 or 1).</li><li>When balance factor hits 2, restructure</li><li><strong>Rotation</strong> moves nodes from heavy to light side<ul><li>Local rearrangement around specific node</li><li>When finished, node has 0 balance factor</li><li>Single rotation: one time rotation between new insert node and its parent node</li><li>Double rotation: two single rotation of the new insert node  </li></ul></li></ul><h5 id="2-3-trees"><a href="#2-3-trees" class="headerlink" title="2-3 trees"></a>2-3 trees</h5><p>Allow the nodes in the tree to hold more than one key: 3-nodes, which hold three links and two keys.</p><ul><li>Definition: A 2-3 search tree is a tree that is either empty or<ul><li>A 2-node, with one key (and associated value) and two links,     a left link to a 2-3 search tree with smaller keys, and a right link to a 2-3 search tree with larger keys</li><li>A 3-node, with two keys (and associated values) and three links, a left link to a 2-3 search tree with smaller keys, a middle link to a 2-3 search tree with keys between the node’s keys, and a right link to a 2-3 search tree with larger keys</li><li>A perfectly balanced 2-3 search tree is one whose null links are all the same distance from the root.</li></ul></li><li>The concept guarantee that search and insert operations in a 2-3 tree with N keys are to visit at most lg N nodes.</li><li>But its dicrect implementation is inconvenient: Not only is there a substantial amount of code involved, but the overhead incurred could make the algorithms slower than standard BST search and insert.</li><li>Consider a simple representation known as a <a href="#red-black-trees">red-black BST</a> that leads to a natural implementation.</li></ul><h3 id="Priority-Queues"><a href="#Priority-Queues" class="headerlink" title="Priority Queues"></a>Priority Queues</h3><p>A priority queue is a data structure that allows at least the following two operations: <strong>insert</strong>, and <strong>deleteMin</strong>, which finds, returns, and removes the minimum element in the priority queue.</p><h4 id="Binary-Heap"><a href="#Binary-Heap" class="headerlink" title="Binary Heap"></a>Binary Heap</h4><p>A heap is a binary tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right. Such a tree is known as a complete binary tree.</p><ul><li>Structure<ul><li>A heap data structure consist of an array (of Comparable objects) and an integer representing the current heap size.</li><li>For any element in array position i, the left child is in position 2i, the right child is in the cell after the left child [2i + 1], and the parent is in position [i/2].</li></ul></li><li>Heap-Order Property<br>  For every node X, the key in the parent of X is smaller than (or equal to) the key in X. So to make find minimum operation quick.</li><li><p>Basic Heap Operation</p><ul><li><p><code>insert</code>: To insert an element X into the heap, create a hole in the next available location. Then <strong>Percolate up</strong> - swap X with its parent index (i/2) so long as X has a higher priority than its parent. Continue this process until X has no more lower priority parent.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Percolate up</span></span><br><span class="line"><span class="keyword">int</span> hole = ++size;</span><br><span class="line">    binaryQueue[<span class="number">0</span>]=<span class="built_in">std</span>::move(*newOne);</span><br><span class="line">    <span class="keyword">for</span> (;(priority&lt;binaryQueue[hole/<span class="number">2</span>].priority || (priority==binaryQueue[hole/<span class="number">2</span>].priority &amp;&amp; name&lt;binaryQueue[hole/<span class="number">2</span>].name) );hole/=<span class="number">2</span>) &#123;</span><br><span class="line">binaryQueue[hole] = <span class="built_in">std</span>::move(binaryQueue[hole/<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    binaryQueue[hole] = <span class="built_in">std</span>::move(binaryQueue[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></li><li><p><code>deleteMin</code>: When the minimum is removed, a hole is created at the root. Move the last element X in the heap to place in the root hole. Then <strong>Percolate down</strong> - swapp X with its more urgent-priority child [index (i<em>2 or i</em>2+1)] so long as it has a lower priority than its child. Repeat this step until X has no more higher priority child.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Percolate down</span></span><br><span class="line"><span class="keyword">int</span> child;</span><br><span class="line">    <span class="keyword">for</span> (; hole*<span class="number">2</span>&lt;=size;hole=child) &#123;</span><br><span class="line">child = hole*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> ( child!=size &amp;&amp; (binaryQueue[child+<span class="number">1</span>].priority&lt;binaryQueue[child].priority || (binaryQueue[child+<span class="number">1</span>].priority==binaryQueue[child].priority &amp;&amp; binaryQueue[child+<span class="number">1</span>].name&lt;binaryQueue[child].name)) )</span><br><span class="line">    ++child;</span><br><span class="line"><span class="keyword">if</span> ( binaryQueue[child].priority&lt;priority_tobePerD || (binaryQueue[child].priority==priority_tobePerD &amp;&amp; binaryQueue[child].name&lt;name_tobePerD) ) &#123;</span><br><span class="line">    binaryQueue[hole] = <span class="built_in">std</span>::move(binaryQueue[child]);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>Use integer division to avoid even odd index.</p></li></ul></li></ul><h3 id="Algorithm-Analysis"><a href="#Algorithm-Analysis" class="headerlink" title="Algorithm Analysis"></a>Algorithm Analysis</h3><p>Space/time, big-O, scalability</p><h4 id="Big-O"><a href="#Big-O" class="headerlink" title="Big-O"></a>Big-O</h4><ul><li>Computational complexity: The relationship between N and the performance of an algorithm as N becomes large</li><li>Big-O notation: to denote the computational complexity of algorithms.</li><li>Standard simplifications of big-O<ul><li>Eliminate any term whose contribution to the total ceases to be significant as N becomes large.</li><li>Eliminate any constant factors.</li></ul></li><li>Worst-case versus average-case complexity<br>Average-case performance often reflects typical behavior, while worst-case performance represents a guarantee for performance on any possible input.</li><li>Predicting computational complexity from code structure<ul><li>Constant time: Code whose execution time does not depend on the problem size is said to run in constant time, which is expressed in big-O notation as O(1).</li><li>Linear time: function that are executed exactly n times, once for each cycle of the for loop, O(N)</li><li>Quadratic time: Algorithms like selection sort that exhibit O(N<sup>2</sup>) performance are said to run in quadratic tim</li><li>For many programs, you can determine the computational complexity simply by finding the piece of the code that is executed most often and determining how many times it runs as a function of N</li></ul></li></ul><h4 id="Space-time"><a href="#Space-time" class="headerlink" title="Space/time"></a>Space/time</h4><ul><li>In general, the most important measure of performance is execution time.</li><li>It also possible to apply complexity analysis to the amount of memory space required. Nowadays the memory is cheap, but it still matters when designing extreamly big programs, or APPs on small memory device, such as phones and wearable devices.</li></ul><h4 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h4><p>There are lots of different sorting algoritms, from the simple to very complex. Some optimized for certain situations (lots of duplicates, almost sorted, etc.). So why do we need multiple algorithms?</p><ol><li><p>Selection sort</p><ul><li><p>Select smallest and swap to front/backend</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(Vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size()<span class="number">-1</span>; i++) &#123;</span><br><span class="line"> <span class="keyword">int</span> minIndex = i;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.size(); j++) &#123;</span><br><span class="line"> <span class="keyword">if</span> (arr[j] &lt; arr[minIndex])</span><br><span class="line"> minIndex = j;</span><br><span class="line"> &#125;</span><br><span class="line"> Swap(arr[i], arr[minIndex]);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>Selection sort analysis<br>Count work inside loops:</p><ul><li>First iteration does N-1 compares, second does N-2, and so on.</li><li>One swap per iteration</li><li>O(N<sup>2</sup>)</li></ul></li></ul></li><li><p>Insertion sort</p><ul><li><p>As sorting hand of just-dealt cards, each subsequent element inserted into proper place</p><ul><li>Start with first element (already sorted)</li><li>Insert next element relative to first</li><li>Repeat for third, fourth, etc.</li><li>Slide elements over to make space during insert<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(Vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line"> <span class="keyword">int</span> cur = v[i]; <span class="comment">// slide cur down into position to left</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j=i<span class="number">-1</span>; j &gt;= <span class="number">0</span> &amp;&amp; v[j] &gt; cur; j--)</span><br><span class="line"> v[j+<span class="number">1</span>] = v[j];</span><br><span class="line"> v[j+<span class="number">1</span>] = cur;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Insertion sort analysis<br>Because of the nested loops, each of which can take N iterations, insertion sort is O(N<sup>2</sup>).</p></li></ul></li><li><p>Heapsort<br><a href="#priority-queues">Priority queues</a> can be used to sort in O(N log N) time. The algorithm based on this idea is known as heapsort.</p><ul><li>Heapsort analysis<br>The building of the heap, uses less than 2N comparisons. In the second phase, the ith <code>deleteMax</code> uses at most less than 2*log (N − i + 1) comparisons, for a total of at most 2N log N − O(N) comparisons (assuming N ≥ 2). Consequently, in the worst case, at most 2N log N − O(N) comparisons are used by heapsort.</li></ul></li><li><p>Merge sort</p><ul><li>Inspiration: Algorithm like selection sort is quadratic growth (O(N<sup>2</sup>)). Double input -&gt; 4X time, halve input -&gt; 1/4 time.<br>Can recursion save the day? If there are two sorted halves, how to produce sorted full result?</li><li><a href="#divide-and-conquer">Divide and conquer</a> algorithm<ul><li>Divide input in half</li><li>Recursively sort each half</li><li>Merge two halves together</li></ul></li><li>“Easy-split hard-join”<ul><li>No complex decision about which goes where, just divide in middle</li><li>Merge step preserves ordering from each half</li></ul></li><li><p>Merge depends on the fact that the first element in the complete ordering must be either the first element in v1 or the first element in v2, whichever is smaller.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(Vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (v.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="keyword">int</span> n1 = v.size()/<span class="number">2</span>;</span><br><span class="line"> <span class="keyword">int</span> n2 = v.size() - n1;</span><br><span class="line"> Vector&lt;<span class="keyword">int</span>&gt; left = Copy(v, <span class="number">0</span>, n1);</span><br><span class="line"> Vector&lt;<span class="keyword">int</span>&gt; right = Copy(v, n1, n2);</span><br><span class="line"> MergeSort(left);</span><br><span class="line"> MergeSort(right);</span><br><span class="line"> v.clear();</span><br><span class="line"> Merge(v, left, right);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(Vector&lt;<span class="keyword">int</span>&gt; &amp;v,Vector&lt;<span class="keyword">int</span>&gt; &amp;left,Vector&lt;<span class="keyword">int</span>&gt; &amp;right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>, r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;left.size() &amp;&amp; r&lt;right.size()) &#123;</span><br><span class="line"><span class="keyword">if</span> (left[l]&lt;right[r])</span><br><span class="line">v.add(left[l++]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">v.add(right[r++]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(l&lt;left.size()) v.add(left[l++]);</span><br><span class="line"><span class="keyword">while</span>(r&lt;right.size()) v.add(right[r++]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Mergesort analysis<br>The time to mergesort N numbers is equal to the time to do two recursive mergesorts of size N/2, plus the time to merge, which is linear. T(N) = N + 2T(N/2). log N levels * N per level= O(NlogN). Mergesort uses the lowest number of comparisons of all the popular sorting algorithms.<br>Theoretical result show that no general sort algorithm could be better than NlogN.<br>But there is still better in practice:</p><ul><li>The running time of mergesort, when compared with other O(N log N) alternatives, depends heavily on the relative costs of comparing elements and moving elements in the array (and the temporary array). These costs are language dependent.</li><li>In <strong>Java</strong>, when performing a generic sort (using a Comparator), an element <strong>comparison can be expensive</strong>, but <strong>moving elements is cheap</strong> (because they are reference assignments, rather than copies of large objects).</li><li>In <strong>C++</strong>, in a generic sort, <strong>copying objects can be expensive</strong> if the objects are large, while <strong>comparing objects often is relatively cheap</strong> because of the ability of the compiler to aggressively perform inline optimization.</li></ul></li></ul></li></ol><ol><li><p>Quicksort<br>Most sorting programs in use today are based on an algorithm called Quicksort, which employs a <a href="#divide-and-conquer">Divide and conquer</a> strategy as merge sort, but instead take a different approach to divide up input vector into low half and high half. Quicksort uses a few more comparisons, in exchange for significantly fewer data movements. The reason that quicksort is faster is that the partitioning step can actually be performed in place and very efficiently.</p><ul><li><p>“Hard-split easy-join”, Each element examined and placed in correct half, so that join step become trivial.</p><ul><li>Choose an element (<strong>pivot</strong>) to serve as the boundary between the small and large elements.</li><li>Partitioning: Rearrange the elements in the vector so that all elements to the left of the boundary are less than the pivot and all elements to the right are greater than or possibly equal to the pivot.</li><li>Sort the elements in each of the partial vectors.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(Vector&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> start, <span class="keyword">int</span> stop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (stop &gt; start) &#123;</span><br><span class="line"> <span class="keyword">int</span> pivot = Partition(v, start, stop);</span><br><span class="line"> Quicksort(v, start, pivot<span class="number">-1</span>);</span><br><span class="line"> Quicksort(v, pivot+<span class="number">1</span>, stop);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Quicksort performance analysis<br>The running time of quicksort is equal to the running time of the two recursive calls plus the linear time spent in the partition (the pivot selection takes only constant time). T(N) = T(i) + T(N − i − 1) + cN, where i = |S1| is the number of elements in S1.<br>There are thre cases</p><ul><li>Ideal 50/50 split: The pivot is in the middle, T(N) = cN + 2T(N/2) =&gt; O(NlogN)</li><li>Average bad 90/10 split: N per level, but more levels, solve N*(9/10)<sup>k</sup> = 1, still k = O(NlogN)</li><li><p>Worst N-1/1 split: The pivot is the smallest element, all the time. Then i = 0, T(N) = T(N − 1) + cN, N &gt; 1. With N levels! O(N<sup>2</sup>)</p><p>In a vector with randomly chosen elements, Quicksort tends to perform well, with an average-case complexity of O(N log N). In the worst case — which paradoxically consists of a vector that is already sorted — the performance degenerates to O(N<sup>2</sup>). Despite this inferior behavior in the worst case, Quicksort is so much faster in practice than most other algorithms that it has become the standard.</p></li></ul></li></ul></li></ol><h3 id="Design-Strategy"><a href="#Design-Strategy" class="headerlink" title="Design Strategy"></a>Design Strategy</h3><p>When an algorithm is given, the actual data structures need not be specified. It is up to the programmer to choose the appropriate data structure in order to make the running time as small as possible. There are many to be considered: algorithms, data structure, space-time tradeoff, code complexity.</p><h4 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h4><p>To solve optimization problems in which we make a set of choices in order to arrive at an optimal solution. As we make each choice, subproblems of the same form often arise. Dynamic programming is effective when a given subproblem may arise from more than one partial set of choices; the key technique is to store the solution to each such subproblem in case it should reappear. Unlike divide-and-conquer algorithms which partition the problem into disjoint subproblems, dynamic programming applies when the subproblems overlap.</p><ul><li>“Programming” in this context refers to a tabular method.</li><li>When should look for a dynamic-programming solution to a problem?<ul><li>Optimal substructure: a problem exhibits optimal substructure if an optimal solution to the problem contains within it optimal solutions to subproblems.</li><li>Overlapping subproblems: When a recursive algorithm revisits the same problem repeatedly, we say that the optimization problem<br>has overlapping subproblems. In contrast, a problem for which a divide-andconquer approach is suitable usually generates brand-new problems at each step of the recursion.</li></ul></li><li>General setps of Dynamic Programming<ul><li>Characterize the structure of an optimal solution.</li><li>Recursively define the value of an optimal solution.</li><li>Compute the value of an optimal solution, typically in a bottom-up fashion.</li><li>Construct an optimal solution from computed information.</li></ul></li></ul><h4 id="Greedy-Algorithms"><a href="#Greedy-Algorithms" class="headerlink" title="Greedy Algorithms"></a>Greedy Algorithms</h4><p>Greedy algorithms work in phases. In each phase, a decision is made in a locally optimal manner, without regard for future consequences. When the algorithm terminates, we hope that the local optimum is equal to the global optimum. If this is the case, then the algorithm is correct; otherwise, the algorithm has produced a suboptimal solution.</p><ul><li><a href="https://en.wikipedia.org/wiki/Huffman_coding" target="_blank" rel="noopener">Huffman Codes</a><ul><li>A Huffman code is a particular type of optimal prefix code that is commonly used for lossless data compression.</li><li>The reason that this is a greedy algorithm is that at each stage we perform a merge without regard to global considerations. We merely select the two smallest trees.</li><li>If we maintain the trees in a priority queue, ordered by weight, then the running time is O(C logC), since there will be one buildHeap, 2C − 2 deleteMins, and C − 2 inserts. A simple implementation of the priority queue, using a list, would give an O(C<sup>2</sup>) algorithm. The choice of priority queue implementation depends on how large C is. In the typical case of an ASCII character set, C is small enough that the quadratic running time is acceptable.</li></ul></li></ul><h4 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h4><p>Traditionally, routines in which the text contains at least two recursive calls and subproblems be disjoint (that is, essentially nonoverlapping) are called divide-and-conquer algorithms.</p><ul><li>Divide: Smaller problems are solved recursively (except, of course, base cases).</li><li>Conquer: The solution to the original problem is then formed from the solutions to the subproblems.<br>We have already seen several divide-and-conquer algorithms: mergesort and quicksort, which have <code>O(N log N)</code> worst-case and averagecase bounds, respectively.</li></ul><h4 id="Backtracking-Algorithms"><a href="#Backtracking-Algorithms" class="headerlink" title="Backtracking Algorithms"></a>Backtracking Algorithms</h4><p>See <a href="#recursive-backtracking">Recursive Backtracking</a><br>In some cases, the savings over a brute-force exhaustive search can be significant.<br>The elimination of a large group of possibilities in one step is known as <strong>pruning</strong>.</p><h4 id="How-to-evaluate-compare-alternatives"><a href="#How-to-evaluate-compare-alternatives" class="headerlink" title="How to evaluate/compare alternatives"></a>How to evaluate/compare alternatives</h4><ul><li>Often interested in execution performance: Time spent and memory used</li><li>Should also consider ease of developing, verifying, maintaining code<h4 id="Quicksort-strategy"><a href="#Quicksort-strategy" class="headerlink" title="Quicksort strategy"></a>Quicksort strategy</h4></li></ul><ol><li><p>Picking the pivot<br>Picking a good pivot improves performance, but also costs some time. If the algorithm spends more time choosing the pivot than it gets back from making a good choice, you will end up slowing down the implementation rather than speeding it up.</p><ul><li>The popular, uninformed choice is to use the first element as the pivot. This is acceptable if the input is random, but if the input is presorted or in reverse order, then the pivot provides a poor partition.</li><li>A safe approach is to choose the pivot element randomly. On the other hand, random number generation is generally an expensive commodity and does not reduce the average running time of the rest of the algorithm at all.</li><li>A good estimate can be obtained by picking three elements randomly and using the median of these three as pivot. The randomness turns out not to help much, so the common course is to use as pivot the median of the left, right, and center elements.</li></ul></li><li><p>Quicksort partitioning strategy<br>A known method that is very easy to do it wrong or inefficiently.</p><ul><li>General process:<ul><li>The first step is to get the pivot element out of the way by swapping it with the last element.</li><li>Two pointers, i point to the first element and j to the next-to-last element. What our partitioning stage wants to do is to move all the small elements to the left part of the array and all the large elements to the right part. “Small” and “large” are relative to the pivot.</li><li>While i is to the left of j, we move i right, skipping over elements that are smaller than the pivot. We move j left, skipping over elements that are larger than the pivot.</li><li>When i and j have stopped, i is pointing at a large element and j is pointing at a small element. If i is to the left of j (not yet cross), those elements are swapped.</li><li>Repeat the process until i and j cross</li><li>The final is to swap the pivot element with present i element</li></ul></li><li>One important detail we must consider is how to handle elements that are equal to the pivot? Suppose there are 10,000,000 elements, of which 500,000 are identical (or, more likely, complex elements whose sort keys are identical).<ul><li>To get an idea of what might be good, we consider the case where all the elements in the array are identical.</li><li>If neither i nor j stops, and code is present to prevent them from running off the end of the array, no swaps will be performed. Although this seems good, a correct implementation would then swap the pivot into the last spot that i touched, which would be the next-to last position (or last, depending on the exact implementation). This would create very uneven subarrays. If all the elements are identical, the running time is O(N<sup>2</sup>).</li><li>If both i and j stop, there will be many swaps between identical elements. The partition creates two nearly equal subarrays. The total running time would then be O(N log N).</li><li>Thus it is better to do the unnecessary swaps and create even subarrays than to risk wildly uneven subarrays.</li></ul></li><li>Small arrays<ul><li>For very small arrays (N ≤ 20), quicksort does not perform as well as insertion sort.</li><li>Furthermore, because quicksort is recursive, these cases will occur frequently.</li><li>A common solution is not to use quicksort recursively for small arrays, but instead use a sorting algorithm that is efficient for small arrays, such as insertion sort.</li><li>A good cutoff range is N = 10, although any cutoff between 5 and 20 is likely to produce similar results. This also saves nasty degenerate cases, such as taking the median of three elements when there are only one or two.</li></ul></li></ul></li></ol><h4 id="Text-editor-case-study"><a href="#Text-editor-case-study" class="headerlink" title="Text editor case study"></a>Text editor case study</h4><ol><li>Buffer requirements<ul><li>Sequence of characters + cursor position</li><li>Operations to match commands above</li></ul></li><li><p>What to consider?</p><ul><li>Implementation choices</li><li>performance implications</li></ul></li><li><p>Buffer class interface</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> Buffer();</span><br><span class="line"> ~Buffer();</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">moveCursorForward</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">moveCursorBackward</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">moveCursorToStart</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">moveCursorToEnd</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">insertCharacter</span><span class="params">(<span class="keyword">char</span> ch)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">deleteCharacter</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// TBD!</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Buffer layered on Vector</p><ul><li>Need character data + cursor<ul><li>Chars in <code>Vector&lt;char&gt;</code></li><li>Represent cursor as integer index</li><li>Minor detail – is index before/after cursor?</li></ul></li><li><p>Buffer contains: AB|CDE</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for Buffer class</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> Vector&lt;<span class="keyword">char</span>&gt; chars;</span><br><span class="line"><span class="keyword">int</span> cursor;</span><br></pre></td></tr></table></figure></li><li><p>Performance</p><ul><li>insertCharacter() and deleteCharacter() is linear, other operation is just O(1)</li><li>Space used ~1 byte per char</li></ul></li></ul></li><li><p>Buffer layered on Stack</p><ul><li>Inspiration: add/remove at end of vector is fast<ul><li>If chars next to cursor were at end…</li><li>Build on top of stack?</li><li>Another layered abstraction!</li><li>How is cursor represented?</li></ul></li><li><p>Buffer contains:AB|CDE<br>There is no explicit cursor representation, instead using two stack to represent a whole data structure being seperated by the implicit cursor.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for Buffer class</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> Stack&lt;<span class="keyword">char</span>&gt; before, after;</span><br></pre></td></tr></table></figure></li><li><p>Performance</p><ul><li>moveCursorToStart(), moveCursorToEnd() operation is linear, other operation is just O(1)</li><li>Space used ~2 byte per char</li></ul></li></ul></li><li><p>Buffer as double linked list</p><ul><li>Inspiration: contiguous memory is constraining<ul><li>Connect chars without locality</li><li>Add tail pointer to get direct access to last cell</li><li>Add prev link to speed up moving backwards</li></ul></li><li><p>Buffer contains:AB|CDE</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for Buffer class</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">cellT</span> &#123;</span></span><br><span class="line"> <span class="keyword">char</span> ch;</span><br><span class="line"> cellT *prev, *next;</span><br><span class="line"> &#125;;</span><br><span class="line"> cellT *head, *tail, *cursor;</span><br></pre></td></tr></table></figure></li><li><p>Cursor design</p><ul><li>To cell before or after?</li><li>5 letters, 6 cursor positions…</li><li>Add “dummy cell” to front of list</li></ul></li><li>Performance<ul><li>destruction is linear, other operation is just O(1)</li><li>Space used ~9 byte per char</li></ul></li></ul></li><li><p>Compare implementations</p><style>table th:nth-of-type(1) { width: 200px;}table th:nth-of-type(2) { width: 80px;}table th:nth-of-type(3) { width: 80px;}</style></li></ol><table><thead><tr><th>Operation</th><th style="text-align:center">Vector</th><th style="text-align:center">Stack</th><th style="text-align:center">Single linked list</th><th style="text-align:center">Double linked list</th></tr></thead><tbody><tr><td>Buffer()</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td></tr><tr><td>~Buffer()</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(N)</td><td style="text-align:center">O(N)</td></tr><tr><td>moveCursorForward()</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td></tr><tr><td>moveCursorBackward()</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(N)</td><td style="text-align:center">O(1)</td></tr><tr><td>moveCursorToStart()</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(N)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td></tr><tr><td>moveCursorToEnd()</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(N)</td><td style="text-align:center">O(N)</td><td style="text-align:center">O(1)</td></tr><tr><td>insertCharacter()</td><td style="text-align:center">O(N)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td></tr><tr><td>deleteCharacter()</td><td style="text-align:center">O(N)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td><td style="text-align:center">O(1)</td></tr><tr><td>Space used</td><td style="text-align:center">1N</td><td style="text-align:center">2N</td><td style="text-align:center">5N</td><td style="text-align:center">9N</td></tr></tbody></table><ol><li>Space-time tradeoff<ul><li>Doubly-linked list is O(1) on all six operations<ul><li>But, each char uses 1 byte + 8 bytes of pointers =&gt; 89% overhead!</li></ul></li><li>Compromise: chunklist<ul><li>Array and linked list hybrid</li><li>Shares overhead cost among several chars</li><li>Chunksize can be tuned as appropriate</li></ul></li><li>Cost shows up in code complexity<ul><li>Cursor must traverse both within and across chunks</li><li>Splitting/merging chunks on insert/deletes</li></ul></li></ul></li></ol><h4 id="Implementing-Map"><a href="#Implementing-Map" class="headerlink" title="Implementing Map"></a>Implementing Map</h4><p>Map is super-useful, support any kind of dictionary, lookup table, index, database, etc.<br>Map stores key-value pairs, support fast access via key, operations to optimize: add, getValue<br>How to make it work efficiently?</p><ol><li>Implement Map as Vector<ul><li>Layer on Vector, provides convenience with low overhead</li><li>Define pair struct, to olds key and value together, <code>Vector&lt;pair&gt;</code></li><li>Vector sorted or unsorted? If sorted, sorted by what?<ul><li>Sorting: Provides fast lookup, but still slow to insert (because of shuffling)</li></ul></li><li>How to implement getValue, add?</li><li>Does a linked list help?<ul><li>Easy to insert, once at a position</li><li>But hard to find position to insert…</li></ul></li></ul></li><li><p>Implementing Map as tree</p><ul><li>Implementatation<ul><li>Each Map entry adds node to tree, node contains: string key, client-type value, pointers to left/right subtrees</li><li>Tree organized for binary search, Key is used as search field</li><li>getValue: Searches tree, comparing keys, find existing match or error</li><li>add: Searches tree, comparing keys, overwrites existing or adds new node</li></ul></li><li><p>Private members for Map</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValType&gt;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Map</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// as before</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"> <span class="built_in">string</span> key;</span><br><span class="line"> ValType value;</span><br><span class="line"> node *left, *right;</span><br><span class="line"> &#125;;</span><br><span class="line"> node *root;</span><br><span class="line"></span><br><span class="line"> <span class="function">node *<span class="title">treeSearch</span><span class="params">(node * t, <span class="built_in">string</span> key)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">treeEnter</span><span class="params">(node *&amp;t, <span class="built_in">string</span> key, ValType val)</span></span>;</span><br><span class="line"> DISALLOW_COPYING(Map)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Evaluate Map as tree</p><ul><li>Space used: Overhead of two pointers per entry (typically 8 bytes total)</li><li>Runtime performance: Add/getValue take time proportional to tree height(expected to be O(logN))</li></ul></li><li>Degenerate trees<ul><li>The insert order is “sorted”: 2 8 14 15 18 20 21, totally unbalanced with height = 7</li><li>The insert order is “alternately sorted”:  21 2 20 8 14 15 18 or  2 8 21 20 18 14 15</li><li>Association: What is the relationship between worst-case inputs for tree insertion and Quicksort?</li><li>What to do about it: AVL tree</li></ul></li></ul></li><li>Compare Map implementations</li></ol><table><thead><tr><th>Operation</th><th style="text-align:center">Vector</th><th style="text-align:center">BST</th><th style="text-align:center">Sorted Vector</th></tr></thead><tbody><tr><td>getValue</td><td style="text-align:center">O(N)</td><td style="text-align:center">O(lgN)</td><td style="text-align:center">O(lgN)</td></tr><tr><td>add</td><td style="text-align:center">O(N)</td><td style="text-align:center">O(lgN)</td><td style="text-align:center">O(N)</td></tr><tr><td>Space used</td><td style="text-align:center">N</td><td style="text-align:center">9N</td><td style="text-align:center">N</td></tr></tbody></table><h3 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h3><ul><li>Hash table ADT<ul><li>Hash table data structure: A list of keys and TableSize</li><li>Hash function: A mapping that map each key into some number in the range 0 to TableSize-1 and distributes the keys evenly among the appropriate cell</li></ul></li><li>Hashing<br>The major problems are choosing a function, deciding what to do when two keys hash to the same value (this is known as a<br>collision), and deciding on the table size</li><li>Rehashing<br>If the table gets too full, the running time for the operations will start taking too long, and insertions might fail for open addressing hashing with quadratic resolution. A solution is to build another table that is about twice as big (with an associated new hash function) and scan down the entire original hash table, computing the new hash value for each (nondeleted) element and inserting it in the new table.</li></ul><h3 id="The-Big-Five"><a href="#The-Big-Five" class="headerlink" title="The Big-Five"></a>The Big-Five</h3><p>In C++11, classes come with five special functions that are already written for you. These are the destructor, copy constructor, move constructor, copy assignment operator, and move assignment operator. Collectively these are the big-five.</p><h4 id="Destructor"><a href="#Destructor" class="headerlink" title="Destructor"></a>Destructor</h4><p>The destructor is called whenever an object goes out of scope or is subjected to a delete. Typically, the only responsibility of the destructor is to free up any resources that were acquired during the use of the object. This includes calling delete for any corresponding news, closing any files that were opened, and so on. The default simply applies the destructor on each data member.</p><h4 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h4><p>A constructor is a method that describes how an instance of the class is constructed. If no constructor is explicitly defined, one that initializes the data members using language defaults is automatically generated.</p><ul><li><p>Copy Constructor and Move Constructor</p></li><li><p>Copy Assignment and Move Assignment (operator=)<br>By Defaults, if a class consists of data members that are exclusively primitive types and objects for which the defaults make sense, the class defaults will usually make sense.<br>The main problem occurs in a class that contains a data member that is a pointer.</p><ul><li>The default destructor does nothing to data members that are pointers (for good reason—recall that we must delete ourselves).</li><li>Furthermore, the copy constructor and copy assignment operator both copy the value of the pointer rather than the objects being pointed at. Thus, we will have two class instances that contain pointers that point to the same object. This is a so-called <strong>shallow copy</strong> (contrast to deep copy).  </li><li><p>To avoid shallow copy, ban the copy funtionality by calling <code>DISALLOW_COPYING(ClassType)</code>.</p><p>As a result, when a class contains pointers as data members, and deep semantics are important, we typically must implement the destructor, copy assignment, and copy constructors ourselves.</p></li></ul></li><li><p>Explicit constructor:<br>All one-parameter constructors should be made explicit to avoid behind-the-scenes type conversions. Otherwise, there are somewhat lenient rules that will allow type conversions without explicit casting operations. Usually, this is unwanted behavior that destroys strong typing and can lead to hard-to-find bugs.<br>The use of explicit means that a one-parameter constructor cannot be used to generate an implicit temporary</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntCell</span>  &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">IntCell</span><span class="params">( <span class="keyword">int</span> initialValue = <span class="number">0</span> )</span></span></span><br><span class="line"> : storedValue&#123; initialValue &#125; &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">( )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="keyword">return</span> storedValue; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> storedValue;</span><br><span class="line"> &#125;;</span><br><span class="line">IntCell obj; <span class="comment">// obj is an IntCell</span></span><br><span class="line">obj = <span class="number">37</span>; <span class="comment">// Should not compile: type mismatch</span></span><br></pre></td></tr></table></figure></li></ul><p>Since <code>IntCell</code> constructor is declared explicit, the compiler will correctly complain that there is a type mismatch</p><h3 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h3><h4 id="Type-independent"><a href="#Type-independent" class="headerlink" title="Type-independent"></a>Type-independent</h4><p>When we write C++ code for a type-independent algorithm or data structure, we would prefer to write the code once rather than recode it for each different type</p><h4 id="Function-template"><a href="#Function-template" class="headerlink" title="Function template"></a>Function template</h4><ul><li>A function template is not an actual function, but instead is a pattern for what could become a function.</li><li>An expansion for each new type generates additional code; this is known as <strong>code bloat</strong> when it occurs in large projects.<h4 id="Class-template"><a href="#Class-template" class="headerlink" title="Class template"></a>Class template</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Object&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryCell</span> &#123;</span></span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">explicit</span> <span class="title">MemoryCell</span><span class="params">( <span class="keyword">const</span> Object &amp; initialValue = Object&#123; &#125; )</span></span></span><br><span class="line">     : storedValue&#123; initialValue &#125; &#123; &#125;</span><br><span class="line">     <span class="keyword">private</span>:</span><br><span class="line">     Object storedValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><code>MemoryCell</code> is not a class, it is only a class template. It will be a class if specify the Object type. <code>MemoryCell&lt;int&gt;</code> and <code>MemoryCell&lt;string&gt;</code> are the actual classes.</p><h3 id="Graph-Algorithms"><a href="#Graph-Algorithms" class="headerlink" title="Graph Algorithms"></a>Graph Algorithms</h3><p>Definitions: vertices, edges, arcs, directed arcs = digraphs, weight/cost, path, length, acyclic(no cycles)</p><h4 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h4><ul><li>A topological sort is an ordering of vertices in a directed acyclic graph, such that if there is a path from vi to vj, then vj appears after vi in the ordering.</li><li>A topological ordering is not possible if the graph has a cycle</li><li>To find a topological ordering, define the indegree of a vertex v as the number of edges (u, v), then use a queue or stack to keep the present 0 indegree vertexes. At each stage, as long as the queue is not empty, dequeue a 0 indegree vertexes in the queue, enqueue each new generated 0 indegree vertexes into the queue.</li></ul><h4 id="Sortest-Path-Algorithms"><a href="#Sortest-Path-Algorithms" class="headerlink" title="Sortest-Path Algorithms"></a>Sortest-Path Algorithms</h4><ul><li><p><a href="http://www.redblobgames.com/pathfinding/a-star/introduction.html#breadth-first-search" target="_blank" rel="noopener">Breadth-first search</a></p><ul><li>Explores equally in all directions</li><li>To find unweighted shortest paths</li><li>Operates by processing vertices in layers: The vertices closest to the start are evaluated first, and the most distant vertices are evaluated last.</li></ul></li><li><p><a href="http://www.redblobgames.com/pathfinding/a-star/introduction.html#dijkstra" target="_blank" rel="noopener">Dijkstra’s Algorithm</a></p><ul><li>Also called Uniform Cost Search, cost matters</li><li>Instead of exploring all possible paths equally, it favors lower cost paths.</li><li>Dijkstra’s algorithm proceeds in stages. At each stage, while there are still vertices waiting to be known:<ul><li>Selects a vertex v, which has the <strong>smallest</strong> dv among all the <em>unknown</em> vertices, and declares v as <em>known</em> stage.</li><li>For each of v’s neighbors, w, if the new path’s cost from v to w is better than previous dw, dw will be updated.</li><li>But w will not be marked as <strong>known</strong>, unless at next while-loop stage, dw happens to be the smalles.</li></ul></li><li>The above steps could be implemented via a priority queue.</li><li>A proof by contradiction will show that this algorithm always works as long as no edge has a negative cost.</li><li>If the graph is sparse, with |E| =θ(|V|), this algorithm is too slow. In this case, the distances would need to be kept in a priority queue. Selection of the vertex v is a <strong>deleteMin</strong> operation. The update of w’s distance can be implemented two ways.<ul><li>One way treats the update as a decreaseKey operation.</li><li>An alternate method is to insert w and the new value dw into the priority queue every time w’s distance changes.</li></ul></li></ul></li><li><p><a href="http://www.redblobgames.com/pathfinding/a-star/introduction.html#greedy-best-first" target="_blank" rel="noopener">Greedy Best First Search(Heuristic search)</a></p><ul><li>With Breadth First Search and Dijkstra’s Algorithm, the frontier expands in all directions. This is a reasonable choice if you’re trying to find a path to all locations or to many locations. However, a common case is to find a path to only one location.</li><li>A modification of Dijkstra’s Algorithm, optimized for a single destination. It prioritizes paths that seem to be leading closer to the goal.</li><li><p>To make the frontier expand towards the goal more than it expands in other directions.</p><ul><li><p>First, define a <em>heuristic</em> function that tells us how close we are to the goal, design a heuristic for each type of graph</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def heuristic(a, b):</span><br><span class="line">     # Manhattan distance on a square grid</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">abs</span>(a.x - b.x) + <span class="built_in">abs</span>(a.y - b.y)</span><br></pre></td></tr></table></figure></li><li><p>Use the estimated distance to the goal for the priority queue ordering. The location closest to the goal will be explored first.</p></li></ul></li><li>This algorithm runs faster when there aren’t a lot of obstacles, but the paths aren’t as good(not always the shortest).</li></ul></li><li><p><a href="http://www.redblobgames.com/pathfinding/a-star/introduction.html#astar" target="_blank" rel="noopener">A* Algorithm</a></p><ul><li>Dijkstra’s Algorithm works well to find the shortest path, but it wastes time exploring in directions that aren’t promising. Greedy Best First Search explores in promising directions but it may not find the shortest path.</li><li>The A* algorithm uses both the actual distance from the start and the estimated distance to the goal.</li><li>Compare the algorithms: Dijkstra’s Algorithm calculates the distance from the start point. Greedy Best-First Search estimates the distance to the goal point. A* is using the sum of those two distances.</li><li>So A* is the best of both worlds. As long as the heuristic does not overestimate distances, A* does not use the heuristic to come up with an approximate answer. It finds an optimal path, like Dijkstra’s Algorithm does. A* uses the heuristic to reorder the nodes so that it’s more likely that the goal node will be encountered sooner.</li></ul></li><li><p>Conclusion: Which algorithm should you use for finding paths on a map?</p><ul><li>If you want to find paths from or to all all locations, use Breadth First Search or Dijkstra’s Algorithm. Use Breadth First Search if movement costs are all the same; use Dijkstra’s Algorithm if movement costs vary.</li><li>If you want to find paths to one location, use Greedy Best First Search or A*. Prefer A<em> in most cases. When you’re tempted to use Greedy Best First Search, consider using A</em> with an “inadmissible” heuristic.</li><li>If you want the optimal paths, Breadth First Search and Dijkstra’s Algorithm are guaranteed to find the shortest path given the input graph. Greedy Best First Search is not. A* is guaranteed to find the shortest path if the heuristic is never larger than the true distance. (As the heuristic becomes smaller, A<em> turns into Dijkstra’s Algorithm. As the heuristic becomes larger, A</em> turns into Greedy Best First Search.)</li></ul></li></ul><h3 id="Advanced-Data-Structures"><a href="#Advanced-Data-Structures" class="headerlink" title="Advanced Data Structures"></a>Advanced Data Structures</h3><h4 id="Red-Black-Trees"><a href="#Red-Black-Trees" class="headerlink" title="Red-Black Trees"></a><a href="http://algs4.cs.princeton.edu/33balanced/" target="_blank" rel="noopener">Red-Black Trees</a></h4><p>Red-black tree leads to a natural implementation of the insertion algorithm for <a href="#2-3-trees">2-3 trees</a></p><ul><li><p>RBT definition</p><ul><li>Red-black tree means encoding 2-3 trees in this way: red links, which bind together two 2-nodes to represent 3-nodes, and black links, which bind together the 2-3 tree.</li><li>An equivalent definition is to define red-black BSTs as BSTs having red and black links and satisfying the following three restrictions:<ul><li>Red links lean left.</li><li>No node has two red links connected to it.</li><li>The tree has perfect black balance : every path from the root to a null link has the     same number of black links.</li></ul></li><li>A 1-1 correspondence: If we draw the red links horizontally in a red-black BST, all of the null links are the same distance from the root, and if we then collapse together the nodes connected by red links, the result is a 2-3 tree.<br><img src="/images/1-1 correspondence between red-black BSTs and 2-3 trees.png" alt="A 1-1 correspondence"></li></ul></li><li><p>RBT implementaion</p><ul><li>Color representation:<ul><li>Each node is pointed to by precisely one link from its parent,</li><li>Encode the color of links in nodes, by adding a boolean instance variable color to our Node data type, which is true if the link from the parent is red and false if it is black. By convention, null links are black.</li><li>For clarity, define constants <code>RED</code> and <code>BLACK</code> for use in setting and testing this variable.</li></ul></li><li>Rotation<br>  To correct right-leaning red links or two red links in a row conditions.<ul><li>takes a link to a red-black BST as argument and, assuming that link to be to a Node h whose right link is red, makes the necessary adjustments and returns a link to a node that is the root of a red-black BST for the same set of keys whose left link is red. Actually it is switching from having the smaller of the two keys at the root to having the larger of the two keys at the root.</li></ul></li><li>Flipping colors<ul><li>to split a 4-node</li><li>In addition to flipping the colors of the children from red to black, we also flip the color of the parent from black to red.</li></ul></li><li>Keeping the root black.</li><li>Insertion<br>  Maintain the 1-1 correspondence between 2-3 trees and red-black BSTs during insertion by judicious use of three simple operations: left rotate, right rotate, and color flip.<ul><li>If the right child is red and the left child is black, rotate left.</li><li>If both the left child and its left child are red, rotate right.</li><li>If both children are red, flip colors.</li></ul></li><li>Deletion</li></ul></li></ul><hr><h3 id="Assignments"><a href="#Assignments" class="headerlink" title="Assignments"></a><a href="https://github.com/ShootingSpace/CS106B_assignments" target="_blank" rel="noopener">Assignments</a></h3><ol><li>Name Hash</li><li>Game of Life</li><li>Serafini</li><li>Recursion</li><li>Boggle!</li><li><a href="http://web.stanford.edu/class/cs106b/assn/patient-queue.html" target="_blank" rel="noopener">Patient Queue</a></li><li><a href="http://web.stanford.edu/class/cs106b/assn/huffman.html" target="_blank" rel="noopener">Huffman Encoding</a></li><li><a href="http://web.stanford.edu/class/cs106b/assn/trailblazer.html" target="_blank" rel="noopener">Trailblazer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Note-CS106B-Stanford-Programming-Abstractions&quot;&gt;&lt;a href=&quot;#Note-CS106B-Stanford-Programming-Abstractions&quot; class=&quot;headerlink&quot; title=&quot;Note CS106B Stanford Programming Abstractions&quot;&gt;&lt;/a&gt;Note &lt;a href=&quot;https://see.stanford.edu/Course/CS106B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CS106B Stanford Programming Abstractions&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;Topics&quot;&gt;&lt;a href=&quot;#Topics&quot; class=&quot;headerlink&quot; title=&quot;Topics:&quot;&gt;&lt;/a&gt;Topics:&lt;/h3&gt;&lt;p&gt;Recursion, algorithms analysis (sort/search/hash), dynamic data structures (lists, trees, heaps), data abstraction (stacks, queues, maps), implementation strategies/tradeoffs&lt;/p&gt;
&lt;h3 id=&quot;Purposes&quot;&gt;&lt;a href=&quot;#Purposes&quot; class=&quot;headerlink&quot; title=&quot;Purposes:&quot;&gt;&lt;/a&gt;Purposes:&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;become acquainted with the C++ programming language&lt;/li&gt;
&lt;li&gt;learn more advanced programming techniques&lt;/li&gt;
&lt;li&gt;explore classic data structures and algorithms&lt;/li&gt;
&lt;li&gt;and apply these tools to solving complex problems&lt;h3 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;Text Book: &lt;a href=&quot;https://www.pearson.com/us/higher-education/program/Weiss-Data-Structures-and-Algorithm-Analysis-in-C-4th-Edition/PGM148299.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Data Structures &amp;amp; Algorithm Analysis in C++, 4th ed, by Mark A. Weiss&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Text Book: &lt;a href=&quot;https://www.pearson.com/us/higher-education/program/Roberts-Programming-Abstractions-in-C/PGM80147.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Programming Abstractions in C++ 1st Edition by Eric Roberts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Text Book: &lt;a href=&quot;http://algs4.cs.princeton.edu/home/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Algorithms, 4th Edition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Blog: &lt;a href=&quot;http://www.redblobgames.com/pathfinding/a-star/introduction.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Red Blob Games&lt;/a&gt;, &lt;a href=&quot;http://theory.stanford.edu/~amitp/GameProgramming/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Amit’s A* Pages&lt;/a&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="cs106b" scheme="http://yoursite.com/tags/cs106b/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 09 - Java | 双向链表 Doubly Linked List - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-09-java-doubly-linked-list/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-09-java-doubly-linked-list/</id>
    <published>2018-01-13T00:00:00.000Z</published>
    <updated>2018-01-30T21:28:28.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="双向链表-Doubly-Linked-List"><a href="#双向链表-Doubly-Linked-List" class="headerlink" title="双向链表 Doubly Linked List"></a>双向链表 Doubly Linked List</h2><p>前面介绍过单向链表，不过单向链表有几个缺点. 第一个就是它的<code>addLast</code>操作非常慢。单向链表只有一个变量保存列表头的地址, 以及每个节点对后面节点的单向引用(链接). 对于很长的列表，<code>addLast</code>方法必须遍历整个列表, 一直到找到列表末尾才能执行插入操作. 那么如何解决呢?</p><p>最直观的解决方案就是加个’车尾’, 如图<img src="/images/sllist_last_pointer.png" alt="" title="image from: https://joshhug.gitbooks.io/"> 这样我们就可以直接通过<code>last.next</code>引用末尾位置.<br>不过另一个问题并没有解决, 就是删除列表最后一项<code>removeLast</code>这个操作还是很慢。因为在目前的结构设计下, 我们需要先找到倒数第二项，然后将其下一个指针设置为<code>null</code>。而要找到倒数第二节点, 我们就得先找到倒数第三个节点…… 以此类推。也就是说，对于删除末尾的操作，还是要几乎遍历整个列表。</p><h3 id="反方向的链接"><a href="#反方向的链接" class="headerlink" title="反方向的链接"></a>反方向的链接</h3><p>基于前面单向链表构建双向链表, 一个比较有效的方法是额外为每个节点添加一个指向前面节点的链接/指针.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> OneNode prev; <span class="comment">//指向前</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">public</span> OneNode next; <span class="comment">//指向后</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>增加这些额外的指针会导致额外的代码复杂度, 以及额外的内存开销, 这就是追求时间效率的代价.</p><h3 id="Sentinel-与尾节点"><a href="#Sentinel-与尾节点" class="headerlink" title="Sentinel 与尾节点"></a>Sentinel 与尾节点</h3><p>双向链表的一个设计初衷，就是为了解决单向链表针对列表末尾位置的操作效率不高的问题，除了sentinel和反方向的链接还不够，我们还需要一个节点（指针）能够直接帮我们定位到列表末端。可以考虑添加一个的尾节点<code>last</code>，<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_basic_size_0.png" alt="" title="image from: https://joshhug.gitbooks.io/"> <img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_basic_size_2.png" alt="" title="image from: https://joshhug.gitbooks.io/"> 这样的列表就可以支持<code>O(1)</code>复杂度的<code>addLast</code>,<code>getLast</code> 和 <code>removeLast</code>操作了。</p><h2 id="循环双端链表"><a href="#循环双端链表" class="headerlink" title="循环双端链表"></a>循环双端链表</h2><p>上面的尾节点设计虽然没什么错误，但有点瑕疵：最后一个尾节点指针有时指向前哨节点，有时指向一个真正的节点。更好的方法是使双向链表首尾相连, 构成一个循环，即前后节点共享唯一的一个前哨节点。<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_0.png" alt="" title="image from: https://joshhug.gitbooks.io/"> <img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_2.png" alt="fig source https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_2.png" title="image from: https://joshhug.gitbooks.io/"><br>这样的设计相对更整洁，更美观(主观上的), sentinel的<code>prev</code>就指向列表最后一个节点, sentinel的<code>next</code>指向列表第一个节点.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDeque</span>&lt;<span class="title">GType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">OneNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> OneNode prev; <span class="comment">//sentinel's forward link always points to the last element</span></span><br><span class="line">        <span class="keyword">public</span> GType item;</span><br><span class="line">        <span class="keyword">public</span> OneNode next; <span class="comment">//sentinel's backward link always points to the first element</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OneNode</span><span class="params">(OneNode p, GType i, OneNode n)</span> </span>&#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            item = i;</span><br><span class="line">            next = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后修改构造函数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Creates an empty deque. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedListDeque</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sentinel = <span class="keyword">new</span> OneNode(<span class="keyword">null</span>,<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    sentinel.prev = sentinel;</span><br><span class="line">    sentinel.next = sentinel;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Creates a deque with x  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedListDeque</span><span class="params">(GType x)</span></span>&#123;</span><br><span class="line">    sentinel = <span class="keyword">new</span> OneNode(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    sentinel.next = <span class="keyword">new</span> OneNode(sentinel, x,sentinel);</span><br><span class="line">    sentinel.prev = sentinel.next;</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果是初始化空列表, 那么其实就是一个自己指向自己的<code>sentinel</code>节点. 如果是非空列表, 那么<code>sentinel</code>节点和真实的节点就构成了一个最简单的二元循环体.</p><h3 id="针对列表末尾位置的操作"><a href="#针对列表末尾位置的操作" class="headerlink" title="针对列表末尾位置的操作"></a>针对列表末尾位置的操作</h3><p>双端链表结构优雅，虽然某些操作如<code>addFirst</code>等编码复杂度会提高, 但不影响速度. 更重要的是, 相比单向链表, 它反而使得<code>addLast, moveLast</code>等方法的代码实现变得简单了, 而且还进一步提升了运行速度(<code>O(n)到O(c)</code>).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Adds an item to the back of the Deque.</span></span><br><span class="line"><span class="comment"> * O(c) */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(GType x)</span></span>&#123;</span><br><span class="line">    OneNode oldBackNode = sentinel.prev;</span><br><span class="line">    OneNode newNode = <span class="keyword">new</span> OneNode(oldBackNode, x, sentinel);</span><br><span class="line">    sentinel.prev = newNode;</span><br><span class="line">    oldBackNode.next = newNode;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes and returns the item at the front of the Deque.</span></span><br><span class="line"><span class="comment"> * If no such item exists, returns null.O(c). */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GType <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OneNode oldFrontNode = sentinel.next;</span><br><span class="line">    sentinel.next = oldFrontNode.next;</span><br><span class="line">    oldFrontNode.next.prev = sentinel;</span><br><span class="line">    size -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldFrontNode.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;双向链表-Doubly-Linked-List&quot;&gt;&lt;a href=&quot;#双向链表-Doubly-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;双向链表 Doubly Linked List&quot;&gt;&lt;/a&gt;双向链表 Doubly Linke
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 08 - Java | 单向链表 Singly Linked List - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-08-java-singly-linked-list/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-08-java-singly-linked-list/</id>
    <published>2018-01-12T00:00:00.000Z</published>
    <updated>2018-01-30T21:24:13.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表 Linked List"></a>链表 Linked List</h2><p>前面有介绍以array为基础搭建的列表，支持自动扩容, 各种插入，删除速度都很快.<br>这里再介绍另一种方案, 链表, 也可以实现列表自动扩容.</p><h3 id="带链接的节点"><a href="#带链接的节点" class="headerlink" title="带链接的节点"></a>带链接的节点</h3><p>链表的核心组成是带链接的节点, 每个节点就像火车车厢, 有钩子连接下一节车厢.</p><p><img src="/images/408px-Singly-linked-list.png" alt=""><br>以int节点为例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">public</span> IntNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntNode</span><span class="params">(<span class="keyword">int</span> i, IntNode n)</span> </span>&#123;</span><br><span class="line">        item = i;</span><br><span class="line">        next = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>next</code>就是这个链接, 每一个节点就是其上一个节点的<code>next</code>.<br><a id="more"></a></p><h3 id="嵌套类-Nested-static-class"><a href="#嵌套类-Nested-static-class" class="headerlink" title="嵌套类 Nested static class"></a>嵌套类 Nested static class</h3><p>这个节点作为一个相对独立的数据结构, 我们更希望让他单独作为一个类来维护. 再另外创建一个名为<code>LinkedList</code>的class与用户进行交互. 这样还有另一个好处就是提供一个命名为<code>LinkedList</code>的类给用户交互，用户更直观地知道自己是在调用链表。如果直接与node类交互，用户可能会困扰. 但同时考虑到这个node类只有<code>LinkedList</code>会调用，所以我们可以把node类嵌套进<code>LinkedList</code>中，也就是嵌套类，在类中定义类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">XXX</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">OneNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> XXX item;</span><br><span class="line">        <span class="keyword">public</span> OneNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OneNode</span><span class="params">(XXX i, OneNode n)</span> </span>&#123;</span><br><span class="line">            item = i;</span><br><span class="line">            next = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OneNode first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(XXX x)</span> </span>&#123;</span><br><span class="line">        first = <span class="keyword">new</span> OneNode(x, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面是各种方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上定义使用了<a href="/NOTE-CS61B-data-structures-05-java-variable-types#通用数据类型-Generic">泛型</a>。声明<code>OneNode</code>实例<code>first</code>为私有变量, 是为了防止用户错误地摆弄链接指向，<code>private</code>和<code>public</code>的使用<a href="/NOTE-CS61B-data-structures-07-java-array-based-list#公共-vs-私有-Public-vs.-Private">参考</a>.</p><h4 id="静态与非静态嵌套类"><a href="#静态与非静态嵌套类" class="headerlink" title="静态与非静态嵌套类"></a>静态与非静态嵌套类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticNestedClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果嵌套类不需要使用<code>LinkedList</code>的任何实例方法或变量，那可以声明嵌套类为static。像静态类方法一样，静态嵌套类不能直接引用其外部类中定义的实例变量或方法, 只能通过实例对象引用来使用它们。同时外部类不能直接访问静态嵌套类的成员变量，但可以通过静态嵌套类来访问。</p><p>非静态嵌套类一般叫做内部类inner class。与实例方法和变量一样，内部类与其外部类的实例关联，并且可以直接访问该对象的方法和变量。另外，因为内部类与一个实例相关联，所以它不能自己定义任何静态成员。一个内部类的实例作为成员存在于其外部类的实例中, <code>InnerClass</code>的一个实例只能存在于<code>OuterClass</code>的一个实例中，并且可以直接访问它的外部实例的方法和变量。</p><p>作为OuterClass的成员，嵌套类可以声明为private，public，protected或package private。外部类只能声明为public或package private。更多详情<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html" target="_blank" rel="noopener">参考官网</a>.</p><h3 id="补充必要的实例方法"><a href="#补充必要的实例方法" class="headerlink" title="补充必要的实例方法"></a>补充必要的实例方法</h3><p>插入的操作核心是改变链接指向， 比如原来是<code>A-&gt;B-&gt;D</code>, 要插入C, 则把<code>C.next</code>指向D,然后把<code>B.next</code>改为指向C, 变为<code>A-&gt;B-&gt;C-&gt;D</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 在列表开头插入 x. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(XXX x)</span> </span>&#123;</span><br><span class="line">    first = <span class="keyword">new</span> OneNode(x, first);</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回列表第一个元素. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> XXX <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 在列表末尾插入 x. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(XXX x)</span> </span>&#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    OneNode p = first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把 p 当做指针顺藤摸瓜一直挪到列表末尾. */</span></span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.next = <span class="keyword">new</span> OneNode(x, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 删除列表末尾的元素. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//自行补充...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，如果用户不小心把某节点x指回自己<code>x.next=x</code>,那就会进入死循环，所以我们需要把<code>OnoNode</code>实例<code>first</code>声明为私有变量已提供必要的保护。</p><h3 id="超载-overloading"><a href="#超载-overloading" class="headerlink" title="超载 overloading"></a>超载 overloading</h3><p>如果想初始化一个空列表, 可以:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 构造一个空列表. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fist = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即使原来已经有一个带参数x的构造器了, 这里再加一个同名构造器也没问题. 因为Java允许有不同参数的方法重名, 叫超载 overloading.</p><h3 id="程序不变条件-invariants"><a href="#程序不变条件-invariants" class="headerlink" title="程序不变条件 invariants"></a>程序不变条件 invariants</h3><p>上面超载了一个初始化空列表的构造器,加入初始化一个空列表，然后直接调用<code>addLast</code>，程序会报错, 因为<code>null</code>没有<code>next</code>.</p><p>有几种修改方法, 比如用<code>if else</code>这种加特例的方法. 这个方案虽然可以能解决问题，但是必要时应该避免加入特例代码, 毕竟有特例就意味着增加了复杂性和额外的代码特例记忆需求, 而人记忆是有限的.</p><p>一个更简洁（尽管不太显而易见）的解决方案是修改数据结构本身，让所有<code>LinkedList</code>，维护起来都没有差别，即使是空的。<br>如果把列表比做拉货的火车，那么货物就是列表承载的数据。一列火车如果只有车厢而没有车头（或者车尾）的话是没有意义的，因为没有动力。所以不管火车有没有拉货，有车厢还是没车厢，要称之为火车我们至少需要一个火车头。<br>我们可以通过创建一个特殊节点, 称为前哨节点 sentinel。前哨节点将保存一个值，具体数值我们不关心，它只是作为火车头，不装货。<br><img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig22/three_item_sentenlized_SLList.png" alt="" title="image from: https://joshhug.gitbooks.io/"><br>所以我们要修改<code>LinkedList</code>为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第一个元素 （假如有的话）就是 sentinel.next. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">XXX</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">OneNode</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OneNode sentinel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造一个空列表. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> OneNode(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造一个初始元素为x的列表. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(XXX x)</span> </span>&#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> OneNode(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> OneNode(x, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于像<code>LinkedList</code>这样简单的数据结构来说，特例不多我们也许可以hold住, 一旦后续遇到像树tree等更复杂的数据结构，控制特例数量就显得极为重要了。所以现在就要培养自己的这方面的习惯，保持程序不变条件成立 Invariants。所谓 invariants 就是指数据结构任何情况下都是不会出错（除非程序有bug）.</p><p>具有前哨节点的<code>LinkedList</code>至少具有以下 invariants：</p><ul><li>列表默认存在前哨节点。</li><li>列表第一个元素（如果非空的话）总是在<code>sentinel.next.item</code>。</li><li>size变量始终是已添加的元素总数。</li></ul><p>不变条件使得代码的推敲变得更加容易，同时给程序员提供了能够确保代码正常工作的具体目标。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;链表-Linked-List&quot;&gt;&lt;a href=&quot;#链表-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;链表 Linked List&quot;&gt;&lt;/a&gt;链表 Linked List&lt;/h2&gt;&lt;p&gt;前面有介绍以array为基础搭建的列表，支持自动扩容, 各种插入，删除速度都很快.&lt;br&gt;这里再介绍另一种方案, 链表, 也可以实现列表自动扩容.&lt;/p&gt;
&lt;h3 id=&quot;带链接的节点&quot;&gt;&lt;a href=&quot;#带链接的节点&quot; class=&quot;headerlink&quot; title=&quot;带链接的节点&quot;&gt;&lt;/a&gt;带链接的节点&lt;/h3&gt;&lt;p&gt;链表的核心组成是带链接的节点, 每个节点就像火车车厢, 有钩子连接下一节车厢.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/408px-Singly-linked-list.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;以int节点为例:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IntNode&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; item;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; IntNode next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IntNode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, IntNode n)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        item = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        next = n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;next&lt;/code&gt;就是这个链接, 每一个节点就是其上一个节点的&lt;code&gt;next&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>Git Bash 直接启动 sublime 或 atom 等编辑器以打开或新建文件</title>
    <link href="http://yoursite.com/Launch-editor-in-Gitbash/"/>
    <id>http://yoursite.com/Launch-editor-in-Gitbash/</id>
    <published>2018-01-01T00:00:00.000Z</published>
    <updated>2018-01-06T22:45:03.611Z</updated>
    
    <content type="html"><![CDATA[<p>程序员或者其他需要码字多的人，经常要使用编辑器如sublime、atom 和 Typora等。如果每次都要用鼠标点击才能用sublime打开文件，或者在编辑器中新建文件，那么就会有点麻烦！但你可以用一句命令解决！</p><p>配置在Git Bash中用各种文本编辑器打开文件或者直接新建文件。这里以atom为例。</p><h2 id="常规步骤"><a href="#常规步骤" class="headerlink" title="常规步骤"></a>常规步骤</h2><ol><li>打开Git Bash并<code>cd</code>到你的目标文件夹, 或者直接在目标文件中右键打开Git Bash.</li><li><code>atom xxx.md</code> 就会在弹出的atom窗口中打开名为<code>xxx.md</code>的markdown文件, 如果没有这个文件, 会自动创建一个.</li><li>适用于其他类型文件, 如<code>.java</code>等.</li><li>如果想用sublime, 可以用<code>subl xxx.java</code>, 同理notepad++ 可以用 <code>notepad++ xxx.java</code>等。 (若出现错误,看下面)</li></ol><h2 id="若系统无法识别命令"><a href="#若系统无法识别命令" class="headerlink" title="若系统无法识别命令"></a>若系统无法识别命令</h2><p>一般使用sublime或者notepad++的用户, 可能会出现<code>error: 系统无法识别命令...</code>之类的, 可以这么解决:</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>新建一个文件命名为<code>subl</code>（注意不能有后缀名），内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">&quot;D:\Sublime Text 3\sublime_text.exe&quot; $1 &amp;</span><br></pre></td></tr></table></figure></p><p>第一行指明这是个 shell 脚本.<br>第二行的字符串是sublime的安装目录, 示例只是我电脑的目录, 注意这里要改为你自己的目录,<br>第二行的$1 是取的命令之后输入的参数<br>第二行的&amp;是此命令在后台打开，这样sublime打开之后，就不会阻塞你的git bash</p><p>文件保存到 <code>C:\Program Files (x86)\Git\mingW32\bin</code> 目录下(你的git目录可能与我的不一样，注意改成你自己的)</p><p>同理适用于其他编辑器，比如用<code>chrome</code>打开<code>.html</code>文件等。如果不想每次都新建一个文件，可以用下面的方法2。</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><ol><li>找到 <code>C:\Users\你的计算机名</code>目录，如果你的计算机名是Administrator，那么你就要去<code>C:\Users\Administrator</code>目录下, 这里一般存放着windows系统的<code>我的文档, 桌面</code>等文件夹.</li><li>在该目录下用Git Bash输入<code>notepad .bashrc</code>, 这会用windows记事本新建并打开一个文件<code>.bashrc</code>，这个文件没有名称只有后缀名。<code>.bashrc</code>里面可以给Git Bash设置命令的别名, 设置路径等。</li><li>在.bashrc文件加入下面一行文本<code>alias notepad++=&quot;/D/Notepad++/notepad++.exe&quot;</code>, 这里你需要修改为你电脑的安装路径。<code>alias</code>就是别名的意思，当我们执行<code>notepad++</code>的时候，实际执行的是<code>=</code>后面的语句.</li><li>重新打开Git Bash, 设置才能生效，如果不想关掉在打开的话，可以直接在bash下输入<code>source ~/.bashrc</code>就可以立刻加载修改后的设置，设置立即生效。<br>现在在bash下输入<code>notepad++ test.py</code>, 就直接打开了notepad++并创建了这个叫test的Python文件。这里的别名不一定非要取<code>notepad++</code>，随你想叫什么都行。</li></ol><p>同理也可以扩展到别的文本编辑器，<code>alias atom=&quot;atom的路径&quot;</code>, <code>alias sublime=&quot;sublime的路径&quot;</code>等. 最后还要注意一点，上面所说的路径最好不要有空格，括号等，否则会造成命令无效.</p><p><code>.bashrc</code>还有很多有用的配置,可以根据需要进行扩展. 比如很多程序猿会选择修改删除命令<code>rm</code>(此命令不加任何参数的话，会直接删除文件, 可能会造成误删的后果)。这个时候可以给rm加个参数-i，意为在删除的时候给出提示。在文件<code>.bashrc</code>里添加这行代码<code>alias rm=&quot;rm -i&quot;</code>。但这里不建议这么做，因为<code>rm=&quot;rm -i&quot;</code>是一个定时炸弹，在使用它之后，习惯了之后, 你会本能地期望<code>rm</code>在删除文件之前会提示你。但是，总有一天你可能会用一个没有rm alias 别名的系统, 这时若你也直接随手一甩<code>rm</code>, 本以为会有提示, 结果发现数据真的被删除了。</p><p>在任何情况下，预防文件丢失或损坏的好方法就是进行备份。</p><p>所以如果你想个性化删除命令, 最好不要动<code>rm</code>，而是创建属于你的命令，比如<code>trash, myrm, delete</code>等, 用<code>alias trash=&#39;/bin/rm -irv&#39;</code>会创建一条把文件放入垃圾回收站的命令.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;程序员或者其他需要码字多的人，经常要使用编辑器如sublime、atom 和 Typora等。如果每次都要用鼠标点击才能用sublime打开文件，或者在编辑器中新建文件，那么就会有点麻烦！但你可以用一句命令解决！&lt;/p&gt;
&lt;p&gt;配置在Git Bash中用各种文本编辑器打开文
      
    
    </summary>
    
      <category term="提高效率" scheme="http://yoursite.com/categories/%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="Git Bash" scheme="http://yoursite.com/tags/Git-Bash/"/>
    
      <category term="Sublime" scheme="http://yoursite.com/tags/Sublime/"/>
    
      <category term="Atom" scheme="http://yoursite.com/tags/Atom/"/>
    
      <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 07 - Java | 用数组构建数据列表 list - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-07-java-array-based-list/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-07-java-array-based-list/</id>
    <published>2017-12-29T00:00:00.000Z</published>
    <updated>2018-01-12T11:11:36.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="列表-List"><a href="#列表-List" class="headerlink" title="列表 List"></a>列表 List</h2><p>前面说到Java的数组无法更改长度，那么也就无法实现插入或者删除数组成员。Java提供了功能更丰富的数据结构 - 列表（<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" target="_blank" rel="noopener">list</a>）。所谓列表，即有序的集合（序列），用户可以精确地控制每个元素插入到列表中的哪个位置。用户可以通过整数索引（列表中的位置）来访问元素，并搜索列表中的元素（详细可进一步参考<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" target="_blank" rel="noopener">oracle官网</a>）。</p><p>这里我们尝试以java的array为基础实现一个列表，目标是实现自动扩容 (Java中的<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html" target="_blank" rel="noopener">ArrayList</a>不仅仅有自动扩容, 也继承了[List]的其他功能)。在探索的过程中, 可以顺带学习很多相关的内容.<br>使用自上而下的设计思想搭建一个框架:<br>先写出最基础的部分, 也就是一个构造器，前面学过了整数数组，我们直接拿来用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Array based list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// index   0 1  2 3 4 5 6 7</span></span><br><span class="line"><span class="comment">// items: [6 9 -1 2 0 0 0 0 ...]</span></span><br><span class="line"><span class="comment">// size: 5</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造一个初始容量100的数组，初始有效数据成员为0. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 下面添加其他方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>然后思考我们需要什么功能，把功能需求转化为实例方法instance method的形式，先把方法的外壳描绘出来，注释上该方法的功能（目的），输入值，返回值是什么之类的。具体的功能实现可以先空着，之后一步步丰富。</p><h3 id="公共-vs-私有-Public-vs-Private"><a href="#公共-vs-私有-Public-vs-Private" class="headerlink" title="公共 vs 私有 Public vs. Private"></a>公共 vs 私有 Public vs. Private</h3><p>在上面的代码块中，可以看到 items 和 size 都被声明为 private 私有变量, 这样就只能被所在的java文件内调用.</p><p>私有变量和方法的设计初衷是服务于程序的内部功能实现, 而不是用来和外部程序(用户)进行交互的. 设置成私有, 可以避免这些变量和方法被外部程序直接调用, 避免用户通过不恰当/容易出错的方式修改某些变量. 在程序说明文档中, 一般也会明确说明程序提供什么公共变量和方法给用户调用.</p><p>因此我们这里也提供几个 public 方法让用户调用, 这样用户就能按照我们设计的方式来访问数据。分别是<code>getLast()</code> - 访问列表最后一个元素，<code>get(int i)</code>访问第<code>i</code>个元素, 和<code>size()</code>访问列表的大小.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 程序内的方法可以访问 private 变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回列表末尾的值. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items[size - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回第 i 个值 (0 是第一个). */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回列表元素长度. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>我们不仅希望我们的列表可以存整数，也可以存其他类型的数据，可以通过泛型解决，泛型的介绍参考<a href="/NOTE-CS61B-data-structures-05-java-variable-types#通用数据类型-Generic">这篇文章</a>.</p><p>泛型数组跟前面介绍的泛型示例有一个重要的语法差异：Java不允许我们创建一个通用对象的数组，原因这里不细展开。</p><p>假如我们用<code>Item</code>来标识泛型, 那么在上面的列表类中构建泛型数组时, 我们不能用<code>items = new Item[8];</code>, 而要用<code>items = (Item []) new Object[8];</code>, 即使这样也会产生一个编译警告，但先忍着, 后面会更详细地讨论这个问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AList</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造一个初始容量100的数组，初始有效数据成员为0.  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        items = (Item[]) <span class="keyword">new</span> Object[<span class="number">100</span>]; <span class="comment">//会有编译警告, 暂时不管, 后面会解释</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数组扩容-Resize"><a href="#数组扩容-Resize" class="headerlink" title="数组扩容 Resize"></a>数组扩容 Resize</h3><p>一个列表应该支持基本的插入和删除数据的操作，但是因为数组本身无法更改长度，所以我们就需要一个方法，在给数组在插入新数据时，先检查长度容量是否足够，如果不够，那么就要增加长度。<br>我们考虑简单的情况, 即需要在数组末尾插入或者删除数据怎么办</p><p>插入元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 把 X 插入到列表末尾. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Item x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 检查长度容量是否足够，如果不够，那么就要增加长度 */</span></span><br><span class="line">    <span class="keyword">if</span> (size == items.length) &#123;</span><br><span class="line">            Item[] temp = (Item[]) <span class="keyword">new</span> Object[size + <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(items, <span class="number">0</span>, temp, <span class="number">0</span>, size);</span><br><span class="line">            items = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        items[size] = x;</span><br><span class="line">        size = size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建新array并把旧数据复制过去的过程通常称为“resizing”。其实用词不当，因为数组实际上并没有改变大小，只是把小数组上的数据复制到大数组上而已。</p><p>为了让代码更易于维护，可以把上面的代码中负责大小调整的部分包装在一个独立的method中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 改变列表容量, capacity为改变后的容量. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    Item[] temp = (Item[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    System.arraycopy(items, <span class="number">0</span>, temp, <span class="number">0</span>, size);</span><br><span class="line">    items = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 把 X 插入到列表末尾. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Item x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == items.length) &#123;</span><br><span class="line">        resize(size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    items[size] = x;</span><br><span class="line">    size = size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">删除元素：</span><br><span class="line">```java</span><br><span class="line"><span class="comment">/** 删去列表最后一个值，并返回该值  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Item x = getLast();</span><br><span class="line">    items[size - <span class="number">1</span>] = <span class="keyword">null</span>; <span class="comment">// 曾经引用“删除”的元素的内存地址被清空</span></span><br><span class="line">    size = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事实上即使没有<code>items[size - 1] = null;</code>,也可以达到删除元素的目的.<br>删除对改存储的对象的引用, 是为了避免“loitering”。所谓 loitering，可以理解为占着茅坑不拉屎的对象，它们已经没啥用了，却还是占用着内存。如果这个对象是些几十兆的高清图片，那么就会很消耗内存。这也是为什么安卓手机越用越慢的一个原因。</p><p>当引用/内存地址丢失时，Java会销毁对象。如果我们不清空引用，那么Java将不会垃圾回收这些本来预计要删除的对象, 因为它们实际还被列表引用着。</p><h4 id="扩容效率分析"><a href="#扩容效率分析" class="headerlink" title="扩容效率分析"></a>扩容效率分析</h4><p>我们直觉也会感觉到，如果按照现在的设计，即每插入一个新元素，就重新复制一遍数组，这样随着数组越来越大，效率肯定会越来越差。事实上也是这样，如果数组目前长度是100个内存块，那么插入1000次，需要创建并填充大约50万个内存块（等差数列求和N(N+1)/2，101+102+…+1000 ≈ 500000）。但假如我们第一次就扩容到1000，那么就省却了很多运算消耗。可惜我们不知道用户需要插入多少数据，所以要采取其他方法-几何调整。也就是与其按照<code>size + FACTOR</code>这样的速率增加容量, 不如按照<code>size * RFACTOR</code>成倍扩容, 前者的增加速率为1, 后者为 RFACTOR, 只要设置 RFACTOR 大于1, 就能减少扩容的次数.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 把 X 插入到列表末尾. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Item x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == items.length) &#123;</span><br><span class="line">        resize(size * RFACTOR); <span class="comment">//用 RFACTOR 作为因子扩容数组,</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    items[size] = x;</span><br><span class="line">    size = size + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>目前我们解决了时间效率问题, 但代价是需要更大的内存空间, 也就是空间效率下降了. 假设我们插入了十亿个item，然后再删去九亿九千万个项目。在这种情况下，我们将只使用10,000,000个内存块，剩下99％完全没有使用到。</p><p>为了解决这个问题，我们可以在数组容量利用率比较低时把容量降下来. 定义利用率 R 为列表的大小除以items数组的长度。一般当R下降到小于0.25时，我们将数组的大小减半。</p><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>比如排序等, 在后面介绍链表的文章中再讨论.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;列表-List&quot;&gt;&lt;a href=&quot;#列表-List&quot; class=&quot;headerlink&quot; title=&quot;列表 List&quot;&gt;&lt;/a&gt;列表 List&lt;/h2&gt;&lt;p&gt;前面说到Java的数组无法更改长度，那么也就无法实现插入或者删除数组成员。Java提供了功能更丰富的数据结构 - 列表（&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;list&lt;/a&gt;）。所谓列表，即有序的集合（序列），用户可以精确地控制每个元素插入到列表中的哪个位置。用户可以通过整数索引（列表中的位置）来访问元素，并搜索列表中的元素（详细可进一步参考&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;oracle官网&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;这里我们尝试以java的array为基础实现一个列表，目标是实现自动扩容 (Java中的&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ArrayList&lt;/a&gt;不仅仅有自动扩容, 也继承了[List]的其他功能)。在探索的过程中, 可以顺带学习很多相关的内容.&lt;br&gt;使用自上而下的设计思想搭建一个框架:&lt;br&gt;先写出最基础的部分, 也就是一个构造器，前面学过了整数数组，我们直接拿来用&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** Array based list.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// index   0 1  2 3 4 5 6 7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// items: [6 9 -1 2 0 0 0 0 ...]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// size: 5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AList&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] items;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/** 构造一个初始容量100的数组，初始有效数据成员为0. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        items = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        size = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/** 下面添加其他方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 06 - Java | array 数组 - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-06-java-array/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-06-java-array/</id>
    <published>2017-12-27T00:00:00.000Z</published>
    <updated>2018-01-04T20:46:01.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h2><p>数组是一种特殊的对象，有一个固定的数组长度参数N，由一连串（N个）连续的带编号的内存块组成，每个都是相同的类型(不像Python可以包含不同类型)，索引从0到N-1编号。A[i]获得数组A的第i个元素。这与普通的类实例不同，类实例有具体变量名命名的内存块。</p><h3 id="数组实例化，包含对象的数组-Array-Instantiation-Arrays-of-Objects"><a href="#数组实例化，包含对象的数组-Array-Instantiation-Arrays-of-Objects" class="headerlink" title="数组实例化，包含对象的数组 Array Instantiation, Arrays of Objects"></a>数组实例化，包含对象的数组 Array Instantiation, Arrays of Objects</h3><p>要创建最简单的整数数组, 有三种方式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>]; <span class="comment">//创建一个指定长度的数组，并用默认值（0）填充每个内存块。</span></span><br><span class="line">y = <span class="keyword">new</span> <span class="keyword">int</span> [] &#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;; <span class="comment">//创建一个合适大小的数组，以容纳指定的初始值</span></span><br><span class="line"><span class="keyword">int</span> [] z = &#123;<span class="number">9</span>，<span class="number">10</span>，<span class="number">11</span>，<span class="number">12</span>，<span class="number">13</span>&#125;; <span class="comment">//省略了new，只能结合变量声明使用。</span></span><br></pre></td></tr></table></figure></p><p>创建一组实例化对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* Create an array of two dogs. */</span></span><br><span class="line">        Dog[] dogs = <span class="keyword">new</span> Dog[<span class="number">2</span>];</span><br><span class="line">        dogs[<span class="number">0</span>] = <span class="keyword">new</span> Dog(<span class="number">8</span>);</span><br><span class="line">        dogs[<span class="number">1</span>] = <span class="keyword">new</span> Dog(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">/* Yipping will result, since dogs[0] has weight 8. */</span></span><br><span class="line">        dogs[<span class="number">0</span>].makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意到new有两种不同的使用方式：一种是创建一个可以容纳两个Dog对象的数组，另外两个创建各个实际的Dog实例。</p><p>数组复制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">99</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line">System.arraycopy(b, <span class="number">0</span>, x, <span class="number">3</span>, <span class="number">2</span>); <span class="comment">//效果类似于Python的`x[3:5] = b[0:2]`</span></span><br></pre></td></tr></table></figure></p><p><code>System.arraycopy</code>的五个参数分别代表：</p><ol><li>待复制的数组(源)</li><li>源数组复制起点</li><li>目标数组</li><li>目标数组粘贴起点</li><li>有多少项要复制</li></ol><p>2D数组<br>Java的二维数组实质上是一数组的数组, 即每一个数组元素里面也是一个数组。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] matrix; <span class="comment">//声明一个引用数组的数组</span></span><br><span class="line">matrix = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][]; <span class="comment">//创建四个内存块, 用默认null值填充, 之后用于储存对整数数组的引用, 即地址,</span></span><br><span class="line"><span class="keyword">int</span>[] rowZero = matrix[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 实例化整数数组, 把其地址/引用分别赋值给/储存到 matrix 的第N个内存块*/</span></span><br><span class="line">matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>&#125;;</span><br><span class="line">matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] rowTwo = matrix[<span class="number">2</span>];</span><br><span class="line">rowTwo[<span class="number">1</span>] = -<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 创建四个内存块, 其中每个被引用的整数数组长度为4,每个元素都是0.*/</span></span><br><span class="line">matrix = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] matrixAgain = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组-Array&quot;&gt;&lt;a href=&quot;#数组-Array&quot; class=&quot;headerlink&quot; title=&quot;数组 Array&quot;&gt;&lt;/a&gt;数组 Array&lt;/h2&gt;&lt;p&gt;数组是一种特殊的对象，有一个固定的数组长度参数N，由一连串（N个）连续的带编号的内存块组成，
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 05 - Java | 数据类型 - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-05-java-variable-types/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-05-java-variable-types/</id>
    <published>2017-12-26T00:00:00.000Z</published>
    <updated>2018-01-04T17:09:34.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><a href="https://zh.wikibooks.org/zh-hans/Java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">数据类型</a>是程序设计语言描述事物、对象的方法。Java数据类型分为基本类型（内置类型）和引用类型(扩展类型）两大类。基本类型就是Java语言本身提供的基本数据类型，比如，整型数，浮点数，字符，布尔值等等。而引用类型则是Java语言根据基本类型扩展出的其他类型，Java要求所有的引用扩展类型都必须包括在类定义里面，这就是Java为什么是面向对象编程语言的原因…</p><p>上面的定义有点抽象，要理解数据类型，需要先理解一个问题: 神秘的海象问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 尝试预测下面的代码运行时会发生什么。</span></span><br><span class="line"><span class="comment">b的变化是否会影响a？提示：类似Python。 */</span></span><br><span class="line">Walrus a = <span class="keyword">new</span> Walrus(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br><span class="line">Walrus b;</span><br><span class="line">b = a;</span><br><span class="line">b.weight = <span class="number">5</span>;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 同样尝试预测下面的代码运行时会发生什么。</span></span><br><span class="line"><span class="comment">x的改变是否影响y？ */</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">y = x;</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">System.out.println(<span class="string">"x is: "</span> + x);</span><br><span class="line">System.out.println(<span class="string">"y is: "</span> + y);</span><br></pre></td></tr></table></figure><p>首先给出答案, b的变化会影响a, 但x的改变不影响y，具体见<a href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+PollQuestions+%7B%0A+++public+static+void+main%28String%5B%5D+args%29+%7B%0A++++++Walrus+a+%3D+new+Walrus%281000,+8.3%29%3B%0A++++++Walrus+b%3B%0A++++++b+%3D+a%3B%0A++++++b.weight+%3D+5%3B%0A++++++System.out.println%28a%29%3B%0A++++++System.out.println%28b%29%3B++++++%0A%0A++++++int+x+%3D+5%3B%0A++++++int+y%3B%0A++++++y+%3D+x%3B%0A++++++x+%3D+2%3B%0A++++++System.out.println%28%22x+is%3A+%22+%2B+x%29%3B%0A++++++System.out.println%28%22y+is%3A+%22+%2B+y%29%3B++++++%0A+++%7D%0A+++%0A+++public+static+class+Walrus+%7B%0A++++++public+int+weight%3B%0A++++++public+double+tuskSize%3B%0A++++++%0A++++++public+Walrus%28int+w,+double+ts%29+%7B%0A+++++++++weight+%3D+w%3B%0A+++++++++tuskSize+%3D+ts%3B%0A++++++%7D%0A%0A++++++public+String+toString%28%29+%7B%0A+++++++++return+String.format%28%22weight%3A+%25d,+tusk+size%3A+%25.2f%22,+weight,+tuskSize%29%3B%0A++++++%7D%0A+++%7D%0A%7D&amp;mode=edit" target="_blank" rel="noopener">可视化过程</a>.<br>这里的差别虽然微妙, 但其背后的原理对于数据结构的效率来说是非常重要的，对这个问题的深入理解也将引导我们写出更安全，更可靠的代码。<br><a id="more"></a></p><h3 id="基本类型-Primative-Types"><a href="#基本类型-Primative-Types" class="headerlink" title="基本类型 Primative Types"></a>基本类型 Primative Types</h3><p>计算机中的所有信息都以一系列1和0的形式存储在内存中，这些二进制的0和1就是比特位（bits）。比如72和“H”在内存一般以01001000的形式存储，对他们的形式是一样的。一个引申问题就是：Java代码如何解释01001000，怎么知道应该解释为72还是“H”？ 通过类型types，预先定义好类型即可, 以下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> x = <span class="string">'H'</span>;</span><br><span class="line"><span class="keyword">int</span> y = x;</span><br><span class="line">System.out.println(x);</span><br><span class="line">System.out.println(y);</span><br></pre></td></tr></table></figure></p><p>会分别得到“H”和72. 在这种情况下，x和y变量都包含几乎相同的bits，但是Java解释器在输出时对它们进行了不同的处理。</p><p>Java有8种基本类型：byte，short，int，long，float，double，boolean和char。</p><h4 id="变量声明-Declaring-Variables"><a href="#变量声明-Declaring-Variables" class="headerlink" title="变量声明 Declaring Variables"></a>变量声明 Declaring Variables</h4><p>计算机的内存可以视为包含大量用于存储信息的内存比特位，每个位都有一个唯一的地址。现代计算机可以使用许多这样的位。 当你声明一个特定类型的变量时，Java会用一串<strong>连续</strong>的内存位存储它。例如，如果你声明一个int，你会得到一个长度32的内存list，里面有32bits。Java中的每个数据类型都有不同的比特数。</p><p>除了留出内存空间外，Java解释器还会在一个内部表中创建一个条目，将每个变量名称映射到内存块中第一个位置（表头list head）。 例如，如果声明了int x和double y，那么Java可能会决定使用计算机内存的352到384位来存储x，而20800到20864位则用来存储y。然后解释器将记录int x从352开始，y从20800开始。</p><p>在Java语言里无法知道变量的具体内存位置，例如你不能以某种方式发现x在位置352。不像C++这样的语言，可以获取一段数据的确切地址。Java的这个特性是一个折衷！隐藏内存位置自然意味着程序猿的控制权更少，就无法做<a href="http://www.informit.com/articles/article.aspx?p=2246428&amp;seqNum=5" target="_blank" rel="noopener">某些类型的优化</a>。但是，它也避免了一大类非常棘手的<a href="http://www.informit.com/articles/article.aspx?p=2246428&amp;seqNum=1" target="_blank" rel="noopener">编程错误</a>。在现在计算成本如此低廉的时代，不成熟的优化还不如少点bug。</p><p>当声明一个变量时，Java不会在预留的内存位置中写入任何内容, 也即没有默认值。因此，如果没有赋值, Java编译器会阻止你使用变量。</p><p>以上只是内存分配的简要说明, 堆和栈的介绍可以参考我的CS106B C++笔记。</p><h3 id="引用类型-Reference-Types"><a href="#引用类型-Reference-Types" class="headerlink" title="引用类型 Reference Types"></a>引用类型 Reference Types</h3><p>所有基本数据类型之外的类型都是引用类型。<br>引用类型顾名思义，就是对对象的引用。在java中内存位置是不开放给程序员的, 但我们可以通过引用类型访问内存中某处对象。所有引用类型都是 java.lang.Object 类型的子类。</p><h4 id="对象实例化-Object-Instantiation"><a href="#对象实例化-Object-Instantiation" class="headerlink" title="对象实例化 Object Instantiation"></a>对象实例化 Object Instantiation</h4><p>对象实例化：当我们使用new（例 new Dog）实例化对象时，Java首先为类的每个实例变量分配一串长度合适的bits位，并用缺省值填充它们。然后，构造函数通常（但不总是）用其他值填充每个位置.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Walrus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> tuskSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Walrus</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">double</span> ts)</span> </span>&#123;</span><br><span class="line">          weight = w;</span><br><span class="line">          tuskSize = ts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用<code>new Walrus(1000, 8.3)</code>创建一个Walrus实例后, 我们得到分别由一个32位(int weight = 1000)和一个64位(double tuskSize = 8.3)的内存块组成的实例：<br>通过程序<a href="http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+PollQuestions+%7B%0A+++public+static+void+main%28String%5B%5D+args%29+%7B%0A++++++Walrus+a+%3D+new+Walrus%281000,+8.3%29%3B%0A++++++Walrus+b%3B%0A++++++b+%3D+a%3B%0A++++++b.weight+%3D+5%3B%0A++++++System.out.println%28a%29%3B%0A++++++System.out.println%28b%29%3B++++++%0A%0A++++++int+x+%3D+5%3B%0A++++++int+y%3B%0A++++++y+%3D+x%3B%0A++++++x+%3D+2%3B%0A++++++System.out.println%28%22x+is%3A+%22+%2B+x%29%3B%0A++++++System.out.println%28%22y+is%3A+%22+%2B+y%29%3B++++++%0A+++%7D%0A+++%0A+++public+static+class+Walrus+%7B%0A++++++public+int+weight%3B%0A++++++public+double+tuskSize%3B%0A++++++%0A++++++public+Walrus%28int+w,+double+ts%29+%7B%0A+++++++++weight+%3D+w%3B%0A+++++++++tuskSize+%3D+ts%3B%0A++++++%7D%0A%0A++++++public+String+toString%28%29+%7B%0A+++++++++return+String.format%28%22weight%3A+%25d,+tusk+size%3A+%25.2f%22,+weight,+tuskSize%29%3B%0A++++++%7D%0A+++%7D%0A%7D&amp;mode=edit" target="_blank" rel="noopener">可视化过程</a>)来更好地理解. 当然在Java编程语言的实际实现中，实例化对象时都有一些额外的内存开销, 这里不展开.</p><p>通过 new 实例化对象，new 会返回该对象的内存地址给我们，但假如我们没有用一个变量去接收这个地址，那么我们就无法访问这个对象。之后该对象会被作为垃圾回收。</p><h4 id="引用变量声明-Reference-Variable-Declaration"><a href="#引用变量声明-Reference-Variable-Declaration" class="headerlink" title="引用变量声明 Reference Variable Declaration"></a>引用变量声明 Reference Variable Declaration</h4><p>前面有提到，我们需要声明变量来接受实例化的对象在内存中的地址。当声明任何引用类型的变量（比如array, 前面的Dog类等）时，Java都会分配一串64位的内存位置. 这个64位的内存块仅用于记录变量的内存<strong>地址</strong>, 所谓内存地址, 可以理解为内存(房子)的编号(地址), 一般是内存块的表头位置的64位表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Walrus someWalrus; <span class="comment">// 创建一个64位的内存位置</span></span><br><span class="line">someWalrus = <span class="keyword">new</span> Walrus(<span class="number">1000</span>, <span class="number">8.3</span>); <span class="comment">//创建一个新的实例</span></span><br><span class="line"><span class="comment">/** 内存地址由 new 返回, 并被复制/赋值给 someWalrus 对应的内存位置</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>比如, 假设weight是从内存位5051956592385990207开始存储的，后面连续跟着其他实例变量，那么就可以把5051956592385990207存储在Dog变量中。5051956592385990207由64位的二进制0100011000011100001001111100000100011101110111000001111000111111表达，这样smallDog的内存就可以抽象的理解为一个表<br><code>smallDog: 0100011000011100001001111100000100011101110111000001111000111111 -&gt; 具体存放实例的内存(Walrus: weight=1000, tuskSize=8.3)</code><br>‘-&gt;’可以理解为指针.</p><p><a href="array-instantiation-arrays-of-objects">实例化数组</a>在前面有介绍过，数组array是引用类型，是对象，故数组变量只是存储内存位置。</p><p>前面有提到，如果丢失了引用变量存储的内存地址，那么该地址对应的对象就找不回来了。例如，如果一个特定的 Walrus 地址的唯一副本存储在x中，那么<code>x = null</code>这行代码将删去地址，我们则丢失了这个 Walrus 对象。这也不一定是坏事，很多时候在完成了一个对象后就不在需要了，只需简单地丢弃这个参考地址就可以了。</p><h3 id="Java-等值规则-Rule-of-Equals"><a href="#Java-等值规则-Rule-of-Equals" class="headerlink" title="Java 等值规则 Rule of Equals"></a>Java 等值规则 Rule of Equals</h3><p><strong>对于<code>y = x</code>，Java解释器会将x的位拷贝到y中</strong>,这个规则适用于java中任何使用<code>=</code>赋值的语法, 是理解开头的”神秘的海象”问题的关键.</p><ul><li><p>基本类型变量的位, 存储赋值的值（基本类型）在内存中值(具体位数取决于具体的类型)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>; <span class="comment">// 此时是把内存中的某一个地址 p 复制给 x</span></span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">y = x; <span class="comment">// y 也指向 p</span></span><br><span class="line">x = <span class="number">2</span>; <span class="comment">// 把一个新的内存地址 new p 复制给x, 但y还是指向原来的p</span></span><br></pre></td></tr></table></figure><p>  x的位存储的是基本类型<code>int 5</code>(32 bits), <code>x = 2</code>是把新的基本类型<code>int 2</code>复制给x, 但y还是指向原来的<code>int 5</code>， 所以y没变化。</p></li><li><p>引用类型 reference type 变量的位, 存储赋值的值（引用类型）在内存中的地址(固定的64 bits)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dog a = <span class="keyword">new</span> Dog(<span class="number">5</span>); <span class="comment">// 创建一个64位的内存位, 并赋值一个新的实例 p</span></span><br><span class="line">Dog b; <span class="comment">// 仅创建一个64位的内存位, 没有引用内存地址(null)</span></span><br><span class="line">b = a; <span class="comment">// 把a的位（是实例 p 的内存地址）复制给b, 这样 b 也是指向实例 p</span></span><br><span class="line">b.weight = <span class="number">21</span>; <span class="comment">// 此时修改b, 会改写b指向的内存实例 p</span></span><br></pre></td></tr></table></figure><p>  a和b只存储地址, 而它们的地址都指向相同的实例；<br>  如果对 b 的修改本质是对 p的修改, 那么输出<code>a.weight</code>的时候, 就会变成<code>21</code>.</p></li></ul><h3 id="参数传递-Parameter-Passing"><a href="#参数传递-Parameter-Passing" class="headerlink" title="参数传递 Parameter Passing"></a>参数传递 Parameter Passing</h3><p>给函数传递参数，本质上也是赋值操作，参考上面的等值规则，也即复制这些参数的bits给函数，也称之为pass by value。Java的参数传递都是pass by value。至于传递过去的参数会不会因为函数内部的操作而更改，其判断原理在上面的<a href="java-等值规则-rule-of-equals">等值规则</a>已经阐明。</p><h3 id="通用数据类型-Generic"><a href="#通用数据类型-Generic" class="headerlink" title="通用数据类型 Generic"></a>通用数据类型 Generic</h3><p>在定义类的时候，有时候我们可能希望这个类能够接受任何类型的数据，而不仅仅是限定了基本类型中的任何一种。比如我们想实现一个类似PPT的类，自然需要这个PPT类能够接收各种类型的字符，数字，并呈现出来。这个时候就需要使用泛型 Generic, 也即通用数据类型。</p><p>在2004年，Java的设计者在语言中加入了泛型，使​​我们能够创建包含任何引用类型的数据结构（引用类型和基本类型的解释参考<a href="/NOTE-CS61B-data-structures-05-java-variable-types#引用类型-Reference-Types">另一篇文章</a>, ）。方法就是在类声明的类名后面，使用一个任意的占位符，并用尖括号括住<code>&lt;随便什么字符&gt;</code>。然后，在任何你想使用泛型的地方，改用占位符。<br>比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PPT</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PPT</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> item;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>改为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PPT</span>&lt;<span class="title">xxx</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PPT</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> xxx item;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>&lt;xxx&gt;</code>里面的名称并不重要, 改成其他也行, 只是一个标识符, 用来接受参数, 当用户实例化这个类时, 必须使用特殊的语法<code>PPT&lt;String&gt; d = new PPT&lt;&gt;(&quot;hello&quot;);</code></p><p>由于泛型仅适用于引用类型，因此我们不能将基本类型<code>int</code>等放在尖括号内。相反，我们使用基本类型的引用版本，比如对于int, 用 Integer，<code>PPT&lt;Integer&gt; d = new PPT&lt;&gt;(&quot;10&quot;);</code></p><p>总结使用方法:</p><ul><li>在一个实现某数据结构的<code>.java</code>文件中，在类名后面, 只指定泛型类型一次。</li><li>在其他使用该数据结构的java文件中，声明实例变量时要指定所需的类型。</li><li>如果您需要在基本类型上实例化泛型，请使用<code>Integer, Double, Character, Boolean, Long, Short, Byte, Float</code>，而不是其基本类型。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikibooks.org/zh-hans/Java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据类型&lt;/a&gt;是程序设计语言描述事物、对象的方法。Java数据类型分为基本类型（内置类型）和引用类型(扩展类型）两大类。基本类型就是Java语言本身提供的基本数据类型，比如，整型数，浮点数，字符，布尔值等等。而引用类型则是Java语言根据基本类型扩展出的其他类型，Java要求所有的引用扩展类型都必须包括在类定义里面，这就是Java为什么是面向对象编程语言的原因…&lt;/p&gt;
&lt;p&gt;上面的定义有点抽象，要理解数据类型，需要先理解一个问题: 神秘的海象问题&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** 尝试预测下面的代码运行时会发生什么。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;b的变化是否会影响a？提示：类似Python。 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Walrus a = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Walrus(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8.3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Walrus b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b = a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b.weight = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(b);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/** 同样尝试预测下面的代码运行时会发生什么。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;x的改变是否影响y？ */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;x is: &quot;&lt;/span&gt; + x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;y is: &quot;&lt;/span&gt; + y);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先给出答案, b的变化会影响a, 但x的改变不影响y，具体见&lt;a href=&quot;http://cscircles.cemc.uwaterloo.ca/java_visualize/#code=public+class+PollQuestions+%7B%0A+++public+static+void+main%28String%5B%5D+args%29+%7B%0A++++++Walrus+a+%3D+new+Walrus%281000,+8.3%29%3B%0A++++++Walrus+b%3B%0A++++++b+%3D+a%3B%0A++++++b.weight+%3D+5%3B%0A++++++System.out.println%28a%29%3B%0A++++++System.out.println%28b%29%3B++++++%0A%0A++++++int+x+%3D+5%3B%0A++++++int+y%3B%0A++++++y+%3D+x%3B%0A++++++x+%3D+2%3B%0A++++++System.out.println%28%22x+is%3A+%22+%2B+x%29%3B%0A++++++System.out.println%28%22y+is%3A+%22+%2B+y%29%3B++++++%0A+++%7D%0A+++%0A+++public+static+class+Walrus+%7B%0A++++++public+int+weight%3B%0A++++++public+double+tuskSize%3B%0A++++++%0A++++++public+Walrus%28int+w,+double+ts%29+%7B%0A+++++++++weight+%3D+w%3B%0A+++++++++tuskSize+%3D+ts%3B%0A++++++%7D%0A%0A++++++public+String+toString%28%29+%7B%0A+++++++++return+String.format%28%22weight%3A+%25d,+tusk+size%3A+%25.2f%22,+weight,+tuskSize%29%3B%0A++++++%7D%0A+++%7D%0A%7D&amp;amp;mode=edit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;可视化过程&lt;/a&gt;.&lt;br&gt;这里的差别虽然微妙, 但其背后的原理对于数据结构的效率来说是非常重要的，对这个问题的深入理解也将引导我们写出更安全，更可靠的代码。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 04 - Java | 类 class 02 类与实例 - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-04-java-class-02-class-instance/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-04-java-class-02-class-instance/</id>
    <published>2017-12-25T00:00:00.000Z</published>
    <updated>2017-12-31T15:40:23.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>前面提到，类的方法和变量细分为静态的和非静态的. 静态就是可以被类调用，所以静态方法/变量也称之为类方法/变量；<br>非静态只能由实例调用，所以也称之为实例方法/变量。</p><h3 id="类方法-vs-实例方法-Class-Methods-vs-Instance-Methods"><a href="#类方法-vs-实例方法-Class-Methods-vs-Instance-Methods" class="headerlink" title="类方法 vs 实例方法 Class Methods vs. Instance Methods"></a>类方法 vs 实例方法 Class Methods vs. Instance Methods</h3><p>参考<a href="/NOTE-CS61B-data-structures-04-java-class-01-intro.html#实例变量和对象实例化-instance-variables-and-object-instantiation">上一篇文章的例子</a>，类方法由类调用<code>Dog.makeNoise();</code>. 实例方法只能由实例调用<code>bigDog.makeNoise();</code>. 同理可推, 类方法无法调用实例变量.</p><p>可以看到实例方法更具体, 更贴近实体世界, 那我们仍需要类方法, 因为:</p><ul><li>有些类不需要实例化, 毕竟我们也经常需要处理抽象的概念, 这些抽象概念在人类认知范畴内是统一的, 比如数学计算, 我们需要计算某个数值的平方根, <code>x = Math.sqrt(100);</code>, 拿来就用, 不需要先实例化. 这点在Python中体现得很好.</li><li><p>有些类有静态方法, 是有实际作用的。例如，若想比较一个类里面的不同实例, 比如两只狗的重量。比较简单的方法就是使用一个比较狗的重量的类方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title">maxDog</span><span class="params">(Dog d1, Dog d2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d1.weight &gt; d2.weight) &#123;</span><br><span class="line">        <span class="keyword">return</span> d1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d2;</span><br><span class="line">&#125;</span><br><span class="line">Dog d = <span class="keyword">new</span> Dog(<span class="number">15</span>);</span><br><span class="line">Dog d2 = <span class="keyword">new</span> Dog(<span class="number">100</span>);</span><br><span class="line">Dog.maxDog(d, d2);</span><br></pre></td></tr></table></figure><ul><li>这个时候, 若使用实例方法也可以, 但没那么直观：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 我们使用关键字this来引用当前对象d。*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dog <span class="title">maxDog</span><span class="params">(Dog d2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.weight &gt; d2.weight) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d2;</span><br><span class="line">&#125;</span><br><span class="line">Dog d = <span class="keyword">new</span> Dog(<span class="number">15</span>);</span><br><span class="line">Dog d2 = <span class="keyword">new</span> Dog(<span class="number">100</span>);</span><br><span class="line">d.maxDog(d, d2);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="类变量-vs-实例变量-Class-Variables-vs-Instance-Variables"><a href="#类变量-vs-实例变量-Class-Variables-vs-Instance-Variables" class="headerlink" title="类变量 vs 实例变量 Class Variables vs. Instance Variables"></a>类变量 vs 实例变量 Class Variables vs. Instance Variables</h3><p>静态变量的也是有用处的。这些变量一般是类本身固有的属性。例如，我们可能需要用狗类的另一种生物学的统称“犬科”来作为类的说明， 这个时候可以用<code>public static String binomen = &quot;犬科&quot;;</code>，这个变量理论上是由类来访问的。<br>虽然Java在技术上允许使用实例名称来访问静态变量，但是这有时候可能会令人困惑， 所以还是少用为好。</p><h3 id="构造器-Constructors-in-Java"><a href="#构造器-Constructors-in-Java" class="headerlink" title="构造器 Constructors in Java"></a>构造器 Constructors in Java</h3><p>与上面的<code>DogLauncher</code>实例化对象的方式相比, 我们更希望实例化可以带参数的，那样可以为我们节省手动给实例变量赋值的麻烦。为了启用这样的语法，我们只需把如下的构造函数直接添加进Dog类中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**注意：构造函数与class类同名</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        weight = w;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>然后在<code>DogLauncher</code>里实例化一只狗时, 直接<code>Dog d = new Dog(20);</code>即可.  </p><p>在以上代码的基础上, 后续当我们想使用new和参数创建一只狗时，可以随时调用<code>public Dog(int w)</code>构造函数。对于熟悉Python的人来说，你可以理解java的构造函数为Python的<code>__init__</code>。</p><p>一些术语:</p><ul><li>声明(declaration): <code>Dog smalldog;</code>声明一个类作为一个变量在内存中占位</li><li>实例化: <code>new Dog(20)</code>, 如果没有把它作为值赋给一个类声明变量,那么这个实例化的值会被垃圾回收.</li><li>声明, 实例化并赋值: <code>Dog smalldog = new Dog(5)</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Class&quot;&gt;&lt;a href=&quot;#Class&quot; class=&quot;headerlink&quot; title=&quot;Class&quot;&gt;&lt;/a&gt;Class&lt;/h2&gt;&lt;p&gt;前面提到，类的方法和变量细分为静态的和非静态的. 静态就是可以被类调用，所以静态方法/变量也称之为类方法/变量；&lt;b
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 04 - Java | 类 class 01 变量和方法 - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-04-java-class-01-intro/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-04-java-class-01-intro/</id>
    <published>2017-12-24T00:00:00.000Z</published>
    <updated>2017-12-31T15:40:03.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>Java的语法是为了更容易地模拟真实世界而设计的. 比如用程序实现一只狗, 可以用定义一个类class来描述它.</p><p>类class里面包括变量Variable，方法method（可以理解为Python的函数function）。变量可以储存数据，方法可以处理数据。变量必须在类中声明(即不能离开类独立存在)，不像Python或Matlab这样的语言可以在运行时添加新的变量。类的方法和变量又细分为静态的和非静态的.</p><p>静态就是可以被类调用，所以静态方法/变量也称之为类方法/变量；<br>非静态只能由实例调用，所以也称之为实例方法/变量。实例instance的概念后面会解释。</p><h3 id="类（静态）变量和方法-Class-Static-Variables-and-Methods"><a href="#类（静态）变量和方法-Class-Static-Variables-and-Methods" class="headerlink" title="类（静态）变量和方法 Class(Static) Variables and Methods"></a>类（静态）变量和方法 Class(Static) Variables and Methods</h3><p>静态变量和方法的特征就是有<code>static</code>字符在前面.<br>以下代码定义了一个类来模拟狗，包含一个类变量作为这个类的说明，一个类方法用于发出叫声：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String instruction = <span class="string">"狗类实例"</span>; <span class="comment">//类变量, 说明</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeNoise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里没有定义main(), 在这种情况下如何直接运行这个类(<code>java Dog</code>), 程序是会报错的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误: 在类 Dog 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">否则 JavaFX 应用程序类必须扩展javafx.application.Application`.</span></span><br></pre></td></tr></table></figure></p><p>你可以选择在里面添加一个<code>main()</code>方法. 但这次我们选择不定义具体的<code>main()</code>. 具体要如何运行, 我们可以另写一个类定义一个main()方法来调用这个类.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogLauncher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这两种方式(在类A内部定义好main() vs. 在其他类B定义main()来调用A)没有优劣之分, 二者有不同的适用情况. 随着不断深入学习，二者的区分将变得更清晰。</p><p>注意到, 类变量和方法是有局限性的。现实世界中, 并不是所有的狗都是一样的特征，仅仅靠类这个概念是无法区分不同个体的狗, 除非你为不同的狗定义不同的类（以及里面的变量和方法）, 那么就会很繁琐痛苦. 也就是说，用类来模拟个体是低效的，我们要使用实例.</p><h3 id="实例变量和对象实例化-Instance-Variables-and-Object-Instantiation"><a href="#实例变量和对象实例化-Instance-Variables-and-Object-Instantiation" class="headerlink" title="实例变量和对象实例化 Instance Variables and Object Instantiation"></a>实例变量和对象实例化 Instance Variables and Object Instantiation</h3><a id="more"></a><p>Java的类定义就像定义一张蓝图, 我们可以在这个蓝图的基础上, 生成不同的实例instance. 实例是概念性的说法，本质上在Java里就是对象object。这样的特性提供了一个很自然而然地在java中模拟生成实体世界的方法：定义一个狗的类，在这个类的基础上，通过不同的特征参数实例化不同特征的狗（instances），并使类方法的输出取决于特定实例的狗的属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 一只狗的类:*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeNoise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (weight &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"嘤嘤嘤!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weight &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"汪汪汪"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"嗷呜!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的方法和变量没有<code>static</code>, 所以是实例（非静态）方法和变量. 如果直接用 Dog 类来调用这些方法, 会报错:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogLauncher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog.weight = <span class="number">21</span>;</span><br><span class="line">        Dog.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DogLauncher.java:<span class="number">3</span>: 错误: 无法从静态上下文中引用非静态 变量 weight</span><br><span class="line">        Dog.weight = <span class="number">21</span>;</span><br><span class="line">           ^</span><br><span class="line">DogLauncher.java:<span class="number">4</span>: 错误: 无法从静态上下文中引用非静态 方法 makeNoise()</span><br><span class="line">        Dog.makeNoise();</span><br><span class="line">           ^</span><br></pre></td></tr></table></figure><p>这个时候, 你需要实例化一只狗, 让这个实例来调用非静态变量和方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogLauncher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog biglDog = <span class="keyword">new</span> Dog();</span><br><span class="line">        biglDog.weight = <span class="number">5</span>;</span><br><span class="line">        biglDog.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行时，这个程序将会创建一个重量为5的狗，这个狗就会“嗷呜”叫。</p><p>总的来说，之所以需要实例方法和变量，是因为我们需要模拟个体，一只具体的狗，并让它发出声音。这个weight和makeNoise()只能由具体的狗调用。狗类不能调用，也没有调用的意义, 毕竟每只狗的重量和声音都不同的. 在设计程序时, 如果其中一个方法我们只打算让特定的实例来调用它(而不让类去调用它), 那么这个方法应该设计成实例方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Class&quot;&gt;&lt;a href=&quot;#Class&quot; class=&quot;headerlink&quot; title=&quot;Class&quot;&gt;&lt;/a&gt;Class&lt;/h2&gt;&lt;p&gt;Java的语法是为了更容易地模拟真实世界而设计的. 比如用程序实现一只狗, 可以用定义一个类class来描述它.&lt;/p&gt;
&lt;p&gt;类class里面包括变量Variable，方法method（可以理解为Python的函数function）。变量可以储存数据，方法可以处理数据。变量必须在类中声明(即不能离开类独立存在)，不像Python或Matlab这样的语言可以在运行时添加新的变量。类的方法和变量又细分为静态的和非静态的.&lt;/p&gt;
&lt;p&gt;静态就是可以被类调用，所以静态方法/变量也称之为类方法/变量；&lt;br&gt;非静态只能由实例调用，所以也称之为实例方法/变量。实例instance的概念后面会解释。&lt;/p&gt;
&lt;h3 id=&quot;类（静态）变量和方法-Class-Static-Variables-and-Methods&quot;&gt;&lt;a href=&quot;#类（静态）变量和方法-Class-Static-Variables-and-Methods&quot; class=&quot;headerlink&quot; title=&quot;类（静态）变量和方法 Class(Static) Variables and Methods&quot;&gt;&lt;/a&gt;类（静态）变量和方法 Class(Static) Variables and Methods&lt;/h3&gt;&lt;p&gt;静态变量和方法的特征就是有&lt;code&gt;static&lt;/code&gt;字符在前面.&lt;br&gt;以下代码定义了一个类来模拟狗，包含一个类变量作为这个类的说明，一个类方法用于发出叫声：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Dog&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; String instruction = &lt;span class=&quot;string&quot;&gt;&quot;狗类实例&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//类变量, 说明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;makeNoise&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;汪!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里没有定义main(), 在这种情况下如何直接运行这个类(&lt;code&gt;java Dog&lt;/code&gt;), 程序是会报错的&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;错误: 在类 Dog 中找不到 main 方法, 请将 main 方法定义为:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;否则 JavaFX 应用程序类必须扩展javafx.application.Application`.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你可以选择在里面添加一个&lt;code&gt;main()&lt;/code&gt;方法. 但这次我们选择不定义具体的&lt;code&gt;main()&lt;/code&gt;. 具体要如何运行, 我们可以另写一个类定义一个main()方法来调用这个类.&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DogLauncher&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Dog.makeNoise();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这两种方式(在类A内部定义好main() vs. 在其他类B定义main()来调用A)没有优劣之分, 二者有不同的适用情况. 随着不断深入学习，二者的区分将变得更清晰。&lt;/p&gt;
&lt;p&gt;注意到, 类变量和方法是有局限性的。现实世界中, 并不是所有的狗都是一样的特征，仅仅靠类这个概念是无法区分不同个体的狗, 除非你为不同的狗定义不同的类（以及里面的变量和方法）, 那么就会很繁琐痛苦. 也就是说，用类来模拟个体是低效的，我们要使用实例.&lt;/p&gt;
&lt;h3 id=&quot;实例变量和对象实例化-Instance-Variables-and-Object-Instantiation&quot;&gt;&lt;a href=&quot;#实例变量和对象实例化-Instance-Variables-and-Object-Instantiation&quot; class=&quot;headerlink&quot; title=&quot;实例变量和对象实例化 Instance Variables and Object Instantiation&quot;&gt;&lt;/a&gt;实例变量和对象实例化 Instance Variables and Object Instantiation&lt;/h3&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 03 - Java | 代码风格 注释 Javadoc - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-03-java-code-style-comments/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-03-java-code-style-comments/</id>
    <published>2017-12-21T00:00:00.000Z</published>
    <updated>2018-01-04T20:46:16.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代码风格与注释-Code-style-and-comments"><a href="#代码风格与注释-Code-style-and-comments" class="headerlink" title="代码风格与注释 Code style and comments"></a>代码风格与注释 Code style and comments</h3><p>在学习和实践过程中，我们应该努力保持代码可读性。良好的编码风格的一些最重要的特点是：</p><ul><li>一致的风格（间距，变量命名，缩进风格等）</li><li>大小（线不太宽，源文件不要太长）</li><li>描述性命名（变量，函数，类），例如变量或函数名称为年份或getUserName而不是x或f。让代码本身提供可解读性。</li><li>避免重复的代码：几乎不会有两个重要的代码块几乎相同，除了一些改变。</li><li>适当的评论, 使其他读者也能轻松理解你的代码<ul><li>行注释: <code>//</code>分隔符开头行被当做注释。</li><li>Block（又名多行注释）注释: <code>/*</code>,  <code>*/</code>, 但我们更推荐javadoc形式的注释。</li></ul></li></ul><h3 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h3><p>Javadoc: <code>/ **</code>，<code>*/</code>, 可以（但不总是）包含描述性标签。 借助<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/windows/javadoc.html" target="_blank" rel="noopener">javadoc工具</a>可以生成HTML格式的API文档。<br>第一段是方法的描述。描述下面是不同的<a href="https://en.wikipedia.org/wiki/Javadoc" target="_blank" rel="noopener">描述性标签</a>, 比如参数 <code>@param</code>， 返回值 <code>@return</code>， 可能抛出的任何异常 <code>@throws</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>   名字，邮箱&lt;address @ example.com&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>     1.6 版本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;代码风格与注释-Code-style-and-comments&quot;&gt;&lt;a href=&quot;#代码风格与注释-Code-style-and-comments&quot; class=&quot;headerlink&quot; title=&quot;代码风格与注释 Code style and comment
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 02 - Java | 语法基础 - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-02-java-basic-syntax/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-02-java-basic-syntax/</id>
    <published>2017-12-20T00:00:00.000Z</published>
    <updated>2018-01-04T20:46:21.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基本语法"><a href="#Java基本语法" class="headerlink" title="Java基本语法"></a>Java基本语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序由一个类声明组成，该声明使用关键字<code>public class</code>声明。</p><ul><li>Java所有的代码都应该包含在class里面。</li><li>真正负责运行的代码，是一个名为main的method，它声明为<code>public static void main(String[] args)</code>。<ul><li>public：公共的，大部分方法都是以这个关键字开始的，后面会进一步解释。</li><li>static：这是一个静态方法，不与任何特定的实例关联，后面会解释。</li><li>void：它没有返回类型。</li><li>main：这是方法的名称。</li><li><code>String [] args</code>：这是传递给main方法的参数。</li></ul></li><li>使用大括号<code>{ }</code>来表示一段代码的开始和结束。</li><li>声明必须以分号结尾</li></ul><h2 id="静态分类-Static-Typing"><a href="#静态分类-Static-Typing" class="headerlink" title="静态分类 Static Typing"></a>静态分类 Static Typing</h2><p>程序语言静态与动态的分类，可以参考oracle的<a href="https://docs.oracle.com/cd/E57471_01/bigData.100/extensions_bdd/src/cext_transform_typing.html" target="_blank" rel="noopener">说明文件</a>，它解释了动态和静态类型之间的区别, 帮助你理解由程序的错误提示信息。<br>两个主要区别:<br>1. 动态类型语言在运行时执行类型检查，而静态类型语言在编译时执行类型检查。这意味如果以静态类型语言（如Java）编写的脚本包含错误，则在编译错误之前将无法编译. 而用动态类型语言编写的脚本可以编译，即使它们包含会阻止脚本正常运行（如果有的话）的错误。<br>2. 静态类型语言要求你在使用它们之前声明变量的数据类型，而动态类型语言则不需要。<br>考虑以下两个代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">num = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line">num = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>这两段代码都创建一个名为num的变量并赋值为5. 不同之处在于Java需要将num的数据类型明确定义为int。因为Java是静态类型的，因此它期望变量在被赋值之前被声明。</p><p>Python是动态类型的，不需要定义类型, Python根据变量的值确定其数据类型。动态类型语言更加灵活，在编写脚本时可以节省时间和空间。但是，这可能会导致运行时出现问题。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line">number = <span class="number">5</span></span><br><span class="line">numbr = (number + <span class="number">15</span>) / <span class="number">2</span>  <span class="comment">#注意错字</span></span><br></pre></td></tr></table></figure></p><p>上面的代码本应创建一个值为5的可变数字，然后将其加上15并除以2以得到10. 但是，<code>number</code>在第二行的开头拼写错误。由于Python不需要声明变量，因此会不由分说直接创建一个名为<code>numbr</code>的新变量，并把本应分配给<code>number</code>的值分配给它。这段代码会很顺利编译，但是如果程序试图用<code>number</code>来做某事，程序员假设它的值是10，那么后续就无法产生期望的结果,而且还很难注意到问题。</p><p>Java的compiler其中一个关键作用是进行静态类型检查（static type check）。若前面定义了 <code>int x = 0;</code>, 那么后面若给x赋值其他的类型值<code>x = &#39;horse&#39;;</code>, compiler就会报错. 这样就保证了程序不会出现类型错误.</p><p>除了错误检查外, static types 也可以让程序媛/猿知道自己处的是什么对象.</p><p>总而言之，静态类型具有以下优点：</p><ul><li>编译器确保所有类型都是兼容的，这使得程序员更容易调试他们的代码。</li><li>由于代码保证没有类型错误，所以编译后程序的用户将永远不会遇到类型错误。例如，Android应用程序是用Java编写的，通常仅以.class文件的形式分发，即以编译的格式。因此，这样的应用程序不应该由于类型错误而崩溃。</li><li>每个变量，参数和函数都有一个声明的类型，使程序员更容易理解和推理代码。</li></ul><h2 id="Code-Style-Comments-Javadoc"><a href="#Code-Style-Comments-Javadoc" class="headerlink" title="Code Style, Comments, Javadoc"></a>Code Style, Comments, Javadoc</h2><p>在学习和实践过程中，我们应该努力保持代码可读性。良好的编码风格的一些最重要的特点是：</p><ul><li>一致的风格（间距，变量命名，缩进风格等）</li><li>大小（线不太宽，源文件不要太长）</li><li>描述性命名（变量，函数，类），例如变量或函数名称为年份或getUserName而不是x或f。让代码本身提供可解读性。</li><li>避免重复的代码：几乎不会有两个重要的代码块几乎相同，除了一些改变。</li><li>适当的评论, 使其他读者也能轻松理解你的代码<ul><li>行注释: <code>//</code>分隔符开头行被当做注释。</li><li>Block（又名多行注释）注释: <code>/*</code>,  <code>*/</code>, 但我们更推荐javadoc形式的注释。</li></ul></li><li>Javadoc: <code>/ **</code>，<code>*/</code>, 可以（但不总是）包含描述性标签。 借助<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/windows/javadoc.html" target="_blank" rel="noopener">javadoc工具</a>可以生成HTML格式的API文档。<br>第一段是方法的描述。描述下面是不同的<a href="https://en.wikipedia.org/wiki/Javadoc" target="_blank" rel="noopener">描述性标签</a>, 比如参数 <code>@param</code>， 返回值 <code>@return</code>， 可能抛出的任何异常 <code>@throws</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>   名字，邮箱&lt;address @ example.com&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>     1.6 版本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java基本语法&quot;&gt;&lt;a href=&quot;#Java基本语法&quot; class=&quot;headerlink&quot; title=&quot;Java基本语法&quot;&gt;&lt;/a&gt;Java基本语法&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HelloWorld&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Hello world!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的程序由一个类声明组成，该声明使用关键字&lt;code&gt;public class&lt;/code&gt;声明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java所有的代码都应该包含在class里面。&lt;/li&gt;
&lt;li&gt;真正负责运行的代码，是一个名为main的method，它声明为&lt;code&gt;public static void main(String[] args)&lt;/code&gt;。&lt;ul&gt;
&lt;li&gt;public：公共的，大部分方法都是以这个关键字开始的，后面会进一步解释。&lt;/li&gt;
&lt;li&gt;static：这是一个静态方法，不与任何特定的实例关联，后面会解释。&lt;/li&gt;
&lt;li&gt;void：它没有返回类型。&lt;/li&gt;
&lt;li&gt;main：这是方法的名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String [] args&lt;/code&gt;：这是传递给main方法的参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用大括号&lt;code&gt;{ }&lt;/code&gt;来表示一段代码的开始和结束。&lt;/li&gt;
&lt;li&gt;声明必须以分号结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;静态分类-Static-Typing&quot;&gt;&lt;a href=&quot;#静态分类-Static-Typing&quot; class=&quot;headerlink&quot; title=&quot;静态分类 Static Typing&quot;&gt;&lt;/a&gt;静态分类 Static Typing&lt;/h2&gt;&lt;p&gt;程序语言静态与动态的分类，可以参考oracle的&lt;a href=&quot;https://docs.oracle.com/cd/E57471_01/bigData.100/extensions_bdd/src/cext_transform_typing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;说明文件&lt;/a&gt;，它解释了动态和静态类型之间的区别, 帮助你理解由程序的错误提示信息。&lt;br&gt;两个主要区别:&lt;br&gt;1. 动态类型语言在运行时执行类型检查，而静态类型语言在编译时执行类型检查。这意味如果以静态类型语言（如Java）编写的脚本包含错误，则在编译错误之前将无法编译. 而用动态类型语言编写的脚本可以编译，即使它们包含会阻止脚本正常运行（如果有的话）的错误。&lt;br&gt;2. 静态类型语言要求你在使用它们之前声明变量的数据类型，而动态类型语言则不需要。&lt;br&gt;考虑以下两个代码示例：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;num = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 01 - Java | 安装 - CS61B Berkeley</title>
    <link href="http://yoursite.com/NOTE-CS61B-data-structures-01-java-install/"/>
    <id>http://yoursite.com/NOTE-CS61B-data-structures-01-java-install/</id>
    <published>2017-12-18T00:00:00.000Z</published>
    <updated>2018-01-29T15:20:49.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>本系列资料来源于伯克利 Josh Hug 的 <a href="datastructur.es/sp17/">cs61b spring 2017</a>和<a href="http://sp18.datastructur.es" target="_blank" rel="noopener">cs61b spring 2018</a>.</p><h2 id="Java安装与配置"><a href="#Java安装与配置" class="headerlink" title="Java安装与配置"></a>Java安装与配置</h2><p>安装Java，前往<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">Oracle</a>下载java sdk，我用的是Java SE 8u151/ 8u152 版本。安装sdk时会同时安装sdr。</p><p>Windows系统配置:</p><ul><li>推荐安装<a href="http://git-scm.com/download/" target="_blank" rel="noopener">git bash</a>, 一切按照默认安装就好.</li><li>更新系统环境变量: 直接在<code>运行</code>中搜索<code>Environment Variables</code>, 选择<code>编辑系统环境变量</code>, 在弹出的框中选择<code>高级-&gt;环境变量</code>, 在弹出的框中<code>系统变量</code>里面<ul><li>新建变量: 变量名 = <code>JAVA_HOME</code>, 变量值 = 你的jdk路径,如<code>C:\Program Files\Java\jdk1.8.0_151</code></li><li>编辑Path: 在前面加入<code>%JAVA_HOME%\bin;%PYTHON_HOME%;</code>(请注意，不能有空格.)</li></ul></li></ul><p>OS X系统配置:</p><ul><li>安装Homebrew，一个非常好用的包管理工具。要安装，请在terminal终端输入<code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code>(注意：在此过程中，可能会提示输入密码。当输入密码时，终端上不会显示任何内容，但计算机还是会记录你的密码的。这是一个安全措施, 让其他人在屏幕上看不到你的密码。只需输入您的密码，然后按回车。)</li><li>然后，通过输入以下命令来检查brew系统是否正常工作<code>brew doctor</code>. 如果遇到警告，要求下载命令行工具，则需要执行此操作。请参考这个<a href="http://stackoverflow.com/questions/9329243/xcode-4-4-and-later-install-%20%20command-line-tools" target="_blank" rel="noopener">StackOverflow</a>。</li><li>安装git：输入<code>brew install git</code></li></ul><p>安装并配置好java后，测试是否成功:<br>随便在你喜欢的文件夹里新建一个java文件<code>HelloWorld.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以选择用sublime来快速新建文件, 直接在你选择的文件里右键 git bash, 在git bash 里面键入<code>subl HelloWorld.java</code>, 还自动启动sublime并新建一个空白的<code>HelloWorld.java</code>文件, 把上面的代码复制进去并保存即可. (若出现类似提示: 找不到subl command, 解决办法请参考博文<a href="/Launch-editor-in-Gitbash">在Gitbash中直接启动sublime或atom等编辑器以打开或新建文件</a> )<br>开始真正的测试。直接在之前打开的git bash中输入:</p><ol><li><code>ls</code>, 会看到<code>HelloWorld.java</code>这个文件, <code>ls</code>会列出这个目录中的文件/文件夹</li><li><code>javac HelloWorld.java</code>, 理论上这一步不会有任何输出，有的话可能是设置有问题。现在，如果你继续<code>ls</code>，会看到多了一个<code>HelloWorld.class</code>文件， 这是javac创建的。</li><li><code>java HelloWorld</code> (注意没有<code>.java</code>), 会看到输出<code>Hello World</code>, 表明你的Java设置没有问题</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h1&gt;&lt;p&gt;本系列资料来源于伯克利 Josh Hug 的 &lt;a href=&quot;da
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="cs61b" scheme="http://yoursite.com/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>CS入门到进阶</title>
    <link href="http://yoursite.com/cs/"/>
    <id>http://yoursite.com/cs/</id>
    <published>2017-01-01T00:00:00.000Z</published>
    <updated>2018-01-28T17:32:57.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>记录学习CS的学习笔记，内容包含基础知识的总结以及编程实现的整理。</p><h3 id="Language"><a href="#Language" class="headerlink" title="Language:"></a>Language:</h3><p><a href="https://github.com/ShootingSpace/Guide-to-Computer-Science/blob/master/readme.md" target="_blank" rel="noopener">English</a></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#cs入门">CS入门</a></li><li><a href="#面向对象编程语言">学习编写(至少)一种面向对象编程语言(C ++，Java®，Python®)</a></li><li><a href="#其他编程语言">学习其他编程语言</a></li><li><a href="#测试你的代码">测试你的代码</a></li><li><a href="#逻辑推理和离散数学">逻辑推理和离散数学</a></li><li><a href="#算法和数据结构">深入了解算法和数据结构</a></li><li><a href="#操作系统">了解计算机操作系统</a></li></ul><a id="more"></a><h3 id="CS入门"><a href="#CS入门" class="headerlink" title="CS入门"></a>CS入门</h3><p>现在的入门课基本都是用Python语言。</p><ul><li><a href="https://www.udacity.com/course/cs101" target="_blank" rel="noopener">计算机科学导论，优达学城</a></li><li><a href="https://cs50.harvard.edu/" target="_blank" rel="noopener">CS50x 哈佛，语言包括C，Python，SQL和JavaScript加CSS和HTML</a></li><li><a href="http://www.cs.cmu.edu/~213/" target="_blank" rel="noopener">CMU 15213: Introduction to Computer Systems (ICS)</a></li></ul><h3 id="面向对象编程语言"><a href="#面向对象编程语言" class="headerlink" title="面向对象编程语言"></a>面向对象编程语言</h3><p>一般而言，建议先学Java，Python，再学C++。 这三种语言都基本掌握后，再根据自身的职业需求，选择其中一个语言（或者其他语言）进一步深入练习。因为学校课程主要以Python为主，所以目前我还是主要深入学习Python，这是我的<a href="https://github.com/ShootingSpace/Self-to-Computer-Science-and-Artificial-Intelligence/blob/master/Note%20-%20Python%20digest.md" target="_blank" rel="noopener">Python学习笔记</a>。</p><h4 id="面向初学者程序员的在线资源："><a href="#面向初学者程序员的在线资源：" class="headerlink" title="面向初学者程序员的在线资源："></a>面向初学者程序员的在线资源：</h4><ul><li><a href="https://see.stanford.edu/Course/CS106A" target="_blank" rel="noopener">编程方法学，斯坦福CS106A，Java</a></li><li><a href="http://www-inst.eecs.berkeley.edu/~cs61a/sp14/" target="_blank" rel="noopener">伯克利大学CS 61A计算机程序的结构与解读，Python</a></li><li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-092-introduction-to-programming-in-java-january-iap-2010/index.htm" target="_blank" rel="noopener">Java编程简介，MIT</a></li><li><a href="https://developers.google.com/edu/python/" target="_blank" rel="noopener">Google的Python Class</a></li><li><a href="https://developers.google.com/edu/c++/" target="_blank" rel="noopener">Google的C ++类</a></li></ul><h4 id="面向有经验的程序员的在线资源："><a href="#面向有经验的程序员的在线资源：" class="headerlink" title="面向有经验的程序员的在线资源："></a>面向有经验的程序员的在线资源：</h4><ul><li><a href="http://datastructur.es/sp16/" target="_blank" rel="noopener">数据结构，伯克利大学 CS 61B，Java</a></li><li><a href="https://www.udacity.com/course/design-of-computer-programs--cs212" target="_blank" rel="noopener">计算机程序设计，Udacity，Python</a></li><li><a href="https://see.stanford.edu/Course/CS106B" target="_blank" rel="noopener">抽象编程，斯坦福 CS106B，C ++</a><br>最新作业：<a href="http://web.stanford.edu/class/cs106b/" target="_blank" rel="noopener">http://web.stanford.edu/class/cs106b/</a></li><li><a href="https://book.douban.com/subject/1909336/" target="_blank" rel="noopener">《数据结构与算法分析:C++描述》, Mark A. Weiss</a></li></ul><h3 id="其他编程语言"><a href="#其他编程语言" class="headerlink" title="其他编程语言"></a>其他编程语言</h3><p>根据实际需要自行选择一种或多种学习：</p><ul><li><a href="#javascript">JavaScript®</a>  </li><li><a href="#CSS-HTML">CSS＆HTML</a></li><li><a href="#ruby">Ruby®</a></li><li><a href="#lua">Lua</a></li><li><a href="#php">PHP®</a></li><li><a href="#haskell">Haskell</a></li><li>Perl®</li><li><a href="#go">Go</a></li><li>Shell®脚本</li><li>Lisp®</li><li>Scheme®</li></ul><p>一些在线资源：</p><ul><li><a href="https://cs50.harvard.edu/" target="_blank" rel="noopener">CS50x 哈佛，语言包括C，Python，SQL和JavaScript加CSS和HTML</a></li><li><a href="https://www.codecademy.com/learn" target="_blank" rel="noopener">Codecademy</a></li></ul><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><ul><li><a href="https://bento.io/topic/javascript" target="_blank" rel="noopener">Bento JavaScript Learning Track</a>(Bento)</li><li><a href="https://egghead.io" target="_blank" rel="noopener">Egghead.io</a></li><li><a href="https://www.learnhowtoprogram.com/javascript" target="_blank" rel="noopener">学习如何编程：JavaScript</a> - Epicodus Inc.</li><li><a href="https://learnquery.infinum.co" target="_blank" rel="noopener">学习：查询</a></li></ul><h4 id="CSS-＆-HTML"><a href="#CSS-＆-HTML" class="headerlink" title="CSS ＆ HTML"></a>CSS ＆ HTML</h4><ul><li><a href="https://bento.io/topic/css" target="_blank" rel="noopener">Bento CSS Learning Track</a>(Bento)</li><li><a href="https://bento.io/topic/html" target="_blank" rel="noopener">Bento HTML Learning Track</a>(Bento)</li><li><a href="https://dash.generalassemblyly" target="_blank" rel="noopener">用破折号建立个人网站</a></li><li><a href="https://www.bloc.io/tutorials/webflow-tutorial-design-responsive-sites-with-webflow" target="_blank" rel="noopener">使用Webflow构建响应式网站</a></li><li><a href="https://www.bloc.io/tutorials/jottly-a-beginner-s-guide-to-html-css-skeleton-and-animate-css" target="_blank" rel="noopener">使用骨架构建SaaS着陆页</a></li><li><a href="http://cs75.tv/2010/fall/" target="_blank" rel="noopener">建立动态网站</a></li><li><a href="http://www.thefirehoseproject.com/lessons/splash-page" target="_blank" rel="noopener">在1小时内编写个人启动页面：实用HTML和CSS简介</a></li><li><a href="https://www.learnhowtoprogram.com/css" target="_blank" rel="noopener">学习如何编程：CSS</a> - Epicodus Inc.</li><li><a href="https://www.udemy.com/learn-html5-programming-from-scratch/" target="_blank" rel="noopener">从头开始学习HTML5编程</a></li></ul><h4 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h4><ul><li><a href="https://www.learnhowtoprogram.com/ruby" target="_blank" rel="noopener">学习如何编程：Ruby</a> - Epicodus Inc.</li><li><a href="https://rubymonk.com" target="_blank" rel="noopener">RubyMonk - 交互式Ruby教程</a></li></ul><h4 id="Haskell"><a href="#Haskell" class="headerlink" title="Haskell"></a>Haskell</h4><ul><li><a href="http://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals" target="_blank" rel="noopener">C9：功能编程基础知识</a> - Erik Meijer</li><li><a href="http://www.seas.upenn.edu/~cis194/" target="_blank" rel="noopener">CIS 194：Haskell简介</a> -  Brent Yorgey</li><li><a href="http://www.scs.stanford.edu/11au-cs240h/notes/" target="_blank" rel="noopener">CS240h：Haskell的功能系统</a> - Bryan O’Sullivan</li><li><a href="https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0" target="_blank" rel="noopener">edX：功能编程简介</a> - Erik Meijer</li><li><a href="https://videoag.fsmpi.rwth-aachen.de/?course=12ss-funkprog" target="_blank" rel="noopener">亚琛大学：功能编程</a> - JürgenGiesl</li></ul><h4 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h4><ul><li><a href="http://luatut.com/crash_course.html" target="_blank" rel="noopener">Lua Interactive Crash Course</a></li><li><a href="http://www.tutorialspoint.com/lua/" target="_blank" rel="noopener">Lua Tutorial</a></li></ul><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><ul><li><a href="https://www.learnhowtoprogram.com/php" target="_blank" rel="noopener">学习如何编程：PHP</a> - Epicodus Inc.</li></ul><h4 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h4><ul><li><a href="http://www.tutorialspoint.com/go/index.htm" target="_blank" rel="noopener">Go Tutorial</a></li></ul><h3 id="测试你的代码"><a href="#测试你的代码" class="headerlink" title="测试你的代码"></a>测试你的代码</h3><p>了解如何捕获错误，创建测试和破解软件.</p><ul><li><a href="https://www.udacity.com/course/software-testing--cs258" target="_blank" rel="noopener">软件测试，Udacity</a></li><li><a href="https://www.udacity.com/course/software-debugging--cs259" target="_blank" rel="noopener">软件调试，Udacity</a></li></ul><h3 id="逻辑推理和离散数学"><a href="#逻辑推理和离散数学" class="headerlink" title="逻辑推理和离散数学"></a>逻辑推理和离散数学</h3><ul><li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/index.HTM" target="_blank" rel="noopener">数学计算机科学，麻省理工学院</a></li><li><a href="https://www.coursera.org/learn/mathematical-thinking" target="_blank" rel="noopener">数学思考导论，斯坦福大学，Coursera</a></li><li><a href="https://www.coursera.org/course/pgm" target="_blank" rel="noopener">概率图形模型，斯坦福大学，Coursera</a></li><li><a href="https://www.coursera.org/course/gametheory" target="_blank" rel="noopener">博弈论，斯坦福大学和不列颠哥伦比亚大学，Coursera</a></li></ul><h3 id="算法和数据结构"><a href="#算法和数据结构" class="headerlink" title="算法和数据结构"></a>算法和数据结构</h3><p>了解基本数据类型(堆栈，队列和袋子)，排序算法(快速排序，合并，堆栈)，数据结构(二叉搜索树，红黑树，哈希表)和Big O.</p><ul><li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/" target="_blank" rel="noopener">算法简介，麻省理工学院，2011秋季</a></li><li><a href="https://www.coursera.org/course/algs4partI" target="_blank" rel="noopener">算法，普林斯顿大学，Part 1</a> ＆ <a href="https://www.coursera.org/learn/algorithms-part2" target="_blank" rel="noopener">Part2</a></li><li><a href="https://www.coursera.org/specializations/algorithms" target="_blank" rel="noopener">算法：设计和分析，斯坦福大学</a></li><li><a href="http://algs4.cs.princeton.edu/home/" target="_blank" rel="noopener">算法，第4版，by Robert Sedgewick and Kevin Wayne</a></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h3><p><a href="https://www.google.com/about/careers/students/guide-to-technical-development.html" target="_blank" rel="noopener">Guide to technical development from Google education</a><br><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="noopener">OS Free Programming Books</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;记录学习CS的学习笔记，内容包含基础知识的总结以及编程实现的整理。&lt;/p&gt;
&lt;h3 id=&quot;Language&quot;&gt;&lt;a href=&quot;#Language&quot; class=&quot;headerlink&quot; title=&quot;Language:&quot;&gt;&lt;/a&gt;Language:&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ShootingSpace/Guide-to-Computer-Science/blob/master/readme.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;English&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#cs入门&quot;&gt;CS入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#面向对象编程语言&quot;&gt;学习编写(至少)一种面向对象编程语言(C ++，Java®，Python®)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#其他编程语言&quot;&gt;学习其他编程语言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#测试你的代码&quot;&gt;测试你的代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#逻辑推理和离散数学&quot;&gt;逻辑推理和离散数学&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#算法和数据结构&quot;&gt;深入了解算法和数据结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#操作系统&quot;&gt;了解计算机操作系统&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="软件工程" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="计算机科学" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>人工智能AI入门到进阶</title>
    <link href="http://yoursite.com/ai/"/>
    <id>http://yoursite.com/ai/</id>
    <published>2017-01-01T00:00:00.000Z</published>
    <updated>2018-01-21T12:12:05.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>记录学习AI的学习笔记，内容包含基础知识的总结以及编程实现的整理。</p><h3 id="Language"><a href="#Language" class="headerlink" title="Language:"></a>Language:</h3><p><a href="https://github.com/ShootingSpace/Guide-to-Computer-Science/blob/master/readme.md" target="_blank" rel="noopener">English</a></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#人工智能">人工智能</a><ul><li><a href="#机器学习">机器学习</a></li><li><a href="#深度学习">深度学习</a></li><li><a href="#自然语言处理">自然语言处理</a></li><li><a href="#计算机视觉">计算机视觉</a></li><li><a href="#机器人">机器人</a></li></ul></li><li><a href="#大数据">大数据</a><ul><li><a href="#mapreduce">MapReduce</a></li></ul></li></ul><a id="more"></a><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><ul><li><a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">Coursera Machine Learning， 吴恩达的简化版机器学习</a></li><li><a href="https://see.stanford.edu/Course/CS229" target="_blank" rel="noopener">Machine Learning, 吴恩达的机器学习课程</a> 这个比较深入</li><li><a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener">Deep Learning, 吴恩达的深度学习课程</a></li><li><a href="https://www.coursera.org/learn/neural-networks" target="_blank" rel="noopener">Neural Networks for Machine Learning, Hinton的神经网络课程</a></li></ul><h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><ul><li><a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener">Deep learning, Coursera</a></li><li><a href="https://github.com/CSTR-Edinburgh/mlpractical/tree/mlp2017-8/master" target="_blank" rel="noopener">Machine Learning Practical: DNN, CNN, RNN</a> 每个lab的答案在下一个lab branch里，即lab1的答案可以在lab2 branch里面看到。这个代码全部用Python class，比coursera的难度高点。</li></ul><h4 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h4><ul><li><a href="https://www.youtube.com/playlist?list=PL6397E4B26D00A269" target="_blank" rel="noopener">自然语言处理, 斯坦福</a></li><li><a href="https://github.com/ShootingSpace/Self-to-Computer-Science-and-Artificial-Intelligence/blob/master/Note%20-%20AI125%20Accelerated%20Natural%20Language%20Processing%20UoE.md" target="_blank" rel="noopener">加速自然语言处理, 爱丁堡大学</a></li><li><a href="http://cs224d.stanford.edu/" target="_blank" rel="noopener">深度学习处理自然语言，斯坦福</a></li></ul><h4 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h4><ul><li><a href="https://www.youtube.com/watch?v=6niqTuYFZLQ&amp;list=PLe7764SJVnV10-Nr7e0sBlC9J0LRf4sQo" target="_blank" rel="noopener">图像识别：卷积神经网络，李飞飞，斯坦福</a></li></ul><h4 id="机器人"><a href="#机器人" class="headerlink" title="机器人"></a>机器人</h4><ul><li><a href="https://see.stanford.edu/Course/CS223A" target="_blank" rel="noopener">机器人入门，斯坦福</a></li></ul><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><ul><li><a href="https://classroom.udacity.com/courses/ud617" target="_blank" rel="noopener">Hadoop和MapReduce入门，优达学城</a></li><li><a href="http://www.inf.ed.ac.uk/teaching/courses/exc/" target="_blank" rel="noopener">MapReduce极限计算，爱丁堡大学</a></li><li><a href="http://web.stanford.edu/class/cme213/" target="_blank" rel="noopener">并行计算入门：MPI, openMP, and CUDA, 斯坦福</a></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h3><p><a href="https://www.google.com/about/careers/students/guide-to-technical-development.html" target="_blank" rel="noopener">Guide to technical development from Google education</a><br><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="noopener">OS Free Programming Books</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;记录学习AI的学习笔记，内容包含基础知识的总结以及编程实现的整理。&lt;/p&gt;
&lt;h3 id=&quot;Language&quot;&gt;&lt;a href=&quot;#Language&quot; class=&quot;headerlink&quot; title=&quot;Language:&quot;&gt;&lt;/a&gt;Language:&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ShootingSpace/Guide-to-Computer-Science/blob/master/readme.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;English&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#人工智能&quot;&gt;人工智能&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#机器学习&quot;&gt;机器学习&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#深度学习&quot;&gt;深度学习&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#自然语言处理&quot;&gt;自然语言处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#计算机视觉&quot;&gt;计算机视觉&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#机器人&quot;&gt;机器人&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#大数据&quot;&gt;大数据&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#mapreduce&quot;&gt;MapReduce&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="人工智能" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="人工智能" scheme="http://yoursite.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="自然语言处理" scheme="http://yoursite.com/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
      <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
</feed>
