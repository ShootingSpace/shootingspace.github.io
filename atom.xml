<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Computer Science &amp; AI</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shukebeta.me/"/>
  <updated>2018-07-21T16:31:28.938Z</updated>
  <id>http://shukebeta.me/</id>
  
  <author>
    <name>Cong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Randomized queue with Knuth shuffling or Reservoir sampling</title>
    <link href="http://shukebeta.me/algorithms-applications-02-randomized-queue/"/>
    <id>http://shukebeta.me/algorithms-applications-02-randomized-queue/</id>
    <published>2018-07-20T23:00:00.000Z</published>
    <updated>2018-07-21T16:31:28.938Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Randomized-queue"><a href="#Randomized-queue" class="headerlink" title="Randomized queue"></a>Randomized queue</h3><p>For a randomized queue, the item removed is chosen <strong>uniformly</strong> at random from items in the data structure. API:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomizedQueue</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RandomizedQueue</span><span class="params">()</span> </span>&#123;&#125;                 <span class="comment">// construct an empty randomized queue</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;&#125;                 <span class="comment">// is the randomized queue empty?</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;&#125;                        <span class="comment">// return the number of items on the randomized queue</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Item item)</span> </span>&#123;&#125;           <span class="comment">// add the item</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Item <span class="title">dequeue</span><span class="params">()</span> </span>&#123;&#125;                    <span class="comment">// remove and return a random item</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Item <span class="title">sample</span><span class="params">()</span> </span>&#123;&#125;                     <span class="comment">// return a random item (but do not remove it)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;&#125;         <span class="comment">// return an independent iterator over items in random order</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;&#125;   <span class="comment">// unit testing (optional)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Each iterator must return the items in <strong>uniformly</strong> random order. The order of two or more iterators to the same randomized queue must be mutually independent; each iterator must maintain its own random order.</p><p>More detail could be found at programming assignment <a href="http://coursera.cs.princeton.edu/algs4/assignments/queues.html" target="_blank" rel="noopener">specification</a> and <a href="http://coursera.cs.princeton.edu/algs4/checklists/queues.html" target="_blank" rel="noopener">checklist</a>.</p><h3 id="Permutation-client-memory-challenge"><a href="#Permutation-client-memory-challenge" class="headerlink" title="Permutation client memory challenge"></a>Permutation client memory challenge</h3><a id="more"></a><p>A client program <code>Permutation.java</code> that takes an integer k as a command-line argument; reads in a sequence of strings from standard input using <code>StdIn.readString()</code>; and prints exactly k of them, uniformly at random. Print each item from the sequence at most once.</p><p>The bonu point is to use only one RandomizedQueue object of maximum size at most k.</p><p>More specifically, as the program sees a sequence of input, one at a time, the programe could only keep k items in memory, and they should be selected at random from the sequence. If we know the total number of items (n), then the solution is easy: select ten distinct indices i between 1 and n with equal probability, and keep the i-th elements. The challenge is that we do not know the input sequence length in advance.</p><p>Two methods explain the same solution:</p><ol><li><p><a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" target="_blank" rel="noopener">Knuth shuffling</a><br>For a loop over n, swap item <code>[n]</code> with a random item in the range <code>[0]</code> through <code>[n]</code>. We store only the first k elements (<code>[0 : k-1]</code>) as that are all we need. Afterwards, when we get a new string (index <code>[n]</code>), we’ll swap it with one of the first k strings for a given probability <code>P</code>, otherwise just discard it.</p></li><li><p><a href="https://en.wikipedia.org/wiki/Reservoir_sampling" target="_blank" rel="noopener">Reservoir sampling</a></p><blockquote><p>Reservoir sampling is a family of randomized algorithms for randomly choosing a sample of k items from a list S containing n items, where n is either a very large or unknown number. Typically n is large enough that the list doesn’t fit into main memory.</p><ol><li>Keep the first k items in memory.</li><li>When the i-th item arrives (for $i&gt;k$):<ul><li>with probability $k/i$, keep the new item (discard an old one, selecting which to replace at random, each with chance $1/k$)</li><li>with probability $1-k/i$, keep the old items (ignore the new one)</li></ul></li></ol></blockquote></li></ol><p>Test report:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Correctness:  43/43 tests passed</span><br><span class="line">Memory:       106/105 tests passed</span><br><span class="line">Timing:       136/136 tests passed</span><br><span class="line"></span><br><span class="line">Aggregate score: 100.10%</span><br><span class="line">[Compilation: 5%, API: 5%, Findbugs: 0%, PMD: 0%, Checkstyle: 0%, Correctness: 60%, Memory: 10%, Timing: 20%]</span><br><span class="line"></span><br><span class="line">Test 3 (bonus): check that maximum size of any or Deque or RandomizedQueue object</span><br><span class="line">                created is equal to k</span><br><span class="line">  * filename = tale.txt, n = 138653, k = 5</span><br><span class="line">  * filename = tale.txt, n = 138653, k = 50</span><br><span class="line">  * filename = tale.txt, n = 138653, k = 500</span><br><span class="line">  * filename = tale.txt, n = 138653, k = 5000</span><br><span class="line">  * filename = tale.txt, n = 138653, k = 50000</span><br><span class="line">==&gt; passed</span><br><span class="line"></span><br><span class="line">Total: 3/2 tests passed!</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Randomized-queue&quot;&gt;&lt;a href=&quot;#Randomized-queue&quot; class=&quot;headerlink&quot; title=&quot;Randomized queue&quot;&gt;&lt;/a&gt;Randomized queue&lt;/h3&gt;&lt;p&gt;For a randomized queue, the item removed is chosen &lt;strong&gt;uniformly&lt;/strong&gt; at random from items in the data structure. API:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RandomizedQueue&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Item&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Iterable&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Item&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RandomizedQueue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;                 &lt;span class=&quot;comment&quot;&gt;// construct an empty randomized queue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;                 &lt;span class=&quot;comment&quot;&gt;// is the randomized queue empty?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;                        &lt;span class=&quot;comment&quot;&gt;// return the number of items on the randomized queue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Item item)&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;           &lt;span class=&quot;comment&quot;&gt;// add the item&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Item &lt;span class=&quot;title&quot;&gt;dequeue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;                    &lt;span class=&quot;comment&quot;&gt;// remove and return a random item&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Item &lt;span class=&quot;title&quot;&gt;sample&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;                     &lt;span class=&quot;comment&quot;&gt;// return a random item (but do not remove it)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Iterator&amp;lt;Item&amp;gt; &lt;span class=&quot;title&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;         &lt;span class=&quot;comment&quot;&gt;// return an independent iterator over items in random order&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;   &lt;span class=&quot;comment&quot;&gt;// unit testing (optional)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Each iterator must return the items in &lt;strong&gt;uniformly&lt;/strong&gt; random order. The order of two or more iterators to the same randomized queue must be mutually independent; each iterator must maintain its own random order.&lt;/p&gt;
&lt;p&gt;More detail could be found at programming assignment &lt;a href=&quot;http://coursera.cs.princeton.edu/algs4/assignments/queues.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;specification&lt;/a&gt; and &lt;a href=&quot;http://coursera.cs.princeton.edu/algs4/checklists/queues.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;checklist&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;Permutation-client-memory-challenge&quot;&gt;&lt;a href=&quot;#Permutation-client-memory-challenge&quot; class=&quot;headerlink&quot; title=&quot;Permutation client memory challenge&quot;&gt;&lt;/a&gt;Permutation client memory challenge&lt;/h3&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Percolations problem</title>
    <link href="http://shukebeta.me/algorithms-applications-01-percolation/"/>
    <id>http://shukebeta.me/algorithms-applications-01-percolation/</id>
    <published>2018-07-01T23:00:00.000Z</published>
    <updated>2018-07-21T16:09:10.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Union-find-applications-Percolation"><a href="#Union-find-applications-Percolation" class="headerlink" title="Union-find applications: Percolation"></a>Union-find applications: Percolation</h3><p><a href="http://coursera.cs.princeton.edu/algs4/assignments/percolation.html" target="_blank" rel="noopener">Problem discriptions</a></p><p>Percolation data type. To model a percolation system, create a data type Percolation with the following API:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percolation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Percolation</span><span class="params">(<span class="keyword">int</span> n)</span></span>;                <span class="comment">// create n-by-n grid, with all sites blocked</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>    <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;    <span class="comment">// open site (row, col) if it is not open already</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;  <span class="comment">// is site (row, col) open?</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;  <span class="comment">// is site (row, col) full?</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>     <span class="keyword">int</span> <span class="title">numberOfOpenSites</span><span class="params">()</span></span>;       <span class="comment">// number of open sites</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">percolates</span><span class="params">()</span></span>;              <span class="comment">// does the system percolate?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Monte Carlo simulation. To estimate the percolation threshold, consider the following computational experiment:</p><ul><li>Initialize all sites to be blocked.</li><li>Repeat the following until the system percolates:<ul><li>Choose a site uniformly at random among all blocked sites.</li><li>Open the site.</li></ul></li><li>The fraction of sites that are opened when the system percolates provides an estimate of the percolation threshold.</li></ul><h4 id="The-back-wash-issue"><a href="#The-back-wash-issue" class="headerlink" title="The back wash issue"></a><a href="http://coursera.cs.princeton.edu/algs4/checklists/percolation.html" target="_blank" rel="noopener">The back wash issue</a></h4><p><img src="http://coursera.cs.princeton.edu/algs4/checklists/percolation-backwash.png" alt="" title="image from: http://coursera.cs.princeton.edu"><br><a id="more"></a><br>My solution inspired from this post <a href="https://www.sigmainfy.com/blog/avoid-backwash-in-percolation.html" target="_blank" rel="noopener">https://www.sigmainfy.com/blog/avoid-backwash-in-percolation.html</a>, with some improvements:</p><ol><li>Using one <code>WeightedQuickUnionUF(n * n)</code> objects to track each site’s parent.</li><li>Use a <code>byte[n * n]</code> to store the each site’s state.<ul><li>There are four possible states, represented as<ul><li><code>BLOCKED: 0b000</code></li><li><code>OPEN: 0b001</code></li><li><code>CONNECT_TO_BOTTOM: 0b010</code></li><li><code>CONNECT_TO_TOP: 0b100</code></li></ul></li><li>With byte operation <code>|</code>, we enable sites to have mixture of states.</li></ul></li><li><code>open(row, col)</code>: to open the current site <code>cur</code>, we need to<ul><li>find out its four possible neibourghs (<code>up</code>, <code>down</code>, <code>left</code>, <code>right</code>, if exist);</li><li>use <code>find()</code> to return the neibourghs’ parents (<code>upParent</code>, etc..), use <code>union()</code> to connect <code>cur</code> and its neibourghs;</li><li>Fianally, update <code>cur</code>‘s new parent <code>newParent</code>‘s state with the combination of <code>cur</code>‘s parent state and the neibourghs’ parents states.</li><li>in totalm, there involves 4 <code>union()</code> and 5 <code>find()</code> API calls at most but the time complexity is still $\Theta(\lg N)$</li></ul></li><li><code>isOpen()</code>: $\in \Theta(1)$ by checking the <code>byte[n * n]</code>.</li><li><code>isFull()</code>: $\in \Theta(1)$, use one call <code>find()</code> API and thus is $\in \Theta (\lg N)$</li><li><code>percolates()</code>: use a <code>boolean isPercolates</code> as mark, for any new open site that becomes both <code>CONNECT_TO_BOTTOM</code> and <code>CONNECT_TO_TOP</code>, we could mark the model as percolates.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Estimated student memory = 9.00 n^2 + 0.00 n + 160.00   (R^2 = 1.000)</span><br><span class="line"></span><br><span class="line">Test 2 (bonus): check that total memory &lt;= 11 n^2 + 128 n + 1024 bytes</span><br><span class="line"></span><br><span class="line">==&gt; passed</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Union-find-applications-Percolation&quot;&gt;&lt;a href=&quot;#Union-find-applications-Percolation&quot; class=&quot;headerlink&quot; title=&quot;Union-find applications: Percolation&quot;&gt;&lt;/a&gt;Union-find applications: Percolation&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://coursera.cs.princeton.edu/algs4/assignments/percolation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem discriptions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Percolation data type. To model a percolation system, create a data type Percolation with the following API:&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Percolation&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Percolation&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;;                &lt;span class=&quot;comment&quot;&gt;// create n-by-n grid, with all sites blocked&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; row, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; col)&lt;/span&gt;&lt;/span&gt;;    &lt;span class=&quot;comment&quot;&gt;// open site (row, col) if it is not open already&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isOpen&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; row, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; col)&lt;/span&gt;&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;// is site (row, col) open?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isFull&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; row, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; col)&lt;/span&gt;&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;// is site (row, col) full?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;     &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;numberOfOpenSites&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;       &lt;span class=&quot;comment&quot;&gt;// number of open sites&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;percolates&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;              &lt;span class=&quot;comment&quot;&gt;// does the system percolate?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Monte Carlo simulation. To estimate the percolation threshold, consider the following computational experiment:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Initialize all sites to be blocked.&lt;/li&gt;
&lt;li&gt;Repeat the following until the system percolates:&lt;ul&gt;
&lt;li&gt;Choose a site uniformly at random among all blocked sites.&lt;/li&gt;
&lt;li&gt;Open the site.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The fraction of sites that are opened when the system percolates provides an estimate of the percolation threshold.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;The-back-wash-issue&quot;&gt;&lt;a href=&quot;#The-back-wash-issue&quot; class=&quot;headerlink&quot; title=&quot;The back wash issue&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://coursera.cs.princeton.edu/algs4/checklists/percolation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The back wash issue&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://coursera.cs.princeton.edu/algs4/checklists/percolation-backwash.png&quot; alt=&quot;&quot; title=&quot;image from: http://coursera.cs.princeton.edu&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Algorithms - Princeton</title>
    <link href="http://shukebeta.me/algorithms/"/>
    <id>http://shukebeta.me/algorithms/</id>
    <published>2018-06-30T23:00:00.000Z</published>
    <updated>2018-07-21T16:08:44.812Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Algorithms, Part I, <a href="https://online.princeton.edu/course/algorithms-part-i" target="_blank" rel="noopener">https://online.princeton.edu/course/algorithms-part-i</a></li><li>Algorithms, Part II, <a href="https://online.princeton.edu/course/algorithms-part-ii" target="_blank" rel="noopener">https://online.princeton.edu/course/algorithms-part-ii</a></li><li>Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne <a href="https://algs4.cs.princeton.edu/" target="_blank" rel="noopener">https://algs4.cs.princeton.edu/</a><a id="more"></a><h2 id="Union−Find"><a href="#Union−Find" class="headerlink" title="Union−Find"></a>Union−Find</h2>Considering the dynamic connectivity problem, modeling of multiple objects connected in a space/network.</li></ul><p>Applications involve manipulating objects of all types.<br>・Pixels in a digital photo.<br>・Computers in a network.<br>・Friends in a social network.<br>・Transistors in a computer chip.</p><p>Given a set of N objects.</p><ul><li><code>union(a, b)</code>: connect two objects.</li><li><code>connected(p, q)</code>: is two objects connected?</li><li><code>find(p)</code>: Find component identifier for <code>p</code> (0 to N – 1)</li></ul><p>Modeling the objects: array.</p><p>Modeling the connections:<br>Maximal set of objects that are mutually connected - Connected components.</p><p>Data structure:</p><ol><li><p>Quick find<br>Integer array <code>id[]</code> of length N, two objects are connected iff they have the same id.<br><img src="https://algs4.cs.princeton.edu/15uf/images/quick-find-overview.png" alt="" title="image from: https://algs4.cs.princeton.edu/"><br>Defect: <code>union</code> too expensive, $\in \Theta(N^2)$.</p></li><li><p>Quick-union<br>Integer array <code>id[]</code> of length N, <code>id[i]</code> is parent of i, root of i is <code>id[id[id[...id[i]...]]]</code> (until it doesn’t change).<br><img src="https://algs4.cs.princeton.edu/15uf/images/quick-union-overview.png" alt="" title="image from: https://algs4.cs.princeton.edu/"><br>The <code>find</code> is recursive.</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** chase parent pointers until reach root</span></span><br><span class="line"><span class="comment"> * (depth of i array accesses) */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i != id[i]) i = id[i];</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Defect: Trees can get tall, <code>find</code> too expensive, $\in \Theta(N)$.</p></li><li><p>Weighted quick-union<br>Modify quick-union to avoid tall trees. Balance by linking root of smaller tree to root of larger tree. Maintain extra array <code>sz[i]</code> to keep track of size of each tree (number of objects).<br><img src="https://algs4.cs.princeton.edu/15uf/images/weighted-quick-union-overview.png" alt="" title="image from: https://algs4.cs.princeton.edu/"><br><code>find</code>: time proportional to depth of p and q, the depth of any node x is at most $\log N$,</p></li><li><p>Weighted quick-union with path compression<br>Making all the nodes that examined directly link to its root. Keeps tree almost completely flat.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Make every other node in path point to its grandparent</span></span><br><span class="line"><span class="comment">* (thereby halving path length). */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i != id[i]) &#123;</span><br><span class="line">        id[i] = id[id[i]];</span><br><span class="line">        i = id[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Amortized analysis: <code>[Hopcroft-Ulman, Tarjan]</code> Starting from an empty data structure, any sequence of M union-find ops on N objects makes $≤ c ( N + M \lg \ast N )$ array accesses. $\lg \ast N$ is <a href="https://en.wikipedia.org/wiki/Iterated_logarithm" target="_blank" rel="noopener">Iterated logarithm</a>, for $N = 2^{65536}$, $\lg \ast N = 5$. In theory, WQUPC is not quite linear. In practice, WQUPC is linear.</p></li></ol><blockquote><p>Amazing fact. <code>[Fredman-Saks]</code> No linear-time algorithm exists.</p></blockquote><p><img src="https://algs4.cs.princeton.edu/15uf/images/uf-performance.png" alt="" title="Summary. image from: https://algs4.cs.princeton.edu/"></p><h2 id="Analysis-of-Algorithms"><a href="#Analysis-of-Algorithms" class="headerlink" title="Analysis of Algorithms"></a>Analysis of Algorithms</h2>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Algorithms, Part I, &lt;a href=&quot;https://online.princeton.edu/course/algorithms-part-i&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://online.princeton.edu/course/algorithms-part-i&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Algorithms, Part II, &lt;a href=&quot;https://online.princeton.edu/course/algorithms-part-ii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://online.princeton.edu/course/algorithms-part-ii&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne &lt;a href=&quot;https://algs4.cs.princeton.edu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://algs4.cs.princeton.edu/&lt;/a&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Efficient Programming in Java - A preview of Algorithms and Data Structures</title>
    <link href="http://shukebeta.me/NOTE-CS61B-data-structures-15-efficient-programming/"/>
    <id>http://shukebeta.me/NOTE-CS61B-data-structures-15-efficient-programming/</id>
    <published>2018-06-25T23:00:00.000Z</published>
    <updated>2018-07-14T11:51:44.820Z</updated>
    
    <content type="html"><![CDATA[<p>Resource and Reference:</p><ul><li>CS61B Berkeley - Josh Hug</li><li>Algorithms Princeton - ROBERT SEDGEWICK, KEVIN WAYNE</li></ul><p>效率来源两个方面:</p><ol><li>编程成本: 开发程序需要多长时间？代码是否容易阅读，修改和维护（大部分成本来自维护和可扩展性）？</li><li>运行成本: 程序需要多长时间运行 (Time complexity)？ 需要多少内存 (Space complexity)？<a id="more"></a><h2 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h2><blockquote><p>Module: A set of methods that work together as a whole to perform some task or set of related tasks.<br>Encapsulated: A module is said to be encapsulated if its implementation is completely hidden, and it can be accessed only through a documented interface.</p></blockquote></li></ol><h2 id="API’s"><a href="#API’s" class="headerlink" title="API’s"></a>API’s</h2><blockquote><p>An API(Application Programming Interface) of an ADT is the list of constructors and methods and a short description of each.</p></blockquote><p>API 包括语法规范和语义规范</p><ul><li>编译器确认语法符合要求</li><li>测试帮助确认语义描述是否正确<ul><li>一般都是用英文写的(可能包含使用例子)</li></ul></li></ul><h3 id="ADT’s"><a href="#ADT’s" class="headerlink" title="ADT’s"></a>ADT’s</h3><p>Abstract Data Structures 是由其行为属性定义的抽象类型, 跟如何实现无关.</p><p>三种方式实现<code>Stack</code>的<code>push(Item x)</code>:</p><ol><li><p>使用 extension 以借用<code>LinkedList&lt;Item&gt;</code>的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtensionStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedList</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item x)</span> </span>&#123;</span><br><span class="line">        add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>委托模式<strong>Delegation</strong>， 生成<code>Linked List</code>并调用其方法来达到目的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegationStack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Item&gt; L = <span class="keyword">new</span> LinkedList&lt;Item&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item x)</span> </span>&#123;</span><br><span class="line">        L.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类似方法2, 只是这里可以利用任何实现了<code>List</code>接口的类, 如<code>Linked List, ArrayList</code>, 等等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAdapter</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List L;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackAdapter</span><span class="params">(List&lt;Item&gt; worker)</span> </span>&#123;</span><br><span class="line">        L = worker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item x)</span> </span>&#123;</span><br><span class="line">        L.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Delegation vs Extension: Extension 一般是基于对父类有比较清楚的了解认知下才会使用。此外，扩展基本上等于在说明正在扩展的类与被扩展类是相似的。如果两个类无法看做是同属的, 那么就用委托模式。</p><p>Views: 通过视图进行的更改会影响底层对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Create an ArrayList. */</span></span><br><span class="line">List&lt;String&gt; L = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">/** Add some items. */</span></span><br><span class="line">L.add(“at”); L.add(“ax”); …</span><br><span class="line">List&lt;String&gt; SL = l.subList(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">/** Mutate that thing. */</span></span><br><span class="line">SL.set(<span class="number">0</span>, “jug”);</span><br></pre></td></tr></table></figure></p><h2 id="Asymptotic-Analysis"><a href="#Asymptotic-Analysis" class="headerlink" title="Asymptotic Analysis"></a>Asymptotic Analysis</h2><p>Care about what happens for very large <code>N</code> (asymptotic behavior). We want to consider what types of algorithms would best handle scalability - Algorithms that scale well have better asymptotic runtime behavior.</p><p>Simplification Summary</p><ol><li>Only consider the worst case.</li><li>Pick a representative operation (aka: cost model)</li><li>Ignore lower order terms</li><li>Ignore multiplicative constants.</li></ol><p>Simplified Analysis Process</p><ol><li>Choose cost model (representative operation)</li><li>Figure out the order of growth for the count of representative operation by either:<ul><li>Making an exact count, and discarding unnecessary pieces<ul><li>Only consider the worst case.</li><li>Ignore lower order terms</li><li>Ignore constants.</li></ul></li><li>Or, using intuition/inspection to determine orders of growth.</li></ul></li></ol><h3 id="Big-Theta"><a href="#Big-Theta" class="headerlink" title="Big Theta"></a>Big Theta</h3><p>Formalizing Order of Growth: Suppose a function $R(N)$ with order of growth $f(N)$, this is represented as $R(N) \in \Theta(f(N))$ in notation. Means that there exists positive constants $k_1, k_2$ such that: $$k_1⋅f(N)≤R(N)≤k_​2⋅f(N),$$ for all values of $N$ greater than some $N_0$(a very large N).</p><p>Procedure:</p><ul><li>Given a piece of code, express its runtime as a function $R(N)$<ul><li>$N$ is some <strong>property</strong> of the input of the function. Oftentimes, $N$ represents the size of the input</li></ul></li><li>Rather than finding $R(N)$ exactly, instead care about the order of growth of $R(N)$.</li><li>One approach (not universal):<ul><li>Choose a representative operation</li><li>Let $C(N)$ = count of how many times that operation occurs, as a function of $N$.</li><li>Determine order of growth $C(N) \in \Theta(f(N))$</li><li>Often (but not always) consider the worst case count.</li><li>If operation takes constant time, then $R(N) \in \Theta(f(N))$</li></ul></li></ul><p>在 Big Theta 的范畴内，对于涉及 logarithm 的情况，底数并不重要，任何底数都是等价的：<br>Binary search: $\Theta(\log N)$ 直接忽略底数符号。<br>Selection sort: $\Theta(N^2)$<br>Merge two sorted array (Merge Sort): $\Theta(N)$</p><p>用 merge sort 加速 selection sort - 把 selection sort 递归地平分, 总共能分解出$\log_2N$个 merge sorts, 伪代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">If the list is size 1:</span><br><span class="line">    return</span><br><span class="line">else:</span><br><span class="line">    Mergesort the left half</span><br><span class="line">    Mergesort the right half</span><br><span class="line">    Merge the results</span><br></pre></td></tr></table></figure></p><p>Total runtime is $≈Nk$, where $k = \log_2(N)$ is the number of levels, overall runtime is $\Theta(N \log N)$.<br>$N^2$ vs. $N \log N$ is an enormous difference. Going from $N\log N$ to $N$ is nice, but not a radical change.</p><p>Useful math:<br>$1 + 2 + 3 + … + N = N * (N + 1) / 2 = \Theta(N^2)$<br>$1 + 2 + 4 + … + N = 2N - 1 = \Theta(N)$</p><p>To estimate a discrete sum, replace the sum with an integral, and use calculus:<br>$1 + 2 + 3 + … + N = \sum_{i=1}^{N} i \sim \int_{x=1}^N x dx \sim \frac{1}{2}(N^2)$</p><p>$1^k + 2^k + … + N^k = \sum_{i=1}^{N} i^k \sim \int_{x=1}^N x^k dx \sim \frac{1}{k+1}(N^{k+1})$</p><p>$1 + 1/2 + 1/3 + … + 1/N = \sum_{i=1}^{N} i^{-1} \sim \int_{x=1}^N x^{-1} dx \sim \ln N$</p><p>3-sum triple loop, $\sum_{i=1}^{N}\sum_{j=1}^{N}\sum_{k=1}^{N} 1 \sim \int_{x=1}^N\int_{y=x}^N\int_{z=y}^N dz dy dx \sim \frac{1}{6}N^3$</p><h3 id="Big-O"><a href="#Big-O" class="headerlink" title="Big O"></a>Big O</h3><p>Big Theta expresses the exact order of as a function of the input size. However, if the runtime depends on more than just the size of the input, then we must qualify our statements into different cases before using Big Theta.</p><p>Big O: $R(N) \in O(f(N))$, means that there exists positive constants $k_2$, such that: $R(N) \leq k_2 \cdot f(N)$ for all values of $N$ greater than some $N_0$(a very large $N$). This is a looser condition than Big Theta since Big O does not care about the lower bound, thus it is less informative than Big Theta.</p><p>To summarize the usefulness of Big O:</p><ul><li>It allows us to make simple statements without case qualifications, in cases where the runtime is different for different inputs.</li><li>Sometimes, for particularly tricky problems, we (the computer science community) don’t know the exact runtime, so we may only state an upper bound.</li><li>It’s a lot easier to write proofs for Big O than Big Theta, like we saw in finding the runtime of mergesort in the previous chapter. This is beyond the scope of this course.</li></ul><p>类似的也可以定义一个<strong>下限</strong>概念 - Big Omega ($\Omega$)， 一般用于表明一个问题的难度有多大。</p><p><img src="/images/three_Asymptotics.png" alt="" title="Three Big letters. image from: https://joshhug.gitbooks.io/"></p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><blockquote><ul><li>Big O is an upper bound (“less than or equals”)</li><li>Big Omega is a lower bound (“greater than or equals”)</li><li>Big Theta is both an upper and lower bound (“equals”)</li><li>Big O does NOT mean “worst case”. We can still describe worst cases using Big Theta</li><li>Big Omega does NOT mean “best case”. We can still describe best cases using Big Theta</li><li>Big O is sometimes colloquially used in cases where Big Theta would provide a more precise statement<br>– from: <a href="https://joshhug.gitbooks.io/" target="_blank" rel="noopener">https://joshhug.gitbooks.io/</a></li></ul></blockquote><h2 id="Amortized-Analysis"><a href="#Amortized-Analysis" class="headerlink" title="Amortized Analysis"></a>Amortized Analysis</h2><p>平摊分析</p><p>假如有两种交税方式：</p><ol><li>每天付 3 金币</li><li>每次付的金币呈指数级增长，但通知付款频率呈指数级下降<ul><li>第1天：付 1</li><li>第2天：付 2 (累计 3)</li><li>第4天：付 4 (累积 7)</li><li>第8天：付 8 (累积 15)</li></ul></li></ol><p>哪种付的钱比较少？<br>第二种比较划算，本质上等同于每天付 2，就是<strong>amortized constant</strong>。</p><p>A more rigorous examination of amortized analysis is done here, in three steps:</p><ol><li>Pick a cost model (like in regular runtime analysis)</li><li>Compute the average cost of the i’th operation</li><li>Show that this average (amortized) cost is bounded by a constant.</li></ol><p>类似的应用在<a href="/NOTE-CS61B-data-structures-07-java-array-based-list#数组扩容">Array list 扩容</a>中提到的 geometric resizing 方法(实际也是Python list 使用的方法)有体现, 所以使用一个因数来扩容数组, 可以让 ArrayList 的 <code>add</code>操作变为 amortized constant time.</p><p>总结</p><blockquote><ul><li>Amortized analysis provides a way to prove the average cost of operations.</li><li>If we chose $a_i$ such that $\Phi_i$ is never negative and $a_i$ is constant for all $i$, then the amortized cost is an upper bound on the true cost.<br>– from: <a href="https://joshhug.gitbooks.io/" target="_blank" rel="noopener">https://joshhug.gitbooks.io/</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Resource and Reference:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CS61B Berkeley - Josh Hug&lt;/li&gt;
&lt;li&gt;Algorithms Princeton - ROBERT SEDGEWICK, KEVIN WAYNE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;效率来源两个方面:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编程成本: 开发程序需要多长时间？代码是否容易阅读，修改和维护（大部分成本来自维护和可扩展性）？&lt;/li&gt;
&lt;li&gt;运行成本: 程序需要多长时间运行 (Time complexity)？ 需要多少内存 (Space complexity)？
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="cs61b" scheme="http://shukebeta.me/tags/cs61b/"/>
    
      <category term="algs4" scheme="http://shukebeta.me/tags/algs4/"/>
    
  </entry>
  
  <entry>
    <title>Java 语法和特性 - CS61B Berkeley - Josh Hug</title>
    <link href="http://shukebeta.me/NOTE-CS61B-data-structures-14-other-syntaxes/"/>
    <id>http://shukebeta.me/NOTE-CS61B-data-structures-14-other-syntaxes/</id>
    <published>2018-05-28T23:00:00.000Z</published>
    <updated>2018-07-21T15:58:14.662Z</updated>
    
    <content type="html"><![CDATA[<p>Java 高级语法。<br><a id="more"></a></p><h2 id="Extends-Casting-Higher-Order-Functions"><a href="#Extends-Casting-Higher-Order-Functions" class="headerlink" title="Extends, Casting, Higher Order Functions"></a>Extends, Casting, Higher Order Functions</h2><p>定义接口之间的层次关系可以使用<code>implement</code>, <code>SLList&lt;xxx&gt; implements List61B&lt;xxx&gt;</code>. 但假如我们想要定义class之间的层次关系呢？</p><p>假设要构建一个<code>RotatingSLList</code>，它具有与<code>SLList</code>相同的功能，如<code>addFirst, size</code>等，但是需要额外的<code>rotateRight</code>操作将最后一项放到列表的前面，因为继承允许子类重用已经定义的类中的代码。所以让<code>RotatingSLList</code>类从<code>SLList</code>继承部分代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotatingSLList</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">extends</span> <span class="title">SLList</span>&lt;<span class="title">Item</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p><code>RotatingSLList</code>“是一种”<code>SLList</code>, <code>extends</code>可以让我们继承<code>SLList</code>的原始功能，并能修改或添加其他功能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The rotateRight method  takes in an existing list,</span></span><br><span class="line"><span class="comment">    and rotates every element one spot to the right,</span></span><br><span class="line"><span class="comment">    moving the last item to the front of the list.</span></span><br><span class="line"><span class="comment">    For example, input [5, 9, 15, 22] should return [22, 5, 9, 15].</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Item x = removeLast();</span><br><span class="line">    addFirst(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>extends</code>, 子类<strong>继承</strong>父类的所有成员，成员包括：</p><ul><li>所有实例和静态变量</li><li>所有方法</li><li>所有嵌套类</li></ul><p>但注意，构造函数不继承，并且私有成员不能被子类直接访问。</p><p>上面的例子使用父类的<code>removeLast()</code>把最后的元素直接丢弃了，但假如有一个子类<code>VengefulSLList</code>想保留被丢弃的元素呢? 考虑到子类可以直接override父类的成员, 可以override父类的<code>removeLast</code>, 通过添加一个实例变量来追踪所有已删除的元素.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VengefulSLList</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">extends</span> <span class="title">SLList</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    SLList&lt;Item&gt; deletedItems;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VengefulSLList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        deleteItems = <span class="keyword">new</span> SLList&lt;Item&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Item x = <span class="keyword">super</span>.removeLast();</span><br><span class="line">        deletedItems.addLast(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Prints deleted items. */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLostItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       deletedItems.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Constructors-Are-Not-Inherited"><a href="#Constructors-Are-Not-Inherited" class="headerlink" title="Constructors Are Not Inherited"></a>Constructors Are Not Inherited</h3><blockquote><p>Java要求所有子类的构造函数必须先调用其某一超类的构造函数。<br>– <a href="https://docs.oracle.com/javase/tutorial/java/IandI/super.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/IandI/super.html</a></p></blockquote><p>因为逻辑上，如果作为基础的超类没有构建，那么子类的构建的无从谈起。完整的子类构造函数应该是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VengefulSLList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">// 第一行</span></span><br><span class="line">    deletedItems = <span class="keyword">new</span> SLList&lt;Item&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之前的例子没有<code>super();</code>也可以通过编译，是因为Java会自动为我们调用超类的<strong>无参数</strong>构造函数。</p><p>具体分情况考虑：</p><ol><li>编译器会自动为任何没有构造函数的类提供一个无参数的默认构造函数：这个默认构造函数将调用其超类的（accessible）无参构造函数。</li><li><p>如果子类构造函数没有指定要调用哪个超类构造函数：则编译器将自动调用超类的可访问的<strong>无参数</strong>构造函数</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果其超类有<strong>有参数</strong>构造函数，但没有无参数构造函数，那么编译出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">(String s)</span> </span>&#123; &#125; &#125;</span><br></pre></td></tr></table></figure><p>此时要在子类构造函数第一行添加<code>super(s)</code></p></li><li><p>如果超类的无参数构造函数是不可访问的，那么编译出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; <span class="function"><span class="keyword">private</span> <span class="title">Base</span><span class="params">()</span> </span>&#123; &#125; &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果没有显式的超类，那么就调用隐式的超类<code>Object</code>的无参构造函数。</p></li></ul></li></ol><p>Constructor Chaining：当子类构造函数调用其父类的构造函数时（无论是显式还是隐式调用），可以认为有一链式的连续调用构造函数，一直到<code>Object</code>的构造函数</p><h3 id="The-Object-Class"><a href="#The-Object-Class" class="headerlink" title="The Object Class"></a>The Object Class</h3><p>Java中的每个类都是 <strong><code>Object</code></strong> class的后代，或者扩展了Object类。即使在类中没有显式的<code>extends</code>仍然隐式地继承了<code>Object</code>。也就是所有 classes 都继承了 Object class 提供的方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">Class&lt;?&gt; <span class="title">getClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span></span></span><br><span class="line"><span class="function">-- https:<span class="comment">//docs.oracle.com/javase/8/docs/api/java/lang/Object.html</span></span></span><br></pre></td></tr></table></figure></p><p><code>==</code>检查两个变量是否引用同一个对象（检查内存地址位）; <code>.equals()</code>默认是等同于<code>==</code>, 但不同的类可能会通过 override 重写它的功能(如<code>Array.equals()</code>就是重写为检查数组内容是否相同). 当override <code>.equals()</code>时，注意：</p><ol><li>必须体现 equivalence relation<ul><li>reflexive: x.equals(x) is true</li><li>symmetric: x.equals(y) IFF y.equals(x)</li><li>transitive: x.equals(y) and y.equals(z) implies x.equals(z)</li></ul></li><li>要 override 原本的<code>.equals()</code>，必须接收一个 Object 参数</li><li>必须 consistent：假如<code>x.equals(y)</code>, 那么只要<code>x</code>和<code>y</code>保持不变, 那么<code>x</code>继续等于<code>y</code>.</li><li><code>null</code>永远非真: <code>x.equals(null)</code> 一定是<code>false</code></li></ol><blockquote><p>Interfaces don’t extend Object.<br>– <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.2" target="_blank" rel="noopener">http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.2</a></p></blockquote><h3 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h3><p>封装是面向对象编程的基本原则之一，也是程序员处理复杂性一个方法。管理复杂性是编写大型程序时必须面对的主要挑战之一。</p><p>对抗复杂性的一些工具包括:</p><ul><li>Hierarchical abstraction: 创建一个个具有明确的 abstraction barriers 的抽象层<ul><li><strong>Abstraction Barriers</strong>：使用<code>private</code>, 保证对象内部不能被查看, 确保底层的复杂性不会暴露给外部世界。</li></ul></li><li>“Design for change” (D. Parnas)<ul><li>Organize program around objects.</li><li>Let objects decide how things are done.</li><li><strong>Hide information</strong> others don’t need.</li></ul></li></ul><p>大概的想法都是 - 程序应该被构建成模块化，可互换的片段，可以在不破坏系统的情况下进行交换。</p><p>封装就是构建在这种对外部隐藏信息的概念上。以细胞为类比：细胞内部可能非常复杂，由染色体，线粒体，核糖体等组成，但它完全被封装在一个单一模块中 - 抽象了内部的复杂性。</p><blockquote><p>In computer science terms, a module can be defined as a set of methods that work together as a whole to perform a task or set of related tasks. Now, if the implementation details of a module are kept internally hidden and the only way to interact with it is through a documented interface, then that module is said to be encapsulated.</p></blockquote><h3 id="Type-Checking"><a href="#Type-Checking" class="headerlink" title="Type Checking"></a>Type Checking</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    VengefulSLList&lt;Integer&gt; vsl = <span class="keyword">new</span> VengefulSLList&lt;Integer&gt;(<span class="number">9</span>);</span><br><span class="line">    SLList&lt;Integer&gt; sl = vsl; <span class="comment">// 超类包含子类</span></span><br><span class="line">    <span class="comment">//sl dynamic type is VengefulSLList</span></span><br><span class="line">    sl.addLast(<span class="number">50</span>);</span><br><span class="line">    sl.removeLast(); <span class="comment">// 根据 dynamic type 选择 VengefulSLList 的 removeLast</span></span><br><span class="line">    sl.printLostItems(); <span class="comment">//编译不过, 因为编译时检查的是 static type</span></span><br><span class="line">    VengefulSLList&lt;Integer&gt; vsl2 = sl; <span class="comment">// 编译不过, 子类无法包含超类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Expressions 是 compile-time types (static), 使用<code>new</code>的表达式具有指定的 compile-time types:</p><ul><li><code>SLList&lt;Integer&gt; sl = new VengefulSLList&lt;Integer&gt;();</code>, 表达式右边 compile-time types 是<code>VengefulSLList</code>。编译器检查并保证<code>VengefulSLList</code>一定也是<code>SLList</code>，因此允许此赋值.</li><li><code>VengefulSLList&lt;Integer&gt; vsl = new SLList&lt;Integer&gt;();</code>, 表达式右边 compile-time types 是<code>SLList</code>。编译器检查, 因为<code>SLList</code>并不一定是<code>VengefulSLList</code>，故编译报错.</li></ul><p>Method calls have compile-time types equal to their declared type.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title">maxDog</span><span class="params">(Dog d1, Dog d2)</span> </span>&#123; ... &#125;</span><br><span class="line">Poodle frank = <span class="keyword">new</span> Poodle(<span class="string">"Frank"</span>, <span class="number">5</span>);</span><br><span class="line">Poodle frankJr = <span class="keyword">new</span> Poodle(<span class="string">"Frank Jr."</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">Dog largerDog = maxDog(frank, frankJr);</span><br><span class="line">Poodle largerPoodle = maxDog(frank, frankJr); <span class="comment">// 编译不过! RHS compile-time type is Dog</span></span><br></pre></td></tr></table></figure></p><p>编译器报错, 因为普遍意义的 Dog object 并不总是贵宾犬, 虽然此时我们都知道这里的”狗”肯定是指贵宾犬. 有没有办法让编译器理解这种特殊情况呢?</p><h3 id="Casting"><a href="#Casting" class="headerlink" title="Casting"></a>Casting</h3><p>通过 casting, 可以告诉编译器一个表达式有某个特定的 compile-time types.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Poodle largerPoodle = (Poodle) maxDog(frank, frankJr);</span><br></pre></td></tr></table></figure></p><p>编译通过, 右边 compile-time type 转换为 <code>Poodle</code>.</p><blockquote><p>Caution: Casting is a powerful but dangerous tool. Essentially, casting is telling the compiler not to do its type-checking duties - telling it to trust you and act the way you want it to.</p></blockquote><h3 id="Inheritance-Cheatsheet"><a href="#Inheritance-Cheatsheet" class="headerlink" title="Inheritance Cheatsheet"></a>Inheritance Cheatsheet</h3><p>VengefulSLList extends SLList means VengefulSLList “is-an” SLList, and inherits all of SLList’s members:<br>总结 Inheritance 的一些要点:</p><ul><li>当子类<code>VengefulSLList</code> <code>extends</code> 超类<code>SLList</code>时, 意味着<code>VengefulSLList</code>也”是”<code>SLList</code>, 并继承<code>SLList</code>的所有成员:<ul><li>Variables, methods, nested classes</li><li>除了 constructors: Subclass constructors 必须先调用 superclass constructor; 通过 <code>super</code> 调用 overridden superclass methods 和 constructors.</li></ul></li></ul><p>调用 overridden methods 遵循两个规则:</p><ul><li>编译器只允许与 static type 符合的行为.</li><li>对于 overridden methods, 调用是基于 dynamic type</li><li>可以使用 casting 来规避 compiler type checking.</li></ul><h2 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher Order Functions"></a>Higher Order Functions</h2><blockquote><p>A higher order function is a function that treats other functions as data.</p></blockquote><p>在 Java 7 及之前的版本, memory boxes (variables) 不能包含指向 functions 的 pointers, 也就是无法给 functions 指定 types. 所以不能像Python一样直接把 function 作为参数传递到另一个 function 中。只能借用 interface：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntUnaryFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TenX</span> <span class="keyword">implements</span> <span class="title">IntUnaryFunction</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Returns ten times the argument. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span> * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_twice</span><span class="params">(IntUnaryFunction f, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f.apply(f.apply(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用高阶方法</span></span><br><span class="line">System.out.println(do_twice(<span class="keyword">new</span> TenX(), <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>Java 8 引入<code>java.util.Function&lt;T, R&gt;</code>接口, 可以接受存储一个函数，<code>&lt;T, R&gt;</code>对应该函数的参数和返回对象</p><h2 id="Subtype-Polymorphism"><a href="#Subtype-Polymorphism" class="headerlink" title="Subtype Polymorphism"></a>Subtype Polymorphism</h2><blockquote><p>多态（polymorphism），是指指相同的消息给予不同的对象会引发不同的动作。</p><ul><li>动态多态（dynamic polymorphism）：通过类继承机制和虚函数机制生效于运行期。可以优雅地处理异质对象集合，只要其共同的基类定义了虚函数的接口。<ul><li>在面向对象程序设计中，多态一般是指子类型多态（Subtype polymorphism）或包含多态（inclusion polymorphism）。一般是通过某种可代换性（ substitutability）与另一个数据类型（超类型，supertype）相关的数据类型，这意味着为在这个超类型的元素上运算而写计算机程序也可以在子类型的元素上运算。</li></ul></li><li>静态多态（static polymorphism）：模板也允许将不同的特殊行为和单个泛化记号相关联，由于这种关联处理于编译期而非运行期，因此被称为“静态”。可以用来实现类型安全、运行高效的同质对象集合操作。C++ STL不采用动态多态来实现就是个例子。<ul><li>非参数化多态或译作特设多态（Ad-hoc polymorphism）：<ul><li>函数重载（Function Overloading）</li><li>运算符重载（Operator Overloading）</li><li>带变量的宏多态（macro polymorphism）</li></ul></li><li>参数化多态（Parametric polymorphism）：把类型作为参数的多态。在面向对象程序设计中，这被称作泛型编程。</li></ul></li></ul></blockquote><blockquote><p>子类型反映了类型（即面向对象的接口）之间的关系；而继承反映了一类对象可以从另一类对象创造出来，是语言特性的实现。因此，子类型也称接口继承；继承称作实现继承。</p></blockquote><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><p>Java的对象不能直接使用<code>&gt;, &lt;, =</code>进行比较. 在Python或C++中，当应用于不同对象类型时，比较运算符可以重新定义，但Java不支持。但可以借用接口继承，Java提供了一个<code>Comparable</code>接口，以保证任何实现该接口的类包含一个比较方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Return negative if this &lt; o.</span></span><br><span class="line"><span class="comment">    Return 0 if this equals o.</span></span><br><span class="line"><span class="comment">    Return positive if this &gt; o.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当有class需要比较时, 就实现这个接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Dog</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Dog uddaDog)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size - uddaDog.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p>除了自然顺序（Natural order，指代<code>Comparable</code>接口定义的<code>compareTo</code>的判断标准，在这里是<code>size</code>），如果我们想用其他方式对狗进行比较排序呢？在Python可以使用HOF，编写新的比较函数，然后直接以参数形式传递该函数。但Java的方案是使用<code>Comparator</code>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例如，当需要按照狗的名字字母顺序（alphabetical order）排序时，就在 Dog class 内部编写一个实现<code>Comparator</code>接口的嵌套类<code>NameComparator</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Dog</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Dog uddaDog)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size - uddaDog.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接利用 String 已经定义好的 compareTo</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NameComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Dog</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dog a, Dog b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.name.compareTo(b.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Dog&gt; <span class="title">getNameComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NameComparator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>main</code>函数中调用时<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Dog d1 = <span class="keyword">new</span> Dog(<span class="string">"Alpha"</span>, <span class="number">3</span>);</span><br><span class="line">Dog d2 = <span class="keyword">new</span> Dog(<span class="string">"Beta"</span>, <span class="number">15</span>);</span><br><span class="line">java.util.Comparator&lt;Dog&gt; nc = Dog.getNameComparator();</span><br><span class="line"><span class="keyword">if</span> (nc.compare(d1, d2) &gt; <span class="number">0</span>) &#123; <span class="comment">//这里就会按照 alphabet 比较</span></span><br><span class="line">    d1.bark();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    d2.bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同理若需要增加其他判断标准，就创建新的实现<code>Comparator</code>的 class.</p><h3 id="Comparable与Comparator"><a href="#Comparable与Comparator" class="headerlink" title="Comparable与Comparator"></a>Comparable与Comparator</h3><p>接口提供了回调(call back)的能力:</p><ul><li>有时一个函数需要调用另一个尚未写好的 helper function, 这时这个 helper function 就是 <code>call back</code>。比如“排序函数”需要“比较函数”的帮助。</li><li>不同语言对于回调有不同的处理方式<ul><li>Python 用函数传递 - <a href="#Higher-Order-Functions">Higher Order Functions</a></li><li>Java 选择把函数包含在一个接口中</li></ul></li></ul><p><strong><code>Comparable</code></strong> 是对象自身主动与另一个对象进行比较。它嵌入在待比较的对象内，定义了一种类型的 natural ordering。</p><p><strong><code>Comparator</code></strong> 更像是将两个对象进行比较的第三方对象。由于只有一个<code>compareTo</code>的空间，如果想要支持多种方式进行比较，则必须使用<code>Comparator</code>。</p><h2 id="Abstract-Data-Types-ADTS"><a href="#Abstract-Data-Types-ADTS" class="headerlink" title="Abstract Data Types (ADTS)"></a>Abstract Data Types (ADTS)</h2><p><code>ArrayDeque</code>和<code>LinkedListDeque</code>都是实现<code>deque</code>这个接口，<code>deque</code>只是罗列了一些 methods，也即是一种合约，保证会实现的行为。而这些方法的具体实现则是由<code>ArrayDeque</code>和<code>LinkedListDeque</code>完成。从概念上讲，<code>deque</code>就是一种抽象的数据类型，只说会有什么行为，但不体现这些行为的具体实现方式，所以是抽象的。</p><h3 id="Java-Libraries"><a href="#Java-Libraries" class="headerlink" title="Java Libraries"></a>Java Libraries</h3><p>Java有一些内置的抽象数据类型，打包在Java库中。 三个最重要的ADTs来自<code>java.util</code>库：</p><ul><li>List 列表：一个有序的元素集合，如<code>ArrayList</code></li><li>Set 集合：元素严格唯一（不重复）的(无序)集合，如<code>HashSet</code></li><li>Map 映射：A collection of <code>Key - value</code> 映射, <code>key</code>是唯一的。通过<code>key</code>访问<code>value</code>，如<code>HashMap</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** takes in a String inputFileName</span></span><br><span class="line"><span class="comment">and puts every word from the input file into a list*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getWords</span><span class="params">(String inputFileName)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; lst = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    In in = <span class="keyword">new</span> In();</span><br><span class="line">    <span class="keyword">while</span> (!in.isEmpty()) &#123;</span><br><span class="line">        lst.add(in.readString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** takes in a List&lt;String&gt; and counts how many unique words there are in the file.*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countUniqueWords</span><span class="params">(List&lt;String&gt; words)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; ss = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : words) &#123;</span><br><span class="line">           ss.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ss.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** takes in a List&lt;String&gt; targets and a List&lt;String&gt; words,</span></span><br><span class="line"><span class="comment">and finds the number of times each target word appears in the word list.*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; <span class="title">collectWordCount</span><span class="params">(List&lt;String&gt; words)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String t: target) &#123;</span><br><span class="line">        counts.put(s, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String s: words) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counts.containsKey(s)) &#123;</span><br><span class="line">            counts.put(word, counts.get(s)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://joshhug.gitbooks.io/hug61b/content/assets/collection_hierarchy.png" alt="" title="Collections represent a group of objects, known as its elements: the white boxes are interfaces. The blue boxes are concrete classes. image from:https://joshhug.gitbooks.io/hug61b/"><br>通过设置环境变量（如<code>CLASSPATH =</code>）让Java编译器/解释器知道去哪里找 libraries。</p><p><code>CLASSPATH</code>：Linux or MacOS, paths are separated by <code>:</code>. In Windows, paths are separated by <code>;</code>.</p><ul><li><code>/home/--/--/javalib/*</code>, 在<code>.class</code>和<code>.jar</code>文件内查找依赖包，用于指定绝对路径。有同名时，会根据环境变量的先后顺序去排序靠前的。</li><li><code>./</code>指当前目录，<code>../</code>指上一层目录，用于指定相对路径。</li><li>也可以指定<code>classpath</code>, 这样系统的<code>CLASSPATH</code>会被忽略: <code>javac -cp ./:/home/stuff/:../ Foo.java</code>, 当有重名时, 选择顺序就是指明的路径顺序（当前目录-stuff目录-上一层目录）</li></ul><p>IntelliJ会忽略<code>CLASSPATH</code>，它会自动调用<code>-cp</code>, 变量是基于当前项目指定的 libraries.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 查看 IntelliJ 使用的 classpath*/</span></span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">    URL[] urls = ((URLClassLoader)cl).getURLs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(URL url: urls)&#123;</span><br><span class="line">        System.out.println(url.getFile());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="其他ADT"><a href="#其他ADT" class="headerlink" title="其他ADT"></a>其他ADT</h3><p>堆栈 Stacks 和队列 Queues 是两种类似的线性集合。堆栈是后进先出的ADT：元素总是从数据结构的一端添加或删除。队列是先进先出的ADT. 二者都支持以下操作:<br><code>push()</code>: 加入<br><code>peek()</code>: 返回下一个<br><code>poll()</code>: 返回下一个并删除</p><p>Java的<code>Deque</code>(double ended queue, “deck”) 接口融合了堆栈和队列, 支持两端的元素插入和移除.</p><p>优先级队列 priority queue 的每个元素都有一个与之关联的优先级，以决定从队列中元素操作的顺序。</p><h3 id="Abstract-classes"><a href="#Abstract-classes" class="headerlink" title="Abstract classes"></a>Abstract classes</h3><p>Interface:</p><ul><li>除非指定<code>access modifier</code>, 否则所有的方法默认都是<code>public</code> （Java 9 支持 <code>private</code>）</li><li>可以提供变量, 但都是<code>public static final</code>, 也即没有实例变量</li><li>无法实例化</li><li>除非指定为<code>default</code>，否则所有方法均为抽象的</li><li>一个类可以实现多个接口</li><li>根据协议承诺, 实现类必须实现其继承的接口的所有抽象方法; 否则要声明为抽象类.</li></ul><p>Abstract classes 介于接口和 classes 之间。</p><ul><li>方法可以是<code>public</code>或<code>private</code>, 也支持<code>protected</code>和<code>package private</code>.</li><li>支持任何类型的变量</li><li>无法实例化</li><li>除非指定为<code>abstract</code>，否则方法默认是具体的实现</li><li>每个类只能实现一个 Abstract classes</li><li>抽象类不需要实现其继承的接口所有抽象方法</li></ul><p>基本上，接口能做的抽象类都可以做。实际应用中，抽象类通常用于部分地实现接口，在接口和实际的类中间扮演一个中间概念。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(Speed x)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DeluxeModel</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> x;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(Speed x)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">autoPilot</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现时, 要 override 所有抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeslaX</span> <span class="keyword">extends</span> <span class="title">DeluxeModel</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">autoPilot</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>若不确定用哪种, 就优先考虑接口，以降低复杂性。<br>– <a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html</a></p></blockquote><h2 id="Packages-and-JAR"><a href="#Packages-and-JAR" class="headerlink" title="Packages and JAR"></a>Packages and JAR</h2><p>同样功能的类可能有多种版本, 或者不同类刚好命名相同。通过 packages 来为每个 classes 提供唯一的标识名称，如<code>java.util.</code></p><blockquote><p>A package is a namespace that organizes classes and interfaces.</p></blockquote><p>在IntelliJ的操作：</p><ul><li><p>创建 package：<br>1, File → New Package<br>2, 选择 package name (i.e. “ug.joshh.animal”)</p></li><li><p>给 Package 添加(新) Java 文件：<br>1, 右键 package name<br>2, New → Java Class<br>3, 命名 class, 然后 IntelliJ 会自动把文件放进正确的路径, 并添加 package declaration.</p></li><li><p>移动其他<code>.java</code>文件到 Package<br>1, 在文件顶部声明 <code>package [packagename]</code><br>2, 将文件存储在（移动到）与 package name 对应的文件夹中：如<code>ug.joshh.animal</code> 对应<code>ug/joshh/animal</code>文件路径.</p></li></ul><p>注意, 不存在<code>sub-package</code>这种概念, 即<code>ug.joshh.Animal</code>和<code>ug.joshh.Plant</code>是完全不同的.</p><h3 id="Default-packages"><a href="#Default-packages" class="headerlink" title="Default packages"></a>Default packages</h3><p>没有在文件顶部明确指明 package name 的Java类默认属于 default package 的一部分。</p><p>一般而言, Java文件应该以明确的 package 声明开头以避免将文件留在 default package 中（除非它是一个非常小的示例程序）。因为来自 default package 的代码无法 import，并且可能会意外地在 default package 下创建相同名称的类。</p><h3 id="JAR-Files"><a href="#JAR-Files" class="headerlink" title="JAR Files"></a>JAR Files</h3><p>一般情况下，程序会包含多个<code>.class</code>文件。如果想共享此程序，可以把压缩成一个<code>.jar</code>文件，此<code>.jar</code>文件将包含程序所有<code>.class</code>文件以及其他附加信息。JAR文件就像zip文件一样, 可以将文件解压缩回<code>.java</code>文件。JAR文件并不会加密保护代码.</p><blockquote><p>Creating a JAR File (IntelliJ)</p><ol><li>Go to File → Project Structure → Artifacts → JAR → “From modules with dependencies”</li><li>Click OK a couple of times</li><li>Click Build → Build Artifacts (this will create a JAR file in a folder called “Artifacts”)</li><li>Distribute this JAR file to other Java programmers, who can now import it into IntelliJ (or otherwise)</li></ol></blockquote><h3 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h3><p>cs61b Josh Hug:<br><code>Private</code></p><blockquote><p>Only code from the given class can access private members.</p></blockquote><p><code>Package Private</code></p><blockquote><p>The default access given to Java members if there is no explicit modifier written. Classes that belong in the same package can access, but not subclasses!</p></blockquote><p><code>Protected</code></p><blockquote><p>Classes within the same package and subclasses can access these members, but the rest of the world (e.g. classes external to the package or non-subclasses) cannot! Subtypes might need it, but subtype clients will not.</p></blockquote><p><code>Public</code></p><blockquote><p>Open and promised to the world, once deployed, the public members’ signatures should not change.<br>就像承诺和合同，尽量不要更改，以便用户始终可以（用已有的代码）访问。如果开发者要舍弃某一个<code>Public</code>，一般标识为<code>deprecated</code>.</p></blockquote><p>细节:</p><ol><li><strong>Access is Based Only on Static Types</strong></li><li>接口的方法默认是<code>public</code>的</li></ol><h3 id="Build-Systems"><a href="#Build-Systems" class="headerlink" title="Build Systems"></a>Build Systems</h3><p>可以简单地将文件放入适当的位置，然后通过 Maven, Ant 和 Gradle 等工具使用 Build Systems 来自动设置项目, 省去了手动加载一长串 libraries.</p><h2 id="丰富扩展generics的语法或特性"><a href="#丰富扩展generics的语法或特性" class="headerlink" title="丰富扩展generics的语法或特性"></a>丰富扩展generics的语法或特性</h2><h3 id="Autoboxing"><a href="#Autoboxing" class="headerlink" title="Autoboxing"></a>Autoboxing</h3><p>在Java中调用包含 Generics 的class时，需要提供确切的类型参数。对于每一种 primitive type (<code>byte, short, int, long, float, double, boolean, char</code>)，必须要用其对应的 reference type (<code>Byte, Short, Integer, Long, Float, Double, Boolean, Character</code>) - 也即是 wrapper classes 作为泛型的实际类型参数。虽然声明函数和变量时必须要用 wraper classes，但在实际的数值传递中，对于 primitives 类型的数据，并不需要显式地转换为 reference types。</p><p>因为 Java 有 Autoboxing，可以隐式地在 wrapper/primitives 类型间转换. Java会自动 “box” 和 “unbox” primitive type 和其对应的 reference type 之间的值。也就是说，如果Java期望的是 wrapper classes （如Integer），假如即使接收到的是 int 这样的基本类型，Java也会“autoboxing”这种整数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blah</span><span class="params">(Integer x)</span> </span>&#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">20</span>;</span><br><span class="line">blah(x); <span class="comment">// 实际上会转换为 blah(new Integer(20))</span></span><br></pre></td></tr></table></figure></p><p>反过来就是<code>unboxing</code>。</p><p>Autoboxing/Unboxing 注意事项:</p><ul><li>不适用于 array 数组</li><li>有性能负担</li><li>Wrapper types 比 primitive types 占用更多内存: 在大多数现代的系统里，对象的引用地址占用64位，还需要额外的64位开销用于存储动态类型等信息。 更多信息参考 <a href="https://www.javamex.com/tutorials/memory/object_memory_usage.shtml" target="_blank" rel="noopener">Memory usage of Java objects: general guide</a> 或 <a href="http://blog.kiyanpro.com/2016/10/07/system_design/memory-usage-estimation-in-java/" target="_blank" rel="noopener">Memory Usage Estimation in Java</a>.</li></ul><h3 id="Widening"><a href="#Widening" class="headerlink" title="Widening"></a>Widening</h3><p>Java会根据需要在 primitive types 之间自动扩展.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blahDouble</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    System.out.println(“<span class="keyword">double</span>: “ + x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">20</span>;</span><br><span class="line">blahDouble(x); <span class="comment">//等同于 blahDouble((double) x)</span></span><br></pre></td></tr></table></figure></p><p>但如果想从一个 wider type 转换为 narrower type，则必须手动 cast.<br>有关 widening 的更多详细信息，包括哪些类型比其他类型更 wider ，参阅<a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html" target="_blank" rel="noopener">官方的Java文档</a>。</p><h3 id="Generic-Methods"><a href="#Generic-Methods" class="headerlink" title="Generic Methods"></a>Generic Methods</h3><p>泛型方法的语法用map数据类型举例. 假如有一个现成的映射数据结构<code>Map61B</code>, 我们需要为她写两个helper methods放在<code>MapHelper</code>里面.</p><p><code>get(Map61B, key)</code>：返回映射中给定key对应的值（如果存在），否则返回null。假如这样写<code>public static V get(Map61B&lt;K, V&gt; map, String key) { ... }</code>会报错. 要将方法声明为泛型，<strong>必须在返回类型前面指定正式的类型参数</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">V <span class="title">get</span><span class="params">(Map61B&lt;K,V&gt; map, K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> map.containsKey(key) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayMap&lt;Integer, String&gt; isMap = <span class="keyword">new</span> ArrayMap&lt;Integer, String&gt;();</span><br><span class="line">System.out.println(mapHelper.get(isMap, <span class="number">5</span>)); <span class="comment">//Java可以自行推断`isMap`的数据类型.</span></span><br></pre></td></tr></table></figure></p><p><code>maxKey</code>: 返回给定<code>ArrayMap</code>中所有keys的最大值（仅在key可以比较的情况下）。实现时要注意, 不能直接用<code>&lt;,&gt;,==</code>来比较, 因为key不一定是primitives. 需要用<code>Comparable</code>接口的<code>compareTo</code>,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K extends Comparable&lt;K&gt;, V&gt; <span class="function">K <span class="title">maxKey</span><span class="params">(Map61B&lt;K, V&gt; map)</span> </span>&#123;</span><br><span class="line">    List&lt;K&gt; keylist = map.keys();</span><br><span class="line">    K largest = map.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (K k: keylist) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k.compareTo(largest)) &#123;</span><br><span class="line">            largest = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> largest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>K extends Comparable&lt;K&gt;</code> 保证了keys必须实现<code>Comparable</code>接口（也是一个generic接口）, 并可以与其他<code>K</code>进行比较。</p><p>这里没有使用<code>implement</code>, 而是用<code>extends</code>, 这里跟前面的<a href="#Subtype-Polymorphism">polymorphism</a>不同. <code>K extends Comparable&lt;K&gt;</code>是<strong>type upper bounding</strong>, 意味着<code>k</code>必须是一种<code>Comparable</code>, 但不需要具备<code>Comparable</code>的所有方法行为.</p><p>在inheritance的含义中，<code>extends</code>指为子类提供超类的能力. 在generic范畴内, <code>extends</code>只是陈述一个事实：该类是其扩展的类的一个子类, 是加了约束, 而不是赋予能力.</p><h2 id="Immutability"><a href="#Immutability" class="headerlink" title="Immutability"></a>Immutability</h2><blockquote><p>An immutable data type is a data type whose instances cannot change in any observable way after instantiation.</p></blockquote><p>比如<code>String</code>是immutable, <code>Array</code>是mutable.</p><p>防止变量在第一次赋值后被更改</p><ul><li>可以使用<code>final</code>: 在 class constructor 里面, 或者变量初始化时, 给变量赋值一次, 之后就无法再被赋值了.</li><li>要保证immutable不一定要使用<code>final</code>, 有时候也可以用<code>private</code>.</li></ul><p>Immutable data types 因为属性不能改变, 缺点是需要创建一个新对象才能更改属性，优点是：</p><ul><li>可以防止bugs, 并使debugging更容易</li><li>可以信赖对象具有某种行为/特质</li></ul><p>注意：</p><ul><li>将一个引用声明为<code>final</code>并不会保证引用指向的对象是immutable. <code>public final ArrayDeque&lt;String&gt;() deque = new ArrayDeque&lt;String&gt;();</code>变量<code>deque</code>是<code>final</code>的, 仅意味着不能重新被赋值, 但其指向的数组队列对象自身还是可变的.</li><li>使用<code>Reflection API</code>，甚至可能对<code>private</code>变量进行更改</li></ul><h2 id="Throwing-Exceptions"><a href="#Throwing-Exceptions" class="headerlink" title="Throwing Exceptions"></a>Throwing Exceptions</h2><p>当程序出现错误时，假如继续运行下去已经没有意义（或者根本不可能继续），那么我们就想要中断正常的控制流程 - throws an exception。</p><p>比如当想从某<code>ArrayMap</code>中提取某个不存在的键值时, java自动抛出一个<code>implicit exception</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java ExceptionDemo</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ArrayIndexOutOfBoundsException: -<span class="number">1</span></span><br><span class="line">at ArrayMap.get(ArrayMap.java:<span class="number">38</span>)</span><br><span class="line">at ExceptionDemo.main(ExceptionDemo.java:<span class="number">6</span>)</span><br></pre></td></tr></table></figure></p><p>如果想让自己的程序抛出更详细的信息, 可以在程序中加入<code>explicit exception</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    intlocation = findKey(key);</span><br><span class="line">    <span class="keyword">if</span>(location &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> newIllegalArgumentException(<span class="string">"Key "</span> + key + <span class="string">" does not exist in map."</span>\);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values[findKey(key)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$java ExceptionDemo</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalArgumentException: Key yolp does not exist in map.</span><br><span class="line">at ArrayMap.get(ArrayMap.java:<span class="number">40</span>)</span><br><span class="line">at ExceptionDemo.main(ExceptionDemo.java:<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>单纯 throw exception 会导致代码崩溃。但是通过 <code>try - catch</code> “捕捉”异常(<code>RuntimeException</code> 是 Java object), 可以防止程序崩溃。</p><p>比如通过捕捉异常, 来引入修正措施: 下面这个代码通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 当狗在生气时, 如果尝试拍拍它，会抛出一个 RuntimeException，</span></span><br><span class="line"><span class="comment">捕捉到 exception 后, 用香蕉来抚慰它. */</span></span><br><span class="line">Dog d = <span class="keyword">new</span> Dog(<span class="string">"Lucy"</span>, <span class="string">"Retriever"</span>, <span class="number">80</span>);</span><br><span class="line">d.becomeAngry();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    d.receivePat();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">    <span class="string">"Tried to pat: "</span> + e);</span><br><span class="line">    d.eatTreat(<span class="string">"banana"</span>);</span><br><span class="line">&#125;</span><br><span class="line">d.receivePat();</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ java ExceptionDemo</span><br><span class="line">Tried to pat: java.lang.RuntimeException: grrr... snarl snarl</span><br><span class="line">Lucy is a displeased Retriever weighing <span class="number">80.0</span> standard lb units.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ java ExceptionDemo</span><br><span class="line">Tried to pat: java.lang.RuntimeException: grrr... snarl snarl</span><br><span class="line">Lucy munches the banana</span><br><span class="line"></span><br><span class="line">Lucy enjoys the pat.</span><br><span class="line"></span><br><span class="line">Lucy is a happy Retriever weighing <span class="number">80.0</span> standard lb units.</span><br></pre></td></tr></table></figure><p>使用<code>if else</code>来管理异常会让代码变得很乱而难以阅读. 而使用<code>try catch</code>可以为每种类型的 exception 提供不同的应对。使代码像清晰的记述文般铺展开来: 首先，尝试执行所需的操作。然后，捕捉任何错误。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    doSomething;</span><br><span class="line">&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    doSomething;</span><br><span class="line">&#125; ...</span><br></pre></td></tr></table></figure></p><p>好的代码像一个故事, 构建上有一定的美感。这种清晰度使代码的长期维护变得更容易。</p><h3 id="Uncaught-Exceptions-Stack-Trace"><a href="#Uncaught-Exceptions-Stack-Trace" class="headerlink" title="Uncaught Exceptions Stack Trace"></a>Uncaught Exceptions Stack Trace</h3><p>如果 exception 到达堆栈底部后仍未被捕获，程序崩溃，Java 打印出堆栈的跟踪:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException in thread “main”:</span><br><span class="line">at ArrayRingBuffer.peek:<span class="number">63</span></span><br><span class="line">at GuitarString.sample:<span class="number">48</span></span><br><span class="line">at GuitarHeroLite.java:<span class="number">110</span></span><br></pre></td></tr></table></figure></p><p><img src="https://joshhug.gitbooks.io/hug61b/content/assets/callstack.png" alt="" title="image from: https://joshhug.gitbooks.io/hug61b"><br>程序猿可以据此追踪错误路径。</p><h3 id="Checked-vs-Unchecked-Exceptions"><a href="#Checked-vs-Unchecked-Exceptions" class="headerlink" title="Checked vs Unchecked Exceptions"></a>Checked vs Unchecked Exceptions</h3><p>有时候，某些抛出的 exception 无法通过编译，可以理解为这些异常在编译器看来是非常恶心的存在，需要程序猿必须给这些 exception 提供明确的应对处理方案 - 这种叫 checked exception （”must be checked”）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eagle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gulgate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (today == “Thursday”) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"hi"</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ javac Eagle</span><br><span class="line">Eagle.java:<span class="number">4</span>: error: unreported exception IOException; must be caught or declared to be thrown</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"hi"</span>); &#125;</span><br><span class="line">^</span><br></pre></td></tr></table></figure><p>很明显，Java对此<code>IOException</code>并不满意, 因为<code>IOExceptions</code>是 checked exception, 而这里没有提供应对处理方案。但假如换做<code>RuntimeException</code>就可以编译通过 (虽然在 runtime 时会崩溃).<br><img src="https://joshhug.gitbooks.io/hug61b/content/assets/checked_exceptions.png" alt="" title="image from: https://joshhug.gitbooks.io/hug61b/"><br><code>Errors</code> 和 <code>Runtime Exceptions</code>, 以及它们的子类都是<code>unchecked</code>. 这种异常都是直到运行时才能发现的错误, 它们一般无法从中恢复到正常状态 - 比如代码尝试从数组中获取<code>-1</code>元素，好像就没什么解决办法。</p><p>其余的都是 <code>checked exception</code>, 它们其中大多数都有修正的可能性。例如遇到<code>FileNotFound</code>，可以考虑要求用户重新指定他们想要的文件 (可能是因为错误输入导致的)。</p><p>Java在尽最大努力确保每个程序运行时不会崩溃，所以它不会允许程序留下任何明明可以应对修正却没有被明确地修正的错误。</p><p>两种方法来处理 checked error:</p><ol><li><p><strong>Catch</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gulgate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (today == “Thursday”) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"hi"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"psych!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 假如能够应对，尽量用 catch 锁定异常防止其逃逸。</p></li><li><p><strong>Specify</strong>: 如果实在不想在该方法中处理这种异常，可以将责任推迟到别的地方。我们可以指定该方法是危险的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gulgate</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ... <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"hi"</span>); ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后任何其他调用<code>gulgate()</code>的方法也变成危险的了, 它们也需要被处理(同样使用两种方法之一)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// catch</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        gulgate();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Averted!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或 specify</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    gulgate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 需要明确异常处理责任人。同时确保调用者知道该方法是危险的！</p></li></ol><h2 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h2><p>Java提供了 foreach (enhanced for) 的循环简写语法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayMap&lt;String, Integer&gt; am = <span class="keyword">new</span> ArrayMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s : am) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现的关键原理是使用<code>Iterable</code>接口使一个类变成可迭代的: 该接口包含一个<code>iterator()</code>方法用于返回一个<code>Iterator</code>对象。<code>Iterator</code>接口定义<code>Iterator</code>对象和<code>hasNext(), next()</code>方法来进行实际的迭代操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map61B</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Iterable</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K[] keys;</span><br><span class="line">    <span class="keyword">private</span> V[] values;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        keys = (K[]) <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">        values = (V[]) <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ptr;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">KeyIterator</span><span class="params">()</span> </span>&#123; ptr = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (ptr != size); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            K returnItem = keys[ptr];</span><br><span class="line">            ptr = ptr + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> returnItem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不同的数据结构，<code>Iterator</code>有不同的实现方式.</p><p><code>KeyIterator</code>即使是<code>private</code>也可以编译, 因为<code>iterator()</code>在这里是<code>public</code>的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayMap&lt;String, Integer&gt; am = <span class="keyword">new</span> ArrayMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; it = am.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : am) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了用嵌套类来自定义实现<code>Iterator</code>, 也可以利用数据结构本身的特性. 比如<code>ArrayMap</code>里面刚好包含一个可迭代的数据结构<code>List keys</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;K&gt; keylist = keys();</span><br><span class="line">    <span class="keyword">return</span> keylist.Iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意要点</strong></p><ul><li><code>hasNext()</code>的判断依据是<strong>当前状态下能返回至少一个成员</strong>, 不要混淆为<em>下一次能否返回</em>: 因为迭代时过程中, 每次调用<code>next()</code>之前, java 都会先调用<code>hasNext()</code>.</li><li>实现方法时, 要保证第一次<code>next()</code>返回的是第一个成员.</li></ul><h2 id="总结Java的特性"><a href="#总结Java的特性" class="headerlink" title="总结Java的特性"></a>总结Java的特性</h2><blockquote><ul><li>Packages<ul><li>Good: Organizing, making things package private</li><li>Bad: Specific</li></ul></li><li>Static type checking<ul><li>Good: Checks for errors early , reads more like a story</li><li>Bad: Not too flexible, (casting)</li></ul></li><li>Inheritance.<ul><li>Good: Reuse of code</li><li>Bad: “Is a”, the path of debugging gets annoying, can’t instantiate, implement every method of an interface</li></ul></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 高级语法。&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="cs61b" scheme="http://shukebeta.me/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>Software Architecture, Process, and Management - Informatics - University of Edinburgh 爱丁堡大学</title>
    <link href="http://shukebeta.me/UoE-sapm/"/>
    <id>http://shukebeta.me/UoE-sapm/</id>
    <published>2018-05-15T23:00:00.000Z</published>
    <updated>2018-06-29T19:34:04.478Z</updated>
    
    <content type="html"><![CDATA[<p>Reference:<br><a href="https://msdn.microsoft.com/en-us/library/ff650706.aspx" target="_blank" rel="noopener">microsoft</a><br><a href="https://www.ibm.com/developerworks/rational/library/feb06/eeles/" target="_blank" rel="noopener">IBM</a><br>Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman</p><a id="more"></a><h2 id="What-is-Software-Architecture"><a href="#What-is-Software-Architecture" class="headerlink" title="What is Software Architecture?"></a>What is Software Architecture?</h2><p>Software architecture is often described as the organization or structure of a system, where the system represents a collection of components that accomplish a specific function or set of functions.</p><ul><li>grouping components into areas of <strong>concern (layers)</strong>: For example, the UI, business processing, and data access.</li><li>focus on interaction between the components and how different components work together.</li></ul><p>在书中的定义：</p><blockquote><p>The software architecture of a system is the set of structures needed to reason about the system, which comprise software elements, relations among them, and properties of both.<br>– Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman</p></blockquote><p>架构的关注点在于系统内各个应用和模块的交互和调用。软件架构的设计，需要考虑满足什么样的需求（用户或甲方），如何解决和优化问题（不同的方向各有偏重），操作中如何做选择（在不同的方面平衡，妥协）。</p><p>Architecture and <strong>design concerns</strong> very often overlap - The selection of data structures and algorithms or the implementation details of individual components are design concerns.</p><p>没必要强硬区分二者，而应该综合起来看待。某些情况下，决策是自然而然的结构层面的；在某些情况下，决策更多是关于于设计层面，以及设计如何帮助实现架构。</p><p>软件架构的定义有如下隐含意思：<br>1, Architecture Is a Set of Software Structures<br>Three frequently occurring types of structure:<br>– <strong>Modular structure</strong>: static structure that focus on how functionality is divided up, structured, and assigned to development and implementation teams.<br>– <strong>Component and Connector structure</strong>: runtime structures that focus on how components interact (e.g. information passing, synchronisation, interference,…)<br>– <strong>Allocation structures</strong>: mapping to organizational, development, installation, execution environments.  (e.g. Components are deployed onto hardware to execute)</p><p>2, Architecture Is an abstraction<br>Architecture specifcally omits certain information about elements that is not useful for reasoning about the system - in particular, it omits information that has no ramifcations outside of a single element.</p><p>3, Every Software System Has a Software architecture</p><p>4, Architecture Includes behavior<br>Behavior embodies how elements interact with each other.</p><p>在本课程, 一个软件项目成功与否, 基于如下三点考量:<br>– The software is delivered on <strong>schedule</strong><br>– Development costs were within <strong>budget</strong><br>– The software meets the <strong>needs</strong> of users</p><h2 id="Contexts-for-Software-Architecture"><a href="#Contexts-for-Software-Architecture" class="headerlink" title="Contexts for Software Architecture"></a>Contexts for Software Architecture</h2><ul><li>Technical: where architecture supports technical activity like measurement, V&amp;V, compliance,…<ul><li>Controlling <strong>Quality Attributes</strong><ul><li><strong>Availability</strong> - ensuring there is a system to take over if a system fails.</li><li><strong>Safety</strong> - ensuring that the system only behaves as intended and has no additonal behaviour.</li><li><strong>Testability</strong> - ensuring:<ul><li>elements are clearly able to be isolated</li><li>we know what behaviour to expect of components of the system</li><li>we know how components relate to modules so we can track down faulty code</li><li>We know how components are intended to integrate to give the overall behaviour</li></ul></li><li>Other qa: <strong>performance</strong>, usability, interoperability,..</li></ul></li><li><strong>Design</strong> - Patterns, Styles, Domain Specific Architecture (DSSA)<ul><li>A DSSA is collection of (pre-decided) design decisions that:<ul><li>Capture important aspects of particular tasks (domain),</li><li>Common across a range of systems in the domain</li><li>Typically they will have some predefined structures</li><li>These are not general purpose because they incorporate many specific characteristics of the domain.</li></ul></li><li>Architectural pattern is a set of architectural design decisions that are applicable to a recurring design problem, and parameterized to account for different software development contexts in which that problem appears.<ul><li>Similar to DSSAs but capture less of the behaviour and attributes of the system</li><li>More general because they are intended to abstract a common pattern over several domains.</li><li>Three-Tiered Pattern: State(database)-Logic(Business)-Display(UI)</li><li>Model-View-Controller (MVC): to separate between information, presentation and user interaction.</li><li>Sense-Compute-Control: Structuring embedded control applications</li></ul></li></ul></li></ul></li><li><strong>Project lifecycle</strong>: where architecture interacts with and supports development process<ul><li>Lifecycle Models: <strong>V-model</strong>, iterative models (Boehm’s spiral model), <strong>Agile</strong></li></ul></li><li>Business: where architecture supports organisations, e.g. customer organisations and development organisations.</li><li>Professional: where the role of architect defines requirements and constraints on architects.</li></ul><h2 id="Quality-Attributes-QA"><a href="#Quality-Attributes-QA" class="headerlink" title="Quality Attributes (QA)"></a>Quality Attributes (QA)</h2><p>Architecture is the right level of abstraction to resolve conflicts between Stakeholders.<img src="/images/Architecture_Influence_Cycle.png" alt="" title="Architecture Influence Cycle. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p>Quality Attributes specify, usually quantitative, requirements on particular bits of functionality or on the whole systems (e.g. that the system should be available 99% of the time).</p><p>Problems With QA<br>1, Often QA requirements are not “testable”, for example modifiable, usable, dependable or resilient.<br>2, It can be difficult to map from a concern about the system to a QA. For example, a high failure rate in some transaction could be a performance issue or it could be an availability issue.<br>3, Communities around a particular quality attribute have developed their own terminology (e.g. security has attacks, performance has events, etc).</p><p>The solution for 1 and 2 is to use <strong>quality attribute scenarios</strong> to provide sufficient specificity to avoid some of these issues.</p><h3 id="Quality-Attributes-Scenarios-场景"><a href="#Quality-Attributes-Scenarios-场景" class="headerlink" title="Quality Attributes Scenarios 场景"></a>Quality Attributes Scenarios 场景</h3><p>A quality attribute requirement should be unambiguous and testable. To specify quality attribute requirements, we capture them formally as six-part scenarios:</p><ol><li><strong>Source of stimulus</strong>. This is some entity (a human, a computer system, or a system administrator) that generated the stimulus.</li><li><strong>Stimulus</strong>. A condition (event) that requires a response when it arrives at a system. e.g. a user operation to the usability community, or an attack to the security community.</li><li>Environment. The stimulus occurs under certain conditions. The system may be in an overload condition or in normal operation. For many systems, “normal” operation can refer to one of a number of modes. For these kinds of systems, the environment should specify in which mode the system is executing.</li><li>Artifact. A collection of systems, the whole system, or part of the system that is stimulated e.g. the configuration checker in the system.</li><li><strong>Response</strong>. The response is the activity undertaken as the result of the arrival of the stimulus. e.g. the configuration issue is identified and then repaired.</li><li><strong>Response measure</strong>. how to measure the response so the scenario is testable. e.g. time to detect the wrong configuration and the time to repair.</li></ol><p><img src="/images/quality_attribute_scenario.png" alt="" title="The parts of a quality attribute scenario. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p>Each QA has a <strong>General Scenario</strong> associated with it that tries to capture the possible components involved in that particular QA. This acts as a template or guide for the architect specifying a specific QA Scenario.</p><p><strong>Specific QA Scenarios</strong> take account of specific stimuli and measures on response, they capture the specification of the QA for a particular system.</p><h3 id="Achieving-QA-through-tactics"><a href="#Achieving-QA-through-tactics" class="headerlink" title="Achieving QA through tactics"></a>Achieving QA through tactics</h3><p>Architectural tactics are design decisions to achieve the required quality attributes, more specifcally, to control responses to stimuli.</p><p>The focus of a tactic is on a single quality attribute response. Within a tactic, there is no consideration of tradeoffs (differ from architectural patterns, where tradeoffs are built into the pattern).</p><p>By cataloging tactics, we provide a way of making design more systematic within some limitations.</p><p>An architecture can be viewed as the result of applying a collection of design decisions. A systematic categorization of these decisions:</p><ol><li>Allocation of responsibilities 责任分配: Identifying the important responsibilities, and determining how these responsibilities are allocated to static and runtime elements (namely, modules, components, and connectors).</li><li>Coordination model 模型协调 - Components in the architecture interact with one another via a collection of mechanisms.<ul><li>What elements in the system need to coordinate with one another.</li><li>What properties the coordination needs to have (e.g. timing properties, security of coordination, …)</li><li>Choosing the mechanisms (ideally a small number) that realize properties like statefulness, synchrony, delivery guarantees, performance.</li></ul></li><li>Data model: Every system must represent artifacts of system-wide interest—data—in some internal fashion<ul><li>Choosing abstractions, operations, and properties. How data is created and destroyed, access methods, …</li><li>Maintaining metadata that controls the interpretation of the data.</li><li>Organising the data, what kind of system will be used to store it, how will it be backed up, how do we recover from data loss</li></ul></li><li>Management of resources: hard (CPU, memory, battery, I/O ports…) or soft resources(system locks, software buffers, thread pools…):<ul><li>Identifying resources to be managed</li><li>What system element should manage a resource</li><li>资源共享策略和争端仲裁 Work out sharing strategies and how to arbitrate in contention situations</li><li>Consider the consequences of resource starvation(e.g. Memory).</li></ul></li><li>Mapping among architectural elements<ul><li>two important types of mapping:<ul><li>Mapping between different types of elements in the architecture, e.g. from static development structures (modules) to execution elements e.g. threads or processes.</li><li>Mappings between software elements and environment elements, e.g. from processes to specific processors and other hardware.</li></ul></li><li>Useful mappings include: code to runtime structure; runtime elements to environment; data model elements to data stores.</li></ul></li><li>Binding time decisions: introduce allowable ranges of variation.<ul><li>This variation can range from design time by a designer to runtime by an end user might allocate a responsibility.</li><li>The decisions in the other six categories have an associated binding time decision: we might want some variability in the resources to be managed determined at run time or we might make the coordination model negotiable at runtime if we want to inter-operate with a range of systems.</li></ul></li><li>Choice of technology: critical to being able to realize all the other decisions in a concrete system.<ul><li>What technologies are available</li><li>What tools are available to support technologies</li><li>How much training will it take to be able to use a technology?</li><li>What are the full range of consequences of the choice of a technology (e.g. it may restrict markets because it is incompatible with some other technologies).</li><li>If the technology is new, how does it fit into the existing preferred technologies for the organisation.</li></ul></li></ol><h2 id="Availability"><a href="#Availability" class="headerlink" title="Availability"></a>Availability</h2><blockquote><p>Availability refers to a property of software that it is there and ready to carry out its task when you need it to be. The availability of a system is usually defined to be the probability it will be there when you ask it to work: $\frac{mtbf}{mtbf+mttr}$</p></blockquote><p>$mtbf$ – mean time between failures: MTBF of a component is the sum of the lengths of the operational periods divided by the number of observed failures: $mtbf = \frac{t}{N(t)}$, $t$ is the cumulative operating time, $N(t)$ is the observed number of failures by time $t$. 假设恒定的故障率 $\lambda$，则 $mtbf = \frac{1}{\lambda}$</p><p>$mttr$ – mean time to repair</p><p>Availability measures the quality of service in terms of running versus down time</p><p><strong>Reliability</strong> indicates the fraction of all attempted operations that complete successfully. The reliability of the system is: $R(t) = e^{-\lambda t}$ where the parameter $\lambda$ is called the failure rate.<br>由于MTBF主要针对可以修复的系统，因此建议针对不可修复的系统（在故障后选择更换而不是修复系统的情况）使用平均故障时间（MTTF），在数学上二者是等价的。<br>MTTF: Mean Time To (first) Failure, or Expected Life.<br>$ MTTF = E(t_f) = \int_0^\infty R(t)dt = \frac{1}{\lambda}$</p><p><strong>Faults, Errors, Failures</strong>: A <strong>fault</strong> is something in the system (e.g. failed component, wrong bit of code,…) that can cause the system to move into an <strong>error</strong> state when the fault is activated, an error may then eventually cause an externally observable deviation from the intended operation - <strong>failure</strong>.</p><p>Generic Scenario<br><img src="/images/general_scenario_for_availability.png" alt="" title="A general scenario for availability. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p><img src="/images/Availability_tactics.png" alt="" title="Availability tactics. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><h3 id="Design-Checklist-for-Availability"><a href="#Design-Checklist-for-Availability" class="headerlink" title="Design Checklist for Availability"></a>Design Checklist for Availability</h3><p><strong>Allocation of Responsibilities</strong><br>■ Determine the system responsibilities that need to be highly available.<br>■ Within those responsibilities, ensure that additional responsibilities have been allocated to detect an omission, crash, incorrect timing, or incorrect response.<br>■ Additionally, ensure that there are responsibilities to do the following:<br>• Log the fault<br>• Notify appropriate entities (people or systems)<br>• Disable the source of events causing the fault<br>• Be temporarily unavailable<br>• Fix or mask the fault/failure<br>• Operate in a degraded mode</p><p><strong>Coordination Model</strong><br>Determine the system responsibilities that need to be highly available. With respect to those responsibilities, do the following:<br>■ Ensure that coordination mechanisms can detect an omission, crash, incorrect timing, or incorrect response. For example, whether guaranteed delivery is necessary. Will the coordination work under conditions of degraded communication?<br>■ Ensure that coordination mechanisms enable the logging of the fault, notification of appropriate entities, disabling of the source of the events causing the fault, fxing or masking the fault, or operating in a <strong>degraded mode</strong>.<br>■ Ensure that the coordination model supports the replacement of the artifacts used (processors, communications channels, persistent storage, and processes). For example, does replacement of a server allow the system to continue to operate?<br>■ Determine if the coordination will work under conditions of degraded communication, at startup/shutdown, in repair mode, or under overloaded operation. For example, how much lost information can the coordination model withstand and with what consequences?</p><p><strong>Data Model</strong><br>■ Determine which portions of the system need to be highly available.<br>■ Within those portions, determine which data abstractions, along with their operations or their properties, could cause a fault of omission, a crash, incorrect timing behavior, or an incorrect response.<br>■ For those data abstractions, operations, and properties, ensure that they can be disabled, be temporarily unavailable, or be fxed or masked in the event of a fault.<br>■ For example, ensure that write requests are cached if a server is temporarily unavailable and performed when the server is returned to service.</p><p><strong>Mapping among Architectural Elements</strong><br>■ Determine which artifacts (processors, communication channels, persistent storage, or processes) may produce a fault.<br>■ Ensure that the mapping (or remapping) of architectural elements is ﬂexible enough to permit the recovery from the fault. This may involve a consideration of the following:<br>• Which processes on failed processors need to be reassigned at runtime<br>• Which processors, data stores, or communication channels can be activated or reassigned at runtime<br>• How data on failed processors or storage can be served by replacement units<br>• How quickly the system can be reinstalled based on the units of delivery provided<br>• How to (re)assign runtime elements to processors, communication channels, and data stores<br>• When employing tactics that depend on redundancy of functionality, the mapping from modules to redundant components is important. For example, it is possible to write one module that contains code appropriate for both the active  component and backup components in a protection group.</p><p><strong>Resource Management</strong><br>■ Determine what critical resources are necessary to continue operating in the presence of a fault.<br>■ Ensure there are suffcient remaining resources in the event of a fault to log the fault; notify appropriate entities (people or systems); disable the source of events causing the fault; be temporarily unavailable; fx or mask the fault/failure; operate normally, in startup, shutdown, repair mode, degraded operation, and overloaded operation.<br>■ Determine the <strong>availability time</strong> for critical resources, what critical resources must be available during specifed time intervals, time intervals during which the critical resources may be in a degraded mode, and repair time for critical resources. Ensure that the critical resources are available during these time intervals.<br>■ For example, ensure that input queues are large enough to buffer anticipated messages if a server fails so that the messages are not permanently lost.</p><p><strong>Binding Time</strong><br>■ Determine how and when architectural elements are bound.<br>■ If late binding is used to alternate between components that can themselves be sources of faults (e.g., processes, processors, communication channels), ensure the chosen availability strategy is suffcient to cover faults introduced by all sources.<br>■ For example:<br>• If late binding is used to switch between artifacts such as processors that will receive or be the subject of faults, will the chosen fault detection and recovery mechanisms work for all possible bindings?<br>• If late binding is used to change the defnition or tolerance of what constitutes a fault (e.g., how long a process can go without responding before a fault is assumed), is the recovery strategy chosen suffcient to handle all cases? For example, if a fault is ﬂagged after 0.1 milliseconds, but the recovery mechanism takes 1.5 seconds to work, that might be an unacceptable mismatch.<br>• What are the availability characteristics of the late binding mechanism itself? Can it fail?</p><p><strong>Choice of Technology</strong><br>■ Determine the available technologies that can (help) detect faults, recover from faults, or reintroduce failed components.<br>■ Determine what technologies are available that help the response to a fault (e.g., event loggers).<br>■ Determine the availability characteristics of chosen technologies themselves: What faults can they recover from? What faults might they introduce into the system?</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p><img src="/images/Performance_General_Scenario.png" alt="" title="Performance General Scenario. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"><br>To ensure resource is effectively monitored and managed.</p><p><img src="/images/Performance_tactics.png" alt="" title="Performance tactics. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><h3 id="Design-Checklist-for-Performance"><a href="#Design-Checklist-for-Performance" class="headerlink" title="Design Checklist for Performance"></a>Design Checklist for Performance</h3><p><strong>Allocation of Responsibilities</strong><br>■ Work out areas responsibility of that require heavy resource use to ensure time-critical events take place.<br>■ Work out processing requirements.<br>■ Take account of:<br>• Responsibilites arising from threads crossing boundaries of responsibility<br>• Responsibilities for thread management<br>• Responsibilities for scheduling shared resources</p><p><strong>Coordination Model</strong><br>■ What needs to coordinate.<br>■ Is there concurrency?  Ensure it is safe.<br>■ Ensure coordination is appropriate for the style of stimulus.<br>■ Ensure the properties of the coordination model are good for the stimuli and  concurrency control?</p><p><strong>Data Model</strong><br>■ Determine what parts of the data model will be heavily loaded or behaves tight time constraints.<br>■ For those data abstractions, determine:<br>• Would keeping multiple copies help?<br>• Would partitioning the data help?<br>• Is it possible to reduce processing requirements for the data?<br>• Does adding resource help deal with data bottlenecks?</p><p><strong>Mapping Among Architecture Elements</strong><br>■ Does colocation of some components reduce latencies?<br>■ Ensure components with high processing needs are allocated to big processors<br>■ Consider introducing concurrency when you map.<br>■ Consider whether some mappings introduce bottlenecks (e.g. allocating non-interfering tasks to the same thread)</p><p><strong>Resource Management</strong><br>■ Work out what needs high levels of resource<br>■ Ensure these are monitoredand managed under all operating modes.<br>■ For example:<br>• Time critical components<br>• Thread management<br>• Prioritization<br>• Locking and scheduling strategies<br>• Deploying additional resource to meet elevated load.</p><p><strong>Binding time</strong><br>■ Look at when you bind.<br>■ Consider the cost of binding at different times<br>■ Try to avoid performance penalties caused by late binding.</p><p><strong>Choice of Technology</strong><br>■ Is the technology right to let you meet hard deadlines and resource use (e.g. use a real-time OS with proper scheduling).<br>■ Do you know its characteristics under load and its limits?<br>■ Does your choice of technology give you the ability to set the following:<br>• Good scheduling<br>• Priorities<br>• Policies for demand reduction<br>• Allocating processing to tasks<br>• Other performance-related parameters.<br>■ Does your choice of technology introduce excessive overhead for heavily used operations?</p><h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p>最简单的表征安全的三个特征 - confdentiality, integrity, and availability (CIA):</p><ol><li>机密性 Confidentiality: Only those who should have access are given access.</li><li>完整性 Integrity: Data or services are not subject to unauthorised manipulation.</li><li>可用性 Availability: the system is available for legitimate use.</li></ol><p>其他用于支撑 CIA 的特征:</p><ol start="4"><li>认证识别 Authentication verifes the identities of the parties to a transaction and checks if they are truly who they claim to be.</li><li>不可否认性 Nonrepudiation guarantees that the sender of a message cannot later deny having sent the message, and that the recipient cannot deny having received the message.</li><li>授权 Authorization grants a user the privileges to perform a task.</li></ol><p>Security General Scenario<br><img src="/images/Security_General_Scenario.png" alt="" title="Security General Scenario. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p><img src="/images/Security_tactics.png" alt="" title="Security tactics. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><h3 id="A-Design-Checklist-for-Security"><a href="#A-Design-Checklist-for-Security" class="headerlink" title="A Design Checklist for Security"></a>A Design Checklist for Security</h3><p><strong>Allocation of Responsibilities</strong><br>■ Ensure all actors have identities<br>■ Authenticate identities<br>■ Check authorizations<br>■ Ensure authorization is required for all such actors<br>■ Log attempts, successes and failures on all sensitive operations<br>■ Ensure data is encrypted<br>■ Ensure responsibilities are allocated to appropriate actors.</p><p><strong>Coordination Model</strong><br>■ Ensure coordination mechanisms use authentication and authorisation.<br>■ Ensure coordination mechanisms are not vulnerable to impersonation, tampering, interception, …<br>■ Ensure data involved in coordination is protected using encryption.<br>■ Monitor level of demand for communication to identify excessive demands</p><p><strong>Data Model</strong><br>■ Ensure there is a valid data model that disallows invalid data flows.<br>■ Ensure logging of access, modification and attempted access or modification.<br>■ Data is protected in flight and at rest using appropriate encryption.<br>■ Ensure appropriate backup/recovery mechanisms are in place.</p><p><strong>Mapping among Architectural Elements</strong><br>■ Explore how different mappings change the way users can access resources.<br>■ Ensure for all of these mappings the models of access and authorisation are preserved.<br>• Actors should be identified and authenticated<br>• Use appropriate authorisation mechanisms<br>• Ensure logging is enabled<br>• Ensure data is protected by encryption<br>• Recognise impact of attack on resources<br>■ Ensure recovery from attack is possible</p><p><strong>Resource Management</strong><br>■ Explore the overheads resulting from monitoring, detecting, preventing and recovering from attacks.<br>■ Analyse how a user can access and make demands on critical resources.<br>■ Manage resource access to ensure malicious use of resource is detected and managed.<br>■ Identify the potential for corruption/contamination and how to manage this.<br>■ Explore the potential for resource use to be used as a covert channel to transmit data.<br>■ Limit resources used to manage attempts at unauthorised use</p><p><strong>Binding Time</strong><br>■ Explore the consequences of varying binding times on the ability to trust an actor or component.<br>■ Put in place appropriate mechanisms to ensure trust given binding time.<br>■ Explore potential impact on resource use, capacity/throughput, response time<br>■ Ensure appropriate encryption of all data around binding.<br>■ Explore the potential of variation in binding time as a covert channel.</p><p><strong>Choice of Technologies</strong><br>■ Ensure limitations of technologies are understood and the potential for future compromise is well identified.<br>■ Ensure your chosen technologies support the tactics you want to deploy to protect the system.</p><h2 id="Connectors"><a href="#Connectors" class="headerlink" title="Connectors"></a>Connectors</h2><p>Key part of Architectures<br>■ Connect components and define the rules of interaction between components<br>• Simple: shared variable access; method calls; …<br>• Complex: database access; client-server; scheduler; load balancer<br>■ Connectors provide: Interaction ducts;</p><p>In coding often connectors are implicit, but in software architecture:<br>■ They are identified and have an identity<br>■ Capture system interaction (at the level of components)<br>■ They have a specification that can be complex</p><p>Relationship between Connectors and components:<br>■ Components have application-specific functionality.<br>■ Connectors provide interaction mechanisms that are generic across different applications.<br>■ Interaction may involve multiple components<br>■ Interaction may have a protocol associated to it. The specification of the connector protocols determine: the types of interface that it works with; properties of interaction; rules about ordering of interaction; measurable features of interaction.</p><p>Benefits of Explicit Connectors<br>■ Interaction is defined by the arrangement of the connectors (as far as possible)<br>■ Component interaction is defined by the pattern of connectors in the architecture<br>■ Interaction is “independent” of the components</p><p>The main roles(services) of Connectors are:</p><ul><li>Communication<ul><li>Information is transmitted between components (e.g. message passing; method call; remote procedure call,…).</li><li>Connectors constrain things: Direction of flow (e.g. pipes), Capacity, rates of flow, etc.</li><li>May have other effects e.g. coordination (e.g. blocking I/O)</li><li>Influences measurable Quality Attributes of the system</li><li>Separates communication from functional aspects (components do the functional part).</li></ul></li><li>Coordination: Controls the timing relationship of functional aspects of the system, e.g. coordinating the arrival of data at a collection of components</li><li>Conversion<ul><li>How to get components to interact that don’t have the right means of interaction. 如何让兼容性差的组件进行交互？</li><li>Incompatibilities might be related to: datatypes, ordering, frequency, structure of parameters etc.</li><li>Examples of types of converters: Wrappers (deal with structural issues), Adaptors (deal with datatype incompatibilities)</li></ul></li><li>Facilitation<ul><li>Enable interaction among a group of components that are intended to interact.</li><li>Help manage the interaction</li><li>Examples: load balancer; replication management; redundancy management; scheduler</li><li>Can also relate to coordination, e.g. synchronization (critical sections; monitors)</li></ul></li></ul><h3 id="Select-Connectors"><a href="#Select-Connectors" class="headerlink" title="Select Connectors"></a>Select Connectors</h3><p>Types of Connector: • Method/Procedure call • Data access • Events • Stream • Distributor • Arbitrator • Adaptor</p><p>Selection</p><ul><li>Determine a system’s interconnection and interaction needs</li><li>Determine roles to be fulfilled by the system’s connectors: Communication, coordination, conversion, facilitation</li><li>For each connector<ul><li>Determine its appropriate type(s)</li><li>Determine its dimensions of interest</li><li>Select appropriate values for each dimension</li></ul></li><li>For multi-type, i.e., composite connectors, determine the atomic connector compatibilities</li></ul><h2 id="Architectural-Patterns"><a href="#Architectural-Patterns" class="headerlink" title="Architectural Patterns"></a>Architectural Patterns</h2><blockquote><p>An architectural patterns is a package of design decisions that is <strong>found repeatedly in practice</strong>, has known properties that permit reuse, and describes a class of architectures.</p></blockquote><p>An architectural pattern comprises:</p><ul><li>A <strong>context</strong> that provides the frame for a problem.</li><li>A <strong>problem</strong> that is a generalised description of a class of problems often with QA requirements that should be met.</li><li>A <strong>solution</strong> that is suitably generalised in the same way as the problem. A solution:<ul><li>Describes the architectural structures that solve the problem, including how to balance the many forces at work.</li><li>The solution might be static, runtime or deployment oriented.</li><li>The solution for a pattern is determined and described by:<ul><li>A set of element types (for example, data repositories, processes, and objects)</li><li>A set of interaction mechanisms or connectors (for example, method calls, events, or message bus)</li><li>A topological layout of the components</li><li>A set of semantic constraints covering topology, element behavior, and interaction mechanisms</li></ul></li></ul></li></ul><h3 id="Module-Patterns"><a href="#Module-Patterns" class="headerlink" title="Module Patterns"></a>Module Patterns</h3><p>Static Pattern: <strong>Layered Pattern</strong></p><p>Overview: The layered pattern defines layers (groupings of modules that offer a cohesive set of services) and a <strong>unidirectional</strong> allowed-to-use relation among the layers. The pattern is usually shown graphically by stacking boxes representing layers on top of each other. Suitable for controlling <strong>static</strong> aspects of architecture.</p><p>Elements: Layer, a kind of module. The description of a layer should define what modules the layer contains and a characterization of the cohesive set of services that the layer provides.</p><p>Relations: <strong>Allowed to use</strong>, which is a specialization of a more generic depends-on relation. The design should define what the layer usage rules are (e.g., “a layer is allowed to use any lower layer” or “a layer is allowed to use only the layer immediately below it”) and any allowable exceptions.<br><img src="/images/layer_pattern_relations.png" alt="" title="A simple layer diagram, with a simple key answering the uses, Clear Access Rules. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p>Constraints:<br>■ Every piece of software is allocated to exactly one layer.<br>■ There are at least two layers (but usually there are three or more).<br>■ The allowed-to-use relations should not be circular (i.e., a lower layer cannot use a layer above).</p><p>Weaknesses:<br>■ The addition of layers adds up-front cost and complexity to a system.<br>■ Layers contribute a performance penalty.</p><h3 id="Component-and-Connector-Patterns"><a href="#Component-and-Connector-Patterns" class="headerlink" title="Component-and-Connector Patterns"></a>Component-and-Connector Patterns</h3><p><strong>Model-View-Controller Pattern</strong></p><p>Context: User interface software is typically the most frequently modifed portion of an interactive application. For this reason it is important to keep modifcations to the user interface software separate from the rest of the system.</p><p>Problem:<br>• Isolating the UI functionality from the Application functionality.<br>• Maintaining multiple views in the presence of change in the underlying data.</p><p>Solution:<br><img src="/images/Model_View_Controller_Pattern_Solution.png" alt="" title="Model-View-Controller Pattern Solution. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p><img src="/images/model_view_controller_pattern.png" alt="" title="The relationships between the components of Model-View-Controller Pattern. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p>Other Component-Connector Patterns<br>• Pipe and Filter Pattern<br>• Broker Pattern<br>• Client-Server Pattern<br>• Peer-to-Peer Pattern<br>• Service-Oriented Architecture Pattern<br>• Publish-Subscribe Pattern<br>• Shared Data Pattern</p><h3 id="Deployment-Allocation-Patterns"><a href="#Deployment-Allocation-Patterns" class="headerlink" title="Deployment/Allocation Patterns"></a>Deployment/Allocation Patterns</h3><p>Context:<br>– we are concerned with resource use<br>– We might consider flexible deployment of resource<br>– The QAs we care about are sensitive to the pattern of deployment and the use of resources.</p><h4 id="Allocation-Map-Reduce-Pattern"><a href="#Allocation-Map-Reduce-Pattern" class="headerlink" title="Allocation: Map-Reduce Pattern"></a>Allocation: Map-Reduce Pattern</h4><p>Context:<br>– We have large quantities of data we wish to treat as “population” data.<br>– This encourages an approach that involves significant amounts of independent processing.</p><p>Problem: Where for ultra-large data sets doing some individual processing to a portion of the data set and then sorting and analyzing grouped data, map-reduce provides a simple way of doing this processing.</p><p>Solution:<br><img src="/images/Map_Reduce_Pattern_Solution.png" alt="" title="Map-Reduce Pattern Solution. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p>Other Allocation Patterns<br>• Multi-tier architecture pattern<br>• Cloud architectures</p><h3 id="Relationships-between-Tactics-and-Patterns"><a href="#Relationships-between-Tactics-and-Patterns" class="headerlink" title="Relationships between Tactics and Patterns"></a>Relationships between Tactics and Patterns</h3><p>Architectural patterns and tactics are ways of capturing proven good design structures and making them reusable.</p><p>Tactics are simpler and more atomic than patterns<br>• Tactics capture one step to take for a particular Quality Attribute to change behaviour with respect to that QA.<br>• use just a single structure or computational mechanism, and they are meant to address a single architectural force.<br>• Tactics can be seen as the building blocks of patterns; Most patterns consist of (are constructed from) several different tactics.<br><img src="/images/Architecture_Patterns_and_Corresponding_Tactics.png" alt="" title="Architecture Patterns and Corresponding Tactics ([Bachmann 07]). image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><h2 id="Testability"><a href="#Testability" class="headerlink" title="Testability"></a>Testability</h2><p>Testability illustrate QAs from a <strong>static</strong> perspective.</p><p>A system or element of a system is testable if it is possible to test it in the way required by a particular development or maintenance process.</p><p>Testability Concerns<br>• Unlike the other QA (availability, performance and security), testability is concerned with the code structure rather than the connector/component view or deployment view.<br>• The system elements we consider are code modules and the relationships are dependencies involved in building the code for components.</p><p>Testability General Scenario<br><img src="/images/Testability_General_Scenario.png" alt="" title="Testability General Scenario. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p>举例 Coverage Concrete Scenario<br>• Source: Regression Tester<br>• Stimulus: Completion of maintenance development to repair a critical bug<br>• Artifact: Modules for the full system<br>• Environment: Maintenance Development<br>• Response: Results from path coverage tool<br>• Response Measure: Path coverage is better than 95% of non-looping paths inside modules</p><p>Testability <strong>Tactics</strong></p><ul><li>adding controllability and observability to the system.<ul><li>Specialized Interfaces</li><li>Record/Playback</li><li>Localize State Storage</li><li>Abstract Data Sources</li><li>Sandbox</li><li>Executable Assertions</li></ul></li><li>limiting complexity in the system’s designs: If it could be broken into smaller modules with lower complexity that could allow the regression test to achieve higher path coverage.<ul><li>Limit Structural Complexity</li><li>Limit behavioral complexity - Nondeterminism</li></ul></li></ul><h3 id="A-Design-Checklist-for-Testability"><a href="#A-Design-Checklist-for-Testability" class="headerlink" title="A Design Checklist for Testability"></a>A Design Checklist for Testability</h3><p><strong>Allocation of Responsibilities</strong><br>■ Determine which system responsibilities are most critical and hence need to be most thoroughly tested.<br>■ Ensure that additional system responsibilities have been allocated to do the following:<br> Execute test suite and capture results (external test or self-test)<br>• Capture (log) the activity that resulted in a fault or that resulted in unexpected (perhaps emergent) behavior that was not necessarily a fault<br>• Control and observe relevant system state for testing Make sure the allocation of functionality provides high cohesion, low coupling, strong separation of concerns, and low structural complexity.</p><p><strong>Coordination Model</strong><br>Ensure the system’s coordination and communication mechanisms<br>■ Support the execution of a test suite and capture the results within a system or between systems<br>■ Support capturing activity that resulted in a fault within a system or between systems<br>■ Support injection and monitoring of state into the communication channels for use in testing, within a system or between systems<br>■ Do not introduce needless nondeterminism</p><p><strong>Data Model</strong><br>Determine the major data abstractions that must be tested to ensure the correct operation of the system.<br>■ Ensure that it is possible to capture the values of instances of these data abstractions<br>■ Ensure that the values of instances of these data abstractions can be set when state is injected into the system, so that system state leading to a fault may be re-created<br>■ Ensure that the creation, initialization, persistence, manipulation, translation, and destruction of instances of these data abstractions can be exercised and captured</p><p><strong>Mapping among Architectural Elements</strong><br>■ Determine how to test the possible mappings of architectural elements (especially mappings of processes to processors, threads to processes, and modules to components) so that the desired test response is achieved and potential race conditions identifed.<br>■ In addition, determine whether it is possible to test for illegal mappings of architectural elements.</p><p><strong>Resource Management</strong><br>■ Ensure there are suffcient resources available to execute a test suite and capture the results.<br>■ Ensure that your test environment is representative of (or better yet, identical to) the environment in which the system will run.<br>■ Ensure that the system provides the means to do the following:<br>• Test resource limits<br>• Capture detailed resource usage for analysis in the event of a failure<br>• Inject new resource limits into the system for the purposes of testing<br>• Provide virtualized resources for testing</p><p><strong>Binding Time</strong><br>■ Ensure that components that are bound later than compile time can be tested in the late-bound context.<br>■ Ensure that late bindings can be captured in the event of a failure, so that you can re-create the system’s state leading to the failure.<br>■ Ensure that the full range of binding possibilities can be tested</p><p><strong>Choice of Technology</strong><br>■ Determine what technologies are available to help achieve the testability scenarios that apply to your architecture. Are technologies available to help with regression testing, fault injection, recording and playback, and so on?<br>■ Determine how testable the technologies are that you have chosen (or are considering choosing in the future) and ensure that your chosen technologies support the level of testing appropriate for your system. For example, if your chosen technologies do not make it possible to inject state, it may be diffcult to re-create fault scenarios.</p><h2 id="Modifiability"><a href="#Modifiability" class="headerlink" title="Modifiability"></a>Modifiability</h2><p>Modifiability illustrate QAs from a <strong>static</strong> perspective. Measure how easy it might be to modify. This is a key area because change incurs cost.</p><p>Four key questions:<br>– What can change?<br>– How likely is something to change?<br>– When, where, how and by whom will changes be made?<br>– What is the cost of making the change?</p><p>General Scenario<br><img src="/images/Modifiability_General_Scenario.png" alt="" title="Modifiability General Scenario. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p>Tactics to control modifiability<br><img src="/images/Modifiability_tactics.png" alt="" title="Modifiability tactics. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><h3 id="GPES-Example"><a href="#GPES-Example" class="headerlink" title="GPES Example"></a>GPES Example</h3><p>Version 1: General purpose query facility in each GP system.<br>Version 2: Building a specific piece of business logic for each different query.<br>Think about:<br>– What changes can happen?<br>– How likely is a change?<br>– When, where, how and by whom?<br>– How mush will it cost?</p><p><strong>GPES-relevant Scenario</strong><br>• Source: One of the stakeholders e.g. Medicines and Healthcare Products Regulatory Agency<br>• Stimulus: Wants prescribing data on NSAIDs<br>• Artifacts: Code (but depending on the architecture this could be configuration data)<br>• Environment: Operation<br>• Response: Develop the code<br>• Response Measure: Data available 5 weeks after request</p><p><strong>GPES Version 1</strong><br>• Design and validate the query with the Medicines agency.<br>• Code the query.<br>• Test on some systems to ensure it does not have bad effects.<br>• Rollout to all systems.<br>• Make the query available to Medicines agency.</p><p><strong>GPES Version 2</strong><br>• Design and validate the query with Medicines agency.<br>• Negotiate with the GP system providers on the design of the business logic (different in all systems?)<br>• Are the providers the only vendor of such services? Should it go to a procurement?<br>• Validate the queries on each system<br>• Integrate the results<br>• Roll out to all systems<br>• Make the query available to the Medicines Agency</p><p>It seems likely that the GPES V2 architecture will not pass the modifiability scenario we describe. Are any of the modifiability tactics appropriate to change the architecture to enable it to pass the scenario?<br>■ Reduce Coupling is the category of tactics we need to consider.<br>■ Each of the following offer potential routes with slightly different emphases:<br>• Use an intermediary<br>• Restrict dependencies<br>• Refactor<br>• Abstract common services<br>■ Defer Binding: can we do this later in the process so it is more likely to be done by a computer than a human? Here this is unlikely.<br>■ More on Binding Time<br>• Compile time/Build Time: component replacement, compile time parameters,…<br>• Deployment time: configuration scripts that bind at deployment, …<br>• Initialization time: resource files<br>• Runtime: dynamic lookup, service lookup, name servers, plugins, publish-subscribe, shared repositories, (Maybe just in time compilation fits here too)</p><h3 id="Design-checklist-for-Modifiability"><a href="#Design-checklist-for-Modifiability" class="headerlink" title="Design checklist for Modifiability"></a>Design checklist for Modifiability</h3><p><strong>Allocation of responsibilities</strong><br>Work out how things are likely to change e.g. technical, legal, organisational, social, markets, customers..<br>■ Work out what responsibilities change.<br>■ Try to modularise so a change does not affect responsibilities that span many modules.</p><p><strong>Coordination model</strong><br>Look at how changes are likely to affect coordination and try to ensure that the most likely changes impact coordination across a small number of modules</p><p><strong>Data model</strong><br>Similar to coordination model – see how a change impacts on data models and try to esnure data model changes span as few modules as possible.</p><p><strong>Mapping among architectural elements</strong><br>■ Looking at potential changes to the system, assess whether some may best be responded to by changing the mapping to elements.<br>■ Explore issues such as dependencies between elements, data holdings in elements, assignment of elements to processes, threads or processors.</p><p><strong>Resource Management</strong><br>■ Determine how a change in responsibility or quality attribute will change resource.<br>■ Attempt to localise resourcing change resulting from a likely change to a small number of modules.<br>■ Look at ways of using policies or configuration to manage resource change more effectively</p><p><strong>Binding Time</strong><br>■ Control choice of binding times so there are not too many combinations to consider.<br>■ Consider attempting to defer binding to later, balance this against the cost of providing a later binding mechanism.</p><p><strong>Choice of Technology</strong><br>Choose technologies that make the most likely changes easier (e.g. choose a technology that allows runtime alteration of critical parameters rather than one where parameters are chosen at compile time) but balance this agains the cost of the different technologies.</p><h2 id="Architectural-Modelling"><a href="#Architectural-Modelling" class="headerlink" title="Architectural Modelling"></a>Architectural Modelling</h2><p>Software Architecture is intended to give us control over Quality Attributes. Ideally we’d like to be able to use Software Architecture to predict Quality Attributes. We should be able to build a predictive model of the Software Architecture and use the model to predict QAs. The current situation is patchy…</p><p>Some quality attributes, most notably performance and availability, have well-understood, time-tested <strong>analytic models</strong> that can be used to assist in an analysis. Analytic model means one that supports quantitative analysis.</p><p><strong>Types of Analysis</strong><br>• Thought experiment: just a sort of discussion using informed people.<br>• Back of the envelope: using very approximate techniques with unreliable assumptions.<br>• Checklist: collated experience.<br>• Analytic Model: based on sound abstractions – heavily dependent on estimates being correct<br>• Simulation: higher level of detail – less analytic, more concrete.<br>• Prototype: approximate system in an experimental setup.<br>• Experiment: fielded system, simulated load<br>• Instrumentation: measuring the variable of interest</p><p><img src="/images/Summary_of_the_Analytic_Model_Space.png" alt="" title="A Summary of the Analytic Model Space. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><h3 id="Analyzing-Performance"><a href="#Analyzing-Performance" class="headerlink" title="Analyzing Performance"></a>Analyzing Performance</h3><p>Models have parameters, which are values you can set to predict values about the entity being modeled. Model can be used to understand the <strong>latency characteristics</strong> of an architectural design.<br><img src="/images/queuing_model_of_performance.png" alt="" title="A queuing model of performance. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"><br>Data Needed for the <strong>Queuing Model</strong><br>■ We need the following information in order to model effectively:<br>• The distribution for the arrival of service requests<br>• The queuing discipline<br>• The scheduling algorithm<br>• The distribution of service times for service requests<br>• Network characteristics<br>■ The theory places restrictions on the distributions<br>• Arrivals are usually expected to be Poisson Distributions specified by arrival rate<br>• Service times are usually exponentially distributed on the service rate.<br>• Some queuing behaviors are excluded such as reneging or jockying</p><p><strong>Example: MVC</strong>, says nothing about its deployment. That is, there is no specifcation of how the model, the view, and the controller are assigned to processes and processors; that’s not part of the pattern’s concern. These and other design decisions have to be made to transform a pattern into an architecture. Until that happens, one cannot say anything with authority about how an MVC-based implementation will perform.<br><img src="/images/Queueing_Model_of_MVC.png" alt="" title="A queuing model of performance for MVC. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"><br><strong>Data for MVC</strong><br>• Rate of service requests: the View component will service them at some rate.<br>• Service requests to the Controller are generated by the View component.<br>• Service requests from the Controller to the View component<br>• Service requests from the Controller to the model<br>• Service requests from the Model to the View Component</p><p><strong>Modelling MVC</strong><br>We need estimates of:<br>■ Distribution of external service demands<br>■ Queuing Disciplines within the queues in front of each component.<br>■ Network latencies<br>■ Transfer characteristics:<br>• View – Controller<br>• Controller – View<br>• Controller – Model<br>• Model – View<br>■ Scaling to large numbers of components is an issue</p><h3 id="Analyzing-Availability"><a href="#Analyzing-Availability" class="headerlink" title="Analyzing Availability"></a>Analyzing Availability</h3><p>One key issue is how long it takes to detect that a failure has taken place. Example is a <strong>Broker system</strong>.<br><img src="/images/Redundancy_tactics_to_a_broker_pattern.png" alt="" title="Redundancy tactics, as applied to a broker pattern. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"><br><strong>Hot Spare 热备用 (Active Redundancy)</strong><br>• Active and redundant both receive identical request stream.<br>• Synchronous maintenance of broker state.<br>• Fast failover in the event of failure of the active system.</p><p><strong>Warm Spare (Passive Redundancy)</strong><br>• Warm broker is maintained at the most recent checkpoint state.<br>• In the event of failure the system rolls back to the most recent checkpoint.<br>• This is slower than the hot spare approach</p><p><strong>Cold Spare</strong><br>• No attempt to synchronise.<br>• In the event of failure the cold spare is started.<br>• The system state is recovered via interaction with other systems (so they have to be resilient to failure in the broker)</p><h3 id="Analysis-at-Different-Stages-of-the-Life-Cycle"><a href="#Analysis-at-Different-Stages-of-the-Life-Cycle" class="headerlink" title="Analysis at Different Stages of the Life Cycle"></a>Analysis at Different Stages of the Life Cycle</h3><p><img src="/images/Analysis_at_Different_Stages_of_the_Life_Cycle.png" alt="" title="Forms of Analysis, Their Life-Cycle Stage, Cost, and Confdence in Their Outputs. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><h2 id="Architecture-in-the-Life-Cycles"><a href="#Architecture-in-the-Life-Cycles" class="headerlink" title="Architecture in the Life Cycles"></a>Architecture in the Life Cycles</h2><p>前面部分关注软件架构的 technical context。这里开始关注 life cycles。<br>The role of software architecture is different for different lifecycles.</p><p><strong>Balancing Agility and Discipline</strong><br>• Lifecycles generally impose some discipline on the development process.<br>• Software Architectures often feature in Lifecycles as a stage or support for analysis or design<br>• Lifecycles exist because they codify useful patterns of activity and save us time and effort<br>• Agility focusses on getting adequate solutions to stakeholders <strong>with less time and effort</strong><br>• We need to balance the discipline of lifecycles against the delivery focus of agility</p><p><strong>Lifecycles</strong><br>• Lifecycles underpin development processes by ordering stages and activities.<br>• Any good organisation is always looking to improve its processes so there is usually an <strong>ongoing process improvement cycle</strong> focussed on making the process better.</p><p>V-Model approach works well when you understand the concept and requirements.<br><img src="/images/v_model_in_lifecycle.png" alt="" title="V-Model. image from: https://davenicolette.files.wordpress.com/2012/02"></p><p><strong>Agile Practice</strong><br>• Test-first programming<br>• Refactoring<br>• Continuous integration<br>• Simple Design<br>• Pair Programming<br>• Common Codebase<br>• Coding Standards<br>• Open Work Area</p><h3 id="Agile-vs-Plan-Driven"><a href="#Agile-vs-Plan-Driven" class="headerlink" title="Agile vs. Plan Driven"></a>Agile vs. Plan Driven</h3><blockquote><p>Early software development methods that emerged in the 1970s - such as the Waterfall method - is plan-driven and inﬂexible. But having a strong 先期 up-front plan provides for considerable predictability (as long as the requirements don’t change too much) and makes it easier to coordinate large numbers of teams.</p></blockquote><blockquote><p>Agile methods and practitioners, on the other hand, often 轻视 scorn planning, preferring teamwork, frequent face-to-face communication, ﬂexibility, and adaptation. This enhances invention and creativity.</p></blockquote><p><img src="/images/agile_vs_plan_application.png" alt="" title="image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/"><br><img src="/images/agile_vs_plan_management.png" alt="" title="image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/"><br><img src="/images/agile_vs_plan_tech.png" alt="" title="image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/"><br><img src="/images/agile_vs_plan_personnel.png" alt="" title="image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/"></p><p>• Work <strong>top-down</strong> and <strong>bottom-up</strong> simultaneously - balance will depend on the size and complexity of the project.<br>• <strong>Top-down</strong> does architectural work based on things like <strong>patterns, product-line</strong>.<br>• <strong>Bottom-up</strong> develops implementation and environment-specific constraints and solutions.<br>• Focus on QAs, scenarios, tactics and processes to 调和 reconcile competing aspects provides a bottomup/top-down link<br>• Balancing commitment and flexibility</p><h3 id="Analysis-Techniques"><a href="#Analysis-Techniques" class="headerlink" title="Analysis Techniques"></a>Analysis Techniques</h3><p><img src="/images/Analysis_Techniques.png" alt="" title="image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/"><br><img src="/images/Analysis_Techniques_and_Stage.png" alt="" title="image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/"></p><h2 id="Product-Line-Architecture"><a href="#Product-Line-Architecture" class="headerlink" title="Product Line Architecture"></a>Product Line Architecture</h2><p>One of the early success areas for Software Architecture was the development of Product Line Architectures. Product Line Architecture is an approach to adopt systematic <strong>reuse of architectural elements</strong> that involves changes in development process supported by specific practices that encourage reuse.</p><blockquote><p>A collection of software-intensive systems sharing a common, managed, set of features that satisfy the specific needs of a market segment or mission that are developed from a set of core assets in a prescribed way.</p></blockquote><p>Software Product Lines are directed by business goals in a particular application domain.<br>• The products in a product line share a software product line architecture<br>• Products are structured by the product line architecture and are built from services and components.<br>• Architercture and components are the core assets used to satisfy the business goals.<br>• Product line leverage commonality and limit variability of the product.</p><p><strong>Benefits to the organisation</strong><br>• Large-scale productivity gains<br>• Improve time to market<br>• Maintian market presence (rapidly evolving variants)<br>• Sustain growth<br>• Improved market agility<br>• Better use of skills<br>• Enable mass customisation<br>• Gain control of configuration<br>• Improve product quality<br>• Better predictability of cost, schedule and quality</p><p><strong>Costs of a product line</strong><br>• Architecture: flexible enough to support variation in the products<br>• Software components: general enough to support variability<br>• Test plans, cases, data: take account of variation in components<br>• Business cases: must operate at the level of a product family<br>• Project plans: generic and extensible to deal with variation<br>• Tools and processes: must support architecture, variation, configuration, ..<br>• People, skills, training: need to be skilled in architecture and product lines.<br><img src="/images/Product_Line_Economics.png" alt="" title="image from: Software Product-Line Engineering: A Family-Based Software Development Process. Weiss,D.M. &amp; Lay, C.T.R. 1999"><br>Product lines spread costs over several products:• Requirements and requirements analysis • Domain model • Architecture and design • Performance engineering • Documentation • Test cases, data, and plans • Skills • Processes, methods and tools • Defect fixing • Components and services</p><p><strong>Core Process Activities</strong><br>• Core asset development: improving the base components in terms of qualities, products they support, and architecture.<br>• Product development: identifying and building products to meet market need inside the product line.<br>• Management: monitoring and improving the processes, tools and practices.</p><p><strong>Introducing Product Lines</strong><br>• Proactive: <strong>Up-front</strong> investment to develop the core assets - need to know the market well (maybe have an already established set of products)<br>• Reactive: Start with one or two products and use them to generate core assets.<br>• Incremental: Develop core assets as the business need evolves.</p><h3 id="Example-Bosch-Gasoline-Systems"><a href="#Example-Bosch-Gasoline-Systems" class="headerlink" title="Example: Bosch Gasoline Systems"></a>Example: Bosch Gasoline Systems</h3><p>Goals<br>■ Competitiveness:<br>• Reduced hardware resource consumption<br>• Reduced time to market for new features<br>■ Development efficiency<br>• Reuse: Applications can be used across different generations of system; “core” software is highly configurable and is reused via reconfiguration; “Vehicle functions” can be used across gasoline and diesel engines<br>• Easy configuration of software products<br>• Increased planning accuracy<br>■ Quality<br>• Interface integrity<br>• Reuse of core assets<br>■ Customer needs<br>• Differentiation by individual software solutions<br>• Clear feature-cost mapping</p><p>Component Redesign<br>■ Focussed on: reuse; simplification of calibration; resource consumption; stabilisation of interfaces (within the architecture)<br>■ Redesign progressed by:<br>• Analysing existing software inventory: features, sources of variability; relation to product line; document interdependency.<br>• Concept development and design of components: simplification; configurability; architecture driven structure; document relations between features and components;<br>• Baselines for variants of software components: document baselines; implement; maintain up-to-date document and implementation.</p><p>Phased Introduction<br>■ Investigate and customise product line engineering.<br>■ Design and pilot adequate processes and methods.<br>■ Roll out and institutionalise in the standard development process.<br><img src="/images/product_line_Roll_out.png" alt="" title="image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/"></p><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><p>The line between development and operation becomes more blurred and the use of the live environment to test innovations becomes more common. DevOps is a set of practices that span development and operation.</p><p>Operations have the direct experience of use of the system<br>– monitoring that use is a way of empirically verifying quality<br>– operations have the data that is used to regulate operations and is essential information for development.</p><p>Development is responsible for building in the right monitoring to ensure operations can operate effectively.</p><blockquote><p>DevOps is a set of practices intended to reduce the time between committing a change to a system and the change being placed into normal operation while ensuring necessary quality.</p></blockquote><p><a href="http://open-services.net/" target="_blank" rel="noopener">Open Services for Lifecycle Collaboration (OSLC)</a>: OSLC is an open and scalable approach to lifecycle integration. It simplifies key integration scenarios across heterogeneous tools.</p><p>Traditionally we use test as the way of delivering quality change but we can “shepherd” committed change into use by controlling quantities of change, users experiencing change, results of monitoring than this may offer a better way. Delivery mechanism needs to be high quality: reliable, repeatable, available.</p><p>Critical points<br>• Making the decision to commit the code to be introduced into the system.<br>• Transitioning from being under consideration into part of the production deployment that will be used by all users.<br>• Issues is how to have enough confidence to make each of these transitions. Monitoring is critical.<br>• The question is how to ensure the transitions are as reliable as possible.</p><p>The extent of the lifecycle<br>• Involves all people involved in the delivery of the service/application<br>• Operations and development people are in continuous interaction.<br>• We need architecture to achieve this.<br>• Microservices architectural pattern is often used.</p><h3 id="Microservices"><a href="#Microservices" class="headerlink" title="Microservices"></a>Microservices</h3><blockquote><p>The term “Microservice Architecture” has sprung up over the last few years to describe a particular way of designing software applications as <strong>suites of independently deployable services</strong>.</p></blockquote><blockquote><p>The microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API.<br>— <a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">https://martinfowler.com/articles/microservices.html</a></p></blockquote><p><img src="https://martinfowler.com/articles/microservices/images/sketch.png" alt="" title="Monoliths and Microservices. Image from: https://martinfowler.com/articles/microservices/images/sketch.png"><br>Attributes of Microservice Architecture<br>• Separately deployed units<br>• Very small service components<br>• Single purpose function or an independent portion of functionality<br>• Distributed<br>• Loosely coupled<br>• Multiple versions are acceptable<br>• Asynchronous<br>• No Orchestration</p><h2 id="Architecture-Evaluation"><a href="#Architecture-Evaluation" class="headerlink" title="Architecture Evaluation"></a>Architecture Evaluation</h2><p>Evaluation by Designer<br>• The consequences of the decision making regulate how much effort to put into the process – more importance means more effort in evaluation.<br>• Try to use iterative approaches that get deeper in order to eliminate unpromising alternatives early.<br>• Don’t strive for perfection, good enough for the context is usually enough.</p><p>Peer Evaluation<br>• Fix on the QAs to consider as part of the review – may be determined by the process or the business case.<br>• The architect presents the architecture to the reviewers – questions are for information.<br>• The review is driven by the relevant scenarios – the architect talks the review team through a scenario demonstrating the architecture meets the requirements captured in the scenario.<br>• The outcome is a list of potential issues with actions: fix, mitigate, tolerate, …</p><p>External Evaluation<br>• Means to bring in additional expertise.<br>• May represent some stakeholder interests.<br>• More expensive and difficult to organise so this will often correspond to some major hurdle in the process.</p><h3 id="The-Architecture-Tradeoff-Analysis-Method-ATAM"><a href="#The-Architecture-Tradeoff-Analysis-Method-ATAM" class="headerlink" title="The Architecture Tradeoff Analysis Method (ATAM)"></a>The Architecture Tradeoff Analysis Method (ATAM)</h3><blockquote><p>ATAM is a risk-mitigation process. Its purpose is to help choose a suitable architecture for a software system by discovering trade-offs and sensitivity points, to capture project risks.<br>ATAM is most beneficial when done <strong>early</strong> in the software development life-cycle, when the cost of changing architectures is minimal.</p></blockquote><p>Designed to be usable where:<br>– Evaluators are not expert in the architecture<br>– Evaluators need not be familiar with the business goals.<br>– The system need not be fully developed<br>– There may be large numbers of stakeholders</p><p>Participants in ATM<br>• <strong>The evaluation team</strong>: 3-5 people with designated roles (people may have multiple roles).  Team members should be seen to be neutral with respect to the project.<br>• <strong>Project decision takers</strong>: manager of the project, funder of the project, main architect<br>• <strong>Architecture stakeholders</strong>: developers, testers, integrators, maintainers, performance engineers, …</p><h4 id="ATAM-evaluation-team-roles-and-responsibilities"><a href="#ATAM-evaluation-team-roles-and-responsibilities" class="headerlink" title="ATAM evaluation team roles and responsibilities"></a>ATAM evaluation team roles and responsibilities</h4><p>Team Leader<br>Sets up the evaluation; coordinates with client, making sure client’s needs are met; establishes evaluation contract; forms evaluation team; sees that final report is produced and delivered (although the writing may be delegated)</p><p>Evaluation Leader<br>Runs evaluation; facilitates elicitation of scenarios; administers scenario selection/prioritization process; facilitates evaluation of scenarios against architecture; facilitates onsite analysis</p><p>Scenario Scribe<br>Writes scenarios on flipchart or whiteboard during scenario elicitation; captures agreed-on wording of each scenario, halting discussion until exact wording is captured</p><p>Proceedings Scribe<br>Captures proceedings in electronic form on laptop or workstation, raw scenarios, issue(s) that motivate each scenario (often lost in the wording of the scenario itself), and resolution of each scenario when applied to architecture(s); also generates a printed list of adopted scenarios for handout to all participants</p><p>Timekeeper<br>Helps evaluation leader stay on schedule; helps control amount of time devoted to each scenario during the evaluation phase</p><p>Process Observer<br>Keeps notes on how evaluation process could be improved or deviated from; usually keeps silent but may make discreet process-based suggestions to the evaluation leader during the evaluation; after evaluation, reports on how the process went and lessons learned for future improvement; also responsible for reporting experience to architecture evaluation team at large</p><p>Process Enforcer<br>Helps evaluation leader remember and carry out the steps of the evaluation method</p><p>Questioner<br>Raise issues of architectural interest that stakeholders may not have thought of</p><h4 id="ATAM-Outputs"><a href="#ATAM-Outputs" class="headerlink" title="ATAM Outputs"></a>ATAM Outputs</h4><p>• Concise presentation of the architecture – needs to be presentable in around one hour.<br>• Articulation of the business goals – clearly communicated to all participants<br>• Prioritized QA requirements expressed as scenarios – testable QA requirements.<br>• Risks and non-risks – architecture decision that carries risks (or not).<br>• Risk themes – attempt to identify systemic risk by grouping risks into themes.<br>• Mapping of Architecture Decisions to QA requirements – motivating architecture decisions by QA requirements<br>• Identified sensitivity and tradeoff decisions – critical decisions that have significant impact on QA requirements.</p><p><img src="/images/ATAM_Phases_and_Their_Characteristics.png" alt="" title="ATAM Phases and Their Characteristics. image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/"><br>Partnership and preparation: Getting the schedule, agendas and list of stakeholders prepared, preparing necessary documents and presentations, and gettting documents to the evaluation team</p><h4 id="Steps-of-Evaluation-Phase"><a href="#Steps-of-Evaluation-Phase" class="headerlink" title="Steps of Evaluation Phase"></a>Steps of Evaluation Phase</h4><p>The ATAM analysis phases (phase 1 and phase 2) consist of nine steps.</p><p>Steps 1 through 6 are carried out in phase 1</p><ol><li>Presentation of the ATAM approach – remind participants of the approach</li><li>Business drivers presentation – functions; constraints; business goals; major stakeholders; architectural drivers</li><li>Architecture presentation:<ul><li>Context for the system</li><li>Static modular view</li><li>Component and connector view</li><li>Deployment view</li><li>Main QA requirements and how the architecture addresses them:<ul><li>What has been reused</li><li>Trace of key use cases</li><li>Trace of key change scenarios</li><li>Main issues/risks driving architectural change</li></ul></li></ul></li><li>Identify architectural approaches – create a catalogue of patterns and tactics used in the architecture.</li><li>Generate Quality Attribute Utility Tree<ul><li>this is an approach to identifying <strong>architecturally significant requirements (ASR)</strong> by looking through the QAs - identifying particular aspects of the QA that are relevant and any requirements related to that aspect of the QA.</li><li>Each ASR is ranked High, Medium or Low in importance.</li></ul></li><li>Analyze architectural approaches – look at the most important QA requirement scenarios as identified at <strong>stage 5</strong> and probe how the architecture meets the QA scenario.</li></ol><p>In phase 2, with all stakeholders present, those steps are summarized</p><ol start="7"><li>Brainstorm prioritization of scenarios – revisit the prioritization for additional scenarios, e.g. a particular stakeholder (performance engineer) might propose a scenario on the response time of the system.</li><li>Analyze Architectural Approaches – revisit <strong>stage 6</strong> but with an expanded and reprioritized set of scenarios</li><li>Present results – the evaluation group tries to group risks into risk themes to identify systemic issues and results are presented.</li></ol><p><img src="/images/Steps_of_Evaluation_Phase.png" alt="" title="Lightweight version of Evaluation ATAM Phases steps. image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/"></p><p>ATAM Results<br>• Documentation of architectural approaches taken by the project.<br>• Prioritized list of scenarios<br>• Utility tree<br>• Risks discovered<br>• Non-risks identified<br>• Sensitivity and Tradeoff points identified</p><h2 id="General-Practice-Extraction-Service-GPES"><a href="#General-Practice-Extraction-Service-GPES" class="headerlink" title="General Practice Extraction Service (GPES)"></a><a href="https://www.nao.org.uk/report/general-practice-extraction-service-investigation/" target="_blank" rel="noopener">General Practice Extraction Service (GPES)</a></h2><p>An IT system designed to allow NHS organizations to <strong>extract data from GP practice computer systems</strong> in England. This data would be used to monitor quality, plan and pay for health services and help medical research.<br>数据的请求和返回不需要实时，更多的是定期的请求，一定时间内返回数据。</p><blockquote><p>General practitioner (GP), 全科医生。在英国，每个人都需要注册一个全科医生的诊所，当人们感到身体不适后首先会去联系的自己的全科医生。全科医生只进行有限的治疗，并建议是否有必要去医院看专科医生。每个 GP 都像小公司一样运作，有自己的 GP 系统，为患者保留病患记录。在英国，各种不同的机构组织可能需要了解GP正在做什么，因此需要从所有这些GP系统中提取数据。GPES 系统允许那些已经得到授权的机构组织，通过 NHSCIC（国家卫生和社会保健信息中心）提取各种GP数据。因为不同机构需要的信息不同，NHSCIC 需要研究制定如何提取指定的数据，并运行 GPES 系统从英国的所有GP系统提取数据。GP 可以从四种不同的 GP 系统中四选一。而 GPES 的挑战在于整合来自各个不同系统的GP的数据。</p></blockquote><p>问题</p><ul><li>The project has been significantly <strong>delayed</strong> and many customers have yet to receive data.</li><li>Mistakes in the original 采购 procurement and contract management contributed to <strong>losses of public funds</strong>, through asset write-offs and settlements with suppliers.</li><li>Only one customer, NHS England has so far received data from GPES. The time needed to design a new type of extract and restrictions in the contracts severely limits HSCIC’s ability to provide data to those who request it. It is unlikely that GPES in its current form can provide the NHS-wide service planned.<br><img src="/images/GPES_customers.png" alt=""><br><img src="/images/GPES_structure.png" alt=""></li></ul><p>Data Extract Issue</p><ul><li>NHS did a technical review of GPES in early 2011, which recommended several <strong>significant changes</strong> to its design. In the original design, each GP system supplier would use <strong>a common query language</strong> as part of their extraction system. This would allow the NHSIC to design a single extract centrally using the query tool, which all GP clinical systems could understand.</li><li>The technical review recommended an <strong>alternative</strong> where each supplier would be <strong>free to develop their own query methods</strong>. New queries would no longer be designed in the query tool using a common language, but would instead need to be designed as logical ‘business rules’ and sent to GP system suppliers to implement.</li><li>The NHSIC decided to abandon both the GPSOC contract approach and the common query language, as they could not agree either with the Department and GP system suppliers. They then procured the extraction systems by negotiating direct with the GP clinical system suppliers.</li><li>NHSIC is using a non-competitive procurement approach, plus the changes in design, contributed to the restrictive process for designing new extracts.</li><li>The HSCIC, has continued to use the GPSOC framework to require data sharing between NHS systems. The new framework, effective from 2014, says that principal clinical system suppliers must provide an interface method for third-party systems to use. This would improve interoperability between systems in GP practices and the health community.</li><li>The HSCIC cannot do the wide range and scale of data extracts the NHS requests, because of the design of the GPES system and restrictions in supplier contracts. Customers have requested over 100 different data extracts from GPES, but the HSCIC estimate they will be able to design only 24 new extracts in 2015-16.</li><li>Figure shows a summary of the HSCIC’s process to develop a new extract, each of which the supplier designs and programmes from scratch. The HSCIC have limited flexibility to amend extracts once developed, for example to change a time period and the specific organisations it will extract data from.<br><img src="/images/GPES_extract_develop_process.png" alt=""></li><li>GPES will continue to operate in the short term, as its data is critical for determining payments to GPs. Its coverage of all practices in England cannot currently be replicated by other primary care data extraction systems.</li><li>However, limited capacity and the difficulty of developing new extracts deters wider use. The HSCIC has acknowledged there is unlikely to be a long-term future for all or part of the GPES. However, they intend to reuse parts for a replacement system if possible. The HSCIC estimate that they will achieve less than two more years of use from the GPES in its current form, in contrast to the five-year minimum lifetime assumed for new IT systems.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Reference:&lt;br&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ff650706.aspx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;microsoft&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/rational/library/feb06/eeles/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IBM&lt;/a&gt;&lt;br&gt;Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>Parallel Programming Language and Systems - Informatics - University of Edinburgh 爱丁堡</title>
    <link href="http://shukebeta.me/UoE-ppls/"/>
    <id>http://shukebeta.me/UoE-ppls/</id>
    <published>2018-05-10T23:00:00.000Z</published>
    <updated>2018-06-29T19:34:08.551Z</updated>
    
    <content type="html"><![CDATA[<p>Reference:<br><a href="http://www.inf.ed.ac.uk/teaching/courses/ppls/" target="_blank" rel="noopener">http://www.inf.ed.ac.uk/teaching/courses/ppls/</a><br><a href="http://www.cs.cmu.edu/~213/" target="_blank" rel="noopener">CMU 15213: Introduction to Computer Systems (ICS)</a><br><a href="http://csapp.cs.cmu.edu/" target="_blank" rel="noopener">Computer Systems: A Programmer’s Perspective</a><br><a href="http://mpitutorial.com/" target="_blank" rel="noopener">A Comprehensive MPI Tutorial Resource</a><br><a href="http://www.mcs.anl.gov/~itf/dbpp/text/node94.html#SECTION03500000000000000000" target="_blank" rel="noopener">A chapter on MPI from Ian Foster’s online Book Designing and Building Parallel Programs</a><br><a id="more"></a></p><h2 id="Introduction-to-parallel-computer-architecture"><a href="#Introduction-to-parallel-computer-architecture" class="headerlink" title="Introduction to parallel computer architecture"></a>Introduction to parallel computer architecture</h2><p>Covering some of the nasty issues presented by the shared memory model, including weak consistency models and false sharing in the cache, and some architectural issues for the multicomputer model.</p><p>Bridging the gap between the parallel applications and algorithms which we can design and describe in abstract terms and the parallel computer architectures (and their lowest level programming interfaces) which it is practical to construct.</p><p>The ability to express parallelism (a.k.a concurrency) concisely, correctly and efficiently is important in several contexts:<br>• Performance Computing: parallelism is the means by which the execution time of computationally demanding applications can be reduced. In the era of static (or even falling) clock speeds and increasing core count, this class is entering the computing mainstream.<br>• Distributed Computing: when concurrency is inherent in the nature of the system and we have no choice but to express and control it.<br>• Systems Programming: when it is conceptually simpler to think of a system as being composed of concurrent components, even though these will actually be executed by time-sharing a single processor.</p><h2 id="Parallel-Architecture"><a href="#Parallel-Architecture" class="headerlink" title="Parallel Architecture"></a>Parallel Architecture</h2><p>Two types (mainstream):</p><ul><li>Shared Memory architectures: in which all processors can physically address the whole memory, usually with support for cache coherency (for example, a quad or oct core chip, or more expensive machines with tens or hundreds of cores)</li><li>Multicomputer architectures: in which processors can only physically address their “own” memory (for example, a networked cluster of PCs), which interact with messages across the network.</li></ul><p>Increasingly, systems will span both classes (e.g. cluster of manycore, or network-onchip manycores like the Intel SCC), and incorporate other specialized, constrained parallel hardware such as GPUs.</p><p>Real parallel machines are complex, with unforseen semantic and performance traps. We need to provide programming tools which simplify things, but without sacrificing too much performance.</p><h3 id="Shared-Memory-Architectures"><a href="#Shared-Memory-Architectures" class="headerlink" title="Shared Memory Architectures"></a>Shared Memory Architectures</h3><p>Uniform Memory Access (UMA) architectures have all memory “equidistant” from all CPUs.<br>For NUMA performance varies with data location. NUMA is also confusingly called Distributed Shared Memory as memory is physically distributed but logically shared.<br><img src="/images/Shared_Memory_Architectures.png" alt="" title="image from: http://www.inf.ed.ac.uk/teaching/courses/ppls/pplsslides.pdf"></p><p>Memory consistency challenge: when, and in what order should one processor public updates to the shared memory? Exactly what and when it is permissible for each processor to see is defined by the <strong>Consistency Model</strong>, which is effectively a contract between hardware and software, must be respected by application programmers (and compiler/library writers) to ensure program correctness.</p><p>Different consistency models trade off conceptual <strong>simplicity against cost</strong> (time/hardware complexity):</p><ul><li><strong>Sequential consistency</strong>: every processor “sees” the same sequential interleaving of the basic reads and writes. This is very intuitive, but expensive to implement.</li><li><strong>Release consistency</strong>: writes are only guaranteed to be visible after program specified synchronization points (triggered by special machine instructions). This is less intuitive, but allows faster implementations.</li></ul><p>Shared memory architectures also raise tricky performance issues: The unit of transfer between memory and cache is a cache-line or block, containing several words. <strong>False sharing</strong> occurs when two logically unconnected variables share the same cache-line. Updates to one cause remote copies of the line, including the other variable, to be invalidated.</p><h3 id="Multicomputer-architectures"><a href="#Multicomputer-architectures" class="headerlink" title="Multicomputer architectures"></a>Multicomputer architectures</h3><p>Lack of any hardware integration between cache/memory system and the interconnect. Each processor only accesses its <strong>own physical address space</strong>, so no consistency issues. Information is shared by explicit, co-operative message passing<br><img src="/images/Multicomputer_Architectures.png" alt="" title="image from: http://www.inf.ed.ac.uk/teaching/courses/ppls/pplsslides.pdf"><br>Performance/correctness issues include the semantics of <strong>synchronization</strong> and constraints on <strong>message ordering</strong>.</p><h2 id="Parallel-Applications-and-Algorithms"><a href="#Parallel-Applications-and-Algorithms" class="headerlink" title="Parallel Applications and Algorithms"></a>Parallel Applications and Algorithms</h2><p>Three well-known parallel patterns: <strong>Bag of Tasks, Pipeline and Interacting Peers</strong>.</p><p>Here using the <code>co</code>, <code>&lt; &gt;</code>, <code>await</code> notation.</p><p>在<code>co oc</code>内的代码, 顺序是任意的.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 这里暂时用 // 表示并行的代码</span><br><span class="line">co</span><br><span class="line">    a=1; // a=2; // a=3; ## all happen at the same time, What is a in the end?</span><br><span class="line">oc</span><br></pre></td></tr></table></figure></p><p>To answer the above question, we need to define <strong>Atomic Actions</strong>: Reads and writes of single variables as being atomic. For more than one statements, if they appear to execute as a single indivisible step with no visible intermediate states, they are atomic, must be enclosed in <code>&lt; &gt;</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=0;</span><br><span class="line">co</span><br><span class="line">    a=1; // a=2; // b=a+a; ## what is b?</span><br><span class="line">oc</span><br></pre></td></tr></table></figure></p><p>The above code has no <code>&lt; &gt;</code>, each value accessed in an expression is a read. Each assignment is <code>a</code> write. Thus, <code>b</code> could be 0, 1, 2, 3, or 4.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=0;</span><br><span class="line">co</span><br><span class="line">    a=1; // a=2; // &lt;b=a+a;&gt;</span><br><span class="line">oc</span><br></pre></td></tr></table></figure></p><p>Now the only outcomes for b are 0, 2 or 4.</p><p><strong>Sequential memory consistency (SC)</strong><br>To make agreement on such inconsistency, we define the sequential memory consistency (SC), to be consistent with the following rules:</p><ol><li>ordering of atomic actions (particularly reads and writes to memory) from any one thread have to occur in normal program order</li><li>atomic actions from different threads are interleaved arbitrarily (ie in an unpredictable sequential order, subject only to rule 1)</li></ol><p><strong>It doesn’t mean that SC programs have to be executed sequentially</strong>!<br>It only means that the results we get must be the same as if the program had been executed in this way.</p><p><strong>Await</strong><br>The await notation <code>&lt; await (B) S &gt;</code> allows us to indicate that <code>S</code> must appear to be delayed until <code>B</code> is true, and must be executed within the same atomic action as a successful check of <code>B</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=0; flag=0;</span><br><span class="line">co</span><br><span class="line">&#123;a=25; flag=1;&#125;</span><br><span class="line">//</span><br><span class="line">&lt;await (flag==1) x=a;&gt; ## x = 25</span><br><span class="line">oc</span><br></pre></td></tr></table></figure></p><p>However, it is not guaranteed that, an await statement is executed right after its condition becomes true. If other atomic actions make the condition false again, before the await executes, it will have to wait for another chance.</p><h3 id="The-Bag-of-Tasks"><a href="#The-Bag-of-Tasks" class="headerlink" title="The Bag-of-Tasks"></a>The Bag-of-Tasks</h3><p>Example: Adaptive Quadrature, compute an approximation to the shaded integral by partitioning until the 梯形 trapezoidal approximation is “good enough”, compared with the sum of its two sub-divided trapezoidals’s area.<br><code>area = quad (a, b, f(a), f(b), (f(a)+f(b))*(b-a)/2);</code><br>The recursive calls to <code>quad</code> do not interfere with each other. So we can parallelize the program by changing the calls to<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 简单地并行</span><br><span class="line">co</span><br><span class="line">    larea = quad(left, mid, f(left), f(mid), larea); //</span><br><span class="line">    rarea = quad(mid, right, f(mid), f(right), rarea);</span><br><span class="line">oc</span><br></pre></td></tr></table></figure></p><p>In practice, there is very little work directly involved in each call to <code>quad</code>. The work involved in <strong>creating and scheduling a process or thread is substantial</strong> (much worse than a simple function call), program may be swamped by this overhead.</p><p>Using the Bag of Tasks pattern: a <strong>fixed number of worker processes/threads</strong> maintain and process a dynamic collection of homogeneous “tasks”. Execution of a particular task may lead to the <strong>creation</strong> of more task instances.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Bag of Tasks pattern</span><br><span class="line">co [w = 1 to P] &#123;</span><br><span class="line">    while (all tasks not done) &#123;</span><br><span class="line">        get a task;</span><br><span class="line">        execute the task;</span><br><span class="line">        possibly add new tasks to the bag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1, Shared bag: contains <code>task(a, b, f(a), f(b), area)</code><br>2, Get a task: remove a record from the bag, either:<br>    • adds its local area approximation to the total<br>    • or creates two more tasks for a better approximation (by adding them to the bag).</p><p>Advantage:<br>1, It constraints the number of processes/threads to avoid overhead.<br>2, Useful for independent tasks and to implement recursive parallelism<br>3, <strong>Naturally load-balanced</strong>: each worker will probably complete a different number of tasks, but will do roughly the same amount of work overall.</p><p>Bag of Tasks <strong>Implementation</strong>: The challenge is to make accessing the bag much cheaper than creating a new thread. With a shared address space, a simple implementation would make the bag an atomically accessed shared data structure.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">shared int size = 1, idle = 0;</span><br><span class="line">shared double total = 0.0;</span><br><span class="line">bag.insert (a, b, f(a), f(b), approxarea);</span><br><span class="line">co [w = 1 to P] &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        &lt; idle++; &gt;</span><br><span class="line">        &lt; await ( size &gt; 0 || idle == P )             ## 检测 termination</span><br><span class="line">          if (size &gt; 0) &#123;                             ## get a task</span><br><span class="line">              bag.remove (left, right ...); size--; idle--;</span><br><span class="line">          &#125; else break; &gt;                             ## the work is done</span><br><span class="line">        mid = (left + right)/2; ..etc..               ## compute larea, etc</span><br><span class="line">        if (fabs(larea + rarea - lrarea) &gt; EPSILON) &#123; ## create new tasks</span><br><span class="line">            &lt; bag.insert (left, mid, fleft, fmid, larea);</span><br><span class="line">              bag.insert (mid, right, fmid, fright, rarea);</span><br><span class="line">              size = size + 2; &gt;</span><br><span class="line">        &#125; else &lt; total = total + larea + rarea; &gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://www2.cs.arizona.edu/~greg/mpdbook/lectures/lec09.html" target="_blank" rel="noopener">Detecting termination</a>:<br>不能仅仅因为 bag 空了就认为可以结束了, 因为还可能有还在工作的 workers 未来会产生新的任务. 所以需要让 workers 有能力把自己的工作完成状况告知 bag. When bag is empty AND all tasks are done; All tasks are done when all workers are waiting to get a new task.</p><p>If a bag of tasks algorithm has terminated, there are no tasks left. However, the inverse is not true. I.e. no tasks in a bag could mean that one of the workers is still processing a task which can lead to creation of multiple new tasks.<br>To solve this problem, workers could have the ability to notify the master/bag once they finish the current task. As a result, an implementation of bag of tasks can then contain a count of idle and active works to prevent early termination</p><p>A more sophisticated implementation (with less contention) might internally have a collection of bags, perhaps one per worker, with task-stealing to distribute the load as necessary.</p><p>With <strong>message passing</strong>, a simple scheme might allocate an explicit “farmer” node to maintain the bag. Again, a more sophisticated implementation could distribute the bag and the farmer, with task-stealing and termination checking via messages.</p><h3 id="Pipeline-Patterns"><a href="#Pipeline-Patterns" class="headerlink" title="Pipeline Patterns."></a>Pipeline Patterns.</h3><p>Example: <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="noopener">The Sieve of Eratosthenes</a> algorithms for finding all prime numbers.</p><p>To find all prime numbers in the range 2 to N. The algorithm write down all integers in the range, then repeatedly remove all multiples of the smallest remaining number. Before each removal phase, the new smallest remaining number is guaranteed to be prime.</p><p>Notice that, it is not necessarily to wait one Sieve completed then start another. As long as one Sieve stage finds out one candidate number could not be divided exactly by the sieve number, it could generate a new stage with this candidate number as Sieve. And different sieve just remove the multiples of its own Sieve number.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># a message-passing style pipeline pseudocode</span><br><span class="line">main() &#123;                                # the generator</span><br><span class="line">    spawn the first sieve process;</span><br><span class="line">    for (i=2; i&lt;=N; i++) &#123;</span><br><span class="line">        send i to first sieve;</span><br><span class="line">    &#125;</span><br><span class="line">    send -1 to first sieve;             # a &quot;stop&quot; signal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sieve() &#123;</span><br><span class="line">    int myprime, candidate;</span><br><span class="line">    receive myprime from predecessor and record it;</span><br><span class="line">    do &#123;</span><br><span class="line">        receive candidate from predecessor;</span><br><span class="line">        if (candidate == -1) &#123;send -1 to successor if it exists&#125;</span><br><span class="line">        else if (myprime doesn&apos;t divide candidate exactly) &#123;</span><br><span class="line">            if (no successor yet) spawn successor sieve process;</span><br><span class="line">            send candidate to successor sieve process;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (candidate != -1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每一个数(2-N)都可能作为筛子, 筛掉能整除这个筛子的其他数，而筛子之间是互相独立的，所以可以以<a href="http://www.informit.com/articles/article.aspx?p=366887&amp;seqNum=8" target="_blank" rel="noopener">流水线模式 pipeline patterns</a>来并行操作，动态生成筛子。最开始最小的数字<code>2</code>会成为筛子。筛子可以理解为不同的工序，其余数字从小到大逐一通过这些工序加工（在 Sieve of Eratosthenes 问题中变为筛选排查），无法被筛子整除的数字会被传递到下个筛子（如果没有下一个筛子，则以这个数字创建新的筛子），这样保证生成的筛子就都是素数了。虽然工序是按顺序过的，但是所有工序可以同时对不同的产品（数字）开工，从而达到并行目的。</p><p>For pipeline patterns, the potential concurrency can be exploited by assigning each operation (stage of the pipeline) to a different worker and having them work simultaneously, with the data elements passing from one worker to the next as operations are completed. Despite the dependencies (order constraints) of the processing steps, the pipeline threads can work in parallel by applying their processing step to different data (products).</p><p>Think of pipeline patterns as the factory assembly line. We need to pick out prime number from a range of numbers N, each number is passed into a sequence of stages, each stages checks a pass in number based on the stages’s Sieve. The numbers that finally pass all stages without being removed is a prime number.</p><p>Pipelines are composed of a sequence of threads, in which each thread’s input is the previous thread’s output, (<strong>Producer-Consumer relationships</strong>).</p><p>The advantages of pipeline patterns is that construction of pipeline stages is dynamic and data-dependent.</p><p>To allow production and consumption to be loosely synchronized, we will need some buffering in the system.</p><p>The programming challenges are to ensure that no producer overwrites a buffer entry before a consumer has used it, and that no consumer tries to consume an entry which doesn’t really exist (or re-use an already consumed entry)</p><h3 id="Interacting-Peers-Pattern"><a href="#Interacting-Peers-Pattern" class="headerlink" title="Interacting Peers Pattern"></a>Interacting Peers Pattern</h3><p>Models of physical phenomena are often expressed as a system of partial differential equations. These can be approximately solved by “finite difference methods” which involve iteration on a matrix of points, in an interacting peers pattern. The “compute” step usually involves only a small number of neighbouring points. The termination test looks for convergence.</p><p>We could use a duplicate grid and <strong>barriers</strong> to enforce correct synchronization between iterations:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">shared real grid[n+2, n+2], newgrid[n+2, n+2];</span><br><span class="line">shared bool converged; local real diff;</span><br><span class="line">co [i = 1 to n, j = 1 to n] &#123;</span><br><span class="line">    initialise grid;</span><br><span class="line">    do &#123;</span><br><span class="line">        barrier();                                  ## before resetting test</span><br><span class="line">        converged = true;                           ## provisionally</span><br><span class="line">        newgrid[i,j] = (grid[i-1,j] + grid[i+1,j] +</span><br><span class="line">            grid[i,j-1] + grid[i,j+1])/4;           ## compute new value</span><br><span class="line">        diff = abs (newgrid[i,j] - grid[i,j]);      ## compute local change</span><br><span class="line">        barrier();                                  ## before converged update</span><br><span class="line">        if (diff &gt; EPSILON) converged = false;      ## any one will do</span><br><span class="line">        grid[i,j] = newgrid[i,j];                   ## copy back to real grid</span><br><span class="line">        barrier();                                  ## before global check</span><br><span class="line">    &#125; while (not converged);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>A <code>barrier()</code> in ppls makes any thread that arrive here has to wait all the other threads arriving here.</p><p>以方腔热对流的模拟计算模型为例，每个网格节点$(i,j)_{t+1}$ 的更新依赖于上一个迭代时间点的$(i,j)_t$以及其临近几个点的值，创建最多跟网格点数量一样的threads，然后并行地计算网格点的新值，更新的值用一个buffer层来缓存，用<code>barrier()</code>来保证所有网格点的更新值都计算完毕，再检查收敛情况，再用一个<code>barrier()</code>保证所有buffer层的值都更新到原网格上，再决定是否进行下一次计算。</p><p>Single Program Multiple Data (SPMD): A programming style, all processes execute more or less the same code, but on distinct partitions of the data.</p><h3 id="Other-Patterns"><a href="#Other-Patterns" class="headerlink" title="Other Patterns"></a>Other Patterns</h3><p>Other candidate patterns include MapReduce (championed by Google), Scan, Divide &amp; Conquer, Farm as well as application domain specific operations.</p><h2 id="Shared-Variable-Programming"><a href="#Shared-Variable-Programming" class="headerlink" title="Shared Variable Programming"></a>Shared Variable Programming</h2><p>In the <strong>shared-memory programming model</strong>, tasks share a common address space, which they read and write asynchronously. An advantage of this model from the programmer’s point is that the notion of data “ownership” is lacking, so there is no need to specify explicitly the communication of data between tasks. Program development can often be simplified.</p><p>There are two fundamentally different synchronization in shared variable programming. <strong>Mutual Exclusion</strong> and <strong>Condition Synchronization</strong>.</p><h3 id="Mutual-Exclusion"><a href="#Mutual-Exclusion" class="headerlink" title="Mutual Exclusion"></a>Mutual Exclusion</h3><p>Atomic actions, at most one thread is executing the critical section at a time. Prevent two or more threads from being active concurrently for some period, because their actions may interfere incorrectly. For example, we might require updates to a shared counter (e.g., count++) to execute with mutual exclusion.</p><h4 id="Critical-Sections-problem"><a href="#Critical-Sections-problem" class="headerlink" title="Critical Sections problem"></a>Critical Sections problem</h4><p>A simple pattern of mutual exclusion occurs in the <strong>critical section problem</strong> - when n threads execute code of the following form, in which it is essential that at most one thread is executing statements in the critical section at a time (because of potentially unsafe access to shared variables)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">co [i = 1 to n] &#123;</span><br><span class="line">    while (something) &#123;</span><br><span class="line">        lock(l);      #entry section</span><br><span class="line">        critical section;</span><br><span class="line">        unlock(l);    #exit section</span><br><span class="line">        non-critical section;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Design code to execute before (<strong>entry protocol</strong>) and after (<strong>exit protocol</strong>) the critical section to make the critical section <strong>atomic</strong>. If one thread lock the critical section, no one(thread) else could lock it or unlock it anymore, until the thread unlock it.</p><p>Important properties:</p><ol><li><strong>Mutual exclusion</strong>: When a thread is executing in its critical section, no other threads can be executing in their critical sections.</li><li><strong>Absence of Deadlock</strong> (or Livelock): If two or more threads are trying to enter the critical section, <strong>at least one succeeds</strong>.<blockquote><p>A deadlock is a state in which each member of a group is waiting for some other member to take action, such as sending a message or more commonly releasing a lock, so that neither of them take action.<br>类似两个人相遇互不相让, 没人肯挪动.<br>Livelock is a condition that takes place when two or more programs change their state continuously, with neither program making progress.<br>类似两个人相遇同时往相同方向避让.</p></blockquote></li><li><strong>Absence of Unnecessary Delay</strong>: If a thread is trying to enter its critical section and the other threads are executing their non-critical sections, or have terminated, the first thread is not prevented from entering its critical section.</li><li><strong>Eventual Entry</strong> (No Starvation): A thread that is attempting to enter its critical section will eventually succeed. May not matter in some “performance parallel” programs - as long as we are making progress elsewhere.</li></ol><p>Simple implementation of each lock with a <strong>shared boolean variable</strong>: if <code>false</code>, then one locking thread can set it to <code>true</code> and be allowed to proceed. Other attempted locks must be forced to wait.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># model assumes that the l = false;</span><br><span class="line"># write is already atomic</span><br><span class="line"># This might fail if the model is more relaxed than SC.</span><br><span class="line">lock_t l = false;</span><br><span class="line">co [i = 1 to n] &#123;</span><br><span class="line">    while (something) &#123;</span><br><span class="line">        &lt; await (!l) l = true; &gt; # guarantee the others waiting</span><br><span class="line">        critical section;</span><br><span class="line">        l = false; # unlock the lock, open the critical section</span><br><span class="line">        non-critical section;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>To implement the <code>&lt; await (!l) l = true; &gt;</code>, we rely on some <strong>simpler atomic primitive</strong>, implemented with hardware support. There are many possibilities, including “Fetch-and-Add”, “Test-and-Set” and the “Load-Linked, Store-Conditional” pairing.</p><h5 id="Test-and-Set-TS-instruction"><a href="#Test-and-Set-TS-instruction" class="headerlink" title="Test-and-Set (TS) instruction"></a>Test-and-Set (TS) instruction</h5><p>Behaving like a call-by-reference function, so that the variable passed in is read from and written to, but in reality it is a single machine instruction. The key feature is that this happens (or at least, appears to happen) atomically.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># A Test-and-Set (TS) instructionW</span><br><span class="line">bool TS (bool v) &#123;</span><br><span class="line">    &lt; bool initial = v;</span><br><span class="line">    v = true;</span><br><span class="line">    return initial; &gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock_t l = false;</span><br><span class="line">co [i = 1 to n] &#123;</span><br><span class="line">    while (something) &#123;</span><br><span class="line">        while (TS(l)) ;  ## spin lock</span><br><span class="line">        critical section;</span><br><span class="line">        l = false;</span><br><span class="line">        non-critical section;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>This is called <strong>spin lock</strong>,</p><p>Simple spin locks don’t make good use of the cache (those spinning Test-And-Sets play havoc with contention and coherence performance). A pragmatically better spin locks is known as <strong>Test-and-Test-and-Set</strong> - mainly spinning on a read rather than a read-write function.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">while</span> (something) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l || TS(l)); <span class="comment">/* only TS() if l was false*/</span></span><br><span class="line">        critical section;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>Simply read <code>l</code> until there is a chance that a Test-and-Set might succeed.</p><p><strong>Spin lock</strong> guarantees mutual exclusion, absence of deadlock and absence of delay, but does <strong>not guarantee eventual entry</strong>.</p><h5 id="Lamport’s-Bakery-Algorithm"><a href="#Lamport’s-Bakery-Algorithm" class="headerlink" title="Lamport’s Bakery Algorithm"></a><a href="https://en.wikipedia.org/wiki/Lamport%27s_bakery_algorithm" target="_blank" rel="noopener">Lamport’s Bakery Algorithm</a></h5><p>Implement critical sections using only simple atomic read and simple atomic write instructions (i.e. no need for atomic read-modify-write).</p><p>采用商店结账排队机制，顾客就是一个个threads，根据排队码，越小的优先级越高（0 除外，0 代表没有结账需求），最小的可以进入critical section。</p><p>The challenge is entry protocal, if a thread intends to access the critical section:</p><ol><li>排队取号：It sets its turn <code>turn[i] = max(turn[:])+1</code> (Threads not at or intend to access the critical section have a turn of 0)</li><li>等待叫号：This thread waits until its turn comes up (until it has the smallest turn).</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int turn[n] = [0, 0, ... 0];</span><br><span class="line">co [i=1 to n] &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        turn[i] = max (turn[1..n]) + 1;</span><br><span class="line">        for (j = 1 to n except i) &#123;</span><br><span class="line">            while ((turn[j]!=0 and (turn[i] &gt; (turn[j])) skip;</span><br><span class="line">        &#125;</span><br><span class="line">        critical section;</span><br><span class="line">        turn[i] = 0;</span><br><span class="line">        noncritical section;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>max (turn[1..n]) + 1</code>不是atomic的, 所以会出现问题.</p><p>问题一: if turn setting is not atomic then two (or more) threads may claim the same turn.</p><blockquote><p>两个threads在取号阶段<code>turn[i] = max(turn[:])+1</code>出现并发，两个都先<code>max</code>, 之后再<code>+1</code>.</p></blockquote><p>问题二: there is possibility that a thread can claim a lower turn than another thread which enters the critical section before it!</p><blockquote><p>两个threads在取号阶段<code>turn[i] = max(turn[:])+1</code>出现并发, 并且在两个threads分别进行<code>max</code>的间隙, 刚好在CS中的thread完成并退出CS，导致两个thread看到的<code>max</code>值不一样了. 前者比后者看到的大, 但前者却因为更早进行<code>+1</code>操作而提前进入了CS.</p></blockquote><p>举例：假如同时有三个thread A B C, A 已经在CS中(turn(A)&gt;0)：</p><ol><li>B 先运行max比较(<code>max = turn(A)</code>),</li><li>C 在 A 退出后(<code>turn(A) = 0</code>)才进行比较(<code>max = 0</code>),</li><li>B 先进行<code>+1</code>操作(<code>turn(B) = turn(A)+1 &gt; 1</code>),</li><li>B 进行比较后允许进入CS (<strong>此时turn(C)还是0</strong>, 0是被忽略的);</li><li>之后C才 <code>+1</code>(<code>turn(C) = 0 + 1 = 1</code>);</li><li>这样导致B的值虽然比C大, 但B还是比C先进入CS; 之后因为 C 的 turn 比较小， 所以 C 也跟着进入 CS。</li></ol><p>问题一解决方案 - 使用线程ID（绝不相同）做二次区分, 在相同 turn 的情况下，具有较低ID的 thread 有限。</p><p>问题二解决方案 - 在<code>max (turn[1..n]) + 1</code>之前先<code>turn[i] = 1;</code>.<br>• 这样，任何 threads 想取号都要先标记为 1<br>• 标记后，才有资格跟其他 thread 比较<br>• 以<code>max+1</code>作为号码进入队列，这样任何的可能的 turn 值都必定大于 1<br>• B 无法提前进入CS (<strong>此时turn(C)不再是被忽略的0, 而是最小正整数1</strong>).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#  (x, a) &gt; (y,b) means (x&gt;y) || (x==y &amp;&amp; a&gt;b).</span><br><span class="line">while (true) &#123;</span><br><span class="line">    turn[i] = 1; turn[i] = max (turn[1..n]) + 1;</span><br><span class="line">    for (j = 1 to n except i) &#123;</span><br><span class="line">        while ((turn[j]!=0 and (turn[i], i) &gt; (turn[j], j)) skip;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Lamport’s algorithm has the strong property of guaranteeing eventual entry (unlike our spin lock versions). The algorithm is too inefficient to be practical if spin-locks are available.</p><h3 id="Condition-Synchronization"><a href="#Condition-Synchronization" class="headerlink" title="Condition Synchronization"></a>Condition Synchronization</h3><p>Delay an action until some condition (on the shared variables such as in producer-consumer, or with respect to the progress of other threads such as in a <strong>Barrier</strong>) becomes true.</p><h4 id="Barrier-synchronization"><a href="#Barrier-synchronization" class="headerlink" title="Barrier synchronization"></a>Barrier synchronization</h4><p><strong>Barrier synchronization</strong> is a particular pattern of condition synchronization, a kind of computation-wide waiting:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">co [i = 1 to n] &#123;</span><br><span class="line">    while (something) &#123;</span><br><span class="line">        do some work;</span><br><span class="line">        wait for all n workers to get here;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>A <strong>Counter Barriers</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;count = count + 1;&gt;</span><br><span class="line">&lt;await (count == n);&gt;</span><br></pre></td></tr></table></figure></p><p>is fine as a single-use barrier, but things get more complex if (as is more likely) we need the barrier to be <strong>reusable</strong>.</p><p>改良为<code>&lt;await (count == n); count = 0;&gt;</code>也不行: an inter-iteration race, 假如<code>count == n</code>, 那么n个threads都完成了前面的statements并准备执行<code>await</code>, 但其中任何一个 thread 先执行完整个代码都使<code>count = 0</code>,这样剩余的threads就无法通过await条件了.</p><h5 id="Sense-Reversing-Barrier"><a href="#Sense-Reversing-Barrier" class="headerlink" title="Sense Reversing Barrier"></a>Sense Reversing Barrier</h5><p>A shared variable <code>sense</code> is <strong>flipped after each use</strong> of the barrier to indicate that all threads may proceed. 关键每个 thread 都有自己的 private variable <code>mySense</code> 和 while spin lock。解决了前面的死锁问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shared int count = 0; shared boolean sense = false;</span><br><span class="line">co [i = 1 to n] &#123;</span><br><span class="line">    private boolean mySense = !sense; ## one per thread</span><br><span class="line">    while (something) &#123;</span><br><span class="line">        do some work;</span><br><span class="line">        &lt; count = count + 1;</span><br><span class="line">          if (count == n) &#123; count = 0; sense = mySense; &#125;   ## flip sense</span><br><span class="line">        &gt;</span><br><span class="line">        while (sense != mySense);                           ## wait or pass</span><br><span class="line">        mySense = !mySense;                                 ## flip mySense</span><br><span class="line">        // 或者使用 &lt; await (sense==mySense) mySense = !sense;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所有thread的local variable <code>mySense</code>开始都被赋值为<code>!sense</code>(<code>true</code>)，前面n-1个thread都得在内循环<code>while</code>那里等着；直到最后一个thread完成工作后, <code>if</code>条件才满足, <code>count</code>重置为<code>0</code>, <strong>反转</strong><code>sense</code>(被赋值为<code>mySense</code>也即是<code>true</code>), 之后所有threads才能结束内部<code>while</code>循环，接着再次<strong>反转</strong><code>sense</code>(被赋值为<code>!mySense</code>也即是<code>false</code>), 然后进行下一轮大循环，借此达到重复利用barrier的目的. <code>sense</code>初始值是什么无所谓, 反转才是关键.</p><p>缺点：$O(n)$效率，count次数（同步次数）正比于thread数量。</p><h5 id="Symmetric-Barriers"><a href="#Symmetric-Barriers" class="headerlink" title="Symmetric Barriers"></a>Symmetric Barriers</h5><p>Symmetric barriers are designed to avoid the bottleneck at the counter.<br>通过 pair-threads barriers 多轮同步来构建一个完整的 n-threads barriers，让所有threads都知道大家已经完成任务。总共是$\log_2n$ 轮同步。每个thread在完成必要工作后, 开始进入下面的pairwise同步环节，自己(myid)的初始arrive状态为0:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># arrive[i] == 1 means arrive barrier</span><br><span class="line"># there will be log_2 #threads stages,</span><br><span class="line"># 每个stage代表一次pairwise同步</span><br><span class="line">for [s = 0 to stages-1] &#123;</span><br><span class="line">    &lt;await (arrive[myid] == 0);&gt;   # 1</span><br><span class="line">    arrive[myid] = 1;              # 2</span><br><span class="line">    work out who my friend is at stage s;</span><br><span class="line">    &lt;await (arrive[friend] == 1);&gt; # 3</span><br><span class="line">    arrive[friend] = 0;            # 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样保证了，每个thread需要先把自己的arrive状态标记为1(#1，#2)，才可以去看同伴的状态（#3），假如同伴也是1，那么表明自己这一组是都到达了barrier状态（大家都是1），那么就会把对方的状态初始化为0 （#4），进入下一阶段，更换同伴，继续同步比较。<br><img src="/images/symmetric_barrier.jpg" alt="" title="Butterfly barrier for 8 processe. Image from: http://www.inf.ed.ac.uk/teaching/courses/ppls/pplsslides.pdf"><br>When used as <strong>a step within a multistage symmetric barrier</strong>, 会出现问题：假如有四个thread，那么就会有两个stages：第一次是1和2同步，3和4同步。2一直没到barrier，1一直卡在#3。而3和4 同步完后开始检查1的状况，发现<code>arrive[1] = 1</code>，就运行Lines (3) and (4), 结果1就被初始化了，而2还没是没到barrier。</p><p>解决办法是给每个stage分配新的arrive变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for [s = 0 to stages-1] &#123;</span><br><span class="line">    &lt;await (arrive[myid][s] == 0);&gt;</span><br><span class="line">    arrive[myid][s] = 1;</span><br><span class="line">    work out who my friend is at this stage;</span><br><span class="line">    &lt;await (arrive[friend][s] == 1);&gt;</span><br><span class="line">    arrive[friend][s] = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样假如出现2一直没到barrier的情况, 那么1会卡在当前stage, 1的stage+1的arrive状态就无法更新为1.</p><h5 id="Dissemination-Barriers"><a href="#Dissemination-Barriers" class="headerlink" title="Dissemination Barriers"></a>Dissemination Barriers</h5><p>If n isn’t a power of 2, instead of pairwise synchs, we have two partners at each stage for each thread, one incoming and one outgoing.<br><img src="/images/dissemination_barrier.png" alt="" title=" Dissemination barrier for 6 processes. Image from: http://www.inf.ed.ac.uk/teaching/courses/ppls/pplsslides.pdf"></p><h2 id="Structured-Primitives"><a href="#Structured-Primitives" class="headerlink" title="Structured Primitives"></a>Structured Primitives</h2><p>Instead of implementing directly in the user-address space, a number of more structured primitives have been devised for <strong>implementation with the assistance of the operating system</strong>, so that threads can be directly suspended and resumed by the OS’s scheduler.</p><blockquote><p>• Machine code, instructions and data directly understandable by a CPU;<br>• Language primitive, the simplest element provided by a programming language;<br>• Primitive data type, a datatype provided by a programming language.</p></blockquote><h3 id="Semaphores-信号灯"><a href="#Semaphores-信号灯" class="headerlink" title="Semaphores 信号灯"></a>Semaphores 信号灯</h3><p>A semaphore is a special shared variable, accessible only through two atomic operations, <strong>P(try to decrease)</strong> and <strong>V(increase)</strong>, defined by:<br>P(s): <code>&lt;await (s&gt;0) s=s-1;&gt;</code><br>V(s): <code>&lt;s=s+1;&gt;</code></p><p>Property: A thread executing <code>P()</code> on a 0 valued semaphore will be suspended on a queue until after some other thread has executed a <code>V()</code>.</p><p>Application: A semaphore appears to be a simple integer. A thread waits for permission to proceed a <strong>critical section</strong>, and then signals that it has proceeded by performing a <code>P()</code> operation on the semaphore.</p><p><strong>Binary semaphore</strong>: A semaphore whose usage is organised to only ever take the value (0, 1) as a mutex 互斥.<br><strong>Counting(split) semaphore</strong>: can take on arbitrary nonnegative values.</p><p>Semaphores still require careful programming: there is no explicit connection in the program source between “matching” semaphore operations. It is easy to get things wrong.</p><p>Similarly, there is no obvious indication of how semaphores are being used - some may be for mutual exclusion, others for condition synchronization. Again confusion is possible.</p><h4 id="Semaphores-for-Critical-Section-mutual-exclusion"><a href="#Semaphores-for-Critical-Section-mutual-exclusion" class="headerlink" title="Semaphores for Critical Section (mutual exclusion)"></a>Semaphores for Critical Section (mutual exclusion)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sem mutex = 1;</span><br><span class="line">co [i = 1 to n] &#123;</span><br><span class="line">    while (whatever) &#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        critical section;</span><br><span class="line">        V(mutex);</span><br><span class="line">        noncritical section;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Semaphores-for-Barrier-Synchronisation"><a href="#Semaphores-for-Barrier-Synchronisation" class="headerlink" title="Semaphores for Barrier Synchronisation"></a>Semaphores for Barrier Synchronisation</h4><p>实现 symmetric barrier: an array of arrive semaphores for each stage<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for [s = 1 to stages] &#123;</span><br><span class="line">    V(arrive[myid][s]);</span><br><span class="line">    work out who my friend is at stage s;</span><br><span class="line">    P(arrive[friend][s]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Semaphores-for-Producer-Consumer-Buffering"><a href="#Semaphores-for-Producer-Consumer-Buffering" class="headerlink" title="Semaphores for Producer-Consumer Buffering"></a>Semaphores for Producer-Consumer Buffering</h4><p>针对单个producer和consumer，控制其接触单个容量的buffer权限：一个semaphores标识buffer已满<code>full</code>，一个标识空<code>empty</code>。这种情况下，只能有一个semaphore是<code>1</code>，故称之为<strong>split binary semaphore</strong>。 <code>P(full)</code> 执行 <code>wait full &gt; 0 : full -= 1</code>, <code>V(empty)</code>执行<code>empty += 1</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">T buf; sem empty = 1, full = 0;</span><br><span class="line">co</span><br><span class="line">  co [i = 1 to M] &#123;</span><br><span class="line">      while (whatever) &#123;</span><br><span class="line">          ...produce new data locally</span><br><span class="line">          P(empty);</span><br><span class="line">          buf = data;                # producer</span><br><span class="line">          V(full);</span><br><span class="line">  &#125;   &#125;</span><br><span class="line">//</span><br><span class="line">  co [j = 1 to N] &#123;</span><br><span class="line">      while (whatever) &#123;</span><br><span class="line">          P(full);</span><br><span class="line">          result = buf;              # consumer</span><br><span class="line">          V(empty);</span><br><span class="line">          ... handle result locally</span><br><span class="line">  &#125;   &#125;</span><br><span class="line">oc</span><br></pre></td></tr></table></figure></p><p><strong>Bounded Buffer</strong>: Control access to a multi-space buffer (the producer can run ahead of the consumer up to some limit)</p><ul><li>Implement the buffer itself with an array (circular),</li><li>and two integer indices, indicating the current front and rear of the buffer and use arithmetic modulo <code>n</code> (the buffer size), so that the buffer conceptually becomes circular</li><li>For a single producer and consumer, we protect the buffer with a split “counting” semaphore, initialised according to the buffer size.</li><li>Think of full as counting how many space in the buffer are full, and empty as counting how many are empty<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">T buf[n]; int front = 0, rear = 0;</span><br><span class="line">sem empty = n, full = 0;</span><br><span class="line">co ## Producer</span><br><span class="line">    while (whatever) &#123;</span><br><span class="line">        ...produce new data locally</span><br><span class="line">        P(empty);                 # empty&gt;0, 才能生产, empty-=1</span><br><span class="line">        buf[rear] = data; rear = (rear + 1) % n;</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">// ## Consumer</span><br><span class="line">    while (whatever) &#123;</span><br><span class="line">        P(full);                  # full&gt;0, 才能消耗, full-=1</span><br><span class="line">        result = buf[front]; front = (front + 1) % n;</span><br><span class="line">        V(empty);</span><br><span class="line">        ... handle result locally</span><br><span class="line">    &#125;</span><br><span class="line">oc</span><br></pre></td></tr></table></figure></li></ul><p><strong>Multiple Producers/Consumers</strong>: Because each producer may access the same pointer to overide each other, so as consumer. Thus we need two levels of protection.</p><ul><li>Use a split counting semaphore to avoid buffer overflow (or underflow), as previously.</li><li>Use a mutual exclusion semaphores to prevent interference between producers (and another to prevent interference between consumers). This allows up to one consumer and one producer to be actively simultaneously within a non-empty, non-full buffer.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">T buf[n]; int front = 0, rear = 0; 86</span><br><span class="line">sem empty = n, full = 0, mutexP = 1, mutexC = 1;</span><br><span class="line">co</span><br><span class="line">  co [i = 1 to M] &#123;</span><br><span class="line">      while (whatever) &#123;</span><br><span class="line">          ...produce new data locally</span><br><span class="line">          P(empty);</span><br><span class="line">            P(mutexP); # stop the other producers from accessing the buffer</span><br><span class="line">              buf[rear] = data; rear = (rear + 1) % n;</span><br><span class="line">            V(mutexP);</span><br><span class="line">          V(full);</span><br><span class="line">&#125; &#125;</span><br><span class="line">//</span><br><span class="line">  co [j = 1 to N] &#123;</span><br><span class="line">      while (whatever) &#123;</span><br><span class="line">          P(full);</span><br><span class="line">            P(mutexC);</span><br><span class="line">              result = buf[front]; front = (front + 1) % n;</span><br><span class="line">            V(mutexC);</span><br><span class="line">          V(empty);</span><br><span class="line">          ... handle result locally</span><br><span class="line">    &#125; &#125;</span><br><span class="line">oc</span><br></pre></td></tr></table></figure><p><strong>Extending Multiple Producers/Consumers</strong>: If the buffered items are large and take a long time to read/write, we would like to relax this solution to allow several producers and/or consumers to be active within the buffer simultaneously.</p><ul><li>We need to ensure that these workers accesse distinct buffer locations, which require the index arithmetic to be kept atomic.</li><li>Make sure that the producer/consumers wait for that element to be empty/full before actually proceeding.<br><img src="/images/Multiple_Producers_Consumers.png" alt="" title="The producers are filling distinct slots, but not necessarily completing these fills in strict order - slot i+1 might finish filling before slot i. However, consumers only know that a slot has been filled and assume, possibly incorrectly, that it is the &quot;next&quot; one. Image from: http://www.inf.ed.ac.uk/teaching/courses/ppls/pplsslides.pdf"></li></ul><p>The solution is to have <strong>extra semaphores pair for each buffer location</strong>.</p><h3 id="Monitors"><a href="#Monitors" class="headerlink" title="Monitors"></a>Monitors</h3><p>The monitor is a more structured mechanism which allows threads to have both <strong>mutual exclusion</strong> and the ability to <strong>wait</strong> (block) for a certain condition to become true. It has a mechanism for <strong>signaling</strong> other threads that their condition has been met. A monitor consists of a <strong>mutex (lock)</strong> object and <strong>condition variables</strong> (cv). A condition variable is basically a container of threads that are waiting for a certain condition.</p><p>For <strong>Mutual Exclusion</strong>: i.e. a mutex (lock) object, ensures that <strong>at most one thread is active within the monitor at each point in time</strong>. 不同线程的下一条即将执行的指令 (suspended) 可能是来自同一个 monitor (由os自行分配), 但同一时间内，至多只能有一个线程执行下一条指令，但可能不同线程各自收到了来自这个 monitor 代码的不同指令. It is as if the body of each monitor method is implicitly surrounded with <code>P()</code> and <code>V()</code> operations on a single hidden binary semaphore, shared by all methods.</p><p>For <strong>Condition Synchronization</strong>, using a cv with a monitor to control <strong>a queue of delayed threads</strong> by a kind of <strong>Signal and Continue (SC)</strong> scheme.<img src="/images/signal_and_continue.png" alt="" title="State transition diagram for &quot;signal-and-continue&quot; monitors. Image from: http://www.inf.ed.ac.uk/teaching/courses/ppls/pplsslides.pdf"><br>For a <code>condition_variables x;</code></p><ul><li><code>wait(x)</code>: Release lock; wait for the condition to become true; reacquire lock upon return (Java wait())</li><li><code>Signal(x)</code>: Wake up a waiter, if any (Java notify())</li><li><code>signal-all(x)</code>or<code>Broadcast(x)</code>: Wake up all the waiters (Java notifyAll())</li></ul><p>For the thread active inside a monitor method - <strong>executing in monitor state</strong></p><ul><li>If the thread could not proceed, it may call the <code>wait(cv)</code> operation to <strong>give up the (implicit) lock</strong> it holds on the monitor, and being <strong>suspended</strong> (push to the end of CV queue). Each CV has its unique block queue.</li><li>Or the thread could calls the operation <code>signal(cv)</code> to release the lock. This allow one previously blocked thread (normally chosen by a FIFO discipline) to <strong>become ready for scheduling</strong> again (only one will be allowed to enter the <strong>monitor entry queue</strong> at a time). The signalling thread <strong>continues</strong> uninterrupted.</li><li>Or <code>return()</code>.</li></ul><p>If no threads are waiting, then a <code>signal()</code> is <strong>“lost”</strong> or “forgotten”, whereas a <code>V()</code> in Semaphores allows a subsequent <code>P()</code> to proceed.</p><p>Monitor semantics mean that when a thread which was previously blocked on a condition is actually awakened again in the monitor.</p><p>The point to remember is that when the signal happened, the signalled thread was allowed to <strong>try to acquire the monitor lock</strong> again). It could be that some other thread acquires the lock first, and does something which negates the condition again (for example, it consumes the “new item” from a monitor protected buffer).</p><p>Thus it is often <strong>necessary</strong>, in all but the most tightly constrained situations, to wrap each conditional variable <code>wait()</code> call in a loop which rechecks the condition it was waiting for is still true.</p><p><strong>Single producer, single consumer bounder buffer</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">monitor Bounded_Buffer &#123;</span><br><span class="line">    typeT buf[n];                     # an array of some type T</span><br><span class="line">    int front = 0,                    # index of first full slot</span><br><span class="line">        rear = 0;                     # index of first empty slot</span><br><span class="line">        count = 0;                    # number of full slots</span><br><span class="line">    ## rear == (front + count) % n</span><br><span class="line">    condition_variables not_full,     # signaled when count &lt; n</span><br><span class="line">                        not_empty;    # signaled when count &gt; 0</span><br><span class="line">    procedure deposit(typeT data) &#123;   # 存</span><br><span class="line">        while (count == n) wait(not_full);</span><br><span class="line">        buf[rear] = data; rear = (rear+1) % n; count++;</span><br><span class="line">        signal(not_empty);</span><br><span class="line">    &#125;</span><br><span class="line">    procedure fetch(typeT &amp;result) &#123;  # 取</span><br><span class="line">        while (count == 0) wait(not_empty);</span><br><span class="line">        result = buf[front]; front = (front+1) % n; count--;</span><br><span class="line">        signal(not_full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Why the while loop is necessary</strong> as a safety check on the <code>wait</code> calls (why not use if)? - 因为<code>notify()</code>只会让正在 wait queue 的 thread 进入准备状态, 但不会直接控制其恢复工作（是否马上开始，谁先开始，都是由os内部控制的）, 所以导致不同 thread 进度不同; 而<code>while</code>可以保证当即使 thread 因为受到<code>notify()</code>而结束<code>wait()</code>开始进入准备状态(entry queue)后, 继续检查 buffer 状态, 这样假如发现自己是最优先安排的那个, 就可以跳出<code>while</code>循环进入工作状态; 假如发现自己优先度不是最高的(<code>while</code>循环条件继续满足), 则继续<code>wait()</code>.</p><p>The key difference to semaphores: <code>signal()</code> on a condition variable is not “remembered” in the way that <code>V()</code> on a semaphore is. If no threads are waiting, then a <code>signal()</code> is “lost” or “forgotten”, whereas a <code>V()</code> will allow a subsequent <code>P()</code> to proceed.</p><h2 id="Real-Shared-Variable-Programming-Systems"><a href="#Real-Shared-Variable-Programming-Systems" class="headerlink" title="Real Shared Variable Programming Systems"></a>Real Shared Variable Programming Systems</h2><p>Various concepts for shared variable programming have been embedded in real programming systems. In particular C’s <strong>Posix threads (Pthreads)</strong> library and <strong>Java’s threads and monitors</strong>.</p><h2 id="POSIX-Threads-Pthread"><a href="#POSIX-Threads-Pthread" class="headerlink" title="POSIX Threads (Pthread)"></a>POSIX Threads (Pthread)</h2><p>Create a new thread: Threads (type <code>pthread_t</code>) begin by executing a given function, and terminate when that function exits (or when killed off by another thread).<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span> <span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">p_thread_attr_t</span> *attr,</span></span></span><br><span class="line">                    void *(*function) (void *), void *arguments);</span><br></pre></td></tr></table></figure></p><p>Wait for thread termination: <code>int pthread_join (pthread_t t, void ** result);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个简单但是有错误的例子，</span></span><br><span class="line"><span class="keyword">int</span> target;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">adderthread</span> <span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        target = target+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i; <span class="keyword">pthread_t</span> thread[P];</span><br><span class="line">    target = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;P; i++) &#123;</span><br><span class="line">        pthread_create(&amp;thread[i], <span class="literal">NULL</span>, adderthread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Variable <code>target</code> is accessible to all threads (shared memory). Its increment is <strong>not atomic</strong>, so we may get unpredictable results.</p><p>POSIX provides mechanisms to coordinate accesses including <strong>semaphores</strong> and building blocks for <strong>monitors</strong>.</p><h3 id="Pthreads-semaphores"><a href="#Pthreads-semaphores" class="headerlink" title="Pthreads semaphores"></a>Pthreads semaphores</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用 pthread semaphores 改写前面的代码</span></span><br><span class="line"><span class="keyword">sem_t</span> lock;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">adderthread</span> <span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        sem_wait(&amp;lock);</span><br><span class="line">        target = target+<span class="number">1</span>;</span><br><span class="line">        sem_post(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    target = <span class="number">0</span>;</span><br><span class="line">    sem_init(&amp;lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>sem_init(&amp;sem, share, init)</code>, where init is the initial value and share is a “boolean” (in the C sense) indicating whether the semaphore will be shared between processes (true) or just threads within a process (false).</li><li><code>sem_wait(s)</code>, which is the Posix name for P(s)</li><li><code>sem_post(s)</code>, which is the Posix name for V(s)</li></ol><p>A Producers &amp; Consumers:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sem_t</span> empty, full; <span class="comment">// the global semaphores</span></span><br><span class="line"><span class="keyword">int</span> data; <span class="comment">// shared buffer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pid, cid;</span><br><span class="line">    ....</span><br><span class="line">    sem_init(&amp;empty, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// sem empty = 1</span></span><br><span class="line">    sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// sem full = 0</span></span><br><span class="line">    pthread_create(&amp;pid, &amp;attr, Producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cid, &amp;attr, Consumer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cid, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Producer</span> <span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> produced;</span><br><span class="line">    <span class="keyword">for</span> (produced = <span class="number">0</span>; produced &lt; numIters; produced++) &#123;</span><br><span class="line">        sem_wait(&amp;empty);</span><br><span class="line">        data = produced;</span><br><span class="line">        sem_post(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Consumer</span> <span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>, consumed;</span><br><span class="line">    <span class="keyword">for</span> (consumed = <span class="number">0</span>; consumed &lt; numIters; consumed++) &#123;</span><br><span class="line">        sem_wait(&amp;full);</span><br><span class="line">        total = total+data;</span><br><span class="line">        sem_post(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after %d iterations, the total is %d (should be %d)\n"</span>, numIters, total, numIters*(numIters+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Pthreads-Monitors"><a href="#Pthreads-Monitors" class="headerlink" title="Pthreads Monitors"></a>Pthreads Monitors</h3><p>Pthreads provides <strong>locks</strong>, of type <code>pthread_mutex_t m;</code>. These can be</p><ul><li><strong>Initialized</strong> with <code>pthread_mutex_init(&amp;m, attr)</code>, where attr are attributes concerning scope (as with semaphore creation). If attr is <code>NULL</code>, the default mutex attributes (NONRECURSIVE) are used;</li><li><strong>Locked</strong> with <code>pthread_mutex_lock(&amp;m)</code>, which blocks the locking thread if <code>m</code> is already locked. There is also a non-blocking version <code>pthread_mutex_trylock(&amp;m)</code>.</li><li><strong>Unlocked</strong> with <code>pthread_mutex_unlock(&amp;m)</code>. Only a thread which holds a given lock, should unlock it!</li></ul><p>Pthreads provides <strong>condition variables</strong> <code>pthread_cond_t</code>. As well as the usual initialization, these can be:</p><ul><li><strong>Waited</strong> on with <code>pthread_cond_wait(&amp;cv, &amp;mut)</code> where <code>cv</code> is a condition variable, and <code>mut</code> must be a lock already held by this thread, and which is implictly released.</li><li><strong>Signalled</strong> with <code>pthread_cond_signal(&amp;cv)</code> by a thread which should (but doesn’t strictly have to) hold the associated mutex. The semantics are “Signal-and-Continue” as previously discussed.</li><li><strong>Signalled all</strong> with <code>pthread_cond_broadcast(&amp;cv)</code>. This is “signal-all”</li></ul><p>A simple Jacobi grid-iteration program with a re-usable Counter Barrier. To avoid copying between “new” and “old” grids, each iteration performs two Jacobi steps. Convergence testing could be added as before.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> barrier; <span class="comment">// mutex semaphore for the barrier</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> go;       <span class="comment">// condition variable for leaving</span></span><br><span class="line"><span class="keyword">int</span> numArrived = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Barrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;barrier);</span><br><span class="line">    numArrived++;</span><br><span class="line">    <span class="keyword">if</span> (numArrived == numWorkers) &#123;</span><br><span class="line">        numArrived = <span class="number">0</span>;</span><br><span class="line">        pthread_cond_broadcast(&amp;go);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pthread_cond_wait(&amp;go, &amp;barrier);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;barrier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> workerid[MAXWORKERS];</span><br><span class="line">    pthread_mutex_init(&amp;barrier, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;go, <span class="literal">NULL</span>);</span><br><span class="line">    InitializeGrids();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numWorkers; i++)</span><br><span class="line">        pthread_create(&amp;workerid[i], &amp;attr, Worker, (<span class="keyword">void</span> *) i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numWorkers; i++)</span><br><span class="line">        pthread_join(workerid[i], <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Worker</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myid = (<span class="keyword">int</span>) arg, rowA = myid*rowshare+<span class="number">1</span>, rowB = rowA+rowshare<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (iters = <span class="number">1</span>; iters &lt;= numIters; iters++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = rowA; i &lt;= rowB; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= gridSize; j++) &#123;</span><br><span class="line">                grid2[i][j] = (grid1[i<span class="number">-1</span>][j] + grid1[i+<span class="number">1</span>][j] + grid1[i][j<span class="number">-1</span>] + grid1[i][j+<span class="number">1</span>]) * <span class="number">0.25</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Barrier();</span><br><span class="line">        <span class="keyword">for</span> (i = rowA; i &lt;= rowB; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= gridSize; j++) &#123;</span><br><span class="line">                grid1[i][j] = (grid2[i<span class="number">-1</span>][j] + grid2[i+<span class="number">1</span>][j] + grid2[i][j<span class="number">-1</span>] + grid2[i][j+<span class="number">1</span>]) * <span class="number">0.25</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Barrier();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Memory-Consistency-in-Pthreads"><a href="#Memory-Consistency-in-Pthreads" class="headerlink" title="Memory Consistency in Pthreads"></a>Memory Consistency in Pthreads</h3><p>Weak consistency models can wreck naive DIY synchronization attempts!</p><p>To enable portability, Pthreads mutex, semaphore and condition variable operations <strong>implicitly act as memory fences</strong>, executing architecture specific instructions.</p><p>In effect, the C + Pthreads combination guarantees a <strong>weak consistency memory model</strong>, with the only certainties provided at uses of Pthreads primitives.</p><p>For example, all writes by a thread which has released some <strong>mutex</strong>, are guaranteed to be seen by any thread which then acquires it. Nothing can be assumed about the visibility of writes which cannot be seen to be ordered by their relationship to uses of Pthread primitives.</p><p>The programmer must also be careful to use only <strong>thread-safe</strong> code, which works irrespective of how many threads are active.</p><blockquote><p>Thread-safe code only manipulates shared data structures in a manner that ensures that all threads behave properly and fulfill their design specification without unintended interaction. Implementation is guaranteed to be free of race conditions when accessed by multiple threads simultaneously.</p></blockquote><p>Typical problems involve the use of non-local data. For example, imagine a non-thread safe <code>malloc</code>. Unluckily interleaved calls might break the underlying free space data structure. Some libraries will provide thread-safe versions (but of course, which pay an unnecessary performance penalty when used in a single threaded program).</p><h2 id="Java-Concurrency"><a href="#Java-Concurrency" class="headerlink" title="Java Concurrency"></a>Java Concurrency</h2><p>Java是一种多线程 multi-threaded 编程语言，其同步模型是基于 monitor 概念，可用于开发多线程程序。多任务 multtasking 就是多个进程共享公共处理资源（如CPU）的时候。多线程将多任务的思想扩展到可以将单个应用程序中的特定操作细分为单独线程的应用程序。每个线程都可以并行运行。操作系统不仅在不同的应用程序之间分配处理时间，而且在应用程序内的每个线程之间分配处理时间。</p><h3 id="Java-Threads"><a href="#Java-Threads" class="headerlink" title="Java Threads"></a>Java Threads</h3><p><img src="https://www.tutorialspoint.com/java/images/Thread_Life_Cycle.jpg" alt="" title="Life Cycle of a Thread. image from: http://www.tutorialspoint.com/java/java_multithreading.htm"><br>Threads can be created from classes which extend <code>java.lang.Thread</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is a thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Simple().start(); <span class="comment">// implicitly calls the run() method</span></span><br></pre></td></tr></table></figure></p><p>Or implement <code>java.lang.Runnable</code> (so we can extend some other class too).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bigger</span> <span class="keyword">extends</span> <span class="title">Whatever</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; .... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Thread( <span class="keyword">new</span> Bigger (...) ).start();</span><br></pre></td></tr></table></figure></p><p>Wait to join with another thread<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Friend</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> me;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Friend</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; me = i; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello from thread "</span> + me);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="title">throws</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">InterruptedException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i; Friend t[] = <span class="keyword">new</span> Friend[n];</span><br><span class="line">        System.out.println (<span class="string">"Hello from the main thread"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            t[i] = <span class="keyword">new</span> Friend(i);</span><br><span class="line">            t[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            t[i].join(); <span class="comment">// might throw java.lang.InterruptedException</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println (<span class="string">"Goodbye from the main thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Java-“Monitors”"><a href="#Java-“Monitors”" class="headerlink" title="Java “Monitors”"></a>Java “Monitors”</h3><p>Java provides an implementation of the <strong>monitor</strong> concept (but doesn’t actually have monitor as a keyword).</p><p>Any object in a Java program can, in effect, become a monitor, simply by declaring one or more of its methods to be <strong>synchronized</strong>, or by including a synchronized block of code.</p><p>Each such object is associated with one, <strong>implicit lock</strong>. A thread executing any <code>synchronized</code> code must first acquire this lock. This happens implicitly (i.e. there is no source syntax). Similarly, upon leaving the synchronized block the lock is <strong>implicitly released</strong>.</p><p>Java’s <strong>condition variable</strong> mechanism uses <strong>Signal-and-Continue</strong> semantics (The signalling thread continues uninterrupted). Each synchronizable object is associated with a <strong>single implicit condition variable</strong>. Manipulated with methods <code>wait()</code>, <code>notify()</code> and <code>notifyAll()</code>. We can only have <strong>one conditional variable queue per monitor</strong> (hence the absence of any explicit syntax for the condition variable itself).</p><p><code>wait()</code>: has three variance, one which waits indefinitely for any other thread to call notify or notifyAll method on the object to wake up the current thread. Other two variances puts the current thread in wait for specific amount of time before they wake up.</p><p><code>notify()</code>: <strong>wakes up only one thread</strong> waiting on the object and that thread starts execution.</p><p><code>notifyAll()</code>: <strong>wakes up all the threads</strong> waiting on the object, although which one will process first depends on the OS implementation.</p><p>These methods can be used to implement producer consumer problem where consumer threads are waiting for the objects in Queue and producer threads put object in queue and notify the waiting threads.</p><p><strong>Readers &amp; Writers problem</strong> requires control access to some shared resource, such that there may be many concurrent readers, but only one writer (with exclusive access) at a time.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 2 readers and 2 writers making 5 accesses each</span></span><br><span class="line"><span class="comment">with concurrent read or exclusive write.  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadWrite</span> </span>&#123; <span class="comment">// driver program -- two readers and two writers</span></span><br><span class="line">    <span class="keyword">static</span> Database RW = <span class="keyword">new</span> Database(); <span class="comment">// the monitor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rounds = Integer.parseInt(arg[<span class="number">0</span>],<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> Reader(rounds, RW).start();</span><br><span class="line">        <span class="keyword">new</span> Reader(rounds, RW).start();</span><br><span class="line">        <span class="keyword">new</span> Writer(rounds, RW).start();</span><br><span class="line">        <span class="keyword">new</span> Writer(rounds, RW).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rounds; Database RW;</span><br><span class="line">    <span class="keyword">private</span> Random generator = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reader</span><span class="params">(<span class="keyword">int</span> rounds, Database RW)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rounds = rounds;</span><br><span class="line">        <span class="keyword">this</span>.RW = RW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;rounds; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(generator.nextInt(<span class="number">500</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.lang.InterruptedException e) &#123;&#125;</span><br><span class="line">            System.out.println(<span class="string">"read: "</span> + RW.read());</span><br><span class="line">        &#125;    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rounds; Database RW;</span><br><span class="line">    <span class="keyword">private</span> Random generator = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(<span class="keyword">int</span> rounds, Database RW)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rounds = rounds;</span><br><span class="line">        <span class="keyword">this</span>.RW = RW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;rounds; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(generator.nextInt(<span class="number">500</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.lang.InterruptedException e) &#123;&#125;</span><br><span class="line">            RW.write();</span><br><span class="line">        &#125;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Implement the “database”. Allowing several readers to be actively concurrently. The last reader to leave will signal a waiting writer.</p><p>Thus we need to count readers, which implies <strong>atomic update</strong> of the count. A reader needs <strong>two protected sections</strong> to achieve this.</p><p>Notice that while readers are actually reading the data they do not hold the lock.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data = <span class="number">0</span>; <span class="comment">// the data</span></span><br><span class="line">    <span class="keyword">int</span> nr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// synchronized means no more than one thread could do that</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startRead</span><span class="params">()</span> </span>&#123; nr++; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">endRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nr--;</span><br><span class="line">        <span class="keyword">if</span> (nr==<span class="number">0</span>) notify(); &#125;<span class="comment">// awaken a waiting writer</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> snapshot;</span><br><span class="line">        startRead();</span><br><span class="line">        snapshot = data;      <span class="comment">// read data</span></span><br><span class="line">        endRead();</span><br><span class="line">        <span class="keyword">return</span> snapshot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span> (nr&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123; wait(); &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line"></span><br><span class="line">        temp = data; <span class="comment">// next six lines are the ‘‘database’’ update!</span></span><br><span class="line">        data = <span class="number">99999</span>; <span class="comment">// to simulate an inconsistent temporary state</span></span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(generator.nextInt(<span class="number">500</span>)); <span class="comment">// wait a bit, for demo purposes only</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.InterruptedException e) &#123;&#125;</span><br><span class="line">        data = temp+<span class="number">1</span>; <span class="comment">// back to a safe state</span></span><br><span class="line">        System.out.println(<span class="string">"wrote: "</span> + data);</span><br><span class="line">        notify(); <span class="comment">// awaken another waiting writer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>We could express the same effect with synchronized blocks<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> snapshot;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; nr++; &#125; <span class="comment">// this - the database object</span></span><br><span class="line">    snapshot = data;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        nr--;</span><br><span class="line">        <span class="keyword">if</span> (nr==<span class="number">0</span>) notify(); <span class="comment">// awaken a waiting writer</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> snapshot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Would it be OK to use <code>notifyAll()</code> in <code>read()</code>? - <strong>Yes</strong>, but with extra transmission cost.</p><p><strong>Buffer for One Producer - One Consumer</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** (borrowed from Skansholm, Java from the Beginning) */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> <span class="keyword">extends</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putLast</span> <span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        addElement(obj); <span class="comment">// Vectors grow implicitly</span></span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">getFirst</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isEmpty())</span><br><span class="line">            <span class="keyword">try</span> &#123;wait();&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">        Object obj = elementAt(<span class="number">0</span>);</span><br><span class="line">        removeElementAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="The-java-util-concurrent-package"><a href="#The-java-util-concurrent-package" class="headerlink" title="The java.util.concurrent package"></a>The <code>java.util.concurrent</code> package</h3><p>Including a re-usable <strong>barrier</strong> and <strong>semaphores</strong> (with P() and V() called <code>acquire()</code> and <code>release()</code>). It also has some thread-safe concurrent data structures (queues, hash tables).</p><p>The <code>java.util.concurrent.atomic</code> package provides implementations of <strong>atomically accessible</strong> integers, booleans and so on, with atomic operations like <code>addAndGet</code>, <code>compareAndSet</code>.</p><p>The <code>java.util.concurrent.locks</code> package provides implementations of <strong>locks and condition variables</strong>, to allow a finer grained, more explicit control than that provided by the built-in synchronized monitors.</p><h2 id="Message-Passing-Programming"><a href="#Message-Passing-Programming" class="headerlink" title="Message Passing Programming"></a>Message Passing Programming</h2><p>When the underyling archictecture doesn’t support physically shared memory (for example, by distributing the OS and virtual memory system, i.e. <strong>Multicomputer architectures</strong>), we can make the disjoint nature of the address spaces apparent to the programmer, who must make decisions about data distribution and invoke explicit operations to allow interaction across these.</p><p><strong>Message passing</strong>, which is a approache to abstract and implement such a model, dominates the performance-oriented parallel computing world.</p><p>Message passing is characterized as requiring the <strong>explicit participation</strong> of both interacting processes, since each address space can only be directly manipulated by its owner. The basic requirement is thus for <strong>send</strong> and <strong>receive</strong> primitives for transferring data out of and into local address spaces.</p><p>The resulting programs can seem quite fragmented: we express algorithms as a collection of local perspectives. These are often captured in a single program source using <strong>Single Program Multiple Data (SPMD)</strong> style, with different processes following different paths through the same code, branching with respect to local data values and/or to some process identifier.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPMD Compare-Exchange</span><br><span class="line">co [me = 0 to P-1] &#123; // assumes P is even</span><br><span class="line">  int a, temp;       // these are private to each process now</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  // typical one step within a parallel sorting algorithm</span><br><span class="line">  if (me%2 == 0) &#123;</span><br><span class="line">      send (me+1, a);    // send from a to process me+1</span><br><span class="line">      recv (me+1, temp); // receive into temp from process me+1</span><br><span class="line">      a = (a&lt;=temp) ? a : temp; // 取较小值</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      send (me-1, a);</span><br><span class="line">      recv (me-1, temp);</span><br><span class="line">      a = (a&gt;temp) ? a : temp; // 取较大值</span><br><span class="line">  &#125; ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/SPMD_Compare_Exchange.png" alt="" title="Image from: http://www.inf.ed.ac.uk/teaching/courses/ppls/pplsslides.pdf"><br>1, <strong>Synchronization</strong>: Must a sending process pause until a matching receive has been executed (<strong>synchronous</strong>), or not (<strong>asynchronous</strong>)? Asynchronous semantics require the implementation to buffer messages which haven’t yet been, and indeed may never be, received. If we use synchronous semantics, the compare-exchange code above will deadlock. Can you fix it?</p><blockquote><p>One way s to make the send be a  non-blocking one (<code>MPI_Isend</code>)<br>Another way is to reverse the order of one of the send/receive pairs:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#125; else &#123;</span><br><span class="line">    recv (me-1, temp);</span><br><span class="line">    send (me-1, a);</span><br><span class="line">    a = (a&gt;temp) ? a : temp; // 取较大值</span><br><span class="line">&#125; ......</span><br></pre></td></tr></table></figure></p></blockquote><p>2, <strong>Addressing</strong>: When we invoke a send (or receive) do we have to specify a unique destination (or source) process or can we use <strong>wild-cards</strong>? Do we require program-wide process naming, or can we create process groups and aliases?<br>3, <strong>Collective Operations</strong>: Do we restrict the programmer to single-source, single-destination, point-to-point messages, or do we provide abstractions of more complex data exchanges involving several partners?<img src="/images/Collective_Operations.jpg" alt="" title="Image from: http://www.inf.ed.ac.uk/teaching/courses/ppls/pplsslides.pdf">• Broadcast: Everyone gets a copy of the same value.<br>• Scatter: Data is partitioned and spread across the group.<br>• Gather: Data is gathered from across the group.<br>• Reduction: Combine the gathered values with an associative operation.<br>• Scan (Prefix): Reduce and also compute all the ordered partial reductions.</p><h2 id="Message-Passing-Interface-MPI"><a href="#Message-Passing-Interface-MPI" class="headerlink" title="Message Passing Interface (MPI)"></a>Message Passing Interface (MPI)</h2><blockquote><p>Message Passing Interface (MPI) is a standardized and portable message-passing standard. The standard defines the syntax and semantics of a core of library routines useful to a wide range of users writing portable message-passing programs in C, C++, and Fortran.</p></blockquote><p>Processes can be created <strong>statically</strong> when the program is invoked (e.g. using the mpirun command) or spawned <strong>dynamically</strong>.</p><p>All communications take place within the context of “communication spaces” called <strong>communicators</strong>, which denote sets of processes, allows the MPI programmer to define <strong>modules</strong> that encapsulate internal communication structures. A process can belong to many communicators simultaneously. New communicators can be defined dynamically.</p><p>Simple send/receives operate with respect to other processes in a communicator. <strong>Send must specify a target</strong> but receive can wild card on matching sender.</p><p>Messages can be tagged with an extra value to aid disambiguation.</p><p>Message-passing programming models are by default <strong>nondeterministic</strong>: the arrival order of messages sent from two processes A and B, to a third process C, is not defined. (However, MPI does guarantee that two messages sent from one process A, to another process B, will arrive in the order sent.)</p><p>There are many <strong>synchronization modes</strong> and a range of <strong>collective operations</strong>.</p><h3 id="MPI-Primitives-6-basics-functions"><a href="#MPI-Primitives-6-basics-functions" class="headerlink" title="MPI Primitives (6 basics functions)"></a>MPI Primitives (6 basics functions)</h3><p>1, <code>int MPI_Init(int *argc, char ***argv)</code>: Initiate an MPI computation.<br>2, <code>int MPI_Finalize()</code>: Terminate a computation.<br>These must be called <strong>once</strong> by every participating process, before/after any other MPI calls. They return <strong>MPI_SUCCESS</strong> if successful, or an error code.</p><p>Each process has a <strong>unique identifier</strong> in each communicator of which it is a member (range 0…members-1). <code>MPI_COMM_WORLD</code> is the built-in <strong>global communicator</strong>, to which all processes belong by default.</p><p>A process can find the size of a communicator, and its own rank within it:<br>3, <code>int MPI_Comm_Size (MPI_Comm comm, int *np)</code>: Determine number of processes (comm - communicator). The processes in a process group are identified with unique, contiguous integers numbered from 0 to <code>np-1</code>.<br>4, <code>int MPI_Comm_rank (MPI_Comm comm, int *me)</code>: Determine my process identifier.</p><p>5, <code>MPI_SEND</code>: Send a message.<br>6, <code>MPI_RECV</code>: Receive a message.</p><h3 id="MPI-Task-Farm"><a href="#MPI-Task-Farm" class="headerlink" title="MPI Task Farm"></a>MPI Task Farm</h3><p>A task farm is bag-of-tasks in which <strong>all the tasks are known</strong> from the beginning. The challenge is to assign them <strong>dynamically</strong> to worker processes, to allow for the possibility that some tasks may take much longer to compute than others.</p><p>To simplify the code, we assume that there are <strong>at least as many tasks as processors</strong> and that tasks and results are just integers. In a real application these would be more complex data structures.</p><p>Notice the handling of the characteristic <strong>non-determinism</strong> in the order of task completion, with tags used to identify tasks and results. We also use a special tag to indicate an “end of tasks” message.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** SPMD style</span></span><br><span class="line"><span class="comment">农场主分配任务给工人 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TASKS 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO_MORE_TASKS MAX_TASKS+1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FARMER 0  <span class="comment">// 第一个 process 是farmer,其余是worker</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np, rank;</span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;np);</span><br><span class="line">    <span class="keyword">if</span> (rank == FARMER) &#123;</span><br><span class="line">        farmer(np<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        worker();</span><br><span class="line">    &#125;</span><br><span class="line">    MPI_Finalize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">farmer</span> <span class="params">(<span class="keyword">int</span> workers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, task[MAX_TASKS], result[MAX_TASKS], temp, tag, who; MPI_Status status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1, 给每个人发送任务</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;workers; i++) &#123;</span><br><span class="line">        MPI_Send(&amp;task[i], <span class="number">1</span>, MPI_INT, i+<span class="number">1</span>, i, MPI_COMM_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2, 收取任务结果, 继续发放剩余任务</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;MAX_TASKS) &#123;</span><br><span class="line">        MPI_Recv(&amp;temp, <span class="number">1</span>, MPI_INT, MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">        who = status.MPI_SOURCE; tag = status.MPI_TAG;</span><br><span class="line">        result[tag] = temp;</span><br><span class="line">        MPI_Send(&amp;task[i], <span class="number">1</span>, MPI_INT, who, i, MPI_COMM_WORLD);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3, 所有任务已经完成, 收集最后一个任务结果, 并且发出结束任务信号</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;workers; i++) &#123;</span><br><span class="line">        MPI_Recv(&amp;temp, <span class="number">1</span>, MPI_INT, MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">        who = status.MPI_SOURCE; tag = status.MPI_TAG;</span><br><span class="line">        result[tag] = temp;</span><br><span class="line">        MPI_Send(&amp;task[i], <span class="number">1</span>, MPI_INT, who, NO_MORE_TASKS, MPI_COMM_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Notice that the final loop, which gathers the last computed tasks, has a predetermined bound. We know that this loop begins after dispatch of the last uncomputed task, so there must be exactly as many results left to gather as there are workers.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> task, result, tag;</span><br><span class="line">    MPI_Status status;</span><br><span class="line">    MPI_Recv(&amp;task, <span class="number">1</span>, MPI_INT, FARMER, MPI_ANY_TAG, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">    tag = status.MPI_TAG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tag != NO_MORE_TASKS) &#123;</span><br><span class="line">        result = somefunction(task);</span><br><span class="line">        MPI_Send(&amp;result, <span class="number">1</span>, MPI_INT, FARMER, tag, MPI_COMM_WORLD);</span><br><span class="line">        MPI_Recv(&amp;task, <span class="number">1</span>, MPI_INT, FARMER, MPI_ANY_TAG, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">        tag = status.MPI_TAG;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>A worker is only concerned with its interaction with the farmer. 这样速度较快的worker可以自动接更多的任务，最终整体上达成 load balance。</p><h3 id="Send-in-standard-mode"><a href="#Send-in-standard-mode" class="headerlink" title="Send in standard mode"></a>Send in standard mode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Send</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">int</span> count, MPI_Datatype datatype, <span class="keyword">int</span> dest,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int</span> tag, MPI_Comm comm)</span></span></span><br></pre></td></tr></table></figure><p>Send <code>count</code> items of given type starting in position <code>buf</code> to process <code>dest</code> in communicator <code>comm</code>, tagging the message with <code>tag</code> (which must be non-negative).</p><p>There are corresponding datatypes for each basic C type, <code>MPI_INT</code>, <code>MPI_FLOAT</code> etc, and also facilities for constructing <strong>derived types</strong> which group these together.</p><p>Are <code>MPI_Send</code> and <code>MPI_Recv</code> synchronous or asynchronous?</p><h3 id="Receive-in-standard-mode"><a href="#Receive-in-standard-mode" class="headerlink" title="Receive in standard mode"></a>Receive in standard mode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">int</span> count, MPI_Datatype datatype, <span class="keyword">int</span> source,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">int</span> tag, MPI_Comm comm, MPI_Status *status)</span></span></span><br></pre></td></tr></table></figure><p>Receive <code>count</code> items of given type starting in position <code>buf</code>, from process <code>source</code> in communicator <code>comm</code>, tagged by <code>tag</code>. It attempts to receive a message that has an envelope corresponding to the specified <code>tag</code>, <code>source</code>, and <code>comm</code>, <strong>blocking</strong> until such a message is available. When the message arrives, elements of the specified datatype are placed into the buffer at address <code>buf</code>. This buffer is guaranteed to be large enough to contain at least <code>count</code> elements.</p><p><strong>Non-determinism</strong> (within a communicator) is achieved with “wild cards”, by naming <code>MPI_ANY_SOURCE</code> and/or <code>MPI_ANY_TAG</code> as the source or tag respectively.</p><p>A receive can match any available message sent to the receiver which has the specified communicator, tag and source, subject to the constraint that messages sent <strong>between any particular pair of processes</strong> are guaranteed to appear to be <strong>non-overtaking</strong>. In other words, a receive cannot match message B in preference to message A if A was sent before B by the same process, the receive will receive the first one which was sent, not the first one to arrive.</p><p>The <code>status</code> variable can be used subsequently to inquire about the <code>size</code>, <code>tag</code>, and <code>source</code> of the received message. <strong>Status information</strong> is returned in a structure with <code>status.MPI_SOURCE</code> and <code>status.MPI_TAG</code> fields. This is useful in conjunction with <strong>wild card</strong> receives, allowing the receiver to determine the actual source and tag associated with the received message.</p><h3 id="Prime-Sieve-Generator"><a href="#Prime-Sieve-Generator" class="headerlink" title="Prime Sieve Generator"></a>Prime Sieve Generator</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    MPI_Comm nextComm; <span class="keyword">int</span> candidate = <span class="number">2</span>, N = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">    MPI_Comm_spawn(<span class="string">"sieve"</span>, argv, <span class="number">1</span>, MPI_INFO_NULL, <span class="number">0</span>, MPI_COMM_WORLD, &amp;nextComm, MPI_ERRCODES_IGNORE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (candidate&lt;N) &#123;</span><br><span class="line">        MPI_Send(&amp;candidate, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, nextComm);</span><br><span class="line">        candidate++;</span><br><span class="line">    &#125;</span><br><span class="line">    candidate = <span class="number">-1</span>;</span><br><span class="line">    MPI_Send(&amp;candidate, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, nextComm);</span><br><span class="line">    MPI_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We use <code>MPI_Comm_spawn</code> to <strong>dynamically create</strong> new sieve processes as we need them, and <code>MPI_Comm_get_parent</code> to find an inter-communicator to the process group which created us.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    MPI_Comm predComm, succComm; MPI_Status status;</span><br><span class="line">    <span class="keyword">int</span> myprime, candidate;</span><br><span class="line">    <span class="keyword">int</span> firstoutput = <span class="number">1</span>;            <span class="comment">// a C style boolean</span></span><br><span class="line">    MPI_Init (&amp;argc, &amp;argv);</span><br><span class="line">    MPI_Comm_get_parent (&amp;predComm);</span><br><span class="line">    MPI_Recv(&amp;myprime, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, predComm, &amp;status);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d is a prime\n"</span>, myprime);</span><br><span class="line">    MPI_Recv(&amp;candidate, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, predComm, &amp;status);</span><br><span class="line">    <span class="keyword">while</span> (candidate!=<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate%myprime != <span class="number">0</span>) &#123;    <span class="comment">// not sieved out</span></span><br><span class="line">            <span class="keyword">if</span> (firstoutput) &#123;      <span class="comment">// create my successor if necessary</span></span><br><span class="line">                MPI_Comm_spawn(<span class="string">"sieve"</span>, argv, <span class="number">1</span>, MPI_INFO_NULL, <span class="number">0</span>,  MPI_COMM_WORLD, &amp;succComm, MPI_ERRCODES_IGNORE);</span><br><span class="line">                firstoutput = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            MPI_Send(&amp;candidate, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, succComm) <span class="comment">// pass on the candidate</span></span><br><span class="line">        &#125;</span><br><span class="line">        MPI_Recv(&amp;candidate, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, predComm, &amp;status); <span class="comment">// next candidate</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!firstoutput) MPI_Send(&amp;candidate, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, succComm); <span class="comment">// candidate=-1, shut down</span></span><br><span class="line">    MPI_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>The message flow is insured by the method in which new processes are spawned/created. Every time a new “sieve” process is spawned, MPI creates it in a new group/communicator. succComm is a handle to this new group which always contains only one process. Therefore, when a candidate is sent to the process, there is only one process in the succComm group and it has id 0.</p><p>The Recv function works in the same way predComm is a handle of the parent group (i.e. group of the process that created this sieve). And because the parent was the only process in this group/communicator, it can be identified by id 0.</p><p>In conclusion, a process creates at most one successor. This successor is the only process in its group/communicator. The succCom and predComm are handles to the children and parent groups respectively, both of which contain a single process with id 0 which is unique in its own group/communicator.</p><p>Spawning New MPI Processes<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Comm_spawn</span> <span class="params">(<span class="keyword">char</span> *command, <span class="keyword">char</span> *argv[], <span class="keyword">int</span> p, MPI_Info info,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> root, MPI_Comm comm, MPI_Comm *intercomm, <span class="keyword">int</span> errcodes[])</span></span></span><br></pre></td></tr></table></figure></p><p>This <strong>spawns</strong> p new processes, each executing a copy of program <code>command</code>, in a new communicator returned as <code>intercomm</code>. To the new processes, <code>intercomm</code> appears as <code>MPI_COMM_WORLD</code>. It must be<br>called by <strong>all processes</strong> in <code>comm</code> (it is “collective”), with process root computing the parameters. <code>info</code> and <code>errcodes</code> are used in system dependent ways to control/monitor process placement, errors etc.</p><p><code>MPI_Comm_get_parent</code> gives the new processes a reference to the communicator which created them.</p><h3 id="Synchronization-in-MPI"><a href="#Synchronization-in-MPI" class="headerlink" title="Synchronization in MPI"></a>Synchronization in MPI</h3><p>MPI uses the term <strong>blocking</strong> in a slightly unconventional way, to refer to the relationship between the <strong>caller</strong> of a communication operation and the <strong>implementation</strong> of that operation (i.e. nothing to do with any matching operation).<img src="/images/Synchronization_in_MPI.png" alt="" title="Image from: http://www.inf.ed.ac.uk/teaching/courses/ppls/pplsslides.pdf"><br>Thus, a <strong>blocking send</strong> complete only when it is safe to reuse the specified output buffer (because the data has been copied somewhere safe by the system). 注意这里跟前面提到的<strong>synchronous</strong>概念不一样，synchronous 强调<strong>接收成功</strong>才是判断发送成功与否的标识，而 blocking 只需要保证缓存可以被安全改写即可。</p><p>In contrast, a process calling a <strong>non-blocking send</strong> continues immediately with unpredictable effects on the value actually sent. Similarly, there is a <strong>non-blocking receive</strong> operation which allows the calling process to continue immediately, with similar issues concerning the values which appear in the buffer. 意义在于，当需要发送的信息字节非常巨大时，发送和接收耗时都非常久，这时候如果可以不需要等待这些巨量信息的传输而直接继续下一个任务，则能提高效率。</p><p>To manage these effects, there are MPI operations for <strong>monitoring</strong> the progress of non-blocking communications (effectively, to ask, “is it OK to use this variable now?”). - The idea is that with <strong>careful use</strong> these can allow the process to get on with other useful work even before the user-space buffer has been safely stored.</p><h3 id="Blocking-Communication-Semantics-in-MPI"><a href="#Blocking-Communication-Semantics-in-MPI" class="headerlink" title="Blocking Communication Semantics in MPI"></a>Blocking Communication Semantics in MPI</h3><p>MPI provides different blocking send operations, vary <strong>in the level of synchronization</strong> they provide. Each makes different demands on the underlying communication protocol (i.e. the implementation).</p><p>1, <strong>Synchronous mode</strong> send (<code>MPI_Ssend</code>) is blocking and synchronous, only complete when a matching receive has been found.</p><p>2, <strong>Standard mode</strong> send (<code>MPI_Send</code>) is blocking. Its synchronicity depends upon the state of the implementation buffers, in that it will be <strong>asynchronous</strong> unless the relevant buffers are full, in which case it will wait for buffer space (and so may appear to behave in a “semi” synchronous fashion).</p><p>3, <strong>Buffered mode</strong> send (<code>MPI_Bsend</code>) is blocking and asynchronous, but the programmer must previously have made enough buffer space available (otherwise an error is reported). There are associated operations for <strong>allocating</strong> the buffer space.</p><p><strong>Receiving</strong> with <code>MPI_Recv</code> blocks until a matching message has been completely received into the buffer (so it is blocking and <strong>synchronous</strong>).</p><p>MPI also provides <strong>non-blocking</strong> sends and receives which return <strong>immediately</strong> (i.e. possibly before it is safe to use/reuse the buffer). There are immediate versions of all the blocking operations (with an extra “I” in the name). For example, <code>MPI_Isend</code> is the <strong>standard mode immediate send</strong>, and <code>MPI_Irecv</code> is the immediate receive.</p><p>Non-blocking operations have an extra parameter, called a ‘request’ which is a <strong>handle on the communication</strong>, used with <code>MPI_Wait</code> and <code>MPI_Test</code> to <strong>wait</strong> or <strong>check</strong> for <strong>completion</strong> of the communication (in the sense of the corresponding blocking version of the operation).</p><h3 id="Probing-for-Messages"><a href="#Probing-for-Messages" class="headerlink" title="Probing for Messages"></a>Probing for Messages</h3><p>A receiving process may want to <strong>check</strong> for a <strong>potential receive</strong> without actually receiving it. For example, we may not know the incoming message size, and want to create a suitable receiving buffer.</p><p><code>int MPI_Probe(int src, int tag, MPI_Comm comm, MPI_Status *status)</code> behaves like <code>MPI_Recv</code> , filling in <code>*status</code>, without actually receiving the message.</p><p>There is also a version which tests whether a message is available immediately <code>int MPI_Iprobe(int src, int tag, MPI_Comm comm, int *flag, MPI_Status *status)</code> leaving a (C-style) boolean result in <code>*flag</code> (i.e. message/no message).</p><p>We can then determine the <strong>size</strong> of the incoming message by inspecting its status information. <code>int MPI_Get_count(MPI_Status *status, MPI_Datatype t, int *count)</code> sets <code>*count</code> to the <strong>number of items</strong> of type <code>t</code> in message with status <code>*status</code>.</p><p>We could use these functions to receive (for example) a message containing an <strong>unknown number</strong> of integers from an <strong>unknown source</strong>, but with <strong>tag</strong> <code>75</code>, in a given communicator comm.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MPI_Probe(MPI_ANY_SOURCE, <span class="number">75</span>, comm, &amp;status);</span><br><span class="line">MPI_Get_count(&amp;status, MPI_INT, &amp;count);</span><br><span class="line">buf = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(count*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">source = status.MPI_SOURCE;</span><br><span class="line">MPI_Recv(buf, count, MPI_INT, source, <span class="number">75</span>, comm, &amp;status);</span><br></pre></td></tr></table></figure></p><h3 id="Collective-Operations"><a href="#Collective-Operations" class="headerlink" title="Collective Operations"></a>Collective Operations</h3><p>MPI offers a range of more complex operations which would otherwise require <strong>complex sequences</strong> of sends, receives and computations.</p><p>These are called <strong>collective</strong> operations, because they must be called by <strong>all</strong> processes in a communicator.<img src="/images/Collective_Operations.jpg" alt="" title="Image from: http://www.inf.ed.ac.uk/teaching/courses/ppls/pplsslides.pdf"></p><p>1, <code>MPI_Bcast</code> <strong>broadcasts</strong> <code>count</code> items of type <code>t</code> from <code>buf</code> in <code>root</code> to <code>buf</code> in all other processes in <code>comm</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Bcast</span> <span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">int</span> count, MPI_Datatype t, <span class="keyword">int</span> root,</span></span></span><br><span class="line"><span class="function"><span class="params">               MPI_Comm comm)</span></span></span><br></pre></td></tr></table></figure></p><p>2, <code>MPI_Scatter</code> is used to <strong>divide the contents of a buffer</strong> across all processes.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Scatter</span> <span class="params">(<span class="keyword">void</span> *sendbuf, <span class="keyword">int</span> sendcount, MPI_Datatype sendt,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *recvbuf, <span class="keyword">int</span> recvcount, MPI_Datatype recvt, <span class="keyword">int</span> root, MPI_Comm comm)</span></span></span><br></pre></td></tr></table></figure></p><p>$i^{th}$ chunk (size <code>sendcount</code>) of <code>root</code>‘s <code>sendbuf</code> is sent to <code>recvbuf</code> on process $i$ (including the root process itself). The first three parameters are only significant at the root. Counts, types, root and communicator parameters must match between root and all receivers.</p><p>3, <code>MPI_Gather</code> is the inverse of <code>MPI_Scatter</code>. Instead of spreading elements from one process to many processes, <code>MPI_Gather</code> takes elements from many processes and gathers them to one single process.</p><blockquote><p><code>MPI_Gather</code> takes elements from each process and gathers them to the root process. The elements are ordered by the rank of the process from which they were received. Only the <code>root</code> process needs to have a valid receive buffer. The <code>recv_count</code> parameter is <strong>the count of elements received per process</strong>, not the total summation of counts from all processes.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MPI_Gather( <span class="keyword">void</span>* send_data, <span class="keyword">int</span> send_count, MPI_Datatype send_datatype,</span><br><span class="line">    <span class="keyword">void</span>* recv_data, <span class="keyword">int</span> recv_count, MPI_Datatype recv_datatype,</span><br><span class="line">    <span class="keyword">int</span> root, MPI_Comm communicator)</span><br></pre></td></tr></table></figure></p></blockquote><p>4, <code>MPI_Allreduce</code> computes a <strong>reduction</strong>, such as adding a collection<br>of values together. No root, all Processes receive the reduced result.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Allreduce</span> <span class="params">(<span class="keyword">void</span> *sendbuf, <span class="keyword">void</span> *recvbuf, <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                   MPI_Datatype sendt, MPI_Op op, MPI_Comm comm)</span></span></span><br></pre></td></tr></table></figure></p><p><strong>Reduces</strong> elements from all send buffers, point-wise, to count single values, using <code>op</code>, storing result(s) in <strong>all</strong> receive buffers. The <code>op</code> is chosen from a <strong>predefined set</strong> (<code>MPI_SUM</code>, <code>MPI_MAX</code> etc) or <strong>constructed</strong> with user code and <code>MPI_Op_create</code>. <code>MPI_Allreduce</code> is the equivalent of doing <code>MPI_Reduce</code> followed by an <code>MPI_Bcast</code>.<img src="http://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/mpi_allreduce_1.png" alt=""></p><p>Jacobi (1-dimensional wrapped), each neighour is owned by distinct process, thus could not read each other’s data - introduce a layer of message passing, introduce halo as buffer.<img src="/images/1_d_jacobi_MPI.png" alt="" title="Image from: http://www.inf.ed.ac.uk/teaching/courses/ppls/pplsslides.pdf"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// here for convenience MPI_Sendrecv combines a send and a receive.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    MPI_Comm_size(MPI_COMM_WORLD, &amp;p);</span><br><span class="line">    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>) read_problem(&amp;n, work); <span class="comment">// 数据存在 root - 0号进程</span></span><br><span class="line"></span><br><span class="line">    MPI_Bcast(&amp;n, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD); <span class="comment">// 广播数据</span></span><br><span class="line">    mysize = n/p;             <span class="comment">// assume p divides n, for simplicity</span></span><br><span class="line">    local = (<span class="keyword">float</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">float</span>) * (mysize+<span class="number">2</span>)); <span class="comment">//include fringe/halo</span></span><br><span class="line">    MPI_Scatter(work, mysize, MPI_FLOAT, &amp;local[<span class="number">1</span>], mysize,</span><br><span class="line">                MPI_FLOAT, <span class="number">0</span>, MPI_COMM_WORLD); <span class="comment">// scatter 分发数据到各process主位置</span></span><br><span class="line">    left = (rank+p<span class="number">-1</span>)%p;      <span class="comment">// who is my left neighour?</span></span><br><span class="line">    right = (rank+<span class="number">1</span>)%p;       <span class="comment">// who is my right neighour?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123; <span class="comment">//[0]和[mysize+1]halo</span></span><br><span class="line">        MPI_Sendrecv(&amp;local[<span class="number">1</span>], <span class="number">1</span>, MPI_FLOAT, left, <span class="number">0</span>,        <span class="comment">// send this</span></span><br><span class="line">                     &amp;local[mysize+<span class="number">1</span>], <span class="number">1</span>, MPI_FLOAT, right, <span class="number">0</span>, <span class="comment">// receive this</span></span><br><span class="line">                     MPI_COMM_WORLD, &amp;status);               <span class="comment">// anti-clockwise</span></span><br><span class="line">        MPI_Sendrecv(&amp;local[mysize], <span class="number">1</span>, MPI_FLOAT, right, <span class="number">0</span>,</span><br><span class="line">                     &amp;local[<span class="number">0</span>], <span class="number">1</span>, MPI_FLOAT, left, <span class="number">0</span>,</span><br><span class="line">                     MPI_COMM_WORLD, &amp;status);               <span class="comment">// clockwise</span></span><br><span class="line">        do_one_step(local, &amp;local_error);</span><br><span class="line">        MPI_Allreduce(&amp;local_error, &amp;global_error, <span class="number">1</span>,</span><br><span class="line">                      MPI_FLOAT, MPI_MAX, MPI_COMM_WORLD);</span><br><span class="line">    &#125; <span class="keyword">while</span> (global_error &gt; acceptable_error);</span><br><span class="line"></span><br><span class="line">    MPI_Gather (&amp;local[<span class="number">1</span>], mysize, MPI_FLOAT,</span><br><span class="line">                work, mysize, MPI_FLOAT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>) print_results(n, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Sendrecv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *sendbuf, <span class="keyword">int</span> sendcount, MPI_Datatype sendtype,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> dest, <span class="keyword">int</span> sendtag,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span> *recvbuf, <span class="keyword">int</span> recvcount, MPI_Datatype recvtype,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> source, <span class="keyword">int</span> recvtag,</span></span></span><br><span class="line"><span class="function"><span class="params">                MPI_Comm comm, MPI_Status *status)</span></span></span><br></pre></td></tr></table></figure><h3 id="Communicators"><a href="#Communicators" class="headerlink" title="Communicators"></a>Communicators</h3><p>Communicators define contexts within which groups of processes interact. All processes belong to <code>MPI_COMM_WORLD</code> from the MPI initialisation call onwards.</p><p>Create new communicators from old ones by collectively calling<br><code>MPI_Comm_split(MPI_Comm old, int colour, int key, MPI_Comm *newcomm)</code> to create new communicators based on <strong><code>colors</code></strong> and <strong><code>keys</code></strong>:<br><strong><code>color</code></strong> - control of subset assignment (nonnegative integer). Processes with the same color are in the same new communicator.<br><strong><code>key</code></strong> - control of rank assignment (integer).</p><p>Within each new communicator, processes are assigned a new rank in the range $0…p^{\prime} − 1$, where $p^{\prime}$ is the size of the new communicator. Ranks are ordered by (but not necessarily equal to) the value passed in as the <code>key</code> parameter, with ties broken by considering process rank in the parent communicator.</p><p>This can be helpful in expressing algorithms which contain nested structure. For example, many <strong>divide-and-conquer</strong> algorithms split the data and machine in half, process recursively within the halves, then unwind to process the recursive results back at the upper level.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Divide &amp; Conquer Communicators</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_DC_algorithm</span> <span class="params">( ..., MPI_Comm comm)</span> </span>&#123;</span><br><span class="line">    MPI_Comm_size(comm, &amp;p); MPI_Comm_rank(comm, &amp;myrank);</span><br><span class="line">    ... pre-recursion work ...</span><br><span class="line">    <span class="keyword">if</span> (p&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        MPI_Comm_split (comm, myrank&lt;(p/<span class="number">2</span>), <span class="number">0</span>, &amp;subcomm); <span class="comment">// two sub-machines</span></span><br><span class="line">        some_DC_algorithm (..., subcomm); <span class="comment">// recursive step</span></span><br><span class="line">        <span class="comment">// in both sub-machines</span></span><br><span class="line">    &#125; <span class="keyword">else</span> do_base_case_solution_locally();</span><br><span class="line">    ... post-recursion work ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Task-and-Pattern-Based-Models"><a href="#Task-and-Pattern-Based-Models" class="headerlink" title="Task and Pattern Based Models"></a>Task and Pattern Based Models</h2><p>Programming explicitly with threads (or processes) has some drawbacks:<br>• Natural expression of many highly parallel algorithms involves creation of far more threads than there are cores. Thread creation and scheduling have higher overheads than simpler activities like function calls (by a factor of 50-100).<br>• The OS has control over the scheduling of threads to processor cores, but it does not have the application specific knowledge required to make intelligent assignments (for example to optimize cache re-use). Traditional OS concerns for fairness may be irrelevant or even counter-productive.</p><p>To avoid this, programmers resort to complex scheduling and synchronization of a smaller number of coarser grained threads. How to avoid this?</p><p>A number of languages and libraries have emerged which<br>• separate the responsibility for identifying potential parallelism, which remains the application programmer’s job, from detailed scheduling of this work to threads and cores, which becomes the language/library run-time’s job.<br>• provide abstractions of common patterns of parallelism, which can be specialized with application specific operations, leaving implementation of the pattern and its inherent synchronization to the system.</p><p>These are sometimes called <strong>task based</strong> approaches, in contrast to traditional threaded models. Examples include <strong>OpenMP</strong>, which is a compiler/language based model, and Intel’s <strong>Threading Building Blocks</strong> library.</p><h2 id="Threading-Building-Blocks"><a href="#Threading-Building-Blocks" class="headerlink" title="Threading Building Blocks"></a>Threading Building Blocks</h2><p>Threading Building Blocks (TBB) is a shared variable model, C++ <strong>template-based</strong> library. It uses <strong>generic programming</strong> techniques to provide a collection of <strong>parallel algorithms</strong>, each of which is an <strong>abstraction of a parallel pattern</strong>. It also provides a direct mechanism for specifying task graphs and a collection of concurrent data structures and synchronization primitives.</p><blockquote><p>泛型程序设计（generic programming）是程序设计语言的一种风格或范式，允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。</p></blockquote><p>It handles <strong>scheduling</strong> of tasks, whether explicit programmed or inferred from pattern calls, to a fixed number of threads internally. In effect, this is a hidden Bag-of-Tasks, leaving the OS with almost nothing to do.</p><p>Game of Life (<a href="http://web.stanford.edu/class/archive/cs/cs106b/cs106b.1186//assn/life.html" target="_blank" rel="noopener">cs106b 作业1</a>) Original Code for a Step<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> State &#123;DEAD,ALIVE&#125; ; <span class="comment">// cell status</span></span><br><span class="line"><span class="keyword">typedef</span> State **Grid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NextGen</span><span class="params">(Grid oldMap, Grid newMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row, col, ncount;</span><br><span class="line">    State current;</span><br><span class="line">    <span class="keyword">for</span> (row = <span class="number">1</span>; row &lt;= MAXROW; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt;= MAXCOL; col++) &#123;</span><br><span class="line">            current = oldMap[row][col];</span><br><span class="line">            ncount = NeighborCount(oldMap, row, col);</span><br><span class="line">            newMap[row][col] = CellStatus(current, ncount);</span><br><span class="line">&#125;   &#125;   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="TBB-parallel-for"><a href="#TBB-parallel-for" class="headerlink" title="TBB parallel_for"></a>TBB <code>parallel_for</code></h3><p>假设我们想将上面的函数<code>NextGen</code>应用到数组(网格)的每个元素，这个例子是可以放心使用并行处理模式的。函数模板<code>tbb::parallel_for</code> 将此迭代空间(<code>Range</code>)分解为一个个块，并把每个块运行在不同的线程上。要并行化这个循环，第一步是将循环体转换为可以在一个块上运行的形式 - 一个STL风格的函数对象，称为<code>body</code>对象，其中由<code>operator()</code>中处理。<br>Game of Life Step Using <code>parallel_for</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NextGen</span><span class="params">(Grid oldMap, Grid newMap)</span> </span>&#123;</span><br><span class="line">    parallel_for (blocked_range&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>, maxrow+<span class="number">1</span>), <span class="comment">// Range</span></span><br><span class="line">                  CompNextGen(oldMap, newMap),     <span class="comment">// Body</span></span><br><span class="line">                  affinity_partitioner());         <span class="comment">// Partitioner</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Range</strong> defines a task(iteration) space, and its sub-division (partition) technique;<br><strong>Body</strong> defines the code which processes a range;<br><strong>Partitioner</strong> (optional parameter) influencing partitioning and scheduling strategy.</p><p>The <code>parallel_for</code> Template:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_for</span><span class="params">(<span class="keyword">const</span> Range&amp; range, <span class="keyword">const</span> Body &amp;body)</span></span>;</span><br></pre></td></tr></table></figure></p><p>Requires definition of:</p><ul><li>A <code>range</code> space to iterate over<ul><li>Must define a copy constructor and a destructor</li><li>a <strong>destructor</strong> to destroy these copies</li><li>Defines <code>is_empty()</code></li><li>Defines i<code>s_divisible()</code></li><li>Defines a <strong>splitting constructor</strong>, <code>R(R &amp;r, split)</code></li></ul></li><li>A <code>body</code> type that operates on the range (or a subrange)<ul><li>Must define a <strong>copy constructor</strong>, which is invoked to create a separate copy (or copies) for each worker thread.</li><li>Defines <code>operator()</code></li></ul></li></ul><blockquote><p>In the C++ programming language, a <strong>copy constructor</strong> is a special constructor for creating a new object as a copy of an existing object.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用形式</span></span><br><span class="line">classname (<span class="keyword">const</span> classname &amp;obj) &#123;</span><br><span class="line">   <span class="comment">// body of constructor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      Line( <span class="keyword">int</span> len );             <span class="comment">// simple constructor</span></span><br><span class="line">      Line( <span class="keyword">const</span> Line &amp;obj);      <span class="comment">// copy constructor</span></span><br><span class="line">      ~Line();                     <span class="comment">// destructor</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> *ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="Range-Class"><a href="#Range-Class" class="headerlink" title="Range Class"></a>Range Class</h4><p>A <code>blocked_range&lt;T&gt;</code> is a template class provided by the library. It describes a one-dimensional iteration space over type <code>T</code>. and be queried for the beginning (<code>r.begin()</code>) and end (<code>r.end()</code>) of the range.</p><p>The TBB runtime can break a <code>blocked_range</code> into two smaller ranges, each (roughly) half the size.</p><p>Note that a <code>blocked_range</code> carries no problem data. The values in the range can be used as we choose, for example to index into arrays.<br><strong>Range is Generic</strong>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R::R (<span class="keyword">const</span> R&amp;) <span class="comment">// Copy constructor</span></span><br><span class="line">R::~R()         <span class="comment">// Destructor</span></span><br><span class="line"><span class="keyword">bool</span> R::is_empty() <span class="keyword">const</span> <span class="comment">// True if range is empty</span></span><br><span class="line"><span class="keyword">bool</span> R::is_divisible() <span class="keyword">const</span> <span class="comment">// True if range can be partitioned</span></span><br><span class="line">R::R (R&amp; r, split) <span class="comment">// Splitting constructor; splits r into two subranges</span></span><br></pre></td></tr></table></figure></p><p>Besides the provided <code>blocked_range</code> and <code>blocked_range2d</code>, users can define their own ranges. TBB DIY Range Example: Compute Fibonacci numbers.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibRange</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> n_ ; <span class="comment">// represents the range corresponding to fib(n)</span></span><br><span class="line">        FibRange(<span class="keyword">int</span> n) : n_(n) &#123; &#125;</span><br><span class="line">        FibRange(FibRange&amp; other, split) <span class="comment">// split constructor</span></span><br><span class="line">        : n_(other.n_ - <span class="number">2</span>) <span class="comment">// initialize the new object</span></span><br><span class="line">        &#123; other.n_ = other.n_ - <span class="number">1</span>;&#125; <span class="comment">// reuse the other range object</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">is_divisible</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (n_ &gt; <span class="number">10</span>); &#125; <span class="comment">// sequential threshold</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n_ &lt; <span class="number">0</span>; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="Body-Class"><a href="#Body-Class" class="headerlink" title="Body Class"></a>Body Class</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompNextGen</span> &#123;</span></span><br><span class="line">    Grid oldMap, newMap;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    CompNextGen (Grid omap, Grid nmap) : oldMap(omap), newMap(nmap) &#123;&#125;</span><br><span class="line">    <span class="comment">// 分割迭代空间的方式多种多样</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">const</span> blocked_range&lt;<span class="keyword">int</span>&gt;&amp; r )</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = r.begin(); row &lt; r.end(); row++)&#123; <span class="comment">// 这里按行分割</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">1</span>; col &lt;= maxcol; col++) &#123;</span><br><span class="line">                nState current = oldMap[row][col];</span><br><span class="line">                <span class="keyword">int</span> ncount = NeighborCount(oldMap, row, col);</span><br><span class="line">                newMap[row][col] = CellStatus(current, ncount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Body is Generic</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Body::Body(<span class="keyword">const</span> Body&amp;) \\ Copy constructor</span><br><span class="line">Body::~Body()           \\ Destructor</span><br><span class="line"><span class="keyword">void</span> Body::<span class="keyword">operator</span>() (Range&amp; subrange) <span class="keyword">const</span>  \\ Apply the body to subrange.</span><br></pre></td></tr></table></figure></p><blockquote><p>Because the body object might be copied, its <code>operator()</code> should not modify the body hence should be declared <code>const</code>. Otherwise the modification might or might not become visible to the thread that invoked parallel_for, depending upon whether <code>operator()</code> is acting on the original or a copy.<br>Credit from <a href="https://www.threadingbuildingblocks.org/docs/help/tbb_userguide/parallel_for.html" target="_blank" rel="noopener">www.threadingbuildingblocks.org</a></p></blockquote><p><code>parallel_for</code> partitions original range into subranges, and deals out subranges to worker threads in a way that: Balances load, Uses cache efficiently, and Scales.</p><p>Game of Life 1D with C++11 Lambda Function, an alternative interface to <code>parallel_for</code> allows us to use a C++ lambda expression to avoid writing a body class.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NextGen</span><span class="params">(Grid oldMap, Grid newMap)</span> </span>&#123;</span><br><span class="line">    parallel_for (blocked_range&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>, maxrow+<span class="number">1</span>),</span><br><span class="line">                [&amp;](<span class="keyword">const</span> blocked_range&lt;<span class="keyword">int</span>&gt;&amp; r)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> row = r.begin(); row &lt; r.end(); row++)&#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">1</span>; col &lt;= MAXCOL; col++) &#123;</span><br><span class="line">                            State current = oldMap[row][col];</span><br><span class="line">                            <span class="keyword">int</span> ncount = NeighborCount(oldMap, row, col);</span><br><span class="line">                            newMap[row][col] = CellStatus(current, ncount);</span><br><span class="line">                        &#125;                    &#125;                &#125;    );&#125;</span><br></pre></td></tr></table></figure></p><p><code>[&amp;]</code>引入 lambda 表达式. 该表达式创建一个类似于<code>CompNextGen</code>的函数对象. 当局部变量在 lambda expression 之外声明，但又在lambda表达式内使用时, 它们被”捕获”为函数对象内的字段. <code>[&amp;]</code>指定引用，<code>[=]</code>指定按值捕获.</p><h3 id="TBB-Partitioners"><a href="#TBB-Partitioners" class="headerlink" title="TBB Partitioners"></a>TBB Partitioners</h3><p>TBB supports different partitioning strategy:<br>1, <code>tbb::parallel_for( range, body, tbb::simple_partitioner() );</code> <strong>forces</strong> all ranges to be <strong>fully partitioned</strong> (i.e. until <code>is_divisible()</code> fails).<br>2, <code>tbb::parallel_for( range, body, tbb::auto_partitioner() );</code> allows the TBB runtime to <strong>decide</strong> whether to partition the range (to improve <strong>granularity</strong>).<br>3, <code>tbb::parallel_for( range, body, tbb::affinity_partitioner );</code> is like <code>auto_partitioner()</code> but also, when the <code>parallel_for</code> is inside a loop, tries to allocate the same range to the same processor core across iterations to <strong>improve cache behaviour</strong>.</p><p>Game of Life Using a 2D decomposition<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NextGen</span><span class="params">(Grid oldMap, Grid newMap)</span> </span>&#123;</span><br><span class="line">    parallel_for (blocked_range2d&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; (<span class="number">1</span>, maxrow+<span class="number">1</span>, <span class="number">1</span>, maxcol+<span class="number">1</span>), <span class="comment">// Range</span></span><br><span class="line">                  CompNextGen(oldMap, newMap));                  <span class="comment">// Body</span></span><br><span class="line">                  auto_partitioner());                           <span class="comment">// Partitioner</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompNextGen</span> &#123;</span></span><br><span class="line">    Grid oldMap, Grid newMap;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CompNextGen (Grid omap, Grid nmap) : oldMap(omap), newMap(nmap) &#123;&#125;</span><br><span class="line">    <span class="comment">// 二维分割</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">const</span> blocked_range2d&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; r )</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = r.rows().begin(); row &lt; r.rows().end(); row++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = r.cols().begin(); col &lt; r.cols().end(); col++) &#123;</span><br><span class="line">                State current = oldMap[row][col];</span><br><span class="line">                <span class="keyword">int</span> ncount = NeighborCount(oldMap, row, col);</span><br><span class="line">                newMap[row][col] = CellStatus(current, ncount);</span><br><span class="line">            &#125;        &#125;    &#125;;&#125;</span><br></pre></td></tr></table></figure></p><p><code>blocked_range2d</code> is partitioned in alternating dimensions, level by level.</p><h3 id="TBB-parallel-reduce-Template"><a href="#TBB-parallel-reduce-Template" class="headerlink" title="TBB parallel_reduce Template"></a>TBB <code>parallel_reduce</code> Template</h3><p>TBB <code>parallel_reduce</code> has similar structure to <code>parallel_for</code> but additionally allows bodies to <code>gather results</code> internally as they go along.</p><p>We could parallelize a loop reduction (iterations are independent), as in a Numerical Integration example, with a <code>parallel_for</code>, but we would need a <strong>critical section</strong> of some kind to accumulate the partial results. <strong><code>parallel_reduce</code></strong> structures and hides this, with one further generic operation, called <code>join</code>.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_reduce</span> <span class="params">(<span class="keyword">const</span> Range&amp; range, Body &amp;body)</span></span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Body::Body( <span class="keyword">const</span> Body&amp;, split ) <span class="comment">//Splitting constructor</span></span><br><span class="line">Body::~Body()                    <span class="comment">// Destructor</span></span><br><span class="line"><span class="keyword">void</span> Body::<span class="keyword">operator</span>() (Range&amp; subrange) <span class="keyword">const</span> <span class="comment">// Accumulate results from subrange</span></span><br><span class="line"><span class="keyword">void</span> Body::join( Body&amp; rhs ); <span class="comment">// Merge result of rhs into the result of this.</span></span><br></pre></td></tr></table></figure><p>When a worker thread is <strong>available</strong>, as decided by the task scheduler, <code>parallel_reduce</code> invokes the <code>splitting constructor</code> to create a subtask for the worker. When the subtask <strong>completes</strong>, <code>parallel_reduce</code> uses method <code>join</code> to accumulate the result of the subtask. It reuses <strong>Range</strong> concept from <code>parallel_for</code>.<br><img src="https://www.threadingbuildingblocks.org/docs/help/tbb_userguide/Images/image009.jpg" alt="" title="Graph of the Split-join Sequence. An arc indicates order in time. image from https://www.threadingbuildingblocks.org/docs/help/tbb_userguide/Images/image009.jpg"><br>The Fib Body Class (with <code>operator()</code>), using the DIY range example - <code>FibRange</code> from above<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> fsum_ ;</span><br><span class="line">        Fib() : fsum_(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">        Fib(Fib&amp; other, split) : fsum_(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">        <span class="comment">// use += since each body may accumulate more than one range</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(FibRange&amp; range)</span> </span>&#123; fsum_ += fib(range.n_ ); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">else</span> <span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>);&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(Fib&amp; rhs)</span> </span>&#123; fsum_ += rhs.fsum_; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="function">task_scheduler_init <span class="title">init</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    Fib f;</span><br><span class="line">    parallel_reduce(FibRange(FIBSEED), f, simple_partitioner());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Fib "</span> &lt;&lt; FIBSEED &lt;&lt; <span class="string">" is "</span> &lt;&lt; f.fsum_ &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Using a <code>simple_partitioner</code> forces full splitting of the ranges. We could use <code>auto_partitioner</code> to let the TBB run-time system control this.</p><h3 id="The-Task-Scheduler"><a href="#The-Task-Scheduler" class="headerlink" title="The Task Scheduler"></a>The Task Scheduler</h3><p>如果一个算法不能自然地映射到前面提到的任何其中一种 high-level loop templates，可以使用 task scheduler 直接操作任务, 可以构建新的高级模板。</p><p>All of TBB’s parallel pattern constructs are implemented via the same underlying <strong>task scheduler</strong>, which executes a task graph representing the pattern.</p><p>TBB also allows the programmer to (carefully!) <strong>create task graphs directly</strong>. This allows expression of unstructured task graphs, or the implementation and abstraction of further patterns.</p><p>There are functions to create new tasks as children of existing tasks and to specify the control dependencies between them.</p><p>How to code Fibonacci using tasks directly? The key method is <code>task::execute</code>, which we override with our application specific behaviour.</p><p>Recursion is typically used to calculate Fibonacci number but leads to unbalanced task graph.</p><p>Fibonacci - Task Spawning Solution - Use TBB tasks to thread creation and execution of task graph:</p><ol><li>Allocate space for the task by a special “overloaded new” and method <code>task::allocate_root</code> - Create root of a task tree. Tasks must be allocated by special methods so that the space can be efficiently recycled when the task completes.</li><li>Construct task with the constructor <code>FibTask(n, &amp;sum)</code> invoked by <code>new</code>. When the task is run in step 3, it computes the nth Fibonacci number and stores it into <code>*sum</code>.</li><li>Run the task and wait for completion with <code>task::spawn_root_and_wait</code>.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tbb/task.h"</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ParallelFib</span><span class="params">( <span class="keyword">long</span> n )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum;</span><br><span class="line">    FibTask&amp; a = *<span class="keyword">new</span>(task::allocate_root()) FibTask(n, &amp;sum);</span><br><span class="line">    task::spawn_root_and_wait(a);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibTask</span>:</span> <span class="keyword">public</span> task &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">long</span> n;</span><br><span class="line">        <span class="keyword">long</span>* <span class="keyword">const</span> sum;</span><br><span class="line">        FibTask( <span class="keyword">long</span> n_, <span class="keyword">long</span>* sum_ ) : n(n_), sum(sum_) &#123;&#125;</span><br><span class="line">        <span class="function">task* <span class="title">execute</span><span class="params">()</span> </span>&#123; <span class="comment">// Overrides virtual function task::execute</span></span><br><span class="line">            <span class="keyword">if</span>( n &lt; CutOff ) &#123;</span><br><span class="line">                *sum = SerialFib(n);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> x, y;</span><br><span class="line">                FibTask&amp; a = *<span class="keyword">new</span>( allocate_child() ) FibTask(n<span class="number">-1</span>,&amp;x);</span><br><span class="line">                FibTask&amp; b = *<span class="keyword">new</span>( allocate_child() ) FibTask(n<span class="number">-2</span>,&amp;y);</span><br><span class="line">                set_ref_count(<span class="number">3</span>); <span class="comment">// Set to 3  = 2 children + 1 for wait</span></span><br><span class="line">                spawn( b ); <span class="comment">// Start b running.</span></span><br><span class="line">                <span class="comment">// Start a running and wait for all children (a and b).</span></span><br><span class="line">                spawn_and_wait_for_all(a);</span><br><span class="line">                *sum = x+y; <span class="comment">// Do the sum</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The TBB scheduler runs tasks in a way that tends to minimize both memory demands and cross-thread communication. The intuition is that a balance must be reached between depth-first and breadth-first execution.</p><p>At any point in execution, the collection of known tasks is maintained as a <strong>shared</strong> graph. Each thread maintains its own <strong>double-ended queue</strong> of tasks (roughly, as pointers into the shared graph).</p><p>Newly <strong>spawned</strong> tasks are added to the front of the local queue.</p><p>当一条线程参与 task graph 时，它会不断按照优先原则执行下面的规则来获取任务:</p><ol><li>looks at the <strong>front of its local queue</strong>, which encourages locality within one thread’s work; 如果 deque 为空，则此规则不适用；</li><li>假如失败, steal a task from the <strong>back of one other (randomly chosen) thread’s queue</strong>, which encourages stealing of big tasks, and discourages locality across threads.<br><img src="/images/TBB_Scheduler.png" alt="" title="Image from: http://www.inf.ed.ac.uk/teaching/courses/ppls/pplsslides.pdf"></li></ol><h2 id="Linda"><a href="#Linda" class="headerlink" title="Linda"></a>Linda</h2><p>Linda presents an alternative conceptual model for parallelism, based around a small library of operations. The Linda model saw something of a revival in distributed java systems programming, under the name <strong>JavaSpaces</strong>.</p><p>The key concept is that processes interact through <strong>tuple space</strong>, a global, <strong>content addressable</strong> memory, which is thread safe, with no race conditions, therefore does not require explicit <strong>locks</strong>. Each tuple is an <strong>ordered</strong> collection of typed data fields. Duplicate tuples are allowed.</p><p>The tuple space itself acts like a <strong>monitor</strong>. If a process tries to access a tuplen, it is blocked until a matching tuple becomes available.</p><p><strong>Semaphore</strong> - Linda have tuple (or a set of tuples for a counting semaphore) that represent the locks. If someone needs to enter the lock, it waits until a tuple is available in the bag, pull it out of the bag and inserts it back into the tuple space.</p><p>Processes run <strong>asynchronously</strong> and can operate on tuple space with six operations.</p><p>1, Add new tuple to tuple space: <code>out(exp1, exp2, ...., expN);</code> - evaluates the expressions in the parameter list before <strong>atomically</strong> placing a copy of the results as a new tuple in tuple space. It could be considered as an <strong>asynchronous send with a wild-card destination</strong> in message-passing. <code>out(&quot;sum&quot;, 2, 3)</code>, <code>out(&quot;Green&quot;, x*y, square(2));</code></p><p>2, To take a tuple from tuple space: <code>in(tuple-template);</code> - <strong>atomically removes</strong> from tuple space a tuple which <strong>matches the template</strong>. <code>template</code> contains actual values and formal parameters (indicated by <code>?</code>) to be assigned during the match. 匹配包含与实际值的匹配，以及与形式参数类型 types 相匹配. <code>in</code> is <strong>blocking</strong>, in the sense that the caller is <strong>suspended</strong> until a matching tuple becomes available. For example: <code>in(&quot;sum&quot;,?i,?j)</code> matches <code>&quot;sum&quot;</code>, assigns <code>2</code> to <code>i</code> and <code>3</code> to <code>j</code> and the tuple is removed from the tuple space. <code>in(&quot;Green&quot;, ?y, ?r, FALSE);</code>. We could think of <code>in</code> as a <strong>blocking, asynchronous receive, with wild-card source</strong>, but with additional constraints implied by the pattern matching.</p><p>3, <strong>Atomically</strong> read a tuple from tuple space with <code>rd(tuple-template);</code></p><p>4, Tuples may also be created with <code>eval(expr, expr, ...)</code> which is like <code>out</code>, but <strong>dynamically creates new processes</strong> to evaluate each field of the tuple which has been expressed as a function call. The calling process continues immediately, and the resulting tuple enters tuple space atomically when all the newly sparked processes have terminated</p><p>5, Finally, there are <strong>non-blocking</strong> forms <code>inp</code>, <code>rdp</code> (<code>p</code> for “predicate”) which complete “immediately”, returning a boolean indicating whether or not a match occurred. This allow a process to carry on with a different task and then try again later.</p><p><strong>Bag of Tasks</strong> Implementation:<br>同样以前面的 Adaptive Quadrature 为例. Use a <code>(&quot;counts&quot;, x, y)</code> tuple, in effect as a shared variable, to count the number of tasks and number of idle workers. The final field in a task tuple indicates whether this is a real task or a “no more tasks” signal.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    out(<span class="string">"total"</span>, <span class="number">0.0</span>); out(<span class="string">"counts"</span>, <span class="number">1</span>, P); <span class="comment">// set initial #task and #idle</span></span><br><span class="line">    out(<span class="string">"task"</span>, a, b, f(a), f(b), approxarea, FALSE); <span class="comment">// make initial task</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;P; i++) eval(worker());             <span class="comment">// create P workers</span></span><br><span class="line">    in (<span class="string">"counts"</span>, <span class="number">0</span>, P);              <span class="comment">// no tasks left, and P workers idle</span></span><br><span class="line">    in (<span class="string">"total"</span>, ?total);                             <span class="comment">// get the result</span></span><br><span class="line">    out (<span class="string">"task"</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, TRUE);      <span class="comment">// indicate no more tasks</span></span><br><span class="line">    ...                                               <span class="comment">//use total</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        in(<span class="string">"task"</span>, ?left, ?right, ?fleft, ?fright, ?lrarea, ?gameOver);</span><br><span class="line">        <span class="keyword">if</span> (gameOver) &#123;  <span class="comment">// if gameOver == TRUE</span></span><br><span class="line">            out (<span class="string">"task"</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, TRUE); <span class="comment">// for others to see</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        in(<span class="string">"counts"</span>, ?size, ?idle); out(<span class="string">"counts"</span>, size<span class="number">-1</span>, idle<span class="number">-1</span>);</span><br><span class="line">        ... usual task calculations ...</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span> (larea + rarea - lrarea) &gt; EPSILON) &#123; <span class="comment">// create new tasks</span></span><br><span class="line">            out(<span class="string">"task"</span>, left, mid, fleft, fmid, larea, FALSE);</span><br><span class="line">            out(<span class="string">"task"</span>, mid, right, fmid, fright, rarea, FALSE);</span><br><span class="line">            in(<span class="string">"counts"</span>, ?size, ?idle); out(<span class="string">"counts"</span>, size+<span class="number">2</span>, idle+<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            in (<span class="string">"total"</span>, ?total); out (<span class="string">"total"</span>, total+larea+rarea);</span><br><span class="line">            in(<span class="string">"counts"</span>, ?size, ?idle); out(<span class="string">"counts"</span>, size, idle+<span class="number">1</span>);</span><br><span class="line">        &#125;  &#125;    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>Pipeline</strong> Implementation:<br>Use <code>eval()</code> to create the sieve processes <strong>dynamically</strong> as we need them. The sieve processes eventually <strong>turn into</strong> part of an “array” of primes in tuple space. We ensure <strong>pipelined message flow by tagging</strong> tuples with their destination and position in the sequence.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    eval(<span class="string">"prime"</span>, <span class="number">1</span>, sieve(<span class="number">1</span>)); <span class="comment">// the 1st prime number, the 1st worker</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span>; i&lt;LIMIT; i++) &#123;</span><br><span class="line">        out(<span class="string">"number"</span>, <span class="number">1</span>, i<span class="number">-1</span>, i); <span class="comment">// send number to sieve</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sieve</span> <span class="params">(<span class="keyword">int</span> me)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, p, in_seq=<span class="number">1</span>, out_seq=<span class="number">1</span>, stop=FALSE;</span><br><span class="line">    in(<span class="string">"number"</span>, me, in_seq, ?p);   <span class="comment">// in_seq = 1, first arrival is prime</span></span><br><span class="line">    <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">        in_seq++;</span><br><span class="line">        in(<span class="string">"number"</span>, me, in_seq, ?n);      <span class="comment">// get the next candidate</span></span><br><span class="line">        <span class="keyword">if</span> (n==LIMIT) &#123;</span><br><span class="line">            stop = TRUE; out(<span class="string">"number"</span>, me+<span class="number">1</span>, out_seq, n); <span class="comment">// pass on the signal</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n%p !=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// if never created a successor before</span></span><br><span class="line">            <span class="keyword">if</span> (out_seq == <span class="number">1</span>) eval(<span class="string">"prime"</span>, me+<span class="number">1</span>, sieve(me+<span class="number">1</span>)); <span class="comment">// new sieve</span></span><br><span class="line">            out(<span class="string">"number"</span>, me+<span class="number">1</span>, out_seq, n);       <span class="comment">// and its first input</span></span><br><span class="line">            out_seq++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Tuple-Space"><a href="#Tuple-Space" class="headerlink" title="Tuple Space"></a>Tuple Space</h3><p>Linda’s powerful matching model sets a demanding implementation challenge, way beyond the associative memory hardware used in on-chip caches.</p><p><strong>Indexing</strong> and <strong>hashing</strong> techniques adapted from relational database technology can help (e.g. Linda <code>rd</code> and SQL <code>select</code>).</p><p>Advanced Linda implementations perform considerable compile-time analysis of program specific tuple usage. For example, possible tuples (in a given program) can be categorised into a set of classes by <strong>type signature</strong>, and stored separately.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Reference:&lt;br&gt;&lt;a href=&quot;http://www.inf.ed.ac.uk/teaching/courses/ppls/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.inf.ed.ac.uk/teaching/courses/ppls/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cs.cmu.edu/~213/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMU 15213: Introduction to Computer Systems (ICS)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://csapp.cs.cmu.edu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Computer Systems: A Programmer’s Perspective&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://mpitutorial.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A Comprehensive MPI Tutorial Resource&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.mcs.anl.gov/~itf/dbpp/text/node94.html#SECTION03500000000000000000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A chapter on MPI from Ian Foster’s online Book Designing and Building Parallel Programs&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>Python Digest 之奇技淫巧</title>
    <link href="http://shukebeta.me/python-digest/"/>
    <id>http://shukebeta.me/python-digest/</id>
    <published>2018-05-07T23:00:00.000Z</published>
    <updated>2018-06-29T19:18:48.676Z</updated>
    
    <content type="html"><![CDATA[<p>What you will get from this Python digest:<br>1, Learn advanced python programming.<br>2, Learn new concepts, patterns, and methods that will expand your programming abilities, helping move you from a novice to an expert programmer.<br>3, Practice going from a problem description to a solution, using a series of assignments.</p><a id="more"></a><h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a><a href="https://docs.python.org/2/library/operator.html" target="_blank" rel="noopener">Operator</a></h2><h3 id="Emulating-numeric-types"><a href="#Emulating-numeric-types" class="headerlink" title="Emulating numeric types"></a>Emulating numeric types</h3><p>In-place operation: One modifies the data-structure itself<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">object.__iadd__(self, other)</span><br><span class="line">object.__isub__(self, other)</span><br><span class="line">object.__imul__(self, other)</span><br><span class="line">object.__imatmul__(self, other)</span><br><span class="line">object.__itruediv__(self, other)</span><br><span class="line">object.__ifloordiv__(self, other)</span><br><span class="line">object.__imod__(self, other)</span><br><span class="line">object.__ipow__(self, other[, modulo])</span><br><span class="line">object.__ilshift__(self, other)</span><br><span class="line">object.__irshift__(self, other)</span><br><span class="line">object.__iand__(self, other)</span><br><span class="line">object.__ixor__(self, other)¶</span><br><span class="line">object.__ior__(self, other)</span><br></pre></td></tr></table></figure></p><p> These methods are called to implement the augmented arithmetic assignments. These methods should attempt to do the operation in-place (modifying self) and return the result (which could be, but does not have to be, self).<br> If x is an instance of a class with an <code>__iadd__()</code> method, <code>x += y</code> is equivalent to <code>x = operator.iadd(x, y)</code><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B = np.arange(12).reshape(4,3)</span><br><span class="line">for b in B:</span><br><span class="line">    b += 1</span><br><span class="line">print(B) # B will be changed</span><br></pre></td></tr></table></figure></p><h2 id="Object-oriented-Programming"><a href="#Object-oriented-Programming" class="headerlink" title="Object oriented Programming"></a>Object oriented Programming</h2><h3 id="Class-Name-Guidline"><a href="#Class-Name-Guidline" class="headerlink" title="Class Name Guidline"></a><a href="https://www.python.org/dev/peps/pep-0008/#id41" target="_blank" rel="noopener">Class Name Guidline</a></h3><p><a href="https://hackernoon.com/understanding-the-underscore-of-python-309d1a029edc" target="_blank" rel="noopener">underscore (_)</a>:<br>• For storing the value of last expression in interpreter.<br>• For ignoring the specific values. (so-called “I don’t care”)<br>• To use as ‘Internationalization(i18n)’ or ‘Localization(l10n)’ functions.<br>• To separate the digits of number literal value.</p><p>To give special meanings and functions to name of variables or functions<br>• _single_leading_underscore: weak “internal use” indicator, declaring private variables, functions, methods and classes in a module. Anything with this convention are ignored in from module import *.<br>• single_trailing_underscore_: used by convention to avoid conflicts with Python keyword<br>• <strong>double_leading_underscore: when naming a class attribute, invokes name mangling (inside class FooBar, </strong>boo becomes _FooBar__boo; see <a href="#designing-for-inheritance">Designing for inheritance</a>)<br>• <strong>double_leading_and_trailing_underscore</strong>: “magic” objects or attributes that live in user-controlled namespaces. E.g. <strong>init</strong>, <strong>import</strong> or <strong>file</strong>. Never invent such names; only use them as documented. See <a href="#magic-attributes">Magic Attributes</a></p><h3 id="Designing-for-inheritance"><a href="#Designing-for-inheritance" class="headerlink" title="Designing for inheritance"></a><a href="https://www.python.org/dev/peps/pep-0008/#id49" target="_blank" rel="noopener">Designing for inheritance</a></h3><p>If your class is intended to be subclassed, and you have attributes that you do not want subclasses to use, consider naming them with double leading underscores and no trailing underscores. This invokes Python’s name mangling algorithm, where the name of the class is mangled into the attribute name. This helps avoid attribute name collisions should subclasses inadvertently contain attributes with the same name.<br>• Note 1: Note that only the simple class name is used in the mangled name, so if a subclass chooses both the same class name and attribute name, you can still get name collisions.<br>• Note 2: Name mangling can make certain uses, such as debugging and <strong>getattr</strong>(), less convenient. However the name mangling algorithm is well documented and easy to perform manually.<br>• Note 3: Not everyone likes name mangling. Try to balance the need to avoid accidental name clashes with potential use by advanced callers.</p><h3 id="Descriptor"><a href="#Descriptor" class="headerlink" title="Descriptor"></a><a href="https://docs.python.org/2/howto/descriptor.html" target="_blank" rel="noopener">Descriptor</a></h3><h3 id="Magic-Attributes"><a href="#Magic-Attributes" class="headerlink" title="Magic Attributes"></a><a href="https://docs.python.org/2/library/stdtypes.html#special-attributes" target="_blank" rel="noopener">Magic Attributes</a></h3><p><code>__init__</code> for initialization purpose.</p><p><a href="https://docs.python.org/2/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>object.__dict__</code></a>: A dictionary or other mapping object used to store an object’s (writable) attributes. Basically it contains all the attributes which describe the object under question. It can be used to alter or read the attributes.  </p><p><code>__call__</code></p><h3 id="Is-Python-call-by-value-or-call-by-reference"><a href="#Is-Python-call-by-value-or-call-by-reference" class="headerlink" title="Is Python call-by-value or call-by-reference?"></a>Is Python call-by-value or call-by-reference?</h3><p>Neither.</p><blockquote><p>In Python, (almost) everything is an object. What we commonly refer to as “variables” in Python are more properly called names. A variable is not an alias for a location in memory. Rather, it is simply a binding to a Python object, likewise, “assignment” is really the binding of a name to an object. Each binding has a scope that defines its visibility, usually the block in which the name originates.<br>– <a href="https://jeffknupp.com/blog/2012/11/13/is-python-callbyvalue-or-callbyreference-neither/" target="_blank" rel="noopener">https://jeffknupp.com/blog/2012/11/13/is-python-callbyvalue-or-callbyreference-neither/</a></p></blockquote><p>Python实际上有两种对象。</p><ul><li>一种是可变对象，表现出随时间变化的行为。可变对象的变更对与它绑定的所有名称都可见，如 Python list。</li><li>一种是不可变对象，值在创建后无法修改。<ul><li>跟java的 immutable reference类似的是 Python tuple：虽然 tuple 不可变，那仅是针对其自身所绑定固定的对象而言<code>tuple(list1, list2)</code>，但tuple包含的元素对象<code>list1, list2</code>本身有自己的可变属性.</li></ul></li></ul><p>所以Python的方法调用中,<code>foo(bar)</code>只是在<code>foo</code>的作用域内创建一个与参数<code>bar</code>的绑定。</p><ul><li>如果<code>bar</code>指向可变对象，当<code>foo</code>更改时，这些更改可以在函数<code>foo</code>的作用域外可见。</li><li>如果<code>bar</code>指向一个不可变的对象，<code>foo</code>只能在其自身本地空间中创建一个名称<code>bar</code>并将其绑定到其他对象。</li></ul><h2 id="Solving-Problem"><a href="#Solving-Problem" class="headerlink" title="Solving Problem"></a>Solving Problem</h2><p>A general process to solve problem with three steps: understand, specify and design.<br>1, Start with a vague understanding that you refine into a formal specification of a problem. In this step you want to take inventory of the concepts you are dealing with.<br>2, Specify how this problem can be made amenable to being coded. What is the input and output? What output is desirable?<br>3, Design working code</p><p>?? —-(1 Vague Understanding)–&gt;Formal specification of a problem —(2 Specify)—&gt;Amendable specification—(3 Design)—&gt;Working Code</p><h2 id="Program-Design-and-Development"><a href="#Program-Design-and-Development" class="headerlink" title="Program Design and Development"></a>Program Design and Development</h2><h3 id="Dimensions-of-programming"><a href="#Dimensions-of-programming" class="headerlink" title="Dimensions of programming"></a>Dimensions of programming</h3><ul><li>Correctness, Efficiency, Features, Elegance</li><li>Each part takes time, learn to make Tradeoff:<ul><li>During the process, generally Correctness comes first.<ul><li>Test</li></ul></li><li>But pursuing the 100% Correctness is not the best choice.</li><li>There is a balance of tradeoff, and sometimes saving some time and efforts to improving the Efficiency or adding more Features may be a better option.</li><li>Elegance is good for maintaining and improving the program, which means saving for the future. <strong>Refactoring</strong> - moving along the Elegance direction without changing the other dimensions.<ul><li>DRY: don’t repeat yourself</li><li>Reuse: save time and code lines, also reduce the possibility of mistake<h3 id="Coding-Style"><a href="#Coding-Style" class="headerlink" title="Coding Style"></a><a href="https://docs.python.org/3.5/tutorial/controlflow.html#intermezzo-coding-style" target="_blank" rel="noopener">Coding Style</a></h3>For Python, <a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008</a> has emerged as the style guide that most projects adhere to; it promotes a very readable and eye-pleasing coding style. Here are the most important points extracted:</li></ul></li></ul></li><li><p>Use 4-space indentation, and no tabs.</p><p> 4 spaces are a good compromise between small indentation (allows greater nesting depth) and large indentation (easier to read). Tabs introduce confusion, and are best left out.</p></li><li><p>Wrap lines so that they don’t exceed 79 characters.</p><p> This helps users with small displays and makes it possible to have several code files side-by-side on larger displays.</p></li><li><p>Use blank lines to separate functions and classes, and larger blocks of code inside functions.</p></li><li><p>When possible, put comments on a line of their own.</p></li><li><p>Use <a href="#docstring">docstrings</a>.</p></li><li><p>Use spaces around operators and after commas, but not directly inside bracketing constructs: <code>a = f(1, 2) + g(3, 4)</code>.</p></li><li><p>Name your classes and functions consistently; the convention is to use CamelCase for classes and lower_case_with_underscores for functions and methods. Always use self as the name for the first method argument (see <a href="https://docs.python.org/3.5/tutorial/classes.html#tut-firstclasses" target="_blank" rel="noopener">A First Look at Classes</a> for more on classes and methods).</p></li><li><p>Don’t use fancy encodings if your code is meant to be used in international environments. Python’s default, UTF-8, or even plain ASCII work best in any case.</p></li><li><p>Likewise, don’t use non-ASCII characters in identifiers if there is only the slightest chance people speaking a different language will read or maintain the code.</p></li></ul><h3 id="Docstring"><a href="#Docstring" class="headerlink" title="Docstring"></a>Docstring</h3><p>An easy way to associate documentation with a function.</p><ul><li>Documentation Strings conventions<ul><li>The first line should always be a short, concise summary of the object’s purpose.</li><li>The second line should be blank</li><li>The following lines should be one or more paragraphs describing the object’s calling conventions, its side effects, etc.</li></ul></li><li><p>The following Python file shows the declaration of docstrings within a Python source file:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;Assuming this is file mymodule.py, then this string, being thefirst statement in the file, will become the &quot;mymodule&quot; module&apos;sdocstring when the file is imported.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">class MyClass(object):</span><br><span class="line">    &quot;&quot;&quot;The class&apos;s docstring&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def my_method(self):</span><br><span class="line">        &quot;&quot;&quot;The method&apos;s docstring&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def my_function():</span><br><span class="line">    &quot;&quot;&quot;The function&apos;s docstring&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></li><li><p>The following is an interactive session showing how the docstrings may be accessed:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import mymodule&gt;&gt;&gt; help(mymodule)</span><br><span class="line"></span><br><span class="line">Assuming this is file mymodule.py then this string, being thefirst statement in the file will become the mymodule modulesdocstring when the file is imported</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; help(mymodule.MyClass)The class&apos;s docstring&gt;&gt;&gt; help(mymodule.MyClass.my_method)The method&apos;s docstring&gt;&gt;&gt; help(mymodule.my_function)The function&apos;s docstring&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>It is important that each part of the specification gets turned into a piece of code that implements it and a test that tests it.</p><ul><li>Extreme values<h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a><a href="https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement" target="_blank" rel="noopener">assert</a></h3>Insert debugging assertions into a program. Assertions are not a substitute for unit tests or system tests, but rather a complement.</li><li><a href="http://wiki.python.org/moin/UsingAssertionsEffectively" target="_blank" rel="noopener">Using Assertions Effectively</a><ul><li>Places to consider putting assertions:<ul><li>checking parameter types, classes, or values</li><li>checking data structure invariants</li><li>checking “can’t happen” situations (duplicates in a list, contradictory state variables.)</li><li>after calling a function, to make sure that its return is reasonable<h3 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h3></li></ul></li></ul></li><li>Tracking time<br> Track which part of the code is the bottle neck of efficiency<ul><li>>&gt; python -m cProfile file.py</li><li><code>import cProfile</code>, <code>cProfile.run(&#39;test()&#39;)</code></li></ul></li></ul><h2 id="Aspect-oriented-programming"><a href="#Aspect-oriented-programming" class="headerlink" title="Aspect-oriented programming"></a>Aspect-oriented programming</h2><ul><li>correct</li><li>efficiency<ul><li><a href="#time">Tracking time</a>: to find out the bottle neck function or algorithm</li><li>Rethinking the implementation of the bottle neck<ul><li>Fewer</li><li>Easier/smaller: <a href="https://github.com/ShootingSpace/Guide-to-Computer-Science/blob/master/Note%20-%20CS106B%20Stanford%20Programming%20Abstractions.md#divide-and-conquer" target="_blank" rel="noopener">Divide and Conquer</a></li></ul></li></ul></li><li>debugging<br>Each part is done with some line of codes. Instead of mix different part of the code together, it would be better to define them as different function/class. Try to seperate them as much as possible.</li></ul><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>There are many special and useful function implementation and control flow in python: lambda, map, filter, reduce, generator, etc..</p><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>λ, istead of defining function with <code>def</code> and a specific function name, Lambda provide a convinent way to define a function using its own native logic and methematical expression.<br>The benifits are<br>• A small function could be defined wihtin the same code structure without seperating out a specific <code>def</code> function<br>• Without bothering creating any proper funciton name for a small anonymous function.</p><p>Lambda implementation<br>1, Like nested function definitions, lambda functions can reference variables from the containing scope, returning a function from another function. This is often used to create <strong>function wrappers</strong>, such as Python’s decorators.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uses a lambda expression to return a function</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_incrementor</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x + n</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = make_incrementor(<span class="number">42</span>)  <span class="comment"># f is declared as a lambda function "lambda x: x+42" with parameter n = 42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">0</span>) <span class="comment"># call f with x=0 to return the</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>)</span><br><span class="line"><span class="number">43</span></span><br></pre></td></tr></table></figure></p><p>This is like creating a compiler to save process cost: some parameters like default values or initial values are compiled into the compiler, program process these parameter only once, then this compiler as a function could be called many times with other input parameters which varies every time the compiler is being called(like user input values).</p><p>2, Pass a small function as an argument, sorting or max by an alternate key<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs = [(<span class="number">1</span>, <span class="string">'one'</span>), (<span class="number">2</span>, <span class="string">'two'</span>), (<span class="number">3</span>, <span class="string">'three'</span>), (<span class="number">4</span>, <span class="string">'four'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs.sort(key=<span class="keyword">lambda</span> pair: pair[<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pairs</span><br><span class="line">[(<span class="number">4</span>, <span class="string">'four'</span>), (<span class="number">1</span>, <span class="string">'one'</span>), (<span class="number">3</span>, <span class="string">'three'</span>), (<span class="number">2</span>, <span class="string">'two'</span>)]</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l =[(<span class="string">'x'</span>,<span class="number">2</span>),(<span class="string">'y'</span>,<span class="number">4</span>),(<span class="string">'z'</span>,<span class="number">0</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>max(l, key = <span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">'z'</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>Lambda with logic control flow<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lambda x,y: <span class="keyword">False</span> <span class="keyword">if</span> x&lt;y <span class="keyword">else</span> x+y</span><br></pre></td></tr></table></figure></p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a><a href="https://docs.python.org/2/library/functions.html#filter" target="_blank" rel="noopener">Filter</a></h3><p>Construct a list from the elements of an iterable for which function returns <strong>true</strong>. If iterable is a string or a tuple, the result also has that type; otherwise it is always a list.</p><ul><li><code>filter(function, iterable)</code> equals to<ul><li>if function is <code>None</code>:  <code>[item for item in iterable if item]</code></li><li>if not: <code>[item for item in iterable if function(item)]</code></li></ul></li><li><code>mult3 = filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9])</code> &gt;&gt;&gt; <code>[3, 6, 9]</code></li><li>See <a href="https://docs.python.org/2/library/itertools.html#itertools.ifilter" target="_blank" rel="noopener">itertools.ifilter()</a> and <a href="https://docs.python.org/2/library/itertools.html#itertools.ifilterfalse" target="_blank" rel="noopener">itertools.ifilterfalse()</a> for iterator versions of this function, including a variation that filters for elements where the function returns false.</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a><a href="https://docs.python.org/2/library/functions.html#map" target="_blank" rel="noopener">Map</a></h3><p>Apply function to every item of iterable and <strong>return a list</strong> of the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; map(lambda x: x % 2, [1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">&gt;&gt;&gt; [1, 0, 1, 0, 1, 0, 1, 0, 1]</span><br></pre></td></tr></table></figure></p><h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a><a href="https://docs.python.org/2/library/functions.html#reduce" target="_blank" rel="noopener">Reduce</a></h3><p>Apply function of two arguments cumulatively to the items of iterable, from left to right, so as to reduce the iterable to a single value.<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])</span><br><span class="line">Out[1]: 15 # ((((1+2)+3)+4)+5)</span><br><span class="line">In [1]: reduce(lambda a, b: &apos;&#123;&#125;, &#123;&#125;&apos;.format(a, b), [1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">Out[1]: &apos;1, 2, 3, 4, 5, 6, 7, 8, 9&apos;</span><br></pre></td></tr></table></figure></p><h3 id="List-Dict-Set-Comprehensions"><a href="#List-Dict-Set-Comprehensions" class="headerlink" title="List/Dict/Set Comprehensions"></a>List/Dict/Set Comprehensions</h3><ul><li>List comprehensions: <code>[ s for r, s in cards if r in &#39;JQK&#39; ]</code></li><li>Dictionary comprehensions: <code>{x: x ** 2 for x in range(5) if x % 2 == 0}</code></li><li>Set comprehensions: <code>{int(sqrt(x)) for x in range(30)}</code></li><li>And in general, we can have any number of for statements, if statements, more for statements, more if statements. The whole is read from left to right</li></ul><h3 id="Generator-Expressions"><a href="#Generator-Expressions" class="headerlink" title="Generator Expressions"></a><a href="https://docs.python.org/2/reference/expressions.html#generator-expressions" target="_blank" rel="noopener">Generator Expressions</a></h3><p>Unlike the for loop in the list comprehensions which walk through the whole loop, generator will walk one step in the for loop if a <code>next()</code> is called.</p><ul><li>The advantage is<ul><li>less indentation</li><li>stop the loop early</li><li>easier to edit</li></ul></li><li>Implementation of generator: <code>g = (sq(x) for x in range(10) if x%2 == 0).</code>  <ul><li>The generator function is a promise, but no computation has been done yet.</li><li><code>next(g)</code> to call a one-time calculation.</li><li>When reaching the end of for-loop in the generator, the <code>next(g)</code> comment will return a false called “StopIteration”.</li><li>To avoid the “StopIteration” false<ul><li>Use a outer for statement: <code>for xx in g: ...</code></li><li>convert the generator to list: <code>list(g)</code></li></ul></li></ul></li></ul><h3 id="Generator-functions"><a href="#Generator-functions" class="headerlink" title="Generator functions"></a>Generator functions</h3><p>Using a yield expression in a function definition is sufficient to cause that definition to create a generator function instead of a normal function.</p><ul><li><a href="https://docs.python.org/2/reference/expressions.html#yield-expressions" target="_blank" rel="noopener">Yield expressions</a><br> The yield expression is only used when defining a generator function, and can only be used in the body of a function definition.</li><li><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/index.html" target="_blank" rel="noopener">Yield implementation</a></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ints</span><span class="params">(start, end=None)</span>:</span></span><br><span class="line">    i = start</span><br><span class="line">    <span class="keyword">while</span> i &lt;= end <span class="keyword">or</span> end <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        i = i + <span class="number">1</span></span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span></span><br><span class="line">     n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">     <span class="keyword">while</span> n &lt; max:</span><br><span class="line">          <span class="keyword">yield</span> b</span><br><span class="line">          <span class="comment"># print b</span></span><br><span class="line">          a, b = b, a + b</span><br><span class="line">          n = n + <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p>The true beneath <code>For Statemet</code> is <strong>iterable</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> itmes:</span><br><span class="line">     <span class="keyword">print</span> x</span><br></pre></td></tr></table></figure></p><p>What the whole truth is:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it = iter(items)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">         x = next(it)</span><br><span class="line">         <span class="keyword">print</span> x</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>Overall, Python calls the thing that can be iterated over in a for loop an iterable. Strings and lists are examples of iterables, and so are generators.</p><p><a href="https://docs.python.org/2/library/itertools.html#module-itertools" target="_blank" rel="noopener">itertools library</a> - Functions creating iterators for efficient looping.<br><code>any(iterable)</code>: Return True if any element of the iterable is true. If the iterable is empty, return False.</p><h3 id="Unpacking-Argument-Lists"><a href="#Unpacking-Argument-Lists" class="headerlink" title="Unpacking Argument Lists"></a><a href="https://docs.python.org/3/tutorial/controlflow.html#tut-unpacking-arguments" target="_blank" rel="noopener">Unpacking Argument Lists</a></h3><p>The <code>*</code> operator simply unpacks the tuple or list and passes them as the positional arguments to the function.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">3</span>, <span class="number">6</span>))            <span class="comment"># normal call with separate arguments</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = [<span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(*args))            <span class="comment"># call with arguments unpacked from a list</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><h3 id="Handling-different-types-of-argument-polymorphism"><a href="#Handling-different-types-of-argument-polymorphism" class="headerlink" title="Handling different types of argument (*polymorphism)"></a>Handling different types of argument (*polymorphism)</h3><p>An argument could be different type:<br>   <code>timedcalls(n,fn)</code>, if n is int <code>isinstance(n,int)</code>, it means controling the how many times fn was called, while n is float, it means controling the total runtime of fn called</p><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><h2 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a><a href="https://www.python.org/dev/peps/pep-0318/" target="_blank" rel="noopener">Decorator</a></h2><p>Motivation: when applying a transformation to a function <code>def f(self): ...definition...; f = dec(f)</code>, it becomes less readable with longer methods. It also seems less than pythonic to name the function three times for what is conceptually a single declaration.</p><p>The solution is to place the decoration in the function’s declaration:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dec</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><h3 id="property"><a href="#property" class="headerlink" title="@property"></a><a href="https://www.programiz.com/python-programming/property" target="_blank" rel="noopener">@property</a></h3><p><code>property(fget=None, fset=None, fdel=None, doc=None)</code><br>A property object has three methods, getter(), setter(), and delete() to specify fget, fset and fdel at a later point.</p><p><code>some_object = property(get_some_object,set_some_object)</code> equals to<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">some_object = property()  <span class="comment"># make empty property</span></span><br><span class="line">some_object = some_object.getter(get_some_object) <span class="comment"># assign fget</span></span><br><span class="line">some_object = some_object.setter(set_some_object) <span class="comment"># assign fset</span></span><br></pre></td></tr></table></figure></p><p>Decorator as tools<br>• Debug tool: help developping, count calls times, count excecute time<br>• Performance: make the programme faster, such as dynamic programming algorithm<br>• Expressiveness: doc string, explaining funciton<br>• Trace: help to monitor the execution of the program, such as each level result printed with different indentation</p><p>Disable decorator: <code>dec = disabled</code>, make the decorator disabled.</p><h2 id="Regular-Expression"><a href="#Regular-Expression" class="headerlink" title="Regular Expression"></a><a href="https://docs.python.org/2/library/re.html" target="_blank" rel="noopener">Regular Expression</a></h2><p><code>import re</code></p><p><a href="http://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html" target="_blank" rel="noopener">Reference: A Regular Expression Matcher</a></p><p>In C language, any number start with ‘0’ is interpreted as an octal number( base-8 number system ):<br>‘012’ -&gt; int 10; ‘09’ -&gt; invalid</p><p><strong>Special characters</strong><br>• <code>*</code> match 0 or more repetitions of the preceding character. ab* will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s.<br>• <code>?</code> Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. ab? will match either ‘a’ or ‘ab’.<br>• <code>.</code> (Dot) matches any single character<br>• <code>^</code> (Caret) Matches the start of the string<br>• <code>$</code> Matches the end of the string or just before the newline at the end of the string, foo matches both ‘foo’ and ‘foobar’, while the regular expression foo$ matches only ‘foo’<br>• <code>+</code> match 1 or more repetitions of the preceding RE. <code>ab+</code> will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’.</p><p><strong>Commonly used expression</strong><br>• Upper case letter <code>&#39;[A-Z]&#39;</code><br>• Any alphanumeric character <code>[a-zA-Z0-9_]</code><br>• Decimal digit <code>[0-9]</code><br>• Non-digit character <code>[^0-9]</code><br>• Whitespace character <code>[ \t\n\r\f\v]</code></p><p><code>search(string[, pos[, endpos]])</code>: Scan through string looking for a location where this regular expression produces a match, and return a corresponding MatchObject instance. Return None if no position in the string matches the pattern.</p><p><code>re.findall(pattern, string, flags=0)</code>：Return all non-overlapping matches of pattern in string, as a list of strings.</p><h3 id="String-Formatting"><a href="#String-Formatting" class="headerlink" title="String Formatting"></a><a href="https://docs.python.org/2.4/lib/typesseq-strings.html" target="_blank" rel="noopener">String Formatting</a></h3><p>Modulo(<code>%</code>): String and Unicode objects have one unique built-in operation: the <code>%</code> operator (modulo). This is also known as the string formatting or interpolation operator. Given format <code>%</code> values (where format is a string or Unicode object), <code>%</code> conversion specifications in format are replaced with zero or more elements of values.<br><code>%d</code>:    Signed integer decimal.<br><code>%s</code>:    String (converts any python object using str()).<br><code>print &#39;%d: %s&#39; % (1, &#39;animal&#39;)</code> &gt;&gt; <code>1: animal</code></p><h2 id="Python-data-structure"><a href="#Python-data-structure" class="headerlink" title="Python data structure"></a>Python data structure</h2><h3 id="Numpy-indexing"><a href="#Numpy-indexing" class="headerlink" title="Numpy indexing"></a><a href="https://docs.scipy.org/doc/numpy-dev/reference/arrays.indexing.html#indexing" target="_blank" rel="noopener">Numpy indexing</a></h3><p>Ellipsis: The same as <code>...</code>. Special value used mostly in conjunction with extended slicing syntax for user-defined container data types. <code>a = [1,2,3], a[...] is actually the same as a</code></p><p>None: extends one more demention by further slicing the corresponding c into smallest units.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t = np.arange(<span class="number">27</span>).reshape(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>), <span class="comment">#t shape is (3,3,3)</span></span><br><span class="line">t[<span class="keyword">None</span>,].shape <span class="comment"># (1, 3, 3, 3)</span></span><br><span class="line">t[...,<span class="keyword">None</span>].shape <span class="comment"># (3, 3, 3, 1)</span></span><br><span class="line">t[:, <span class="keyword">None</span>,:].shape <span class="comment"># (3, 1, 3, 3)</span></span><br><span class="line">t[:,:, <span class="keyword">None</span>].shape <span class="comment"># (3, 3, 1, 3)</span></span><br></pre></td></tr></table></figure></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>• <a href="https://www.udacity.com/course/design-of-computer-programs--cs212" target="_blank" rel="noopener">CS212 Design of Computer Program @Udacity</a>, <a href="https://www.udacity.com/wiki/cs212" target="_blank" rel="noopener">Course Wiki</a></p><blockquote><p>Syllabus<br>Lesson 1: How to think to solve problem<br>Lesson 2: Python features; Instrumentation<br>Lesson 3: Build function as tools; Define language; Grammar<br>Lesson 4: Dealing with Complexity Through Search<br>Lesson 5: Dealing with Uncertainty Through Probability</p></blockquote><p>• <a href="https://docs.python.org/3/tutorial/" target="_blank" rel="noopener">The Python Tutorial</a><br>• <a href="http://www.openbookproject.net/thinkcs/" target="_blank" rel="noopener">Open Book Project: How to Think Like a Computer Scientist: Learning with Python</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;What you will get from this Python digest:&lt;br&gt;1, Learn advanced python programming.&lt;br&gt;2, Learn new concepts, patterns, and methods that will expand your programming abilities, helping move you from a novice to an expert programmer.&lt;br&gt;3, Practice going from a problem description to a solution, using a series of assignments.&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Python" scheme="http://shukebeta.me/tags/Python/"/>
    
      <category term="Programming Language" scheme="http://shukebeta.me/tags/Programming-Language/"/>
    
  </entry>
  
  <entry>
    <title>Software Testing - Informatics - University of Edinburgh 爱丁堡大学</title>
    <link href="http://shukebeta.me/UoE-st/"/>
    <id>http://shukebeta.me/UoE-st/</id>
    <published>2018-05-05T23:00:00.000Z</published>
    <updated>2018-07-21T16:18:41.644Z</updated>
    
    <content type="html"><![CDATA[<p>Reference:<br><a href="http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/index.html" target="_blank" rel="noopener">http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/index.html</a><br>Pezze and Young, Software Testing and Analysis: Process, Principles and Techniques, Wiley, 2007.<br><a id="more"></a></p><h2 id="Why-Software-Testing"><a href="#Why-Software-Testing" class="headerlink" title="Why Software Testing?"></a>Why Software Testing?</h2><p><strong>1, 软件的漏洞, 错误和失效 Software Faults, Errors &amp; Failures</strong><br>The problem start with Faults,</p><blockquote><p>Fault(BUG): latent error, mistakes in programming.</p></blockquote><p>e.g <code>add(x, y) = x * y</code>.<br>With the Faults in programs, <strong>if and only if</strong> executing <code>add(x, y) = x * y</code>, the fault being activated, and generate an Errors.</p><blockquote><p>Error: An incorrect <strong>internal</strong> state that is the manifestation of some fault</p></blockquote><p>Now we has an effective Error, <strong>if and only if</strong> we use the values from <code>add(x, y) = x * y</code> to contribute to the program function (such as, assign it to some variables), then we get the Failure.</p><blockquote><p>Failure : <strong>External</strong>, observable incorrect behavior with respect to the requirements or other description of the expected behavior.</p></blockquote><p>总结: 软件的漏洞不一定会导致错误, 错误不一定会导致软件失效.</p><p><strong>2, 软件工程需要验证确认</strong></p><blockquote><p>在软件项目管理、软件工程及软件测试中，验证及确认（verification and validation，简称V&amp;V）是指检查软件是否匹配规格及其预期目的的程序。验证及确认也被视为一种软件质量管理，是软件开发过程的一部分，一般归类在软件测试中。</p></blockquote><p>Validation: 是否符合预期的目的，是否满足用户实际需求？</p><p>Verification: meets the specification?</p><p>Verification and Validation （V&amp;V） start at the beginning or even before we decide to build a software product. V&amp;V last far beyond the product delivery as long as the software is in use, to cope with evolution and adaptations to new conditions.</p><p>The distinction between the two terms is largely to do with the role of specifications. Validation is the process of checking whether the specification captures the customer’s needs, while verification is the process of checking that the software meets the specification.<br><img src="/images/VandVtoolbox.jpg" alt="" title="V＆V包含的技术细节。 &quot;modeling&quot; 和 &quot;model checking&quot;指建立和分析软件行为的抽象模型。image from: http://www.easterbrook.ca/steve/2010/11/the-difference-between-verification-and-validation/"></p><p><strong>3, 软件工程的可靠性 Dependability</strong></p><blockquote><p>In software engineering, dependability is the ability to provide services that can defensibly be trusted within a time-period</p></blockquote><p>Assess the readiness of a product.</p><p>Different measures of dependability:<br>• Availability measures the quality of service in terms of running versus down time<br>• Mean time between failures (MTBF) measures the quality of the service in terms of time between failures<br>• Reliability indicates the fraction of all attempted operations that complete successfully</p><h2 id="JUnits"><a href="#JUnits" class="headerlink" title="JUnits"></a>JUnits</h2><p>JUnit Terminology<br>• A test runner is software that runs tests and reports results. Many implementations: standalone GUI, command line, integrated into IDE<br>• A test suite is a collection of test cases.<br>• A test case tests the response of a single method to a particular set of inputs.<br>• A unit test is a test of the smallest element of code you can sensibly test, usually a single class.</p><p>如何使用请参考<a href="/NOTE-CS61B-data-structures-11-testing">Java 测试</a>.</p><p>Test class<br><code>@Before public void init()</code>: Creates a test fixture by creating and initialising objects and values.</p><p><code>@After public void cleanUp()</code>: Releases any system resources used by the test fixture. Java usually does this for free, but files, network connections etc. might not get tidied up automatically.</p><p><code>@Test public void noBadTriangles()</code>, <code>@Test public void scaleneOk()</code>, etc.<br>These methods contain tests for the Triangle constructor and its isScalene() method.</p><p>Test assert<br><code>static void assertTrue(boolean test)</code>,<br><code>static void assertTrue(String message, boolean test)</code>,<br><code>static void assertFalse(boolean test)</code>,<br><code>static void assertFalse(String message, boolean test)</code></p><h2 id="软件测试的核心问题和解决思路"><a href="#软件测试的核心问题和解决思路" class="headerlink" title="软件测试的核心问题和解决思路"></a>软件测试的核心问题和解决思路</h2><p>A key problem in software testing is <strong>selecting and evaluating</strong> test cases.</p><ul><li>Test case: A test case is a set of inputs, execution conditions, and a pass/fail criterion.</li><li><strong>Test case specification</strong> is a requirement to be satisfied by one or more actual test cases.</li><li>Test suite: a set of test cases.</li><li>Adequacy criterion: a predicate that is true (satisfied) or false (not satisfied) of a &lt; program, test suite &gt; pair.</li></ul><p>Adequacy criterion is a set of test obligations, which can be derived from several sources of information, including<br>• specifications (functional and model-based testing)<br>• detailed design and source code (structural testing),<br>• model of system<br>• hypothesized defects (fault-based testing),<br>• security testing.</p><h3 id="Test-Case-Selection-and-Adequacy-Criteria"><a href="#Test-Case-Selection-and-Adequacy-Criteria" class="headerlink" title="Test Case Selection and Adequacy Criteria"></a>Test Case Selection and Adequacy Criteria</h3><p>How do we know when the test suite is enough?<br>It is impossibal to provide adequate test suite for a system to pass. Instead, <strong>design rules to highlight inadequacy of test suites</strong>: if outcome break the rule, then there is bugs, if not, then not sure…</p><p>Test case specification: a requirement to be satisfied by one or more test cases.</p><p>Test obligation: a partial test case specification, requiring some property deemed important to thorough testing. From:<br>• Functional (black box specification Functional (black box, specification based): from software specifications<br>• Structural (white or glass box): from code<br>• Model-based: from model of system, models used in specification or design, or derived from code<br>• Fault-based: from hypothesized faults (common bugs)</p><p>Adequacy criterion: set of test obligations, a predicate that is true (satisfied) or false (not satisfied) of a (program, test suite) pair.</p><p>A test suite satisfies an adequacy criterion if:<br>• all the tests succeed (pass)<br>• every test obligation in the criterion is satisfied by at least one of the test cases in the test suite.</p><h3 id="Satisfiability"><a href="#Satisfiability" class="headerlink" title="Satisfiability"></a>Satisfiability</h3><p>Sometimes no test suite can satisfy a criterion for a given program, e.g. defensive programming style includes “can’t happen” sanity checks.</p><p>Coping with Unsatisfiability:<br>Approach A, exclude any unsatisfiable obligation from the criterion.<br>• Example: modify statement coverage to require execution only of statements that can be executed - But we can’t know for sure which are executable!</p><p>Approach B, measure the extent to which a test suite approaches an adequacy criterion<br>• Example: if a test suite satisfies 85 of 100 obligations we have reached 85% coverage.</p><p>An adequacy criterion is satisfied or not, a coverage measure is the fraction of satisfied obligations</p><h3 id="Subsumption-relation"><a href="#Subsumption-relation" class="headerlink" title="Subsumption relation"></a>Subsumption relation</h3><p>Test adequacy criterion A subsumes test adequacy criterion B iff, for every program P, every test suite satisfying A with respect to P also satisfies B with respect to P.</p><p>e.g. Exercising all program branches (branch coverage) subsumes exercising all program statements</p><h2 id="Functional-Testing"><a href="#Functional-Testing" class="headerlink" title="Functional Testing"></a>Functional Testing</h2><p>Design functional test case: Generate test cases from specifications.</p><p>Specification: A <strong>functional specification</strong> is a description of intended program behavior.</p><p>Not based on the internals of the code but program specifications, functional testing is also called <strong>specification-based</strong> or <strong>black-box testing 黑箱測試</strong>.</p><p>The core of functional test is systematic selection of test cases: <strong>partitioning</strong> the possible behaviors of the program into a finite number of homogeneous classes, where each such class can reasonably be expected to be consistently correct or incorrect. Test each category and boundaries between (experience suggests failures often lie at the boundaries).</p><blockquote><p><strong>Functional test case design</strong> is an indispensable base of a good test suite, complemented but never replaced by <strong>structural and fault-based testing</strong>, because there are classes of faults that only functional testing effectively detects. Omission of a feature, for example, is unlikely to be revealed by techniques that refer only to the code structure.</p></blockquote><h3 id="Partition-Strategies"><a href="#Partition-Strategies" class="headerlink" title="Partition Strategies"></a>Partition Strategies</h3><p>Failures are sparse in the whole input space, and dense in some specific regions, justified based on specification.</p><p><strong>Random</strong> (uniform):<br>• Pick possible inputs uniformly<br>• Avoids designer bias: The test designer can make the same logical mistakes and bad assumptions as the program designer (especially if they are the same person)<br>• But treats all inputs as equally valuable</p><p><strong>Systematic</strong> (non-uniform, Partition Testing Strategies):<br>• Try to select inputs that are especially valuable<br>• Usually by choosing representatives of classes that are apt to fail often or not at all<br>• (Quasi-)Partition: separates the input space into classes whose union is the entire space (classes may overlap), sampling each class in the quasi-partition selects at least one input that leads to a failure, revealing the fault.</p><p>Steps of systematic approaches to form test cases from specifications:<br>1, Decompose the specification. If the specification is large, break it into independently testable features (ITF) to be considered in testing:<br>• An ITF is a functionality that can be tested independently of other functionalities of the software under test. It need not correspond to a unit or subsystem of the software.<br>• ITFs are described by identifying all the inputs that form their execution environments.<br>• ITFs are applied at different granularity levels, from unit testing through integration and system testing. The granularity of an ITF depends on the exposed interface and whichever granularity(unit or system) is being tested.<br>2, Identify Representative Classes of Values or Derive a Model<br>• Representative values of each input<br>• Representative behaviors of a model: simple input/output transformations don’t describe a system. We use models in program specification, in program design, and in test design<br>3, Generate Test Case Specifications with constraints: The test case specifications represented by the <strong>combinations</strong> (cartesian product) of all possible inputs or model behaviors, which must be restricted by ruling out illegal combinations and selecting a practical subset of the legal combinations.</p><p>Given a specification, there may be one or more techniques well suited for deriving functional test case. For example, the presence of several constraints on the input domain may suggest using a partitioning method with constraints, such as the <a href="#category-partition">category-partition method</a>. While unconstrained combinations of values may suggest a <a href="#pairwise-combination-testing">pairwise combinatorial approach</a>. If transitions among a finite set of system states are identifiable in the specification, a finite state machine approach may be indicated.</p><h3 id="Combinatorial-approaches"><a href="#Combinatorial-approaches" class="headerlink" title="Combinatorial approaches"></a>Combinatorial approaches</h3><blockquote><p>Combinatorial approaches to functional testing consist of a manual step of structuring the specification statement into a set of properties or attributes that can be <strong>systematically varied</strong> and an automatizable step of producing combinations of choices.</p></blockquote><p>总体思路：<br>1, Identify <strong>distinct</strong> attributes that can be varied: the data, environment, or configuration<br>2, Systematically generate combinations to be tested</p><p>Rational: test cases should be varied and include possible “corner cases”</p><p><strong>Environment</strong> describes external factors we need to configure in particular ways in order to specify and execute tests to fully exercise the system. Some common options: System memory, Locale.</p><p>There are three main techniques that are successfully used in industrial environments and represent modern approaches to systematically derive test cases from natural language specifications:<br>• category-partition approach to identifying attributes, relevant values, and possible combinations;<br>• Pairwise (n-way) combination test a large number of potential interactions of attributes with a relatively small number of inputs;<br>• provision of catalogs to systematize the manual aspects of combinatorial testing.</p><p>Combinatorial approaches 将test cases的粗暴合成分解成一个个步骤，通过解析和综合那些可以量化和监控(并得到工具部分支持)的活动来逐步拆解问题.</p><p>A combinatorial approach may work well for functional units characterized by a large number of <strong>relatively independent inputs</strong>, but may be less effective for functional units characterized by complex interrelations among inputs.</p><p>Category-partition 和 pairwise partition 都是使用上面的总体思路，差别在于最后如何自动生成 test cases。</p><h4 id="Category-partition"><a href="#Category-partition" class="headerlink" title="Category-partition"></a>Category-partition</h4><p>将穷举枚举作为自动生成combinations的基本方法，同时允许测试设计者添加限制组合数量增长的约束条件。当这些约束能够反映应用域中的真实约束（例如，category-partition中的”error”条目）时，能够非常有效地消除许多冗余组合。</p><ol><li>Decompose the specification into independently testable features<ul><li>for each feature: identify parameters, environment elements</li><li>for each parameter and environment element: identify elementary characteristics (categories)</li></ul></li><li>Identify relevant/representative values: for each category identify  representative (classes of) values<ul><li>normal values</li><li>boundary values<ul><li>select extreme values within a class ((e.g., maximum and minimum legal values)</li><li>select values outside but as close as possible to the class</li><li>select interior (non-extreme) values of the class</li></ul></li><li>special values: 0 and 1, might cause unanticipated behavior alone or in combination with particular values of other parameters.</li><li>error values: values outside the normal domain of the program</li><li>Ignore interactions among values for different categories (considered in the next step)</li></ul></li><li>Introduce constraints: rule out invalid combinations. For single consgtraints, indicates a value class that test designers choose to test only once to reduce the number of test cases.</li></ol><p>优点：Category partition testing gave us systematic approach -Identify characteristics and values (the creative step), generate combinations (the mechanical step).</p><p>缺点：test suite size grows very rapidly with number of categories.</p><p>不适合使用Category partition testing的情况：当缺乏应用领域的实际约束时，测试设计者为了减少组合数量被迫任意添加的约束（例如，”single”条目），此时不能很有效的减少组合数量。</p><h4 id="Pairwise-combination-testing"><a href="#Pairwise-combination-testing" class="headerlink" title="Pairwise combination testing"></a>Pairwise combination testing</h4><p>Most failures are triggered by single values or combinations of a few values.</p><p>为n个测试类选择组合时，除了简单地枚举所有可能的组合外，更实际的组合方案是在集合n中取出k(<code>k&lt;n</code>)项, 一般是二元组或三元组，总的 test cases 要包含所有 features 的两两（或三三）组合。生成测试用例时，先控制某一个变量逐一改变，记录配对了的变量，后续遇到重复的就可以忽略。这样即使没有加constraints也可以大大减少组合数（但我们也可以加constraints）。</p><p>使用低阶组合构建测试用例时，可能会遗漏某些高阶组合的情况。</p><h3 id="Befinits-of-functional-testing"><a href="#Befinits-of-functional-testing" class="headerlink" title="Befinits of functional testing"></a>Befinits of functional testing</h3><p>Functional testing is the base-line technique for designing test cases:<br>• Timely: Often useful in refining specifications and assessing testability before code is written<br>• Effective: finds some classes of fault (e.g.,missing logic) that can elude other approaches<br>• Widely applicable: to any description of program behavior serving as spec,  at any level of granularity from module to system testing.<br>• Economical: typically less expensive to design and execute than structural (code-based) test cases</p><p>Early functional testing design:<br>• Program code is not necessary: Only a description of intended behavior is needed<br>• Often reveals ambiguities and inconsistency in spec<br>• Useful for assessing testability, and improving test schedule and budget by improving spec<br>• Useful explanation of specification, or in the extreme case (as in Extreme Programming), test cases are the spec</p><h2 id="Finite-Models"><a href="#Finite-Models" class="headerlink" title="Finite Models"></a>Finite Models</h2><p>建模主要解决两个工程问题:<br>• 首先，不能等到实际的产品出来后才分析和测试。<br>• 其次，对实际产品进行彻底的测试是不切实际的，无论是否受制于所有可能的状态和输入。</p><p>模型允许我们在开发早期就着手分析，并随着设计的发展重复分析，并允许我们应用比实际情况更广泛的分析方法。更重要的是，这些分析很多都是可以自动化的。</p><p>Model program execution, emphasized control.</p><blockquote><p>A model is a representation that is simpler than the artifact it represents but preserves (or at least approximates) some important attributes of the actual artifact.</p></blockquote><p>A good model is:<br>• compact: A model must be representable and manipulable in a reasonably compact form.<br>• Predictive: well enough to distinguish between “good” and “bad” outcomes of analysis.<br>• Semantically meaningful: interpret analysis results in a way that permits diagnosis of the causes of failure.<br>• Sufficiently general: Models intended for analysis of some important characteristic must be general enough for practical use in the intended domain of application.</p><p>模型的表达：使用有向图描述程序模型。通常我们将它们绘制为”方框和箭头”图，由一组节点N的组成的集合和它们间的关系E（即ordered pairs的集合），edges。节点表示某种类型的实体，例如源代码的步骤，类或区域。边表示实体之间的某种关系。</p><p>模拟程序执行的模型，是该程序状态空间的抽象。通过抽象函数，程序运行状态空间中的状态与程序运行的finite state 模型中的状态相关联。但抽象函数无法完美呈现程序运行的所有细节，将实际的无限可能的状态折叠成有限必然需要省略一些信息，这就引入了不确定性nondeterminism。</p><p>有什么软件模型的基本概念，又有哪些可以应用于测试和分析的模型？</p><h3 id="Controal-flow-graph"><a href="#Controal-flow-graph" class="headerlink" title="Controal flow graph"></a>Controal flow graph</h3><p>程序中的单个步骤或方法的 Control flow 可以用 <strong>过程内流程图 intraprocedural control flow graph (CFG)</strong> 来表示. CFG 模拟通过<strong>单个过程或方法</strong>的可能运行路径, 是一个有向图，nodes 表示源代码的一个个区域，有向边 directed edges 表示程序可以在哪些代码区域间流转.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">collapseNewlines</span><span class="params">(String argStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> last = argStr.charAt(<span class="number">0</span>);</span><br><span class="line">    StringBuffer argBuf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cIdx = <span class="number">0</span> ; cIdx &lt; argStr.length(); cIdx++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = argStr.charAt(cIdx);</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="string">'\n'</span> || last != <span class="string">'\n'</span>) &#123;</span><br><span class="line">            argBuf.append(ch);</span><br><span class="line">            last = ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> argBuf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>左边是上面代码对应的CFG，右边的表格是Linear Code Sequence and Jump (LCSJ)，表示从一个分支到另一个分支的控制流程图的子路径<br><img src="/images/cfg.jpg" alt="" title="Derive from code, not specifications. image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Ch05.pdf"></p><p>Nodes = regions of source code (basic blocks)<br>• Basic block = maximal program region with a single entry and single exit point<br>• Often statements are grouped in single regions to get a compact model<br>• Sometime single statements are broken into more than one node to model control flow within the statement<br>Directed edges = possibility that program execution proceeds from the end of one region directly to the beginning of another</p><p>为了便于分析，控制流程图通常会通过其他信息进一步加持。例如，后面介绍的数据流模型 data flow models 就是基于加持了有关变量被程序各个语句访问和修改的信息的CFG模型构建的.</p><h3 id="Call-Graphs"><a href="#Call-Graphs" class="headerlink" title="Call Graphs"></a>Call Graphs</h3><p>过程间流程 Interprocedural control flow 也可以表示为有向图。最基本的模型是调用图 call graphs, nodes represent procedures (methods, C functions, etc.) and edges represent the “calls” relation.</p><p>相较于CFG，调用图比有更多设计问题和权衡妥协， 因此基本调用图的表达方式是不固定的，特别是在面向对象的语言中，methods跟对象动态绑定。<br>调用图存在Overapproximation现象，比如尽管方法<code>A.check()</code>永远不会实际调用<code>C.foo()</code>，但是一个典型的调用图会认为这个调用是可能的。</p><p><strong>Context-sensitive call graph</strong>：调用图模型根据过程被调用的具体位置来表示不同行为。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Context c = <span class="keyword">new</span> Context();</span><br><span class="line">        c.foo(<span class="number">3</span>);</span><br><span class="line">        c.bar(<span class="number">17</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] myArray = <span class="keyword">new</span> <span class="keyword">int</span>[ n ];</span><br><span class="line">        depends( myArray, <span class="number">2</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] myArray = <span class="keyword">new</span> <span class="keyword">int</span>[ n ];</span><br><span class="line">        depends( myArray, <span class="number">16</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">depends</span><span class="params">( <span class="keyword">int</span>[] a, <span class="keyword">int</span> n )</span> </span>&#123;</span><br><span class="line">        a[n] = <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/call_graphs_contex.jpg" alt="" title="Contex Insensitive vs. Sensitive Call graphs"></p><p>Context sensitive analyses can be more precise than Context-insensitive analyses when the model includes some additional information that is shared or passed among procedures. But sensitive call graphs size grows exponentially, not fit for large program.</p><h3 id="Finite-state-machines"><a href="#Finite-state-machines" class="headerlink" title="Finite state machines"></a>Finite state machines</h3><p>前面介绍的模型都是都是基于源代码抽象出来的。不过，模型的构建也常常先于或者独立于源代码，有限状态机 finite state machines 就是这种模型。</p><blockquote><p>有限状态机（finite-state machine，FSM）又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。</p></blockquote><p>最简单的FSM由一个有限的状态集合和状态间的转移动作构成，可以有向图表示，节点表示状态，edges表示在状态间的转移需要的运算、条件或者事件。因为可能存在无限多的程序状态，所以状态节点的有限集合必须是具体编程状态的抽象。</p><p>Usually we label the edge to indicate a program operation, condition, or event associated with the transition. We may label transitions with both an external event or a condition and with a program operation that can be thought of as a “response” to the event. Such a finite state machine with event/response labels on transitions is called a Mealy machine.</p><blockquote><p>In the theory of computation, a <strong>Mealy machine</strong> is a finite-state machine whose output values are determined both by its current state and the current inputs. (This is in contrast to a <strong>Moore machine</strong>, whose output values are determined solely by its current state.)</p></blockquote><p>An alternative representation of finite state machines, including Mealy machines, is the state transition table:<br><img src="/images/FSM_state_transition_table.png" alt="" title="Could be constructed from features. image from: Pezze and Young, Software Testing and Analysis: Process, Principles and Techniques, Wiley, 2007."><br>There is one row in the transition table for each state node and one column for each event or input. If the FSM is complete and deterministic, there should be exactly one transition in each table entry. Since this table is for a Mealy machine, the transition in each table entry indicates both the next state and the response (e.g., d / emit means “emit and then proceed to state d”).</p><h2 id="Structural-Testing"><a href="#Structural-Testing" class="headerlink" title="Structural Testing"></a>Structural Testing</h2><p>Judging test suite thoroughness based on the structure of the program itself, it is still testing product functionality against its specification, but the measure of thoroughness has changed to <strong>structural criteria</strong>. Also known as “white-box”, “glass-box”, or “codebased” testing.</p><p>Motivation:<br>1, If part of a program is not executed by any test case in the suite, faults in that part cannot be exposed. The <strong>part</strong> is a control flow element or combination, statements (or CFG nodes), branches (or CFG edges), fragments and combinations, conditions paths.<br>2, Complements functional testing, another way to recognize cases that are treated differently<br>3, Executing all control flow elements does not guarantee finding all faults: Execution of a faulty statement may not always result in a failure<br>• The state may not be corrupted when the statement is executed with some data values<br>• Corrupt state may not propagate through execution to eventually lead to failure<br>4, Structural coverage: Increases confidence in thoroughness of testing, removes some obvious inadequacies</p><p>Steps:</p><ol><li>Create functional test suite first, then measure structural coverage to identify see what is missing</li><li>Interpret unexecuted elements<ul><li>may be due to natural differences between specification and implementation</li><li>or may reveal flaws of the software or its development process<ul><li>inadequacy of specifications that do not include cases present in the implementation</li><li>coding practice that radically diverges from the specification</li><li>inadequate functional test suites</li></ul></li></ul></li></ol><p>Coverage measurements are convenient progress indicators, sometimes used as a criterion of completion.</p><h3 id="Control-flow-Adequacy-expression-coverage"><a href="#Control-flow-Adequacy-expression-coverage" class="headerlink" title="Control-flow Adequacy (expression coverage)"></a>Control-flow Adequacy (expression coverage)</h3><p>A structural testing strategy that uses the program’s control flow as a model. Control flow elements include statements, branches, conditions, and paths.</p><p>But a set of correct program executions in which all control flow elements are exercised does not guarantee the absence of faults.</p><p>Test based on control-flow are concerned with expression coverage.</p><h3 id="Statement-testing"><a href="#Statement-testing" class="headerlink" title="Statement testing"></a>Statement testing</h3><p>Adequacy criterion: each statement (or node in the CFG) must be executed at least once. Because a fault in a statement can only be revealed by executing the faulty statement.</p><p>Coverage: <code>#(executed statements) / #(statements)</code></p><p>Minimizing test suite size is seldom the goal, but small test cases make failure diagnosis easier.</p><p>Complete statement coverage may not imply executing all branches in a program.</p><h3 id="Branch-testing"><a href="#Branch-testing" class="headerlink" title="Branch testing"></a>Branch testing</h3><p>Adequacy criterion: each branch (edge in the CFG) must be executed at least once.</p><p>Coverage: <code>#(executed branches) / #(branches)</code><br>Traversing all edges of a graph causes all nodes to be visited: test suites that satisfy the branch adequacy criterion for a program P also satisfy the statement adequacy criterion for the same program</p><p>But “All branches” can still miss conditions.<br>Sample fault: missing operator (negation):<code>digit_high == 1 || digit_low == -1</code>, branch adequacy criterion can be satisfied by varying only part of the condition.</p><h3 id="Condition-testing"><a href="#Condition-testing" class="headerlink" title="Condition testing"></a>Condition testing</h3><p>Basic condition adequacy criterion: each basic condition must be executed at least once.</p><p>Coverage: <code>#(truth values taken by all basic conditions) / 2 * #(basic conditions)</code></p><p>Branch and basic condition are not comparable. Basic condition adequacy criterion can be satisfied without satisfying branch coverage</p><p>Branch and condition adequacy: cover all conditions and all decisions</p><p><strong>Compound condition adequacy</strong>:<br>• Cover all possible evaluations of compound conditions - A compound condition is either an atomic condition or some boolean formula of atomic conditions. For example, in the overall condition “<code>A || (B &amp;&amp; C)</code>“ the set of compound conditions are “A”, “B”, “<code>C&quot;, &quot;B &amp;&amp; C</code>“, “<code>A || (B &amp;&amp; C)</code>“.<br>• Cover all branches of a decision tree.<br>• Number of test cases grows exponentially with the number of basic conditions in a decision ($2^N$).</p><p>练习 - Write tests that provide statement, branch, and basic condition coverage over the following code:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(string A[], <span class="keyword">int</span> N, string what)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((N == <span class="number">1</span>) &amp;&amp; (A[<span class="number">0</span>] == what))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (N &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; N)&#123;</span><br><span class="line">            <span class="keyword">if</span> (A[index] == what) <span class="keyword">return</span> index;</span><br><span class="line">            <span class="keyword">else</span> index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先画出 CFG 图，再遍历：<img src="/images/Structural_testin_答案.png" alt="" title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Activity.pdf"></p><h3 id="Modified-condition-decision-adequacy-criterion-MC-DC"><a href="#Modified-condition-decision-adequacy-criterion-MC-DC" class="headerlink" title="Modified condition/decision adequacy criterion (MC/DC)"></a>Modified condition/decision adequacy criterion (MC/DC)</h3><p>Motivation: Effectively test <strong>important combinations</strong> of conditions, without exponential blow up in test suite size. (<strong>Important combinations</strong>: Each basic condition shown to independently affect the outcome of each decision)</p><p>假如这些组合表明每一个条件都可以独立影响结果，那么就不要穷尽各种条件组合了，对于那些不影响结果的条件组合，测了也没有意义。</p><p>Requires:<br>• For each basic condition $C_i$, two test cases<br>• 控制变量，只改变 $C_i$：values of all evaluated conditions except $C_i$ are the same<br>• Compound condition as a whole evaluates to <code>True</code> for one and <code>False</code> for the other，结果的改变表明 $C_i$ 可以独立影响结果</p><p><img src="/images/MC_DC.png" alt="" title="每一个条件的下划线组合表明该条件独立地影响结果。 image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Ch12.pdf."></p><p>MC/DC:<br>• basic condition coverage (C)<br>• branch coverage (DC)<br>• plus one additional condition (M): every condition must independently affect the decision’s output</p><p>It is subsumed by compound conditions and subsumes all other criteria discussed so far - stronger than statement and branch coverage. A good balance of thoroughness and test size (and therefore widely used).</p><h3 id="Path-Testing"><a href="#Path-Testing" class="headerlink" title="Path Testing"></a>Path Testing</h3><p>Sometimes, a fault is revealed only through exercise of some sequence of decisions (i.e., a particular path through the program).</p><p>Path coverage requires that all paths through the CFG are covered. In theory, path coverage is the ultimate coverage metric. But in practice, it is impractical if there is loop involed.</p><p>Adequacy criterion: each path must be executed at least once:<br>Coverage = #(Paths Covered) / #(Total Paths)</p><p>Practical path coverage criteria:<br>• The number of paths in a program with loops is unbounded - the simple criterion is usually impossible to satisfy<br>• For a feasible criterion: Partition infinite set of paths into a finite number of classes<br>• Useful criteria can be obtained by limiting<br>•• the number of traversals of loops<br>•• the length of the paths to be traversed<br>•• the dependencies among selected paths</p><h4 id="Boundary-Interior-Coverage"><a href="#Boundary-Interior-Coverage" class="headerlink" title="Boundary Interior Coverage"></a>Boundary Interior Coverage</h4><p>Groups paths that differ only in the subpath they follow when repeating the body of a loop.<br>• Follow each path in the control flow graph up to the first repeated node<br>• The set of paths from the root of the tree to each leaf is the required set of subpaths for boundary/interior coverage<br><img src="/images/Boundary_interior_adequacy.png" alt="" title="Deriving a tree from a CFG to derive subpaths for boundary/interior testing. Part (i) is the CFG of the C function cgi decode, Part (ii) is a tree derived from part (i) by following each path in the control flow graph up to the first repeated node. image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Ch12.pdf."><br>把分支拆分为每一条可能的 path.</p><p>Limitations:<br>1, The number of paths through non-loop branches (conditions) can still be exponential ($2^N$).<br>2, Choosing input data to force execution of one particular path may be very difficult, or even impossible if the conditions are not independent.</p><h4 id="Loop-Boundary-Coverage"><a href="#Loop-Boundary-Coverage" class="headerlink" title="Loop Boundary Coverage"></a>Loop Boundary Coverage</h4><p>Since coverage of non-looping paths is expensive, we can consider a variant of the boundary/interior criterion that treats loop boundaries similarly but is less stringent with respect to other differences among paths.</p><p>Criterion: A test suite satisfies the loop boundary adequacy criterion iff for every loop:<br>• In at least one test case, the loop body is iterated zero times<br>• In at least one test case, the loop body is iterated once<br>• In at least one test case, the loop body is iterated more than once</p><p>For simple loops, write tests that:</p><ul><li>Skip the loop entirely.</li><li>Take exactly one pass through the loop.</li><li>Take two or more passes through the loop.</li><li>(optional) Choose an upper bound N, and:<ul><li>M passes, where 2 &lt; M &lt; N</li><li>(N-1), N, and (N+1) passes</li></ul></li></ul><p>For Nested Loops:</p><ul><li>For each level, you should execute similar strategies to simple loops.</li><li>In addition:<ul><li>Test innermost loop first with outer loops executed minimum number of times.</li><li>Move one loops out, keep the inner loop at “typical” iteration numbers, and test this layer as you did the previous layer.</li><li>Continue until the outermost loop tested.</li></ul></li></ul><p>For Concatenated Loops, one loop executes. The next line of code starts a new loop:</p><ul><li>These are generally independent(Most of the time…)</li><li>If not, follow a similar strategy to nested loops.<ul><li>Start with bottom loop, hold higher loops at minimal iteration numbers.</li><li>Work up towards the top, holding lower loops at “typical” iteration numbers.</li></ul></li></ul><h4 id="Linear-Code-Sequences-and-Jumps"><a href="#Linear-Code-Sequences-and-Jumps" class="headerlink" title="Linear Code Sequences and Jumps"></a>Linear Code Sequences and Jumps</h4><p>There are additional path-oriented coverage criteria that do not explicitly consider loops. Among these are criteria that consider paths up to a fixed length. The most common such criteria are based on Linear Code Sequence and Jump (LCSAJ) - sequential subpath in the CFG starting and ending in a branch.</p><p>A single LCSAJ is a set of statements that come one after another (meaning no jumps) followed by a single jump. A LCSAJ starts at either the beginning of the function or at a point that can be jumped to. The <strong>LCSAJ coverage</strong> is what fraction of all LCSAJs in a unit are followed by your test suite.</p><p>We can require coverage of all sequences of LCSAJs of length N.<br>Stronger criteria can be defined by requiring N consecutive LCSAJs to be covered - $TER_{N+2}$:<br>1, $TER_1$ is equivalent to statement coverage.<br>2, $TER_2$ is equivalent to branch coverage<br>3, $TER_3$ is LCSAJ coverage<br>4, $TER_4$ is how many pairs of LCSAJ covered<br>…</p><h4 id="Cyclomatic-adequacy-Complexity-coverage"><a href="#Cyclomatic-adequacy-Complexity-coverage" class="headerlink" title="Cyclomatic adequacy (Complexity coverage)"></a>Cyclomatic adequacy (Complexity coverage)</h4><p>There are many options for the set of basis subpaths. When testing, count the number of independent paths that have already been covered, and add any new subpaths covered by the new test.</p><p>You can identify allpaths with a set of independent subpaths of size = the <strong>cyclomatic complexity</strong>. Cyclomatic coverage counts the number of independent paths that have been exercised, relative to cyclomatic complexity.</p><p>• A path is representable as a bit vector, where each component of the vector represents an edge<br>• “Dependence” is ordinary linear dependence between (bit) vectors</p><p>If e = #(edges), n = #(nodes), c = #(connected components) of a graph, it is $e - n + c$ for an arbitrary graph, $e - n + 2$ for a CFG.</p><p>Cyclomatic Complexity could be used to guess “how much testing is enough”.<br>○ Upper bound on number of tests for branch coverage.<br>○ Lower bound on number of tests for path coverage.</p><p>And Used to refactor code.<br>○ Components with a complexity &gt; some threshold should be split into smaller modules.<br>○ Based on the belief that more complex code is more fault-prone.</p><h3 id="Procedure-call-coverage"><a href="#Procedure-call-coverage" class="headerlink" title="Procedure call coverage"></a>Procedure call coverage</h3><p>The criteria considered to this point measure coverage of control flow within individual procedures - not well suited to integration or system testing, where connections between procedures(calls and returns) should be covered.</p><p>Choose a coverage granularity commensurate with the granularity of testing - if unit testing has been effective, then faults that<br>remain to be found in integration testing will be primarily interface faults, and testing effort should focus on interfaces between units rather than their internal details.</p><p><strong>Procedure Entry and Exit Testing</strong> - A single procedure may have several entry and exit points.<br>• In languages with goto statements, labels allow multiple entry points.<br>• Multiple returns mean multiple exit points.</p><p><strong>Call coverage</strong>: The same entry point may be called from many points. Call coverage requires that a test suite executes all possible method calls.</p><h3 id="Satisfying-structural-criteria"><a href="#Satisfying-structural-criteria" class="headerlink" title="Satisfying structural criteria"></a>Satisfying structural criteria</h3><p><img src="/images/subsumption_relation.png" alt="" title="Subsumption relation. image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Ch12.pdf"><br>The criterion requires execution of</p><ul><li><strong>statements</strong> that cannot be executed as a result of:<ul><li>defensive programming</li><li>code reuse (reusing code that is more general than strictly required for the application)</li></ul></li><li><strong>conditions</strong> that cannot be satisfied as a result of interdependent conditions</li><li><strong>paths</strong> that cannot be executed as a result of interdependent decisions</li></ul><p>Rather than requiring full adequacy, the “degree of adequacy” of a test suite is estimated by coverage measures.</p><h2 id="Dependence-and-Data-Flow-Models"><a href="#Dependence-and-Data-Flow-Models" class="headerlink" title="Dependence and Data Flow Models"></a>Dependence and Data Flow Models</h2><p>前面介绍的 Finite models (Control flow graph, call graph, finite state machines) 只是捕捉程序各部分之间依赖关系的其中一个方面。它们明确地表现<strong>控制</strong>流程，但不重视程序变量间的信息传递. <strong>Data flow models</strong> provide a complementary view, emphasizing and making explicit relations involving <strong>transmission of information</strong>.</p><blockquote><p>Models of data flow and dependence in software were originally developed in the field of compiler construction, where they were (and still are) used to detect opportunities for optimization.</p></blockquote><h3 id="Definition-Use-Pairs-Def-Use-Pairs"><a href="#Definition-Use-Pairs-Def-Use-Pairs" class="headerlink" title="Definition-Use Pairs (Def-Use Pairs)"></a>Definition-Use Pairs (Def-Use Pairs)</h3><blockquote><p>The most fundamental class of data flow model associates the point in a program where a value is produced (called a “definition”) with the points at which the value may be accessed (called a “use”).</p></blockquote><p><strong>Definitions</strong> - Variable declaration (often the special value “uninitialized”), Variable initialization, Assignment, Values received by a parameter.<br><strong>Use</strong> - Expressions, Conditional statements, Parameter passing, Returns.<br><img src="/images/Def_Use_path.png" alt="" title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Ch06.pdf"></p><p>A <strong>Definition-Use pair</strong> is formed if and only if there is a <strong>definition-clear path</strong> between the Definition and the Use. A definition-clear path is a path along the CFG path from a definition to a use of the same variable without another definition of the variable in between.</p><p><code>&lt;D,U&gt;</code> pairs coverage: #(pairs covered)/ #(total number of pairs)<br>If instead another definition is present on the path, then the latter definition kills the former.</p><p>Definition-use pairs record direct data dependence, which can be represented in the form of a graph - <strong>(Direct) Data Dependence Graph</strong>, with a directed edge for each definition-use pair.</p><p>The notion of dominators in a rooted, directed graph can be used to make this intuitive notion of “controlling decision” precise. Node M dominates node N if every path from the root of the graph to N passes through M.</p><h3 id="Analyses-Reaching-definition"><a href="#Analyses-Reaching-definition" class="headerlink" title="Analyses: Reaching definition"></a>Analyses: Reaching definition</h3><p>Definition-use pairs can be defined in terms of paths in the program control flow graph.<br>• There is an association $(d,u)$ between a definition of variable $v$ at $d$ and a use of variable $v$ at $u$ if and only if there is at least one control flow path from $d$ to $u$ with no intervening definition of $v$.<br>• Definition $v_d$ <strong>reaches</strong> $u$ ($v_d$ is a <strong>reaching definition</strong> at $u$).<br>• If a control flow path passes through another definition $e$ of the same variable $v$, we say that $v_e$ kills $v_d$ at that point.</p><p>Practical algorithms do not search every individual path. Instead, they <strong>summarize the reaching definitions</strong> at a node over all the paths reaching that node.</p><p>An algorithm for <strong>computing reaching definitions</strong> is based on the way reaching definitions at one node are related to reaching definitions at an adjacent node.</p><p>Suppose we are calculating the reaching definitions of node n, and there is an edge $(p,n)$ from an immediate predecessor node $p$.<br>We observe:<br>• If the predecessor node $p$ can assign a value to variable $v$, then the definition $v_p$ reaches $n$. We say the definition $v_p$ is generated at $p$.<br>• If a definition $v_d$ of variable $v$ reaches a predecessor node $p$, and if $v$ is not redefined at that node, then the definition is propagated on from $p$ to $n$.</p><p>These observations can be stated in the form of an equation describing sets of reaching definitions.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Euclid's algorithm */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCD</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;              <span class="comment">// A: def x, y, tmp</span></span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;      <span class="comment">// B: use y</span></span><br><span class="line">            tmp = x % y;      <span class="comment">// C: def tmp; use x, y</span></span><br><span class="line">            x = y;            <span class="comment">// D: def x; use y</span></span><br><span class="line">            y = tmp;          <span class="comment">// E: def y; use tmp</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;             <span class="comment">// F: use x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/images/data_dependence_graph.png" alt="" title="Nodes: as in the control flow graph (CFG); Each edge represents a direct data dependence, labelled with the variable name. image from: Pezze and Young, Software Testing and Analysis: Process, Principles and Techniques, Wiley, 2007."></p><p>Reaching definitions at node E are those at node D, except that D adds a definition of x and replaces (kills) an earlier definition of x:<br>$$<br>\begin{equation}<br>\begin{split}<br>    Reach(E) &amp;= ReachOut(D) \\<br>    ReachOut(D) &amp;= (Reach(D) \backslash {x_A}) \cup {x_D}<br>\end{split}<br>\end{equation}<br>$$<br>Equations at the head of the while loop - node B, where values may be transmitted both from the beginning of the procedure - node A and through the end of the body of the loop - node E. The beginning of the procedure (node A) is treated as an initial definition of parameters and local variables:<br>$$<br>\begin{equation}<br>\begin{split}<br>    Reach(B) &amp;= ReachOut(A) \cup ReachOut(E) \\<br>    ReachOut(A) &amp;= gen(A) = {x_A, y_A, tmp_A } \\<br>    ReachOut(E) &amp;= (Reach(E) \backslash {y_A}) \cup {y_D}<br>\end{split}<br>\end{equation}<br>$$</p><p>(If a local variable is declared but not initialized, it is treated as a definition to the special value “<strong>uninitialized</strong>.”)</p><p>General equations for Reach analysis:<br>$$\begin{equation} \begin{split}<br>Reach(n) &amp;= \mathop{\cup} \limits_{m \in pred(n)} ReachOut(m) \\<br>ReachOut(n) &amp;=(Reach(n) \backslash kill(n)) \cup gen(n) \\<br>\end{split} \end{equation}$$<br>$gen(n) = v_n$, $v$ is defined or modified at $n$;<br>$kill(n) = v_x$, $v$ is defined or modified at $x, x \ne n$.</p><p>Reaching definitions calculation: first initializing the reaching definitions at each node in the control flow graph to the empty set, and then applying these equations repeatedly until the results stabilize.</p><h3 id="Analyses-Live-and-Avail"><a href="#Analyses-Live-and-Avail" class="headerlink" title="Analyses: Live and Avail"></a>Analyses: Live and Avail</h3><p><strong>Available expressions</strong> is another classical data flow analysis, used in compiler construction to determine <strong>when</strong> the value of a subexpression can be saved and reused rather than recomputed.</p><blockquote><p>An expression is available at a point if, for all paths through the control flow graph from procedure entry to that point, the expression has been computed and not subsequently modified.</p></blockquote><p>An expression is generated (becomes available) where it is computed and is killed (ceases to be available) when the value of any part of it changes (e.g., when a new value is assigned to a variable in the expression).</p><p>The expressions propagation to a node from its predecessors is described by a pair of set equations:<br>$$\begin{equation} \begin{split}<br>Avail(n) &amp;= \mathop{\cap} \limits_{m \in pred(n)} AvailOut(m) \\<br>AvailOut(n) &amp;=(Avail(n) \backslash kill(n)) \cup gen(n) \\<br>\end{split} \end{equation}$$<br>$gen(n)$, available, computed at $n$;<br>$kill(n)$, has variables assigned at $n$.</p><p>Reaching definitions combines propagated sets using set union, since a definition can reach a use along any execution path. Available expressions combines propagated sets using set intersection, since an expression is considered available at a node only if it reaches that node along all possible execution paths.</p><p>Reaching definitions is a <strong>forward, any-path analysis</strong>; Available expressions is a <strong>forward, all-paths analysis</strong>.</p><p><strong>Live variables</strong> is a <strong>backward, any-path analysis</strong> that determines whether the value held in a variable may be subsequently used. Backward analyses are useful for determining what happens after an event of interest.</p><p>A variable is live at a point in the control flow graph if, on some execution path, its current value may be used before it is changed, i.e. there is any possible execution path on which it is used.</p><p>$$\begin{equation} \begin{split}<br>Live(n) &amp;= \mathop{\cup} \limits_{m \in succ(n)} LiveOut(m) \\<br>LiveOut(n) &amp;=(Live(n) \backslash kill(n)) \cup gen(n) \<br>\end{split} \end{equation}$$<br>$gen(n)$, $v$ is used at $n$;<br>$kill(n)$, $v$ is modified at $n$.</p><p>One application of live variables analysis is to recognize useless definitions, that is, assigning a value that can never be used.</p><h3 id="Iterative-Solution-of-Dataflow-Equations"><a href="#Iterative-Solution-of-Dataflow-Equations" class="headerlink" title="Iterative Solution of Dataflow Equations"></a>Iterative Solution of Dataflow Equations</h3><p>Initialize values (first estimate of answer)<br>• For “any path” problems, first guess is “nothing”(empty set) at each node<br>• For “all paths” problems, first guess is “everything” (set of all possible values = union of all “gen” sets)</p><p>Repeat until nothing changes<br>• Pick some node and recalculate (new estimate)</p><h3 id="From-Execution-to-Conservative-Flow-Analysis"><a href="#From-Execution-to-Conservative-Flow-Analysis" class="headerlink" title="From Execution to Conservative Flow Analysis"></a>From Execution to Conservative Flow Analysis</h3><p>We can use the same data flow algorithms to approximate other dynamic properties<br>• Gen set will be “facts that become true here”<br>• Kill set will be “facts that are no longer true here”<br>• Flow equations will describe propagation</p><p>Example: Taintedness (in web form processing)<br>• “Taint”: a user-supplied value (e.g., from web form) that has not been validated<br>• Gen: we get this value from an untrusted source here<br>• Kill: we validated to make sure the value is proper</p><h3 id="Data-flow-analysis-with-arrays-and-pointers"><a href="#Data-flow-analysis-with-arrays-and-pointers" class="headerlink" title="Data flow analysis with arrays and pointers"></a>Data flow analysis with arrays and pointers</h3><p>The models and flow analyses described in the preceding section have been limited to simple scalar variables in individual procedures.</p><p>Arrays and pointers (dynamic references and the potential for aliasing) introduce uncertainty: Do different expressions access the same storage?<br>• a[i] same as a[k] when i = k<br>• a[i] same as b[i] when a = b (aliasing)</p><p>The uncertainty is accomodated depending on the kind of analysis<br>• Any-path: gen sets should include all potential aliases and kill set should include only what is definitely modified<br>• All path: vice versa</p><h3 id="Scope-of-Data-Flow-Analysis"><a href="#Scope-of-Data-Flow-Analysis" class="headerlink" title="Scope of Data Flow Analysis"></a>Scope of Data Flow Analysis</h3><p><strong>过程内 Intraprocedural</strong>: Within a single method or procedure, as described so far.</p><p><strong>过程之间 Interprocedural</strong>: Across several methods (and classes) or procedures</p><p>Cost/Precision trade-offs for <strong>interprocedural</strong> analysis are critical, and difficult: context sensitivity, flow-sensitivity.</p><p>Many <strong>interprocedural</strong> flow analyses are flow-insensitive<br>• $O(n^3)$ would not be acceptable for all the statements in a program. Though $O(n^3)$ on each individual procedure might be ok<br>• Often flow-insensitive analysis is good enough… considering type checking as an example</p><p>Reach, Avail, etc were flow-sensitive sensitive, <strong>intraprocedural</strong> analyses.<br>• They considered ordering and control flow decisions<br>• Within a single procedure or method, this is (fairly) cheap - $O(n^3)$ for $n$ CFG nodes.</p><h3 id="Summary-of-Data-flow-models"><a href="#Summary-of-Data-flow-models" class="headerlink" title="Summary of Data flow models"></a>Summary of Data flow models</h3><ul><li>Data flow models detect patterns on CFGs:<ul><li>Nodes initiating the pattern</li><li>Nodes terminating it</li><li>Nodes that may interrupt it</li></ul></li><li>Often, but not always, about flow of information (dependence)</li><li>Pros:<ul><li>Can be impy g lemented by efficient iterative algorithms</li><li>Widely applicable (not just for classic “data flow” properties)</li></ul></li><li>Limitations:<ul><li>Unable to distinguish feasible from infeasible paths</li><li>Analyses spanning whole programs (e.g., alias analysis) must trade off precision against computational cost</li></ul></li></ul><h2 id="Data-Flow-Testing"><a href="#Data-Flow-Testing" class="headerlink" title="Data Flow Testing"></a>Data Flow Testing</h2><p>In structural testing,<br>• Node and edge coverage don’t test interactions<br>• Path-based criteria require impractical number of test cases: And only a few paths uncover additional faults, anyway<br>• Need to distinguish “important” paths</p><p>Data flow testing attempts to distinguish “important” paths: Interactions between statements - Intermediate between simple statement and branch coverage and more expensive path-based structural testing.</p><p>Intuition: Statements interact through data flow<br>• Value computed in one statement used in another Value computed in one statement, used in another<br>• Bad value computation revealed only when it is used</p><p>Adequacy criteria:<br>• All DU pairs: Each DU pair is exercised by at least one test case<br>• All DU paths: Each simple (non looping) DU path is exercised by at least one test case<br>• All definitions: For each definition, there is at least one test case which exercises a DU pair containing it - Every computed value is used somewhere</p><p>Limits: Aliases, infeasible paths - Worst case is bad (undecidable properties, exponential blowup of paths), so 务实的 pragmatic compromises are required</p><h3 id="Data-flow-coverage-with-complex-structures"><a href="#Data-flow-coverage-with-complex-structures" class="headerlink" title="Data flow coverage with complex structures"></a>Data flow coverage with complex structures</h3><p>Arrays and pointers<br>• Under-estimation of aliases may fail to include some DU pairs<br>• Over-estimation, may introduce unfeasible test obligations</p><p>For testing, it may be preferrable to accept under-estimation of alias set rather than over-estimation or expensive analysis<br>• 有争议的 Controversial: In other applications (e.g., compilers), a conservative over-estimation of aliases is usually required<br>• Alias analysis may rely on external guidance or other global<br>analysis to calculate good estimates<br>• Undisciplined use of dynamic storage, pointer arithmetic, etc.<br>may make the whole analysis infeasible</p><h2 id="Mutation-testing"><a href="#Mutation-testing" class="headerlink" title="Mutation testing"></a>Mutation testing</h2><p>Fault-based Testing, directed towards “typical” faults that could occur in a program.</p><ol><li>Take a program and test suite generated for that program (using other test techniques)</li><li>Create a number of similar programs (<strong>mutants</strong>), each differing from the original in one small way, i.e., each possessing a fault</li><li>The original test data are then run through the mutants</li><li>Then mutants either:<ul><li>To be dead: test data detect all differences in mutants, the test set is adequate.</li><li>Remains live if:<ul><li>it is equivalent to the original program (functionally identical although syntactically different - called an <strong>equivalent mutant</strong>) or,</li><li>the test set is inadequate to kill the mutant. The test data need to be augmented (by adding one or more new test cases) to kill the live mutant.</li></ul></li></ul></li></ol><p>Numbers of mutants tend to be large (the number of mutation operators is large as they are supposed to capture all possible syntactic variations in a program), hence random sampling, selective mutation operators (Offutt).</p><p>Coverage - mutation score: #(killed mutants) / #(all non-equivalent mutants) (or random sample).</p><p>Benifits:<br>• It provides the tester with a clear target (mutants to kill)<br>• It does force the programmer to think of the test data that will expose certain kinds of faults<br>• Probably most useful at unit testing level</p><p>Mutation operators could be built on<br>• source code (body),<br>• module interfaces (aimed at integration testing),<br>• specifications: Petri-nets, state machines, (aimed at system testing)</p><p>Tools: MuClipse</p><h2 id="Model-based-testing"><a href="#Model-based-testing" class="headerlink" title="Model based testing"></a>Model based testing</h2><p>Models used in specification or design have structure<br>• Useful information for selecting representative classes of behavior; behaviors that are treated differently with respect to the model should be tried by a thorough test suite<br>• In combinatorial testing, it is difficult to capture that structure clearly and correctly in constraints</p><p>Devise test cases to check actual behavior against behavior specified by the model - “Coverage” similar to structural testing, but applied to specification and design models.</p><p>Deriving test cases from finite state machines: From an informal specification, to a finite state machine, to a test suite</p><p>“Covering” finite state machines<br>• State coverage: Every state in the model should be visited by at least one test case<br>• Transition coverage<br>    •• Every transition between states should be traversed by at least one test case.<br>    •• A transition can be thought of as a (precondition, postcondition) pair.</p><p>Models are useful abstractions<br>• In specification and design, they help us think and communicate about complex artifacts by emphasizing key features and suppressing details<br>• Models convey structure and help us focus on one thing at a time</p><p>We can use them in systematic testing<br>• If a model divides behavior into classes, we probably want to exercise each of those classes!<br>• Common model-based testing techniques are based on state machines, decision structures, and grammars, but we can apply the same approach to other models.</p><h2 id="Testing-Object-Oriented-Software"><a href="#Testing-Object-Oriented-Software" class="headerlink" title="Testing Object Oriented Software"></a>Testing Object Oriented Software</h2><p>Typical OO software <strong>characteristics</strong> that impact testing<br>• State dependent behavior<br>• Encapsulation<br>• Inheritance<br>• 多态性 Polymorphism and dynamic binding<br>• Abstract and generic classes<br>• Exception handling</p><p><strong>Procedural software</strong>, unit = single program, function, or procedure, more often: a unit of work that may correspond to one or more intertwined functions or programs.</p><p><strong>Object oriented software</strong>:<br>• unit = class or (small) cluster of strongly related classes (e.g., sets of Java classes that correspond to exceptions)<br>• unit testing = 类内测试 intra-class testing<br>• integration testing = 类之间测试 inter-class testing (cluster of classes)<br>• dealing with single methods separately is usually too expensive (complex scaffolding), so methods are usually tested in the context of the class they belong to.</p><p>Basic approach is <strong>orthogonal</strong>: Techniques for each major issue (e.g., exception handling, generics, inheritance ) can be applied incrementally and independently. <img src="/images/orthogonal_approach.png" alt="" title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Ch14-15.pdf."></p><h3 id="Intraclass-State-Machine-Testing"><a href="#Intraclass-State-Machine-Testing" class="headerlink" title="Intraclass State Machine Testing"></a>Intraclass State Machine Testing</h3><p>Basic idea:<br>• The state of an object is modified by operations<br>• Methods can be modeled as state transitions<br>• Test cases are sequences of method calls that traverse the state machine model</p><p>State machine model can be derived from specification (functional testing), code (structural testing), or both.</p><p>Testing with State Diagrams:<br>• A statechart (called a “state diagram” in UML) may be produced as part of a specification or design - May also be implied by a set of message sequence charts (interaction diagrams), or other modeling formalisms.<br>• Two options:<br>1, Convert (“flatten”) into standard finite-state machine, then derive test cases<br>2, Use state diagram model directly</p><h3 id="Intraclass-data-flow-testing"><a href="#Intraclass-data-flow-testing" class="headerlink" title="Intraclass data flow testing"></a>Intraclass data flow testing</h3><p>Exercise sequences of methods<br>• From setting or modifying a field value<br>• To using that field value</p><p>The intraclass control flow graph - control flow through sequences of method calls:<br>• Control flow for each method<br>• node for class<br>• edges: from node class to the start nodes of the methods; from the end nodes of the methods to node class.</p><h3 id="Interclass-Testing"><a href="#Interclass-Testing" class="headerlink" title="Interclass Testing"></a>Interclass Testing</h3><p>The first level of integration testing for object-oriented software - Focus on interactions between classes</p><p>Bottom-up integration according to <strong>“depends”</strong> relation - A depends on B - Build and test B, then A</p><p>Start from <strong>use/include</strong> hierarchy - Implementation-level parallel to logical “depends” relation<br>• Class A makes method calls on class B<br>• Class A objects include references to class B methods - but only if reference means “is part of”<br><img src="/images/class_diagram_BankAccount.png" alt="" title="A class with three compartments"></p><blockquote><p>In software engineering, a class diagram in the Unified Modeling Language (UML) is a type of static structure diagram that describes the structure of a system by showing the system’s <strong>classes, their attributes, operations (or methods)</strong>, and the relationships among objects.</p></blockquote><blockquote><p>Dependency is a weaker form of bond that indicates that one class depends on another because it uses it at some point in time. One class depends on another if the independent class is a parameter variable or local variable of a method of the dependent class.</p></blockquote><p>Interactions in Interclass Tests:</p><ul><li>Proceed bottom-up</li><li>Consider all combinations of interactions<ul><li>example: a test case for class <code>Order</code> includes a call to a method of class <code>Model</code>, and the called method calls a method of class <code>Slot</code>, exercise all possible relevant states of the different classes.</li><li>problem: combinatorial explosion of cases</li><li>so select a subset of interactions:<ul><li>arbitrary or random selection</li><li>plus all significant interaction scenarios that have been previously identified in design and analysis: sequence + collaboration diagrams</li></ul></li></ul></li></ul><p>Using Structural Information:<br>• Start with functional testing: the specification (formal or informal) is the first source of information<br>• Then add information from the code (structural testing)</p><h3 id="Interclass-structural-testing"><a href="#Interclass-structural-testing" class="headerlink" title="Interclass structural testing"></a>Interclass structural testing</h3><p>Working “bottom up” in dependence hierarchy<br>• Dependence is not the same as class hierarchy; not always the same as call or inclusion relation.<br>• May match bottom-up build order</p><p>Starting from leaf classes, then classes that use leaf classes,…</p><p>Summarize effect of each method: Changing or using object state, or both - Treating a whole object as a variable (not just primitive types)</p><h3 id="Polymorphism-and-dynamic-binding"><a href="#Polymorphism-and-dynamic-binding" class="headerlink" title="Polymorphism and dynamic binding"></a>Polymorphism and dynamic binding</h3><p>One variable potentially bound to methods of different (sub-)classes.</p><p>The combinatorial approach: identify a set of combinations that cover all pairwise combinations of dynamic bindings.</p><h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>When testing a subclass, We would like to re-test only what has not been thoroughly tested in the parent class. But we should test any method whose behavior may have changed.</p><p>Reusing Tests with the Testing History Approach:</p><ul><li>Track test suites and test executions<ul><li>determine which new tests are needed</li><li>determine which old tests must be re-executed</li></ul></li><li>New and changed behavior …<ul><li>new methods must be tested</li><li>redefined methods must be tested, but we can partially reuse test suites defined for the ancestor</li><li>other inherited methods do not have to be retested</li></ul></li></ul><p>Abstract methods (and classes) - Design test cases when abstract method is introduced (even if it can t be executed yet)</p><p>Behavior changes<br>• Should we consider a method “redefined” if another new or redefined method changes its behavior?<br>• The standard “testing history” approach does not do this<br>• It might be reasonable combination of data flow (structural) OO testing with the (functional) testing history approach</p><h3 id="Testing-exception-handling"><a href="#Testing-exception-handling" class="headerlink" title="Testing exception handling"></a>Testing exception handling</h3><p>Exceptions create implicit control flows and may be handled by different handlers.</p><p>Impractical to treat exceptions like normal flow<br>• too many flows: every array subscript reference, every memory, allocation, every cast, …<br>• multiplied by matching them to every handler that could appear immediately above them on the call stack.<br>• many actually impossible</p><p>So we separate testing exceptions, and ignore program error exceptions (test to prevent them, not to handle them)</p><p>What we do test: Each exception handler, and each explicit throw or re-throw of an exception.</p><h2 id="Integration-Testing"><a href="#Integration-Testing" class="headerlink" title="Integration Testing"></a>Integration Testing</h2><p>Unit (module) testing is a foundation, unit level has maximum controllability and visibility.</p><p>Integration testing may serve as a process check<br>• If module faults are revealed in integration testing, they signal inadequate unit testing<br>• If integration faults occur in interfaces between correctly implemented modules, the errors can be traced to module breakdown and interface specifications.<br><img src="/images/module_integration_system_test.png" alt="" title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Ch21.pdf"><br>Integration test plan drives and is driven by the project “build plan”</p><p>Structural orientation: Modules constructed, integrated and tested based on a hierarchical project structure - Top-down, Bottom-up, Sandwich, Backbone</p><p>Functional orientation: Modules integrated according to application characteristics or features - Threads, Critical module.</p><blockquote><p>A “thread” is a portion of several modules that together provide a user-visible program feature.</p></blockquote><h2 id="Component-based-software-testing"><a href="#Component-based-software-testing" class="headerlink" title="Component-based software testing"></a>Component-based software testing</h2><p>Working Definition of <strong>Component</strong><br>• Reusable unit of deployment and composition<br>• Characterized by an interface or contract<br>• Often larger grain than objects or packages - A complete database system may be a component</p><p><strong>Framework</strong><br>• Skeleton or micro-architecture of an application<br>• May be packaged and reused as a component, with “挂钩 hooks” or “插槽 slots” in the interface contract</p><p><strong>Design patterns</strong><br>• Logical design fragments<br>• Frameworks often implement patterns, but patterns are not frameworks. Frameworks are concrete, patterns are abstract</p><p><strong>Component-based system</strong><br>• A system composed primarily by assembling components, often “Commercial off-the-shelf” (COTS) components<br>• Usually includes application-specific “glue code”</p><p><strong>Component Interface Contracts</strong><br>• Application programming interface (API) is distinct from implementation<br>• Interface includes everything that must be known to use the component: More than just method signatures, exceptions, etc; May include non-functional characteristics like performance, capacity, security; May include dependence on other components.</p><p>Testing a Component: Producer View<br>• Thorough unit and subsystem testing<br>• Thorough acceptance testing: Includes stress and capacity testing</p><p>Testing a Component: User View<br>• Major question: Is the component suitable for this application?<br>• Reducing risk: Trial integration early</p><h2 id="System-Acceptance-and-Regression-Testing"><a href="#System-Acceptance-and-Regression-Testing" class="headerlink" title="System, Acceptance, and Regression Testing"></a>System, Acceptance, and Regression Testing</h2><p><img src="/images/System_Acceptance_and_Regression.png" alt="" title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/system-acceptance.pdf."></p><h2 id="System-Testing"><a href="#System-Testing" class="headerlink" title="System Testing"></a>System Testing</h2><p>Characteristics:<br>• Comprehensive (the whole system, the whole spec)<br>• Based on specification of observable behavior: Verification against a requirements specification, not validation, and not opinions<br>• Independent of design and implementation</p><p>Independence: Avoid repeating software design errors in system test design.</p><p>Maximizing independence:<br>• Independent V&amp;V: System (and acceptance) test performed by a different organization.<br>• Independence without changing staff: Develop system test cases early</p><p>System tests are often used to measure progress. As project progresses, the system passes more and more system tests. Features exposed at top level as they are developed.</p><p>System testing is the only opportunity to verify <strong>Global Properties</strong> - Performance, latency, reliability, … Especially to find unanticipated effects, e.g., an unexpected performance bottleneck.</p><p><strong>Context-Dependent Properties</strong> is beyond system-global: Some properties depend on the system context and use, Example:<br>• Performance properties depend on environment and configuration<br>• Privacy depends both on system and how it is used<br>• Security depends on threat profiles</p><h3 id="Stress-Testing"><a href="#Stress-Testing" class="headerlink" title="Stress Testing"></a>Stress Testing</h3><p>When a property (e.g., performance or real-time response) is parameterized by use - requests per second, size of database,… Extensive stress testing is required - varying parameters within the envelope, near the bounds, and beyond.</p><p>Often requires extensive simulation of the execution environment, and requires more resources (human and machine) than typical test cases - Separate from regular feature tests, Run less often, with more manual control.</p><p>Capacity, Security, Performance, Compliance, Documentation Testing.</p><h2 id="Acceptance-testing"><a href="#Acceptance-testing" class="headerlink" title="Acceptance testing"></a>Acceptance testing</h2><p>Estimating dependability, measuring quality, not searching for faults. Requires valid <strong>statistical samples</strong> from <strong>operational profile</strong>(model), and a clear, precise definition of what is being measured.</p><p>Quantitative dependability goals are statistical:<br>• Reliability: Survival Probability - when function is critical during the mission time.<br>• Availability: The fraction of time a system meets its specification - Good when continuous service is important but it can be delayed or denied<br>• Failsafe: System fails to a known safe state<br>• Dependability: Generalisation - System does the right thing at right time</p><p>Usability, Reliability, Availability/Reparability Testing</p><h3 id="System-Reliability"><a href="#System-Reliability" class="headerlink" title="System Reliability"></a>System Reliability</h3><p>The reliability $R_F(t)$ of a system is the <strong>probability</strong> that no fault of the class $F$ occurs (i.e. system survives) during time $t \sim (t_{init}, t_{failure})$.</p><p>Failure Probability $Q_F(t) = 1 -R_F(t)$.</p><p>When the lifetime of a system is exponentially distributed, the reliability of the system is: $R(t) = e^{-\lambda t}$ where the parameter $\lambda$ is called the failure rate.</p><p>MTTF: Mean Time To (first) Failure, or Expected Life.<br>$ MTTF = E(t_f) = \int_0^\infty R(t)dt = \frac{1}{\lambda}$</p><p><strong>Serial System Reliability</strong>: Serially Connected Components. Assuming the failure rates of components are statistically independent, The overall system reliability:<br>$$R_{ser}(t) = \prod_{i=1}^n R_i(t) = e^{-t(\lambda_{ser})} = e^{-t(\sum_{i=1}^n \lambda_i)}$$<br>$R_i(t) = e^{-\lambda_i t}$ is reliability of a single component $i$.</p><p><strong>Parallel System Reliability</strong>: Parallel Connected Components.<br>$$R_{par}(t) = 1 - Q_{par}(t) = 1 - \prod_{i=1}^n Q_i(t) = 1 - \prod_{i=1}^n (1 - e^{-\lambda_i t}) = 1 - \prod_{i=1}^n (1 - R_i(t)) $$</p><p>For example:<br>· if one is to build a serial system with 100 components each of which had a reliability of 0.999, the overall system reliability would be $0.999^{100} = 0.905$.<br>· Consider 4 identical modules are connected in parallel, System will operate correctly provided at least one module is operational. If the reliability of each module is 0.95, the overall system reliability is $1-(1-0.95)^4 = 0.99999375$.</p><p>Statistical testing is necessary for critical systems (safety critical, infrastructure, …), but difficult or impossible when operational profile is unavailable or just a guess, or when reliability requirement is very high.</p><h3 id="Process-based-Measures"><a href="#Process-based-Measures" class="headerlink" title="Process-based Measures"></a>Process-based Measures</h3><p>Based on <strong>similarity with prior projects</strong>, less rigorous than statistical testing.</p><p>System testing process - Expected history of bugs found and resolved:<br>• Alpha testing: Real users, controlled environment<br>• Beta testing: Real users, real (uncontrolled) environment<br>• May statistically sample users rather than uses<br>• Expected history of bug reports</p><h2 id="Regression-Testing"><a href="#Regression-Testing" class="headerlink" title="Regression Testing"></a>Regression Testing</h2><p>Ideally, software should improve over time. But changes can both<br>• Improve software, adding features and fixing bugs<br>• Break software, introducing new bugs - <strong>regressions</strong></p><p>Tests must be re-run after any changes.</p><p>Make use of different techniques for selecting a subset of all tests to reduce the time and cost for regression testing.</p><h3 id="Regression-Test-Selection"><a href="#Regression-Test-Selection" class="headerlink" title="Regression Test Selection"></a>Regression Test Selection</h3><p>From the entire test suite, only select subset of test cases whose execution is relevant to changes.</p><p><strong>Code-based Regression Test Selection</strong>: Only execute test cases that execute changed or new <strong>code</strong>.</p><p><strong>Control-flow and Data-flow Regression Test Selection</strong>: Re-run test cases only if they include changed <strong>elements</strong> – elements may be modified control flow nodes and edges, or definition-use (DU) pairs in data flow. To automate selection:<br>• Tools record changed elements touched by each test case - stored in database of regression test cases<br>• Tools note changes in program<br>• Check test-case database for overlap</p><p><strong>Specification-based Regression Test Selection</strong>:<br>• Specification-based prioritization: <strong>Execute all test cases</strong>, but start with those that related to changed and added <strong>features</strong>.</p><h3 id="Test-Set-Minimization"><a href="#Test-Set-Minimization" class="headerlink" title="Test Set Minimization"></a>Test Set Minimization</h3><p>Identify test cases that are redundant and remove them from the test suite to reduce its size.<br>• Maximize coverage with minimum number of test cases.<br>• Stop after a pre-defined number of iterations<br>• Obtain an approximate solution by using a greedy heuristic</p><h3 id="Test-Set-Prioritisation"><a href="#Test-Set-Prioritisation" class="headerlink" title="Test Set Prioritisation"></a>Test Set Prioritisation</h3><p>• Sort test cases in order of increasing cost per additional coverage<br>• Select the first test case<br>• Repeat the above two steps until k test cases are selected or max cost is reached (whichever is first).<br><img src="/images/Cost_per_additional_coverage.png" alt="" title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/RegTesting.pdf."></p><p><strong>Prioritized Rotating Selection</strong>: Execute some sooner than others, eventually execute all test cases. Possible priority schemes:<br>• Round robin: Priority to least-recently-run test cases<br>• Track record: Priority to test cases that have detected faults before - They probably execute code with a high fault density<br>• Structural: Priority for executing elements that have not been recently executed - Can be coarse-grained: Features, methods, files.</p><h2 id="Test-Driven-Development-TDD"><a href="#Test-Driven-Development-TDD" class="headerlink" title="Test-Driven Development (TDD)"></a>Test-Driven Development (TDD)</h2><p>Test-Driven Development (or test driven design) is a methodology.</p><p>• Short development iterations.<br>• Based on requirement and pre-written test cases.<br>• Produces code necessary to pass that iteration’s test.<br>• Refactor both code and tests.<br>• The goal is to produce working clean code that fulfills requirements.</p><p>Principle of TDD - Kent Beck defines:<br>• Never write a single line of code unless you have a failing automated test.<br>• Eliminate duplication</p><p>TDD uses Black-box Unit test：<br>1， 明确功能需求。<br>2， 为功能需求编写 test。<br>3， 运行测试，<font color="red">按理应该无法通过测试</font>（因为还没写功能程序）。<br>4， 编写实现该功能的代码，<font color="green">通过测试</font>。<br>5， 可选：重构代码（和 test cases），使其更快，更整洁等等。<br>6， 可选：循环此步骤</p><p><img src="http://www.pathfindersolns.com/wp-content/uploads/2012/05/red-green-refactorFINAL2.png" alt="source from http://ryantablada.com/post/red-green-refactor---a-tdd-fairytale " title="image from: http://ryantablada.com/post/red-green-refactor---a-tdd-fairytale"></p><h2 id="Automating-Test-Execution"><a href="#Automating-Test-Execution" class="headerlink" title="Automating Test Execution"></a>Automating Test Execution</h2><p>Designing test cases and test suites is creative, but executing test cases should be automatic.</p><p>Example Tool Chain for Test Case Generation &amp; Execution:<br>Combine …<br>• A combinatorial test case generation (genpairs.py) to create test data<br>• DDSteps to convert from spreadsheet data to JUnit test cases<br>• JUnit to execute concrete test cases</p><h3 id="Scaffolding"><a href="#Scaffolding" class="headerlink" title="Scaffolding"></a>Scaffolding</h3><p>Code to support development and testing.<br>• Test driver: A “main” program for running a test<br>• Test stubs: Substitute for called functions/methods/objects.</p><blockquote><p><strong>Stub</strong> is an object that holds predefined data and uses it to answer calls during tests. It is used when we cannot or don’t want to involve objects that would answer with real data or have undesirable side effects. 代指那些包含了预定义好的数据并且在测试时返回给调用者的对象。Stub 常被用于我们不希望返回真实数据或者造成其他副作用的场景。</p></blockquote><p>• Test harness: Substitutes for other parts of the deployed environment</p><p>• <strong>Comparison-based oracle</strong>: need predicted output for each input. Fine for a small number of hand-generated test cases, e.g. hand-written JUnit test cases.</p><p>• <strong>Self-Checking Code as Oracle</strong>: oracle written as self-checks, possible to judge correctness without predicting results. Advantages and limits: Usable with large, automatically<br>generated test suites, but often only a partial check.</p><p>• <strong>Capture and Replay</strong>: If human interaction is required, capture the manually run test case, replay it automatically. With a comparison-based test oracle, behavior same as previously accepted behavior.</p><h2 id="Security-Testing"><a href="#Security-Testing" class="headerlink" title="Security Testing"></a>Security Testing</h2><p>“Regular” testing aims to ensure that the program meets customer requirements in terms of features and functionality. Tests “normal” use cases - Test with regards to common expected usage patterns.</p><p>Security testing aims to ensure that program fulfills security requirements. Often non-functional. More interested in misuse cases.</p><p>Two common approaches:<br>• Test for known vulnerability types<br>• Attempt directed or random search of program state space to uncover the “weird corner cases”</p><h3 id="Penetration-testing"><a href="#Penetration-testing" class="headerlink" title="Penetration testing"></a>Penetration testing</h3><p>• Manually try to “break” software<br>• Typically involves looking for known common problems.</p><h3 id="Fuzz-testing"><a href="#Fuzz-testing" class="headerlink" title="Fuzz testing"></a>Fuzz testing</h3><p>Send semi-valid input to a program and observe its behavior.<br>• <strong>Black-box testing</strong> - System Under Test (SUT) treated as a “black-box”<br>• The only feedback is the output and/or externally observable<br>behavior of SUT.</p><p><strong>Input generation</strong><br>• <strong>Mutation based fuzzing</strong>: Start with a valid seed input, and “mutate” it. Can typically only find the “low-hanging fruit” - shallow bugs that are easy to find.<br>• <strong>Generation based fuzzing</strong>: Use a specification of the input format (e.g. a grammar) to automatically generate semi-valid inputs - Very long strings, empty strings, Strings with format specifiers, “extreme” format strings, Very large or small values, values close to max or min for data type, Negative values. Almost invariably gives better coverage, but requires much more manual effort.</p><p><strong>The Dispatcher</strong>: running the SUT on each input generated by fuzzer module.</p><p><strong>The Assessor</strong>: automatically assess observed SUT behavior to determine if a fault was triggered.</p><h3 id="Concolic-testing"><a href="#Concolic-testing" class="headerlink" title="Concolic testing"></a>Concolic testing</h3><p>Concolic execution workflow:<br>1, Execute the program for real on some input, and record path taken.<br>2, Encode path as query to SMT solver and negate one branch condition<br>3, Ask the solver to find new satisfying input that will give a different path.</p><p><strong>White-box testing</strong> method.<br>• Input generated from control-structure of code to systematically explore different paths of the program.<br>• Generational search (“whitebox fuzzing”): Performs concolic testing, but prioritizes paths based on how much they improve coverage.</p><p><strong>Greybox fuzzing</strong><br>▪ Coverage-guided semi-random input generation.<br>▪ High speed sometimes beats e.g. concolic testing, but shares some limitations with mutation-based fuzzing (e.g. magic constants, checksums).</p><h2 id="Software-Process-Models-Software-Development"><a href="#Software-Process-Models-Software-Development" class="headerlink" title="Software Process Models - Software Development"></a>Software Process Models - Software Development</h2><p><strong>Waterfall model</strong>: Sequential, no feedback<br>1, Requirements<br>2, Design<br>3, Implementation<br>4, Testing<br>5, Release and maintenance</p><p><strong>V-model</strong>: modified version of the waterfall model<br><img src="/images/V_model.png" alt="" title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/02_dev_process.pdf."><br>• Tests are created at the point the activity they validate is being carried out. So, for example, the acceptance test is created when the systems analysis is carried out.<br>• Failure to meet the test requires a further <strong>iteration</strong> beginning with the activity that has failed the validation</p><p><strong>Boehm’s Spiral Model</strong>: focuse on controlling project risk and attempting formally to address project risk throughout the lifecycle.<br><img src="/images/Boehm_Spiral_Model.png" alt="" title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/02_dev_process.pdf."><br>• V&amp;V activity is spread through the lifecycle with more explicit validation of the preliminary specification and the early stages of design. The goal here is to subject the early stages of design to V&amp;V activity.<br>• At the early stages there may be no code available so we are working with models of the system and environment and verifying that the model exhibits the required behaviours.</p><p><strong>Extreme Programming (XP)</strong>: one of [Agile Processes]<br><img src="/images/Extreme_Programming.png" alt="" title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/02_dev_process.pdf."><br>• Advocates working directly with code almost all the time.<br>• The 12 principles of XP summarise the approach.</p><blockquote><p>1, Test-driven development; 2, The planning game; 3, On-site customer; 4, Pair programming; 5, Continuous integration; 6, Refactoring; 7, Small releases; 8, Simple design; 9, System metaphor; 10, Collective code ownership; 11, Coding standards; 12, 40-hour work week;</p></blockquote><p>• Development is test-driven.<br>• Tests play a central role in refactoring activity.<br>• “Agile” development mantra: Embrace Change.</p><p>Facebook’s Process Model</p><blockquote><p>Perpetual development - a continuous development model. In this model, software will never be considered a finished product. Instead features are continuously added and adapted and shipped to users. Fast iteration is considered to support rapid innovation.</p></blockquote><h2 id="Planning-and-Monitoring-the-Process"><a href="#Planning-and-Monitoring-the-Process" class="headerlink" title="Planning and Monitoring the Process"></a>Planning and Monitoring the Process</h2><p>Monitoring: Judging progress against the plan.</p><p><strong>Quality process</strong>: Set of <strong>activities and responsibilities</strong>. Follows the overall software process in which it is embedded.<br>• Example: waterfall software process ––&gt; “V model”: unit testing starts with implementation and finishes before integration<br>• Example: XP and agile methods ––&gt; emphasis on unit testing and rapid iteration for acceptance testing by customers.</p><h3 id="Strategies-vs-Plans"><a href="#Strategies-vs-Plans" class="headerlink" title="Strategies vs. Plans"></a>Strategies vs. Plans</h3><p><img src="/images/Strategies_vs_Plans.png" alt="" title="Strategies vs. Plans. image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Ch20.pdf."><br>Test and Analysis Strategy:<br>• Lessons of past experience: an organizational asset built and refined over time<br>• Body of explicit knowledge: amenable to improvement, reduces vulnerability to organizational change (e.g., loss of key individuals)</p><p>Elements of a Strategy:<br>• Common quality requirements that apply to all or most products - unambiguous definition and measures<br>• Set of documents normally produced during the quality process - contents and relationships<br>• Activities prescribed by the overall process - standard tools and practices<br>• Guidelines for project staffing and assignment of roles and responsibilities</p><p>Main Elements of a Plan:<br>• Items and features to be verified - Scope and target of the plan<br>• Activities and resources - Constraints imposed by resources on activities<br>• Approaches to be followed - Methods and tools<br>• Criteria for evaluating results</p><h3 id="Schedule-Risk"><a href="#Schedule-Risk" class="headerlink" title="Schedule Risk"></a>Schedule Risk</h3><p>• Critical path = chain of activities that must be completed in sequence and that have maximum overall duration<br>• Critical dependence = task on a critical path scheduled immediately after some other task on the critical path</p><h3 id="Risk-Planning"><a href="#Risk-Planning" class="headerlink" title="Risk Planning"></a>Risk Planning</h3><p>• Generic management risk: personnel, technology, schedule<br>• Quality risk: development, execution, requirements</p><h3 id="Contingency-Plan"><a href="#Contingency-Plan" class="headerlink" title="Contingency Plan"></a>Contingency Plan</h3><p>• Derives from risk analysis<br>• Defines actions in response to bad news - Plan B at the ready</p><h3 id="Process-Monitoring"><a href="#Process-Monitoring" class="headerlink" title="Process Monitoring"></a>Process Monitoring</h3><p>• Identify deviations from the quality plan as early as possible and take corrective action</p><h3 id="Process-Improvement"><a href="#Process-Improvement" class="headerlink" title="Process Improvement"></a>Process Improvement</h3><p>Orthogonal Defect Classification (ODC)<br>• Accurate classification schema: for very large projects, to distill an unmanageable amount of detailed information<br>• Two main steps<br>1, Fault classification: when faults are detected, when faults are fixed.<br>2, Fault analysis</p><p>Root Cause Analysis (RCA)<br>• Technique for identifying and eliminating process faults<br>• Four main steps<br>1, What are the faults?<br>2, When did faults occur? When, and when were they found?<br>3, Why did faults occur?<br>4, How could faults be prevented?</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Reference:&lt;br&gt;&lt;a href=&quot;http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/index.html&lt;/a&gt;&lt;br&gt;Pezze and Young, Software Testing and Analysis: Process, Principles and Techniques, Wiley, 2007.&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>Natural Language Understanding - Informatics - University of Edinburgh 爱丁堡大学</title>
    <link href="http://shukebeta.me/UoE-nlu/"/>
    <id>http://shukebeta.me/UoE-nlu/</id>
    <published>2018-04-30T23:00:00.000Z</published>
    <updated>2018-06-29T19:34:30.851Z</updated>
    
    <content type="html"><![CDATA[<p>References:<br><a href="http://www.inf.ed.ac.uk/teaching/courses/nlu/" target="_blank" rel="noopener">Natural language understanding</a><br><a href="http://web.stanford.edu/class/cs224n/syllabus.html" target="_blank" rel="noopener">CS224n: Natural Language Processing with Deep Learning</a><br><a href="https://web.stanford.edu/~jurafsky/NLPCourseraSlides.html" target="_blank" rel="noopener">Lecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christopher Manning</a></p><a id="more"></a><h2 id="循环神经网络-RNNs"><a href="#循环神经网络-RNNs" class="headerlink" title="循环神经网络 RNNs"></a>循环神经网络 RNNs</h2><p><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/RNN-unrolled.png" alt="" title="A recurrent neural network and the unfolding in time of the computation involved in its forward computation. Source: http://colah.github.io"></p><p><img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/09/rnn.jpg" alt="" title="Source: Nature"></p><p>For a sequence of input data (sequence of words, or speech) and sequence of output problem (many to many):<br>· feed input $x_{t}$ into the RNN: feeding one word (represented as vector) at a time, e.g one word in a sentence from left to right, $x_1$ corresponds to the second word of a sentence.</p><p>· $s_t$ is the hidden state at time step t. It is calculated based on the previous hidden state and the input at the current step:$s_t = f(Ux_t + Ws_{t-1})$. Function f is the activation.</p><p>· o(t) is the output at step t. For example, if we wanted to predict the next word in a sentence it would be a vector of probabilities across our vocabulary. $o_t = softmax(Vs_t)$.</p><p>RNN shares the same parameters ($U, V, W$ above) across all steps.</p><p>In addition to the above normal many to many structure RNNs, there are other non-sequence input or output: Many to one, e.g. when predicting the sentiment of a sentence we may only care about the final output, not the sentiment after each word. One to many: Music generation.<br><img src="http://karpathy.github.io/assets/rnn/diags.jpeg" alt="" title="source from http://karpathy.github.io/2015/05/21/rnn-effectiveness/"></p><p>除了应用于语言模型, RNNs 还可以应用于<br>· tagging, e.g. part-of-speech tagging, named entity recognition (many to many RNNs)<br>· sentence classification, e.g. sentiment classification (many to one RNNs)<br>· generate text, e.g. speech recognition, machine translation, summarization</p><h3 id="RNNs-Backpropagation"><a href="#RNNs-Backpropagation" class="headerlink" title="RNNs Backpropagation"></a>RNNs Backpropagation</h3><p>Backpropagation Through Time (BPTT): Because the parameters are shared by all time steps in the network, the gradient at each output depends not only on the calculations of the current time step, but also the previous time steps.</p><p>RNNs trained with BPTT have difficulties learning long-term dependencies (e.g. dependencies between steps that are far apart) due to what is called the vanishing/exploding gradient problem.</p><h3 id="梯度消失与爆炸"><a href="#梯度消失与爆炸" class="headerlink" title="梯度消失与爆炸"></a>梯度消失与爆炸</h3><p>The Vanishing/Exploding Gradient problem。</p><p>RNNs shares the same matrix (w, u, etc.) at each time step during forward prop and backprop. 求导数时, 根据链式法则, loss对各参数的导数会转换为loss对输出y的导数, 乘以y对隐含层的导数, 乘以隐含层相对隐含层之间的导数, 再乘以隐含层对参数的导数.<img src="/images/vanish_gradient.png" alt=""></p><p>不同隐含层（举例如$h_t$和$h_k$）之间如果相隔太远, $h_t$对$h_k$的导数就变成多个jacobian矩阵的相乘， 对各个jacobian范数（norms）进行分析后，发现$h_t$对$h_k$的导数值在训练过程中会很快变得很极端（非常小或者非常大）。</p><p>Gradient作为传导误差以帮助系统纠正参数的关键角色，如果本身变得接近于<code>0</code>或者<code>nan</code>，那么我们就无法判断t和t+n的数据的依赖性（是没有依赖？还是因为vanish of gradient？还是因为参数设置错误？）。梯度衰减会直接降低模型学习长距离依赖关系的能力，给定一个时间序列，例如文本序列，循环神经网络较难捕捉两个时刻距离较大的文本元素（字或词）之间的依赖关系。</p><p>在使用RNN学习language model的时候，非常容易出现梯度爆炸，解决办法是使用 gradient clipping 梯度裁剪，就是通过把梯度映射到另一个大小的空间，以限制梯度范数的最大值<a href="https://arxiv.org/abs/1211.5063" target="_blank" rel="noopener">On the difficulty of training Recurrent Neural Networks</a>。</p><p>虽然梯度裁剪可以应对梯度爆炸，但无法解决梯度衰减的问题。一个缓解梯度衰减的方案是使用更好的参数初始化方案和激活函数（ReLUs）<a href="https://arxiv.org/abs/1504.00941" target="_blank" rel="noopener">A Simple Way to Initialize Recurrent Networks of Rectified Linear Units</a>.</p><p>不过更主流的解决梯度衰减的方案是使用更复杂的rnn隐含单元: Gated Recurrent Units (GRU) introduced by <a href="https://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation</a> and LSTMs.</p><h3 id="Long-Short-Term-Memory"><a href="#Long-Short-Term-Memory" class="headerlink" title="Long Short-Term Memory"></a>Long Short-Term Memory</h3><p>Outside of the vanilla RNNs work flow, LSTMs use gated <strong>cells</strong> as memory to chose what error to be remembered. The cells take as input the previous state $s_{t-1}$ and current input $x_t$. Thus help to solve the long-term dependencies.</p><p>Whether the gated cell let information flow through (open) or not (closed) depends on its inner sigmoid activation layer with a pointwise multiplication operation. A sigmoid function values between 0 and 1, it could be used to describe how much information is allowed to through the cell.</p><p>Take a most basic sequence problem as example - predict next word: the cell state might include the gender of the present subject, so that the correct pronouns can be used. When we see a new subject, we want to forget the gender of the old subject.</p><p>LSTM的细胞的直观理解，就是细胞可以完整地保存信息，而新的输入可以诱发细胞对旧信息的遗忘，细胞自行决定记忆哪些新信息。</p><p>LSTM 用遗忘门来决定从 cell state 中丢弃哪些信息。<br>Forget gate: Control how much information of pervious state $h_{t-1}$ should be forgetten in the current internal cell. Learned by a sigmoid layer called the “forget gate layer” <img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-f.png" alt="" title="image from: http://colah.github.io/posts/2015-08-Understanding-LSTMs/"></p><p>用输入门 Input gate 来决定有多少新信息是值得储存的（记忆）。<br>Control how much new information is going to be remembered by internal state cell in current step t.<br>1, an input gate (a sigmoid hidden layer) decides which values we’ll update.<br>2, a hidden(tanh/relu) layer creates a vector of new candidate values $\hat{C}_t$, that could be added to the state. <img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-i.png" alt="" title="image from: http://colah.github.io/posts/2015-08-Understanding-LSTMs/"></p><p>下一步就可以更新旧的 cell sate $C_{t-1}$.<br>Input and forget gates together allow the network to control what information is stored and overwritten at each step. Combine the forget and remember information together to update the previous cell state.<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-C.png" alt="" title="image from: http://colah.github.io/posts/2015-08-Understanding-LSTMs/"></p><p>最后，用一个输出门 Output gate 来决定要输出的内容。<br>1, Run a sigmoid layer to decide what parts of the cell state we’re going to output.<br>2, put the cell state through tanh pointwise operation (to push the values to be between −1 and 1) and multiply it by the output of the output gate, so that we only output the parts decided by the output gate.<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-o.png" alt="" title="image from: http://colah.github.io/posts/2015-08-Understanding-LSTMs/"></p><p>总的来说, LSTM有输入门、遗忘门和输出门。这三个门形式上，都是关于旧隐含状态和新输入向量的 Sigmoid 隐含神经网络层, 只是各自有各自的参数矩阵.</p><h3 id="Gated-Recurring-Unit"><a href="#Gated-Recurring-Unit" class="headerlink" title="Gated Recurring Unit"></a>Gated Recurring Unit</h3><p>GRU combines the forget and remember gates into one single gate. This combination leads to a simpler LSTMs model. This combined gate is called update gate. GRU first computes the update gate $z_t$ (another layer) based on current input word vector and hidden state. Then there is a reset gate r similarly but with different weights. The new memory content $\hat{h}_t$; Final memory $h_t$ at time step combines current and previous time steps:<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-var-GRU.png" alt="" title="image from: http://colah.github.io/posts/2015-08-Understanding-LSTMs/"></p><h4 id="GRU-intuition"><a href="#GRU-intuition" class="headerlink" title="GRU intuition"></a>GRU intuition</h4><ul><li>重置门赋予了模型丢弃与未来无关的信息的能力。若重置门接近于0，则忽略之前的记忆，仅储存新加入的信息.</li><li>更新门控制过去的状态对现在的影响程度（即决定更新多少），如果接近于1，则 h<sub>t</sub>=z<sub>t</sub>*h<sub>t-1</sub>, 等同于把过去的信息完整复制到未来，相应地缓解梯度衰减。</li><li>短距离依赖的单元，过去的信息仅保留很短的时间，重置门一般很活跃，也就是数值在0和1之间频繁变动。</li><li>长距离依赖的单元，重置门较稳定（保留过去的记忆较长时间），而更新门较活跃。</li></ul><h3 id="不同RNNs变种的比较"><a href="#不同RNNs变种的比较" class="headerlink" title="不同RNNs变种的比较"></a>不同RNNs变种的比较</h3><p>Vanilla RNNs Execution:</p><ol><li>Read the whole register h</li><li>Update the whole register</li></ol><p>GRU Execution:</p><ol><li>Select a readable subset</li><li>Read the subset</li><li>Select a writable subset</li><li>Update the subset</li></ol><p><img src="/images/gru.vs.lstm.png" alt="" title="image from: http://web.stanford.edu/class/cs224n"></p><h3 id="门控循环神经网络的训练"><a href="#门控循环神经网络的训练" class="headerlink" title="门控循环神经网络的训练"></a>门控循环神经网络的训练</h3><ol><li>把参数矩阵初始化为正交</li><li>把遗忘门的bias初始化为1，默认不遗忘</li><li>别忘了梯度裁剪</li><li>注意dropout在RNNs中的应用不同于DNN和CNN</li></ol><h3 id="Bidirectional-RNNs"><a href="#Bidirectional-RNNs" class="headerlink" title="Bidirectional RNNs"></a>Bidirectional RNNs</h3><p>Bidirectional RNNs are based on the idea that the output at time t may not only depend on the previous elements in the sequence, but also future elements. They are just two RNNs stacked on top of each other. The output is then computed based on the hidden state of both RNNs.<br><img src="/images/bidirectional_rnn.png" alt="" title="image from: http://web.stanford.edu/class/cs224n"></p><h2 id="Meaning-representations"><a href="#Meaning-representations" class="headerlink" title="Meaning representations"></a>Meaning representations</h2><p>意思的表达有很多方法。一种有效的表示单词的含义的方法是 distributional semantic.</p><blockquote><p>Semantics (from Ancient Greek: σημαντικός sēmantikos, “significant”) is the linguistic and philosophical study of meaning, in language, programming languages, formal logics, and semiotics.</p></blockquote><blockquote><p>语义学 Semantics 在语言学中的研究目的在于找出语义表达的规律性、内在解释、不同语言在语义表达方面的个性以及共性；与计算机科学相关的语义学研究在于机器对自然语言的理解。</p></blockquote><p>Tradition solution of usable meaning in a computer: Use e.g. WordNet, a resource containing lists of synonym sets and hypernyms.</p><p>To convert natural language into values that computer understands, represent words as discrete symbols: Words can be represented by one-hot vectors, Vector dimension is the vocabulary. But there is no natural notion of similarity for one-hot vectors!</p><p>So learn to encode similarity in the vectors themselves.</p><p>The core idea is representing words by their context, building a <strong>dense</strong> vector for each word, chosen so that it is similar to vectors of words that appear in similar contexts.</p><p><code>Distributional models of meaning = vector-­space models of meaning = vector semantics</code>.<br><code>word vectors = word embeddings = word representations</code>.</p><h3 id="Four-kinds-of-vector-models"><a href="#Four-kinds-of-vector-models" class="headerlink" title="Four kinds of vector models"></a>Four kinds of vector models</h3><p>Sparse vector representations:<br>1, Mutual-­information weighted word co-­occurrence matrices</p><p>Dense vector representations:<br>2, Singular value decomposition (SVD): A special case of this is called LSA - Latent Semantic Analysis<br>3, Neural­‐network­‐inspired models (skip­‐grams, CBOW)<br>4, Brown clusters</p><p>Prediction-­based models learn embeddings as part of the process of word prediction. Train a neural network to predict neighboring words. The advantages:<br>· Fast, easy to train (much faster than SVD)<br>· Available online in the word2vec package<br>· Including sets of pretrained embeddings</p><h3 id="Word-representation-and-Word2vec"><a href="#Word-representation-and-Word2vec" class="headerlink" title="Word representation and Word2vec"></a>Word representation and Word2vec</h3><p>Word2vec is a framework for learning word vectors representation.<br>Idea:<br>1, We have a large corpus of text<br>2, Every word in a fixed vocabulary is represented by a vector<br>3, Go through each position t in the text, which has a center word c and context (“outside”) words o<br>4, Use the similarity of the word vectors for c and o to calculate the probability of o given c (or vice versa)<br>5, Keep adjusting the word vectors to maximize this probability</p><p>在上面第四点, 如果是给定中心词，计算上下文词, 那么就是 <strong>Skip-grams model</strong>, 比如 Given word w<sub>t</sub>, in a context window of 2C words, predict 4 context words [w<sub>t-2</sub>, w<sub>t-1</sub>, w<sub>t+1</sub>, w<sub>t+2</sub>]<br><img src="/images/word2vec_window.png" alt="" title="Example windows and process for computing P(w&lt;sub&gt;t+j&lt;/sub&gt; | w&lt;sub&gt;t&lt;/sub&gt;), image from: http://web.stanford.edu/class/cs224n"><br>Skip-grams 给予模型跳词能力，比如 “I hit the tennis ball” 有三个trigrams: “I hit the”, “hit the tennis”, “the tennis ball”. 但是，这个句子也同样包含一个同样重要但是N-Gram无法提取的trigram:”hit the ball”. 而使用 skip-grams 允许我们跳过 “tennis” 生成这个trigram.</p><p>反之，给定 bag-of-words context, predict target word, 那就是 <strong>Continuous Bag of Words, CBOW model</strong>.</p><p>缺点：因为output size 等于 vocabulary，而 softmax 分母中需要求和每一个词的 output size × hidden units 的内积， 计算会非常昂贵。解决办法是使用负采样 <a href="#negative-sampling">negative sampling</a>。</p><p>Word2vec的本质是遍历语料库的每一个词$w_i$，捕捉$w_i$与其上下文位置目标词的同时出现的概率。</p><h4 id="目标函数-Obejective-funtion-cost-or-loss-function-J-θ"><a href="#目标函数-Obejective-funtion-cost-or-loss-function-J-θ" class="headerlink" title="目标函数 Obejective funtion (cost or loss function) J(θ):"></a>目标函数 Obejective funtion (cost or loss function) J(θ):</h4><p>For each position $t = 1, … , T$, predict context words within a window of fixed size m, given center word, use chain rule to multiply all the probability to get the likelihood $L(θ)$:<br><img src="/images/word2vec_likelihood.png" alt="" title="Function for L(θ), image from: http://web.stanford.edu/class/cs224n"><br>The θ is the vectors representations, which is the only parameters we needs to optimize(其实还有其他hyperparameters，这里暂时忽略).</p><p>The loss function is the (average) negative log likelihood:<br><img src="/images/word2vec_costfunction.png" alt="" title="image from: http://web.stanford.edu/class/cs224n"></p><p>Minimizing objective function ⟺ Maximizing predictive accuracy.</p><p>The problem is how to calculate $P(w_{t+j} \mid w_t; θ)$:</p><p>每个词由两个向量表示（Easier optimization. Average both at the end）：<br>$v_w$ when w is a center word, $u_w$ when w is a context word.</p><p>Then for a center word c and a “outside” word o:<br><img src="/images/word2vec_conprobability.png" alt="" title="image from: http://web.stanford.edu/class/cs224n"><br>The numerator contains dot product, compares similarity of o and c, larger dot product = larger probability. The denominator works as a normalization over entire vocabulary.</p><h4 id="高频词二次采样-subsampling"><a href="#高频词二次采样-subsampling" class="headerlink" title="高频词二次采样 subsampling"></a>高频词二次采样 subsampling</h4><p>二次采样是指当决定是否选取一个词作为样本时，它被选择的概率反比于它出现的概率，这样不仅可以降低无意义但高频的词(“the”, “a”等)的重要性，也可以加快采样速度。$$P(w_i) = (\sqrt{\frac{z(w_i)}{0.001}} + 1) \cdot \frac{0.001}{z(w_i)}$$ $z(w_i)$ 是词$w_i$在语料库中的占比，如果”peanut”在10亿语料库中出现了1,000次, 那么z(“peanut”) = 1e-6.<br><img src="/images/sub-sample.png" alt="" title="sub sample of P(wi)"></p><h4 id="Negative-sampling"><a href="#Negative-sampling" class="headerlink" title="Negative sampling"></a>Negative sampling</h4><p>负采样是指每个训练样本仅更新模型权重的一小部分：only the output that represents the positive class(1) + other few randomly selected classes(0) are evaluated.<br><a href="https://arxiv.org/pdf/1310.4546.pdf" target="_blank" rel="noopener">该论文指出</a></p><blockquote><p>负采样5-20个单词适用于较小的数据集，对于大型数据集只需要2-5个单词。</p></blockquote><p>修改目标函数，选择k个负样本（即除了概率最高的那个目标词之外的其他词）：<img src="/images/negative-sample.png" alt="" title="image from: http://web.stanford.edu/class/cs224n"></p><p>这样可以最大化真正的外部词出现的概率，最小化随机负采样的词概率。</p><p>负面样本的选择是基于 unigram 分布 $f(w_i)$: 一个词作为负面样本被选择的概率与其出现的频率有关，更频繁的词更可能被选作负面样本。<br>$$P(w_i) = \frac{  {f(w_i)}^{3/4}  }{\sum_{j=0}^{n}\left(  {f(w_j)}^{3/4} \right) }$$<br>负采样的优点是：<br>· Training speed is independent of the vocabulary size<br>· Allowing parallelism.<br>· 模型的表现更好。因为负采样契合NLP的稀疏性质，大部分情况下，虽然语料库很大，但是每一个词只跟很小部分词由关联，大部分词之间是毫无关联的，从无关联的两个词之间也别指望能学到什么有用的信息，不如直接忽略。</p><h4 id="与传统的NLP方法比较"><a href="#与传统的NLP方法比较" class="headerlink" title="与传统的NLP方法比较"></a>与传统的NLP方法比较</h4><p>在word2vec出现之前，NLP使用经典且直观的共生矩阵（co-occurrence matrix）来统计词语两两同时出现的频率，参考<a href="/NOTE-ANLP-01-distributional-semantic-models">ANLP - Distributional semantic models</a>。缺点也明显，词汇量的增加导致矩阵增大，需要大量内存，随之而来的分类模型出现稀疏性问题，模型不稳定。虽然可以使用SVD来降维，但是一个<code>n×m</code>矩阵的计算成本是O(mn<sup>2</sup>)浮点数（当<code>n&lt;m</code>），还是非常大的。而且很难并入新词或新文档。<br><img src="/images/count_based_vs_direct_prediction.png" alt="" title="Count based vs direct prediction, image from: http://web.stanford.edu/class/cs224n"></p><p>目前融合了两种方法的优点的Glove是最常用的。</p><h4 id="TODO-Glove"><a href="#TODO-Glove" class="headerlink" title="TODO(Glove)"></a>TODO(Glove)</h4><h3 id="Morphological-Recursive-Neural-Network-morphoRNN"><a href="#Morphological-Recursive-Neural-Network-morphoRNN" class="headerlink" title="Morphological Recursive Neural Network (morphoRNN)"></a>Morphological Recursive Neural Network (morphoRNN)</h3><p>Limitation of word2vec:<br>• Closed vocabulary assumption<br>• Cannot exploit functional relationships in learning:</p><blockquote><p>如英语的dog、dogs和dog-catcher有相当的关系，英语使用者能够利用他们的背景知识来判断此关系，对他们来说，dog和dogs的关系就如同cat和cats，dog和dog-catcher就如同dish和dishwasher</p></blockquote><p>To walk closer to open vocabulary, use compositional representations based on morphemes. Instead of word embedding, embed morphemes - the smallest meaningful unit of language.  Compute representation recursively from morphemes, word embedding 由 morphemes embedding 拼接而来.<img src="/images/Morphological_Recursive_Neural_Network.png" alt="" title="Morphological Recursive Neural Network. A vector representation for the word &quot;unfortunately&quot; is constructed from morphemic vectors: un&lt;sub&gt;pre&lt;/sub&gt;, fortunate&lt;sub&gt;stm&lt;/sub&gt;, ly&lt;sub&gt;suf&lt;/sub&gt;. Dotted nodes are computed on-the-fly and not in the lexicon. image from: http://www.aclweb.org/anthology/W13-3512"></p><p>与基础版的morphoRNN结构相同，Context-insensitive Morphological RNN model (cimRNN) 考察 morphoRNN 在不参考任何上下文信息情况下， 仅仅用 morphemic representation 构造词向量的能力。训练时，给每个词xi定义损失函数s(xi)为新构造的词向量p<sub>c</sub>(xi)和参考词向量p<sub>r</sub>(xi)之间的欧几里得距离平方<br><img src="/images/cimRNN_cost.png" alt=""></p><p>该cimRNN模型没有机会改进可能被估计不足的罕见词的表达.</p><p>Context-sensitive Morphological RNN (csmRNN) 在学习语素组成时同时参考语境信息，在训练过程中，神经网络顶层的更新将一直反向传播直至底层的语素层。<br><img src="/images/Context_sensitive_morphological_RNN.png" alt="" title="Context-sensitive morphological RNN has two layers: (a) the morphological RNN, which constructs representations for words from their morphemes and (b) the word-based neural language which optimizes scores for relevant ngrams. image from: http://www.aclweb.org/anthology/W13-3512"></p><h3 id="Compositional-character-representations"><a href="#Compositional-character-representations" class="headerlink" title="Compositional character representations"></a>Compositional character representations</h3><p>在自然语言处理中使用 word 作为基本单位的问题在于词汇量太大了，所以几乎所有主流模型都会省略很多词，比如Bengio的RNNs语言模型就把所有出现频率<code>&lt;3</code>的单词统一标记为一个特殊词。但这样的操作也只是把词汇量降到了16,383。又比如word2vec模型只考虑出现频率最高的30,000个词。</p><p>所以寻找其他有限集合的语言单位成为替代选择，比如字母 character（更确切地说是 unicode code points），比如前面提到的 Morphemes，还有其他比如 Character n-grams，Morphological analysis等，这些可以统称为 subwords units。</p><p>然后再通过 subwords 来重构 word representation，进而构建整个文本的meaning representation.</p><p>构建 word representation 最简单的方法就是把 subwords vectors 相加、平均或者拼接等，但更好的是使用非线性的方法，比如 Bidirectional LSTMs, Convolutional NNs 等。<br><img src="/images/char_rep.png" alt="" title="Compose character representations into word representations with LSTMs. Illustration of the word lookup tables (top) and the lexical Composition Model (bottom). Square boxes represent vectors of neuron activations. Shaded boxes indicate that a non-linearity. image from: Finding function in form: compositional character models for open vocabulary word representation, Ling et al. 2015"></p><h4 id="哪种方式构建-subword-representations-比较好？"><a href="#哪种方式构建-subword-representations-比较好？" class="headerlink" title="哪种方式构建 subword representations 比较好？"></a>哪种方式构建 subword representations 比较好？</h4><p>在 word representation 的重构中，涉及了几个变量:<br>1, Subword Unit<br><img src="/images/Subword_Unit.png" alt="" title="The last row is part of an oracle: the true morphology, a human annotator."></p><p>2, Composition Function<br>• Linear Vector operation<br>• Bi-LSTMs<br>• Convolutional NNs</p><p>3, Language Typology</p><table><thead><tr><th>Type</th><th>example</th><th>Morphology</th><th>analysis</th></tr></thead><tbody><tr><td>Fusional (English)</td><td>“reads”</td><td>read-s</td><td>read-3SG.SG</td></tr><tr><td>Agglutinative (Turkish)</td><td>“If I read …”</td><td>oku-r-sa-m</td><td>read-AOR.COND.1SG</td></tr><tr><td>Root&amp;Pattern (Arabic)</td><td>“he wrote”</td><td>k(a)t(a)b(a)</td><td>write-PST.3SG.M</td></tr><tr><td>Reduplication (Indonesian)</td><td>“children”</td><td>anak~anak</td><td>child-PL</td></tr></tbody></table><p><img src="/images/sum_biLSTMs_char_trigrams.png" alt="" title="Summary of perplexity: use biLSTMs over character trigrams. In general, the results are better than vanilla word representation"></p><p>除了语言模型外, 其他NLP任务如SQuAd问答数据集上的很多优秀模型，也会加入character embedding.</p><p>但目前 Character-level models 并不具有触及实际 morphology 的模型预测能力。</p><h3 id="Multi-word-language-representations"><a href="#Multi-word-language-representations" class="headerlink" title="Multi-word language representations"></a>Multi-word language representations</h3><p><strong>Neural bag-of-words models</strong>:<br>· Simply average (or just sum) word vectors,<br>· Can improve effectiveness by putting output through 1+ fully connected layers (DANs)<br>· Recurrent neural networks(LSTM/GRU): cannot capture phrases without prefix context, and empirically, representations capture too much of last words in final vector – focus is LM next word prediction<br>· Convolutional Neural Network: compute vectors for every h-word phrase, often for several values of h. Example: “the country of my birth” computes vectors for: the country, country of, of my, my birth, the country of, country of my, of my birth, the country of my, country of my birth. Not very linguistic, but you get everything!</p><p><strong>Data-dependent composition</strong>:<br>Recursion is natural for describing language, Phrases correspond to semantic units of language.</p><p>How to map longer phrases into the same vector space?<br>利用复合性原理 principle of compositionality:</p><blockquote><p>在数学、语义学和语言哲学中，复合性原理是指，一个复杂表达式的意义是由其各组成部分的意义以及用以结合它们的规则来决定的。</p></blockquote><p>Recursive neural nets, a tree structure.<br>For Structure Prediction:<br>Inputs: two candidate children’s representations<br>Outputs:<br>1, The semantic representation if the two nodes are merged.<br>2, Score of how plausible the new node would be.</p><h2 id="神经网络语言模型"><a href="#神经网络语言模型" class="headerlink" title="神经网络语言模型"></a>神经网络语言模型</h2><p>如何构建一个神经网络语言模型?<br>语言模型的目的是输入一串字符, 输出下一个字符的概率分布, 可以使用 fixed-window neural Language Model, 类似于N-Gram, 仅考虑前(n-1)个窗口长度序列, “<del>as  the  proctor  started  the clock</del> the students opened their _“ 得到定长的输入序列, 而 Feedforward neural networks 的输入就是要求固定长度的向量.<br><img src="/images/fixed_window_nn_lm.png" alt="" title="一个固定长度的神经网络语言模型 image from: http://web.stanford.edu/class/cs224n"></p><p>用前馈神经网络做语言模型的优点（相对于N-Gram）就是没有了稀疏性问题，而且模型的大小也控制在 <code>O(n)</code>（N-Gram是<code>O(exp(n))</code>）</p><p>固定长度的前馈神经网络的固有缺陷就是它要求输入和输出都是固定长度的, 仅考虑前的(n-1)长度的序列, 很多时候会丢失NLP中的长距离依赖信息, 跟N-Gram的有一样的缺陷。而且实际的应用中语句的长度是不固定的，最好有一个神经网络可以接受任意长度的输入序列, 输出任意长度的序列。循环神经网络 (Recurrent neural networks, aka RNNs) 就可以解决这个问题.</p><h2 id="循环神经网络语言模型"><a href="#循环神经网络语言模型" class="headerlink" title="循环神经网络语言模型"></a>循环神经网络语言模型</h2><p>不同于前馈神经网络使用输入序列的每一个词单独训练一行(或一列, 取决于矩阵的设计)参数矩阵, RNNs的设计核心是用输入序列的每一个词, 反复地训练同一个参数, 即”共享参数”.<br><img src="/images/rnn_lm.png" alt="" title="RNNs神经网络语言模型 image from: http://web.stanford.edu/class/cs224n"></p><p>因为参数共享:<br>1, 模型大小不会随着输入序列长度增加而增加。<br>2, 每一步的计算，理论上都使用到了之前的历史信息，所以理论上可以更好的捕捉长距离依赖（但实际上表现并不好，看后面的<a href="#梯度消失与爆炸">梯度消失与爆炸</a>）.<br>3, 模型有更好的泛化能力</p><p>使用基于Softmax的RNNs语言模型等同于解决矩阵分解问题, 参考<a href="https://openreview.net/forum?id=HkwZSG-CZ" target="_blank" rel="noopener">Breaking the Softmax Bottleneck: A High-Rank RNN Language Model</a>。</p><p>循环神经网络语言模型使用损失函数评估模型表现: 损失函数 loss function on step t is usual 交叉熵 cross-entropy between predicted probability distribution and the true next word.</p><p>传统的统计语言模型使用困惑度(perplexity)来评估模型表现，但其实降低困惑度等价于减小损失函数.</p><h2 id="神经网络语言模型的学习能力"><a href="#神经网络语言模型的学习能力" class="headerlink" title="神经网络语言模型的学习能力"></a>神经网络语言模型的学习能力</h2><p>Character models are good at reduplication (no oracle, though), works well on language with reduplication patterns like Indonesian, Malay. Character NLMs learn word boundaries, memorize POS tags.</p><p>What do NLMs learn about morphology?<br>1, Character-level NLMs work across typologies, but especially well for agglutinative morphology.<br>2, predictive accuracy is not as good as model with explicit knowledge of morphology (or POS).<br>3, They actually learn orthographic similarity of affixes, and forget meaning of root morphemes accordong to qualitative analyses.<br>4, More generally, they appear to <strong>memorize frequent subpatterns</strong></p><p>总的来说，神经网络处理自然语言的能力并不特殊，表现的性能，跟神经网络本身的长处相匹配，如泛化、模式匹配、端到端应用的能力等。</p><h2 id="Dependency-parsing"><a href="#Dependency-parsing" class="headerlink" title="Dependency parsing"></a>Dependency parsing</h2><p>语言学里有两种角度看待语法结构 - Constituency and Dependency：</p><ul><li>Constituency: phrase structure grammar, 从句子成分构造的角度看，capture the configurational patterns of sentences，即把句子的语法理解为词组成分的递归嵌套. 可以用 context-free grammars (CFGs) 来表达语法规则，就是语法树。</li><li>Dependency syntax: 主要是从语义的角度来看，显示哪些单词依赖于（一般指修改或作为参数其参数）哪些单词。特别用于区分动词的主格（subject position or with nominative inflection）宾格（object position or with accusative inflection）. Dependencies can be identified even in non-configurational languages.</li></ul><p>A sentence dependency structure explains the <strong>dependency relation</strong> between its words: represented as a graph with the words as its nodes, linked by directed, labeled edges, with the following properties:<br>• connected: every node is related to <strong>at least one other node</strong>, and (through transitivity) to ROOT;<br>• single headed: every node (except ROOT) has exactly <strong>one incoming edge</strong> (from its head);<br>• acyclic: the graph cannot contain cycles of directed edges.<br><img src="/images/dependency_relation.png" alt="" title="A dependency relation consists of: a head (H); a dependent (D); a label identifying the relation between H and D. image from: Joakim Nivre, Dependency Grammar and Dependency Parsing."></p><p>Dependency trees 有两种，如果dependency graph中有edges交叉则是<strong>non-projective</strong>, 反之则是 <strong>projective</strong>。更确切的定义是：A dependency tree is <strong>projective</strong> wrt. a particular linear order of its nodes if, for all edges <code>h → d</code> and nodes w, w occurs between h and d in linear order only if w is dominated by h.</p><p>A non-projective dependency grammar is not context-free.<br><img src="/images/non_projective.jpg" alt="" title="上图是 non-projective，下图是 projective. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l07.pdf"></p><p>Motivation for Dependency parsing:<br>• context-free parsing algorithms base their decisions on adjacency;<br>• in a dependency structure, a dependent need not be adjacent to its head (even if the structure is projective);<br>• we need new parsing algorithms to deal with non-adjacency (and with non-projectivity if present).</p><p>Evaluation: accuracy (# correct dependencies with or ignore label)).</p><h3 id="Graph-based-dependency-parsing"><a href="#Graph-based-dependency-parsing" class="headerlink" title="Graph-based dependency parsing"></a>Graph-based dependency parsing</h3><p>Based on <strong>maximum spanning trees (MST parser)</strong>, views syntactic structure as a set of constraints</p><p>Intuition as tagging problem: since each word has exactly one parent, the possible tags are the other words in the sentence (or a dummy node called root). If we <strong>edge factorize</strong> the score of a tree so that it is simply the product of its edge scores, then we can simply select the best incoming edge for each word.</p><p>The tartget function is to find the highest scoring dependency tree in the space of all possible trees for a sentence. The score of dependency tree y for sentence x is:<br>$$s(x,y) = \sum_{(i,j)\in y} s(i,j)$$<br>$x = x_1…x_n, y$ is a set of dependency edges, with $(i, j) ∈ y$ if there is an edge from $x_i$ to $x_j$.</p><p>Scoring edges with a neural network<br><img src="/images/dependency_nn_edge_scores.jpg" alt="" title="Get a&lt;sub&gt;i&lt;/sub&gt; by concatenating the hidden states of a forward and backward RNN at position i. image from: Zhang and Lapata (2016)"><br>The function g(a<sub>j</sub>, a<sub>i</sub>) computes an <strong>association score</strong> telling us how much word wi prefers word wj as its head. Association scores are a useful way to select from a dynamic group of candidates, 跟注意力机制的similarity score 异曲同工，方程的形式也很相似。</p><p>Parsing 算法：</p><ul><li>start with a <strong>totally connected graph</strong> G, i.e., assume a directed edge between every pair of words;</li><li>find the maximum spanning tree (MST) of G, i.e., the directed tree with the highest overall score that includes all nodes of G;</li><li>this is possible in O(n<sup>2</sup>) time using the <strong>Chu-Liu-Edmonds algorithm</strong>; it finds a MST which is not guaranteed to be projective;<br>  1, Each node j in the graph greedily selects the incoming edge with the highest score s(i,j)<br>  2, If result were a tree, it would have to be the maximum spanning tree; If not, there must be a cycle.<br>  3, Break the cycle by replacing a single incoming edge to one of the nodes in the cycle. To choose the node, decide recursively by identifying the cycle and contract it into a single node and recalculate scores of incoming and outgoing edges. Now call CLE recursively on the contracted graph. MST on the contracted graph is equivalent to MST on the original graph. 这里是指先识别出循环体<code>saw ⇄ john</code>②，然后在这个循环体范围内，使用CLE找出 root 进出这个循环体的最大概率路线<code>(root → saw → john = 40) &gt; (root → john → saw = 29)</code>③；<br>  4, Greedily collect incoming edges to all nodes, find out to be a tree and thus the MST of the graph. 把循环体以及其包含的nodes合并为一个node wjs，并且已经有了进出wjs的最大概率路径，这样就可以在整个图上继续运行CLE算法找出最大概率路线<code>(root → wjs → mary = 70) &gt; (root → mary → wjs = 40)</code>④.<br><img src="/images/break_the_cycle.jpg" alt="" title="Graph-based dependency parsing procedure. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l07.pdf"></li></ul><p>Chu-Liu-Edmonds (CLE) Algorithm:</p><blockquote><p>In graph theory, Edmonds’ algorithm or Chu–Liu/Edmonds’ algorithm is an algorithm for finding a spanning arborescence of minimum weight (sometimes called an optimum branching). It is the directed analog of the minimum spanning tree problem</p></blockquote><h3 id="Transition-based-dependency-parsing"><a href="#Transition-based-dependency-parsing" class="headerlink" title="Transition-based dependency parsing"></a>Transition-based dependency parsing</h3><p>An extension of shift-reduce parsing (MALT parser), views syntactic structure as the actions of an automaton:<br>• for a given parse state, the transition system defines a set of actions T which the parser can take;<br>• if more than one action is applicable, a machine learning classifier is used to decide which action to take;<br>• just like in the MST model, this requires a mechanism to compute scores over a set of (possibly dynamic) candidates.<br><img src="/images/Transition_based_Dependency_Parsing.png" alt="" title="Configuration c = (s, b, A) with stack s, buffer b, set of dependency arcs A; c is terminal if buffer is empty, stack contains only ROOT, and parse tree is given by Ac image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l07.pdf"><br>if si is the ith top element on stack, and bi the ith element on buffer, then we have the following transitions:<br>• <code>LEFT-ARC(l)</code>: adds arc <code>s1 → s2</code> with label <code>l</code> and removes s2 from stack (|s| ≥ 2);<br>• <code>RIGHT-ARC(l)</code>: adds arc <code>s2 → s1</code> with label <code>l</code> and removes s1 from stack (|s| ≥ 2);<br>• <code>SHIFT</code>: moves b1 from buffer to stack; recondition: |b| ≥ 1.<br>总的来说就是：父节点保留在stack中; 从始至终 root 一直都是父节点；从 buffer 中把候选词一个一个 push 到stack中，根据 classifier 预测的结果，分辨出哪个候选词是子节点，并把子节点 pop 出 stack；直到清空 buffer，stack 中只剩下 root。</p><h3 id="Comparing-MST-and-transition-based-parsers"><a href="#Comparing-MST-and-transition-based-parsers" class="headerlink" title="Comparing MST and transition-based parsers:"></a>Comparing MST and transition-based parsers:</h3><p>Both require dynamic classifiers, and these can be implemented using neural networks, conditioned on bidirectional RNN encodings of the sentence.</p><p>The MST parser selects the globally optimal tree, given a set of edges with scores;<br>• it can naturally handle projective and non-projective trees;</p><p>A transition-based parser makes a sequence of local decisions about the best parse action;<br>• it can be extended to projective dependency trees by changing the transition set;</p><p>Accuracies are similar, but transition-based is faster;</p><h2 id="Recurrent-neural-network-grammars-RNNGs"><a href="#Recurrent-neural-network-grammars-RNNGs" class="headerlink" title="Recurrent neural network grammars (RNNGs)"></a>Recurrent neural network grammars (RNNGs)</h2><p>Widespread phenomenon: <strong>Polarity items</strong> can only appear in certain contexts, e.g. “anybody”.</p><blockquote><p>In linguistics, a <strong>polarity item</strong> is a lexical item that can appear only in environments associated with a particular grammatical polarity – affirmative or negative. A polarity item that appears in affirmative (positive) contexts is called a positive polarity item (PPI), and one that appears in negative contexts is a negative polarity item (NPI).</p></blockquote><blockquote><p>The environment in which a polarity item is permitted to appear is called a “<strong>licensing context</strong>“.</p></blockquote><p>The lecture that I gave did not appeal to anybody;<br><del>The lecture that I gave appealed to anybody.</del></p><p>也许”anybody”出现的条件是前面出现过”not”，那么应该可以使用 RNNs 模型来解码这点信息。然而:<br><del>The lecture that I did not give appealed to anybody.</del></p><p>这说明 Language is hierarchical: The <strong>licensing context</strong> depends on recursive structure (syntax)。不能简单根据”not”是否出现来判断，而是需要看”not”修饰的成分，也就是说要考虑语法的合理。这就给文本生成任务（或者说构建语言模型）带来挑战。</p><p><a href="https://arxiv.org/pdf/1602.07776.pdf" target="_blank" rel="noopener">Recurrent neural network grammars (Dyer et al. 2016)</a>提出了一种具有明确短语结构的语言模型 RNNGs。</p><blockquote><p> RNNGs operate via a recursive syntactic process reminiscent of probabilistic context-free grammar generation, but decisions are parameterized using RNNs that condition on the entire syntactic derivation history, greatly relaxing context-free independence assumptions.</p></blockquote><p>就是在使用 RNNs 构建语言模型，除了考虑历史词信息, 还会生成历史的语法结构, 并以此为参考预测语法结构和词语,以保证生成的语言符合语法结构。这里的语法是针对 phrase structure (constituency) grammars，所以 RNNGs 也是一种 <strong>constituency parsing</strong>：</p><ul><li>Generate symbols sequentially using an RNN</li><li>Add some “control symbols” to rewrite the history periodically<ul><li>Periodically “compress” a sequence into a single “constituent”</li><li>Augment RNN with an operation to compress recent history into a single vector (-&gt; “reduce”)</li><li>RNN predicts next symbol based on the history of compressed elements and non-compressed terminals (“shift” or “generate”)</li><li>RNN must also predict “control symbols” that decide how big constituents are</li></ul></li></ul><p>首先注意到，如果有序地去遍历语法树，得出的就是一个序列：<br><img src="/images/tree_traversals.gif" alt="" title="(Ordered) tree traversals are sequences. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></p><p>What information can we use to predict the next action, and how can we encode it with an RNN?</p><p>Use an RNN for each of:</p><ul><li>Previous terminal symbols</li><li>Previous actions</li><li>Current stack contents<br><img src="/images/tree_traversals_table.gif" alt="" title="Actions prediction. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"><br>最后得出的 stack 就是完整的语法树（以序列的形式）。</li></ul><h3 id="Syntactic-Composition"><a href="#Syntactic-Composition" class="headerlink" title="Syntactic Composition"></a>Syntactic Composition</h3><p>人们通过较小元素的语义组合来解释较大文本单元的含义 - 实体，描述性词语，事实，论据，故事.<br>When compressing “The hungry cat” into a single composite symbol, use Bi-LSTM to encode <code>(NP The hungry cat)</code>.<br><img src="/images/NP_The_hungry_cat.png" alt="" title="Representation of (NP The hungry cat). image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></p><p>基于此可以递归地解码更复杂的短语，比如<code>(NP The (ADJP very hungry) cat)</code>, 只需要把原来的<code>hungry</code>替换为<code>(ADJP very hungry)</code>即可。</p><p>这种递归地堆栈符号的构建行为映射了符号对应的树结构<br><img src="/images/Stack_symbols_composed_recursively.png" alt="" title="Stack encodes top-down syntactic recency, rather than left-to-right string recency. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></p><p>除此了使用 Bi-LSTM 解码，还可以使用 Attention：Replace composition with one that computes attention over objects in the composed sequence, using embedding of NT for similarity.</p><h3 id="Implement-RNNGs"><a href="#Implement-RNNGs" class="headerlink" title="Implement RNNGs"></a>Implement RNNGs</h3><p>Stack RNNs</p><ul><li>Augment a sequential RNN with a <strong>stack pointer</strong></li><li>Two constant-time operations<ul><li><label style="color:#1565C0"><strong>push</strong></label> - read input, add to top of stack, connect to current location of the stack pointer</li><li><label style="color:#C62828"><strong>pop</strong></label> - move stack pointer to its parent</li></ul></li><li>A <strong>summary</strong> of stack contents is obtained by accessing the output of the RNN at location of the stack pointer<br><img src="/images/stack_LSTM_over_time.gif" alt="" title="The evolution of the stack LSTM over time mirrors tree structure. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></li></ul><p>Training RNNs:</p><ul><li>Each word is conditioned on history represented by a trio of RNNs</li><li>backpropagate through these three RNNs, and recursively through the phrase structure <code>S → NP VP</code>.<br><img src="/images/RNNGs_history_informationn.png" alt="" title="RNNs compute probability conditions on histroy. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></li></ul><p>完整的RNNGs模型，用 softmax 计算下一个 action 的概率分布：<br><img src="/images/RNNGs_model.png" alt="" title="Complete RNNGs model. x is sentence, y is tree; $A_G$ is allowable actions at this step;  $a(x,y)$ is sequence of actions, ; $r_α$ is action embedding, $u_t$ is history embedding; $o_t$ is output (buffer), $s_t$ is stack, $h_t$ is action history, the three are concatenated together. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></p><h3 id="Parameter-Estimation"><a href="#Parameter-Estimation" class="headerlink" title="Parameter Estimation"></a>Parameter Estimation</h3><p>RNNGs jointly model sequences of words together with a “tree structure”.</p><p>Any parse tree can be converted to a sequence of actions (depth first traversal) and vice versa (subject to wellformedness constraints).</p><h3 id="Inference-problems-of-RNNGs"><a href="#Inference-problems-of-RNNGs" class="headerlink" title="Inference problems of RNNGs"></a>Inference problems of RNNGs</h3><p>An RNNG is a joint distribution p(x,y) over strings (x) and parse trees (y), i.e. it jointly predicts the word, and the parse context together. So the model will still generate the syntactic information and the next word but we can discard the additional outputs if all we want is the language model.</p><p>Two inference questions:<br>• What is $p(x)$ for a given x? - language modeling<br>• What is $argmax_yp(y | x)$ for a given x? - parsing</p><p>The model predicts the next action (NT() GEN() or REDUCE in generative mode, NT() SHIFT or REDUCE in discriminative mode). The set of actions completely determines the string and tree structure, so we can get their joint probability by multiplying over the probabilities of all actions.</p><p>In discriminative mode, the input is a string of words, and the model cannot generate words, but instead “consumes” the words in the input buffer. The model can be used as a parser (find the maximum prob. tree, i.e., $argmax_yP(y \mid x)$).</p><p>In generative mode, there is a respective GEN() action for every word, so the word is predicted with the action. To be a language model (find the maximum prob. sentence/assign probabilities to a sentence, i.e., $p(x)$), we must marginalize over trees to get the probability of the sentence. This is intractable so is approximated with importance sampling by sampling from a discriminatively trained model.</p><h3 id="importance-sampling"><a href="#importance-sampling" class="headerlink" title="importance sampling"></a>importance sampling</h3><p>Assume we”ve got a conditional distribution $q(y | x)$<br>s.t. (i) $p(x, y) &gt; 0 \Rightarrow q(y | x) &gt; 0$<br>(ii) $y \sim q(y | x)$ is tractable and<br>(iii) $q(y | x)$ is tractable</p><p>The importance weights $w(x,y) = \frac{p(x, y)}{q(y | x)}$</p><p><img src="/images/Importance_Sampling.png" alt="" title="image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></p><h3 id="从句子到语法树的seq2seq模型"><a href="#从句子到语法树的seq2seq模型" class="headerlink" title="从句子到语法树的seq2seq模型"></a>从句子到语法树的seq2seq模型</h3><p>其实从句子到语法的映射类似于一个seq2seq模型。而直接的把语法树以字符序列的形式表达，使用简单的 RNNs 直接构建句子到语法序列的 seq2seq 模型效果也不错，比如：<br>input:     The hungry cat meows .<br>output:    S( NP( _ _ _ ) VP( _ ) _ )<br>Vanilla RNNs 在模式匹配和计数方面非常出色，经验证明，训练有素的 seq2seq 模型通常会输出格式良好的字符串，见<a href="https://arxiv.org/abs/1412.7449" target="_blank" rel="noopener">这篇文章 section 3.2</a></p><p>但潜在的问题是，seq2seq 模型并不要求输出是有正确括号字符（数量对齐，位置正确）。另外，理论上单个RNN也只能记忆括号结构一定的有限深度，因为 RNNs 只有固定的有限数量的隐藏单元。例如，它将为这些输出分配非零概率：<br>S( NP( _ _ ) VP ( _ ) _ )<br>S( NP( _ _ _ ) VP ( _ ) _ ) ) )</p><p>理想情况下，模型应该给任何不完整的输出分配零概率。使用 RNNGs 是因为它本身能够履行这些限制， 保证生成完整正确的语法树。</p><p>从中可以看出，seq2seq模型可以用于快速原型和 baseline 搭建，但如果遇到要求输出遵守某些约束条件的问题，则需要直接执行这些约束条件。</p><h2 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h2><p>Parsing is a fundamental task in NLP. But what is parsing actually good for?</p><p>Parsing breaks up sentences into meaningful parts or finds meaningful relationships, which can then feed into downstream semantic tasks:<br>• semantic role labeling (figure out who did what do whom);<br>• semantic parsing (turn a sentence into a logical form);<br>• word sense disambiguation (figure out what the words in a sentence mean);<br>• compositional semantics (compute the meaning of a sentence based on the meaning of its parts).</p><h2 id="Semantic-role-labeling-SRL"><a href="#Semantic-role-labeling-SRL" class="headerlink" title="Semantic role labeling (SRL)"></a>Semantic role labeling (SRL)</h2><p>虽然可以使用 Distributional semantics 表达含义，只是 Distributional semantics 比较擅长处理相似度，且无法很明确地处理复合性 Compositionality。</p><blockquote><p>在数学、语义学和语言哲学中，复合性原理是指，一个复杂表达式的意义是由其各组成部分的意义以及用以结合它们的规则来决定的。</p></blockquote><p>为了能够处理复合性和推理，我们需要象征性和结构化的意义表示。</p><p>虽然语言是无穷无尽的，句子是无限的集合，而人脑的能力却是有限的，但人们总能够理解一个句子的含义（假如人们熟知表达句子的语言）. 因此, 对于 semantics, 语义肯定是有限的集合, 这样才能确定句子的确切意义.</p><blockquote><p>In generative grammar, a central principle of formal semantics is that the relation between syntax and semantics is <strong>compositional</strong>.</p></blockquote><blockquote><p>The principle of compositionality (Fregean Principle): The meaning of a complex expression is determined by the meanings of its parts and the way they are syntactically combined.</p></blockquote><p>Semantic role labeling means identifying the arguments (<strong>frame elements</strong>) that participate in a prototypical situation (frame) and labeling them with their roles;</p><p>SRL task is typically broken down into a sequence of sub-tasks:</p><ol><li>parse the training corpus;</li><li>match <strong>frame elements</strong> to constituents;</li><li>extract features from the parse tree;</li><li>train a probabilistic model on the features.</li></ol><p>所谓 frame elements 是针对 Frame Semantics 而言的。</p><p>SRL provides a shallow semantic analysis that can benefit various NLP applications; no parsing needed, no handcrafted features.</p><h3 id="Frame-Semantics"><a href="#Frame-Semantics" class="headerlink" title="Frame Semantics"></a>Frame Semantics</h3><p>表达词义，除了 Firth, J.R. (1957) 的 “a word is characterized by the company it keeps”（也即是 Distributional semantics）之外, 还有 Charles J. Fillmore 的 Frame Semantics.</p><blockquote><p>The basic idea is that one cannot understand the meaning of a single word without access to all the essential knowledge that relates to that word.</p></blockquote><blockquote><p>A semantic frame is a collection of facts that specify “characteristic features, attributes, and functions of a denotatum, and its characteristic interactions with things necessarily or typically associated with it.”</p></blockquote><blockquote><p>A semantic frame can also be defined as a coherent structure of related concepts that are related such that without knowledge of all of them, one does not have complete knowledge of any one; they are in that sense types of gestalt.</p></blockquote><h3 id="Proposition-Bank"><a href="#Proposition-Bank" class="headerlink" title="Proposition Bank"></a>Proposition Bank</h3><p>完整的句子表达了命题 propositions, 也即一个主张. 比如”John smokes”这个句子的命题如果是真的,那么”John”在这里一定是某个”smokes”的人, 也就是必须是<code>NP</code>.</p><blockquote><p>在现代哲学、逻辑学、语言学中，命题是指一个判断（陈述）的语义（实际表达的概念），这个概念是可以被定义并观察的现象。命题不是指判断（陈述）本身。当相异判断（陈述）具有相同语义的时候，他们表达相同的命题。例如，雪是白的（汉语）和Snow is white（英语）是相异的判断（陈述），但它们表达的命题是相同的。在同一种语言中，两个相异判断（陈述）也可能表达相同命题。例如，刚才的命题也可以说成冰的小结晶是白的，不过，之所以是相同命题，取决于冰的小结晶可视为雪的有效定义。</p></blockquote><p>PropBank is a version of the Penn Treebank annotated with semantic roles. More coarse-grained than Frame Semantics:<br><img src="/images/PropBank.png" alt="" title="Proposition Bank, Arg2–Arg4 are often verb specific. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l09.pdf"></p><h3 id="End-to-end-SRL-system"><a href="#End-to-end-SRL-system" class="headerlink" title="End-to-end SRL system"></a>End-to-end SRL system</h3><p>基本的结构单元是Bi-LSTM，用法是：<br>· a standard LSTM layer processes the input in forward direction;<br>· the output of this LSTM layer is the input to another LSTM layer, but in reverse direction;<br>这些Bi-LSTM单元可以叠加起来构造更深层的神经网络.</p><p>The input (processed word by word) features are:<br>• argument and predicate: the argument is the word being processed, the predicate is the word it depends on;<br>• predicate context (ctx-p): the words around the predicate; also used to distinguish multiple instances of the same predicate;<br>• region mark (m<sub>r</sub>): indicates if the argument is in the predicate context region or not;<br>• if a sequence has n<sub>p</sub> predicates it is processed n<sub>p</sub> times.</p><p>Output: semantic role label for the predicate/argument pair using IOB tags (inside, outside, beginning).<br><img src="/images/end_to_end_SRL.png" alt="" title="End to end SRL model. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l09.pdf"></p><p>Training:<br>• Word embeddings are used as input, not raw words;<br>• the embeddings for arguments, predicate, and ctx-p, as well as m<sub>r</sub> are <strong>concatenated</strong> and used as input for the Bi-LSTM;<br>• the output is passed through a conditional random field (CRF); allows to model dependencies between output labels;<br>• Viterbi decoding is used to compute the best output sequence</p><p>Model learns “syntax”(Maybe): it associates argument and predicate words using the forget gate:</p><h2 id="Semantic-Parsing"><a href="#Semantic-Parsing" class="headerlink" title="Semantic Parsing"></a>Semantic Parsing</h2><p>Semantic Parsing 指语义分析，把文本解析为任意的逻辑形式(一种 meaning representation)，比如 first-order logic(FOL).<br><code>Sam likes Casey</code> - <code>likes(Sam, Casey)</code>;<br><code>Anna&#39;s dog Mr. PeanutButter misses her</code> - <code>misses(MrPB, Anna) ∧ dog(MrPB)</code>;<br><code>Kim likes everyone</code> - <code>∀x.likes(x, Kim)</code>.<br>Predicate-argument structure is a good match for FOL, as well as structures with argument-like elements (e.g. NPs).<br>Determiners, quantifiers (e.g. “everyone”, “anyone”), and negation can be expressed in FOL.</p><p>However, much of natural language is unverifiable, ambiguous, non-canonical. That makes it hard to represent the wide-coverage meaning of arbitrary NL. Closed domains are easier, and can sometimes be harvested automatically, e.g. GEOQUERY dataset.</p><p>This leads to a proliferation of domain-specific MRs.<br>· Pairs of NL sentences with structured MR can be collected, e.g. IFTTT dataset (Quirk et al. 2015).<br>· WikiTableQuestions<br>· Google’s knowledge graph</p><p>Viewing MR as a string, semantic parsing is just conditional language modeling. Trainable alternative to compositional approaches: encoder-decoder neural models. The encoder and decoder can be mixed and matched: RNN, top-down tree RNN.<br><img src="/images/meaning_representation_model.png" alt="" title="Meaning representation model using standard sequence models. Since logical forms are treelike, can use treeLSTM decoder. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l10.pdf"></p><p>Works well on small, closed domains if we have training data, but there are many unsolved phenomena/ problems in semantics.</p><h3 id="Abstract-meaning-representation-AMR"><a href="#Abstract-meaning-representation-AMR" class="headerlink" title="Abstract meaning representation (AMR)"></a>Abstract meaning representation (AMR)</h3><p>• The edges (ARG0 and ARG1) are <label style="color:#C62828">relations</label><br>• Each node in the graph has a <label style="color:#BA68C8">variable</label><br>• They are labeled with <label style="color:#1565C0">concepts</label><br>• <label style="color:#BA68C8">d</label> / <label style="color:#1565C0">dog</label> means “<label style="color:#BA68C8">d</label> is an instance of <label style="color:#1565C0">dog</label>“<br><code>The dog is eating a bone</code><br>(<label style="color:#BA68C8">e</label> / <label style="color:#1565C0">eat-01</label><br>&nbsp;&nbsp;&nbsp;&nbsp;:<label style="color:#C62828">ARG0</label> (<label style="color:#BA68C8">d</label> / <label style="color:#1565C0">dog</label>)<br>&nbsp;&nbsp;&nbsp;&nbsp;:<label style="color:#C62828">ARG1</label> (<label style="color:#BA68C8">b</label> / <label style="color:#1565C0">bone</label>))</p><p><code>The dog wants to eat the bone</code><br>(want-01<br>&nbsp;&nbsp;&nbsp;&nbsp;:ARG0 (d / dog)<br>&nbsp;&nbsp;&nbsp;&nbsp;:ARG1 (e / eat-01<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:ARG0 d<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:ARG1 (b / bone)))</p><p><strong>Coreference</strong><br>Charles just graduated, and now Bob wants Anna to give <strong>him</strong> a job.<br>Q: who does <strong>him</strong> refer to?</p><p><strong>Metonymy</strong><br><strong>Westminster</strong> decided to distribute funds throughout England, Wales, Northern Island, and Scotland<br>decided(Parliament, …)</p><p><strong>Implicature</strong><br>That cake looks delicious - I would like a piece of that cake.</p><p>Even more phenomena…<br>• Abbreviations (e.g. National Health Service=NHS)<br>• Nicknames (JLaw=Jennifer Lawrence)<br>• Metaphor (crime is a virus infecting the city)<br>• Time expressions and change of state<br>• Many others</p><h2 id="TODO-指代消解-Coreference-Resolution"><a href="#TODO-指代消解-Coreference-Resolution" class="headerlink" title="TODO(指代消解 Coreference Resolution)"></a>TODO(指代消解 Coreference Resolution)</h2><h2 id="Unsupervised-Part-of-Speech-Tagging"><a href="#Unsupervised-Part-of-Speech-Tagging" class="headerlink" title="Unsupervised Part-of-Speech Tagging"></a>Unsupervised Part-of-Speech Tagging</h2><p>Parts-of-speech(POS), word classes, or syntactic categories, 一般指八个词性：noun, verb, adjective, adverb, pronoun, preposition, conjunction, interjection, 有时候是 numeral, article or determiner.<br>1, noun 名詞 ( n. )<br>2, pronoun 代名詞 ( pron. )<br>3, verb 動詞 ( v. )<br>4, adjective 形容詞 ( adj. )<br>5, adverb 副詞 ( adv. )<br>6, preposition 介系詞 ( prep. )<br>7, conjunction 連接詞 ( conj. )<br>8, interjection 感歎詞 ( int. )</p><p>Tagging is a task that take a sentence, assign each word a label indicating its syntactic category (part of speech).</p><p>One common standard label is Penn Treebank PoS tagset.</p><blockquote><p>DT - Determiner 定语<br>IN - Preposition or subord. conjunction<br>NN - Noun, singular or mass<br>NNS - Noun, plural<br>NNP - Proper noun, singular<br>RB - Adverb<br>TO - to<br>VB - Verb, base form<br>VBZ - Verb, 3rd person singular present</p></blockquote><p>In supervised POS tagging, the input is the text and a set of allowed POS labels. The training data contains input and output examples. The output is a guess, for each word in the test data, which POS label it should have.</p><p>A common approach is to use an HMM. To train it, choose parameters θ that maximize $P(x,y \mid θ)$, the probability of the training data given the parameters. This is <strong>maximum likelihood estimation</strong> and it was covered in <a href="">ANLP</a>. You can use the model to predict y for each x in the test data by solving $P(y \mid x,θ)$ using the <strong>Viterbi algorithm</strong>.</p><p>A consequence of supervised training with MLE is that the model will only learn <strong>non-zero probability</strong> for tag-word pairs that actually appear in the data. Hence, if “the” is only ever tagged with DT in the training data, then the model will learn that the probability of producing “the” from any other tag is zero. This means that many word tokens will be (empirically) unambiguous, which is one of the things that makes supervised POS tagging easy.</p><p>RNNs 虽然也可以处理序列模型, 但是神经网络需要目标函数, 没有目标无法计算损失, 就无法调整参数, 也就是”监督学习”.</p><p>Current PoS taggers are highly accurate (97% accuracy on Penn Treebank). But they require manually labelled training data, which for many major language is not available. Hence motivated for unsupervised PoS tagging.</p><p>In unsupervised POS tagging, the input is the text and <strong>the number of clusters</strong>. The training data contains only input examples. The output is a guess, for each word in the text, which cluster the word belongs to. For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number of clusters: 50</span><br><span class="line">Input x: The hungry cat meows</span><br><span class="line">Output y: 23 45 7 18</span><br></pre></td></tr></table></figure></p><p>What we hope is that the cluster labels will correlate with true POS labels; that is, that tokens labeled 23 will tend to be determiners, that clusters label 45 will tend to be adjectives, and so on.</p><p>这个时候可以使用隐马尔科夫模型, 这个”隐”就是针对没有目标可以参考这种情况.</p><h3 id="Hidden-Markov-Models"><a href="#Hidden-Markov-Models" class="headerlink" title="Hidden Markov Models"></a>Hidden Markov Models</h3><p>The unsupervised tagging models here are based on Hidden Markov Models (HMMs).<br><img src="/images/HMM.png" alt="" title="Hidden Markov Models (HMMs). image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l11.pdf"><br>To train it, choose parameters θ that maximize $P(x \mid θ)$, the probability of the training data given the parameters.</p><p>The parameters θ = (τ, ω) define:<br>• τ : the probability distribution over tag-tag transitions;<br>• ω: the probability distribution over word-tag outputs.<br>The parameters are sets of multinomial distributions:<br>• $ω = ω^{(1)} . . . ω^{(T)}$: the output distributions for each tag;<br>• $τ = τ^{(1)} . . . τ^{(T)}$: the transition distributions for each tag;<br>• $ω^{(t)} = ω_1^{(t)}. . . ω_W^{(t)}$: the output distribution from tag $t$;<br>• $τ^{(t)} = τ_1^{(t)}. . . τ_T^{(t)}$: the transition distribution from tag $t$.</p><p>Another way to write the model, often used in statistics and machine learning:</p><p>$w_i | t_i = t ∼ Multinomial(ω^{(t)})$</p><p>So as tag, given that $t_{i−1} = t$, the value of $t_i$ is drawn from a multinomial distribution with parameters $τ^{(t)}$.</p><p>How to estimate ω and τ without supervision. This is still maximum likelihood estimation, but notice that it’s more difficult because the tags y are unobserved, so you must marginalize them out.</p><p>For <strong>estimation</strong> (i.e., training the model, determining its parameters), we need a procedure to set θ based on data. Rely on Bayes Rule:<br>\begin{equation}\begin{split}<br>    P(θ|w)&amp;=\frac{P(w|θ)P(θ)}{P(w)}\\<br>    &amp;∝P(w|θ)P(θ)\\<br>\end{split}\end{equation}<br>Choose the θ that maximize the likelihood $P(w|θ)$. Basically, we ignore the prior. In most cases, this is equivalent to assuming a uniform prior.</p><p>To do this, you can use <strong>expectation maximization</strong> (EM), a variant of MLE that can cope with unobserved data, which was also covered in <a href="">ANLP</a>. For examples, forward-backward algorithm for HMMs, inside-outside algorithm for PCFGs, k-means clustering.</p><p>For <strong>inference</strong> (i.e., decoding, applying the model at test time), we need to know θ and then we can compute $P(t, w)$:<br><img src="/images/Inference_for_HMMs.png" alt="" title="Inference for HMMs. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l11.pdf"></p><p>E-step: use current estimate of θ to compute expected counts of hidden events ($n(t,t^{\prime})$, $n(t,w)$).<br>M-step: recompute θ using expected counts.</p><p>You can then use the trained model to predict y for each x in the test data by solving $P(y \mid x,θ)$ using the Viterbi algorithm.</p><p>But EM often fails, even very small amounts of training data have been show to work better than EM. One consequence of unsupervised training with EM is that every word can be assigned to any cluster label. This makes things really difficult, because it means every word is ambiguous. The basic assumptions of EM (that any tag-word or tag-tag distribution is equally likely) make this even more difficult.</p><p>Instead, use Bayesian HMM with Gibbs sampling.</p><h3 id="Bayesian-HMM"><a href="#Bayesian-HMM" class="headerlink" title="Bayesian HMM"></a>Bayesian HMM</h3><p>When training HMM model, we are not actually interested in the value of θ, we could simply integrate it out. This approach is called <strong>Bayesian integration</strong>. Integrating over θ gives us an average over all possible parameters values.</p><p>The Bayesian HMM is simply an alternative way to solve the unsupervised POS tagging problem. The input and output is the same. But instead of learning θ, we directly solve $P(y \mid x)$. Note that we don’t need to learn θ (though we could) - in this setting, we integrate it out, after first supplying some information about the tag-tag and word-tag distributions encoded in θ. Specifically, we tell the model that a sparse distribution is much more likely than a uniform distribution. We do this by defining a distribution $P(θ)$, and this gives us a new model,  $P(y,x \mid θ)×P(θ)$. By integrating out θ we can solve the unsupervised tagging problem directly.</p><p>Example: we want to predict a spinner result will be “a” or not?<br>• Parameter θ indicates spinner result: $P(θ = a) = .45$, $P(θ = b) = .35$, $P(θ = c) = .2$;<br>• define t = 1: result is “a”, t = 0: result is not “a”;<br>• make a prediction about one random variable (t) based on the value of another random variable (θ).</p><p><strong>Maximum likelihood approach</strong>: choose most probable θ, $\hat{θ} = a$, and $P(t = 1|\hat{θ}) = 1$, so we predict $t = 1$.</p><p><strong>Bayesian approach</strong>:<br>average over θ,<br>$P(t = 1) = \sum_θ P(t = 1|θ)P(θ) = 1(.45) + 0(.35) + 0(0.2) = .45$, predict t = 0.</p><p>Advantages of Bayesian integration:<br>• accounts for uncertainty as to the exact value of θ;<br>• models the shape of the distribution over θ;<br>• increases robustness: there may be a range of good values of θ;<br>• we can use priors favoring sparse solutions (more on this later).</p><p>Dirichlet distribution<br>Choosing the right prior can make integration easier. A $K$-dimensional Dirichlet with parameters $α = α_1 . . . α_K$ is defined as:</p><p>$$ P(θ) = \frac{1}{Z} \prod_{j=1}^K θ_j^{α_j−1} $$</p><p>We usually only use symmetric Dirichlets, where $α_1 . . . α_K$ are all equal to β. We write Dirichlet(β) to mean $Dirichlet(β, . . . , β)$.</p><p><img src="/images/Dirichlet_Distribution.png" alt="" title="A 2-dimensional symmetric Dirichlet(β) prior over θ = (θ1, θ2), β &gt; 1: prefer uniform distributions, β = 1: no preference, β &lt; 1: prefer sparse (skewed) distributions. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l11.pdf"><br>注意到这是一个二维的概率密度图. $β&gt;1$意味着更喜欢均值分布, 此时$θ$大概率落在$0.5$附近,因为$θ_1+θ_2=1$, 所以此时$θ_1, θ_2$概率均等. 如果$β=1$, $θ_1$的任何取值是等概率的, 等于说任何$θ_1,θ_2$的组合概率都是均等的.</p><p>To Bayesianize the HMM, we augment with it with symmetric Dirichlet priors:<br><img src="/images/Bayesianizing_the_HMM.png" alt="" title="image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l11.pdf"></p><p>To simplify things, use a bigram version of the Bayesian HMM; If we integrate out the parameters θ = (τ, ω), we get:<br><img src="/images/BHMM_Dirichlet_Distribution_.png" alt="" title="With T possible tags and Wt possible words with tag t. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l11.pdf"></p><p>Use these distributions to find $P(t|w)$ using an estimation method called <strong>Gibbs sampling</strong>.</p><p>Results: Integrating over parameters is useful in itself, even with uninformative priors $(α = β = 1)$;</p><p>总结：<br>· Bayesian HMM improves performance by averaging out uncertainty;<br>· allows us to use priors that favor sparse solutions as they occur in language data.<br>· Using a tag dictionary is also really helpful. We still have no labeled training data, but if we only allow each word to be tagged with one of the labels that appears in the dictionary, then most word-tag pairs will have probability zero. So this is a very different way of supplying information to the unsupervised model that is very effective.</p><h2 id="Bias-in-NLP"><a href="#Bias-in-NLP" class="headerlink" title="Bias in NLP"></a>Bias in NLP</h2><h3 id="The-social-impact-of-NLP"><a href="#The-social-impact-of-NLP" class="headerlink" title="The social impact of NLP"></a>The social impact of NLP</h3><p>Outcome of an NLP experiment can have a direct effect on people’s lives, e.g.</p><ol><li><a href="https://www.youtube.com/watch?v=p8phGxzUC_Y" target="_blank" rel="noopener">频繁出现亚马逊 Alexa 突然发出诡异笑声，给多名用户造成困惑和恐慌</a>, 因为人们谈话中偶然包含 trigger 词：”Alexa, laugh” 而发出 - 亚马逊的<a href="https://www.nytimes.com/2018/03/08/business/alexa-laugh-amazon-echo.html" target="_blank" rel="noopener">解决方案是把 trigger 改为更难触发的 “Alexa, can you laugh”</a></li><li>Chatbot 对于人们敏感问题的不恰当回答, 比如 “Should I kill myself?” - “Yes.”，这些回答对患有心理障碍的人群或者青少年儿童带来非常大的危害。</li><li><a href="https://www.theverge.com/2016/3/24/11297050/tay-microsoft-chatbot-racist" target="_blank" rel="noopener">Microsoft 的 AI chatbot 上线仅一天, 就通过 twitter 和人交谈并学会涉及种族, 性别歧视等的话语</a>, 典型的 “garbage in, garbage out” 现象.</li><li>其他涉及数据隐私等问题</li></ol><p><strong>语言的特性，导致NLP涉及的社会伦理问题非常多, 而且影响非常大</strong>：<br>· 语言传递着信息、偏见，是政治性的、权力的工具, 同时比其他技术带有更明显的拟人化、人格化倾向，这可能给个人生活带来不便或危害，给整个社会带来舆论影响。<br>· Any dataset carries demographic bias: latent information about the demographics of the people that produced it. That excludes people from other demographics.</p><p><strong>同时人类本身的认知容易加深偏见</strong>:<br>The <strong>availability heuristic</strong>: the more knowledge people have about a specific topic, the more important they think it must be. <strong>Topic overexposure</strong> creates biases that can lead to discrimination and reinforcement of existing biases. E.g. NLP focused on English may be self-reinforcing.</p><p><strong>NLP 实验本身容易加深偏见</strong>：<br>• Advanced grammar analysis can improve search and educational NLP, but also reinforce prescriptive linguistic norms.<br>• Stylometric analysis can help discover provenance of historical documents, but also unmask anonymous political dissenters.</p><p><strong>NLP 技术可能被不恰当地使用</strong>：<br>• Text classification and IR can help identify information of interest, but also aid censors.<br>• NLP can be used to discriminate fake reviews and news, and also to generate them.</p><h3 id="Word-embeddings-contain-human-like-biases"><a href="#Word-embeddings-contain-human-like-biases" class="headerlink" title="Word embeddings contain human-like biases"></a>Word embeddings contain human-like biases</h3><p>word2vec learns semantic/ syntactic relationships, also keep company with unsavoury stereotypes and biases?<br>• Man:Woman - King:Queen<br>• Man:Doctor - Woman:Nurse<br>• Man:Computer Programmer - Woman:Homemaker</p><p>Measure bias using implicit association tests:<br>1, Compute similarity of group1 and stereotype1 word embeddings. Cosine similarity is use to measure association (in place of reaction time).<br>2, Compute similarity of group1 and stereotype 2 word embeddings.<br>3, Null hypothesis: if group1 is not more strongly associated to one of the stereotypes, there will be no difference in the means.<br>4, Effect size measured using Cohen’s d.<br>5, Repeat for group 2.</p><p>Experiments<br>• Uses GloVe trained on Common Crawl—a large-scale crawl of the web.<br>• Removed low frequency names.<br>• Removed names that were least “name-like” (e.g. Will) algorithmically.<br>• Each concept is represented using a small set of words, designed for previous experiments in the psychology literature.</p><p>Result:<br>· flowers associate with pleasant, insects associate with unpleasant. $p &lt; 10^{−7}$<br>· Men’s names associate with career, women’s names associate with family. $p &lt; 10^{−3}$<br>· European American names associate with pleasant, African American names associate with unpleasant. $p &lt; 10^{−8}$</p><p>这些结果的确真实地反映人类社会的现状。但大部分性别方面的偏见其实是反映了目前的社会分工，无所谓高低贵贱；人种的偏见倒是反映了历史问题对现在的影响，这种偏见是不符合道德的。人对于其他生物的偏见，虽然是没必要的，但人类的确倾向于喜爱行为”可爱”，外形”美好”的生物，比如大熊猫就是比鳄鱼受欢迎。</p><p>偏见的存在不一定合理。哪些偏见是不合理的，才是人们更应该去思考和讨论的地方。</p><h3 id="Debiasing-word-embeddings"><a href="#Debiasing-word-embeddings" class="headerlink" title="Debiasing word embeddings"></a>Debiasing word embeddings</h3><p><a href="https://arxiv.org/abs/1607.06520" target="_blank" rel="noopener">Bolukbasi. et. al., 2016. Man is to Computer Programmer as Woman is to Homemaker? Debiasing Word Embeddings</a>提供了一个思路:</p><ol><li>确认偏见的方向</li><li>中和抵消偏见: 对于非定性的词（如”医生”），通过投射来消除偏见</li><li>等价：让<code>father - mother</code>和<code>boy - girl</code>等距，让定性词间的距离只有性别的距离；或者让<code>doctor - woman</code>和<code>doctor - man</code>等距，消除非定性词的性别偏见。</li></ol><p>什么词需要抵消偏见: 训练一个线性分类器来确定词是非定性还是非定性的, 结果当然是大部分英语词都是非定性的.</p><p>If analogies reveal a gender dimension, use analogies on specific seed pairs to find it.<br><img src="/images/Gender_subspace.png" alt="" title="Selected words projected along two axes: x is a projection onto the difference between the embeddings of the words he and she, and y is a direction learned in the embedding that captures gender neutrality, with gender neutral words above the line and gender specific words below the line. In this figure, the words above the horizontal line would all be collapsed to the vertical line. image from: Bolukbasi. et. al., 2016. Man is to Computer Programmer as Woman is to Homemaker? Debiasing Word Embeddings"><br>y 轴下面的词属于定性词, 不需要中性化, 而y轴之上的词则需要进行中性化处理.</p><p>不同的偏见, 需要不同的 seed words; 一种偏见, 可以有多种 seed words 选择: 除了用”She-He”作为性别偏见的基准, 还有其他选择.</p><h2 id="编码器—解码器-Sequence-to-sequence-和注意力机制"><a href="#编码器—解码器-Sequence-to-sequence-和注意力机制" class="headerlink" title="编码器—解码器 Sequence-to-sequence 和注意力机制"></a>编码器—解码器 Sequence-to-sequence 和注意力机制</h2><p>当输入输出都是不定长序列时, 比如机器翻译这种任务，需要使用 Sequence-to-sequence（seq2seq）或者 encoder-decoder 神经网络结构。这种结构可以通过一种方法叫注意力机制来显著提高性能。</p><h3 id="编码器—解码器-Sequence-to-sequence（seq2seq）"><a href="#编码器—解码器-Sequence-to-sequence（seq2seq）" class="headerlink" title="编码器—解码器 Sequence-to-sequence（seq2seq）"></a>编码器—解码器 Sequence-to-sequence（seq2seq）</h3><p>编码器：所谓编码，就是把不定长的输入序列输入RNN，以得出某种定长的编码信息。<br>解码器：所谓解码，就是把编码器编码后的信息（一般取编码器的RNN最终时刻的隐含层变量）输入到解码器的RNN中，每个t时刻的输出既取决于之前时刻（t-1）的输出又取决于编码信息。等同于一个以解码信息作为条件概率生成目标语言句子的语言模型。</p><p>所以 seq2seq 本质是一个条件概率语言模型：语言模型是指解码器每次会预测下一个出现的单词，条件概率是指预测是基于编码后的源句子。</p><h3 id="注意力"><a href="#注意力" class="headerlink" title="注意力"></a>注意力</h3><p>在传统的seq2seq模型中，解码器各个时刻都使用相同的编码信息，这就要求解码器把源输入序列的所有信息都解码并整合到最后时刻的隐含状态中，这个是很大的信息瓶颈。而人们知道，在实际任务中，比如机器翻译，目标句子的不同单词，一般只对应源句子的某一部分而已。如果能够让解码器在解码时，在不同时刻专注于源输入序列的不同部分，那么就可以突破这个瓶颈。</p><ol><li>对于解码器的每一时间步的隐含状态s<sub>t</sub>，可以衡量其与编码器的所有时间步隐含状态h<sub>0</sub>……e<sub>t</sub>的相似性(或score评分) <code>e = α(s, h)</code>，简单的评分方式是元素间相乘, <code>e = s*h</code>（<a href="https://arxiv.org/abs/1409.0473" target="_blank" rel="noopener">Bahanau的论文</a>提供了更复杂的形式), 也可以参考<a href="https://nlp.stanford.edu/pubs/emnlp15_attn.pdf" target="_blank" rel="noopener">论文Effective Approaches to Attention-based Neural Machine Translation</a>探讨的集中评分方式, 这篇论文提供了一种 Bilinear 形式的相似性评分法, 就是在s和h之间以点乘的形式插入一个交互矩阵 interaction matrix.</li><li>对得出的评分求加权平均<code>a = softmax(e)</code>, 得出的权值分布也称注意力权重</li><li>通过注意力权重把编码器隐含状态加权求和，得到注意力输出 <code>A = Σah</code></li><li>最后把注意力输出和对应时间步的解码器隐含状态s<sub>t</sub>拼接在一起 [A;s<sub>t</sub>]，作为解码器rnn的隐含层.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;References:&lt;br&gt;&lt;a href=&quot;http://www.inf.ed.ac.uk/teaching/courses/nlu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Natural language understanding&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://web.stanford.edu/class/cs224n/syllabus.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CS224n: Natural Language Processing with Deep Learning&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://web.stanford.edu/~jurafsky/NLPCourseraSlides.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christopher Manning&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>自然语言处理快速入门 | 02 N-Gram 语言模型 - ANLP UoE 爱丁堡</title>
    <link href="http://shukebeta.me/NOTE-ANLP-02-n-gram-model/"/>
    <id>http://shukebeta.me/NOTE-ANLP-02-n-gram-model/</id>
    <published>2018-04-01T23:00:00.000Z</published>
    <updated>2018-06-29T19:35:53.370Z</updated>
    
    <content type="html"><![CDATA[<p>生成模型在语言模型中的应用包括 N-Gram语言模型，朴素贝叶斯分类器，隐马尔可夫模型。</p><blockquote><p>在概率统计理论中, 生成模型是指能够生成观测数据的模型，尤其是在给定某些隐含参数的条件下。它给观测值和标注数据序列指定一个联合概率分布。</p></blockquote><blockquote><p>生成模型的定义与判别模型相对应：生成模型是所有变量的全概率模型，而判别模型是在给定观测变量值前提下目标变量条件概率模型。因此生成模型能够用于模拟（即生成）模型中任意变量的分布情况，而判别模型只能根据观测变量得到目标变量的采样。判别模型不对观测变量的分布建模，因此它不能够表达观测变量与目标变量之间更复杂的关系。因此，生成模型更适用于无监督的任务，如分类和聚类。</p></blockquote><a id="more"></a><h2 id="N-Gram-语言模型"><a href="#N-Gram-语言模型" class="headerlink" title="N-Gram 语言模型"></a>N-Gram 语言模型</h2><p>如何训练一个语言模型? 在神经网络大热之前, 人们普遍使用<code>N-Gram</code>语言模型。就是收集不同n-gram频率的统计数据，并用它们预测下一个单词，概率模型基于前面提到的马尔可夫简化假设：若使用<code>N</code>-Gram 来预测下一个单词，出现概率仅取决于前面的<code>(N-1)</code>个单词.</p><p>一个<code>N-Gram</code>就是n个连续的单词</p><ul><li><code>Uni</code>gram: “the”, “students”, “opened”, ”their”</li><li><code>Bi</code>gram: “the students”, “students opened”, “opened their”</li><li><code>tri</code>grams: “the students opened”, “students opened their”</li><li><code>4-</code>grams: “the students opened their”</li></ul><p>通过计数来估计统计概率：<code>P(wi| prefixes) = count(prefixes, wi)/count(prefixes) = count(“the students”)/count(“the students opened”)</code></p><p>在实际中，使用 log 转换来避免数值下溢，并且log 转换可以把乘法转换为加法, 计算更快.</p><p>N-Gram模型的缺点很明显：</p><ul><li>无法很好地解决NLP中的长距离依赖现象</li><li>N-gram只是在测试语料库与训练语料库比较相似时表现才比较好。</li><li>稀疏问题1：大多数高阶N-Gram几乎不会出现，我们不能简单地把这些定义为0概率的，因为语言是千变万化的，有些词组虽然少见但不代表不存在</li><li>稀疏问题2：少部分低阶n-gram在测试集中出现了但是在训练集中没有。比如需要预测 “students opened their _”, 但是训练集中没出现过“students opened their”。</li><li>一般而言，N越高，模型表现越好，但是更大的N使稀疏问题变得更糟。通常人们不会取大于5的N。</li><li>需要存储所有可能的N-Gram，所以模型的大小是 <code>O(exp(n))</code>,需要大量的内存.</li></ul><p>针对数据稀疏问题, 可以使用各种平滑处理.</p><h3 id="Add-alpha-smoothing"><a href="#Add-alpha-smoothing" class="headerlink" title="Add alpha smoothing"></a>Add alpha smoothing</h3><ul><li>Assign equal probability to all unseen events.</li><li>Applied in text classification, or domains where zeros probability is not common.</li></ul><h3 id="Backoff-smoothing"><a href="#Backoff-smoothing" class="headerlink" title="Backoff smoothing"></a>Backoff smoothing</h3><ul><li>Use information from lower order N-grams (shorter histories)</li><li>Back off to a lower-order N-gram if we have zero evidence for a higher-order interpolation N-gram.</li><li>Discount: In order for a backoff model to give a correct probability distribution, we have to discount the higher-order N-grams to save some probability mass for the lower order N-grams.</li></ul><p>对于像网络数据这种非常大的N-gram，使用stupid backoff.</p><h3 id="Interpolation-smoothing"><a href="#Interpolation-smoothing" class="headerlink" title="Interpolation smoothing"></a>Interpolation smoothing</h3><ul><li>Interpolation: mix the probability estimates from all the N-gram estimators, weighing and combining the trigram, bigram, and unigram counts</li><li>Simple interpolation: <code>P(w3|w1,w2)=1P(w3|w1,w2)+λ2P(w3|w2)+λ3P(w3)</code>, Σλ=1.</li><li>λ could be trianed/conditioned on training set/contest, choose λ that maximie the probability of held-out data</li></ul><h3 id="Kneser-Ney-smoothing"><a href="#Kneser-Ney-smoothing" class="headerlink" title="Kneser-Ney smoothing"></a>Kneser-Ney smoothing</h3><p>这是目前表现最好的平滑方案.</p><ul><li>Combine absolute discounting and interpolation: Extending interpolatation with an absolute discounting 0.75 for high order grams.</li><li>Use a better estimate for probabilities of lower-order unigrams, the continuation probability, P_continuatin(w) is how likely is w to appear as a novel continutaion.<ul><li>For each word w, count the number of bigram types it completes. Or count the number of word types seen to precede w.</li><li>Every bigram type was a novel continuation the first time it was seen.</li><li>normalized by the total number of word bigram types.</li></ul></li><li>To lower the probability of some fix bigram like “San Franscio”</li><li>For bigram, <code>Pkn(wi|wi-1)=max(count(wi-1,wi)-d, 0)/c(wi-1) +λ(wi-1)P_continuatin(wi), λ(wi-1) = d{w:count(wi-1,w)&gt;0}/c(wi-1)</code>, where {w:count(wi-1,w)&gt;0} is the number of word types that can follow wi-1, also is the # of word types we discounted, also is the # of times we applied normalized discount.</li><li>For general N-gram, <img src="/images/kneser-ney.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;生成模型在语言模型中的应用包括 N-Gram语言模型，朴素贝叶斯分类器，隐马尔可夫模型。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在概率统计理论中, 生成模型是指能够生成观测数据的模型，尤其是在给定某些隐含参数的条件下。它给观测值和标注数据序列指定一个联合概率分布。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;生成模型的定义与判别模型相对应：生成模型是所有变量的全概率模型，而判别模型是在给定观测变量值前提下目标变量条件概率模型。因此生成模型能够用于模拟（即生成）模型中任意变量的分布情况，而判别模型只能根据观测变量得到目标变量的采样。判别模型不对观测变量的分布建模，因此它不能够表达观测变量与目标变量之间更复杂的关系。因此，生成模型更适用于无监督的任务，如分类和聚类。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理快速入门 | 01 概率模型 - 语言模型 - ANLP UoE 爱丁堡</title>
    <link href="http://shukebeta.me/NOTE-ANLP-01-probability-model/"/>
    <id>http://shukebeta.me/NOTE-ANLP-01-probability-model/</id>
    <published>2018-03-31T23:00:00.000Z</published>
    <updated>2018-06-29T19:35:57.287Z</updated>
    
    <content type="html"><![CDATA[<p>爱丁堡大学的自然语言处理入门课程笔记。</p><p>References:<br><a href="http://www.inf.ed.ac.uk/teaching/courses/anlp/" target="_blank" rel="noopener">Accelerated natural language processing</a><br><a href="https://www.inf.ed.ac.uk/teaching/courses/anlp/review/review_ay17.html" target="_blank" rel="noopener">ANLP revision guide</a><br><a href="https://web.stanford.edu/~jurafsky/NLPCourseraSlides.html" target="_blank" rel="noopener">Lecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christopher Manning</a><br><a id="more"></a></p><h2 id="概率模型-Probability-model"><a href="#概率模型-Probability-model" class="headerlink" title="概率模型 Probability model"></a>概率模型 Probability model</h2><p>概率模型是随机现象的数学表示，由样本空间，样本空间内的事件以及与每个事件相关的概率定义。目标是模拟给一个事件发生的概率</p><h3 id="估算概率-Probability-estimation"><a href="#估算概率-Probability-estimation" class="headerlink" title="估算概率 Probability estimation"></a>估算概率 Probability estimation</h3><p>相关频率/最大似然估计<br>Relative frequency / maximum likelihood estimation p(X) = Count(x)/N</p><h3 id="平滑处理-Smoothing"><a href="#平滑处理-Smoothing" class="headerlink" title="平滑处理 Smoothing"></a>平滑处理 Smoothing</h3><p>一般用于处理0概率的问题，比如在训练集中看不到, 但出现在测试集中的词。</p><h4 id="加一（Laplace）平滑"><a href="#加一（Laplace）平滑" class="headerlink" title="加一（Laplace）平滑"></a>加一（Laplace）平滑</h4><p>最简单的平滑法，为所有事件（不管有没出现过）的频次加一，这样保证了没有0概率事件出现。<br>这种平滑效果很差，因为齐夫定律<code>Zipf&#39;s law</code>的关系:</p><blockquote><p>在自然语言的语料库里，一个单词出现的频率与它在频率表里的排名成反比。</p></blockquote><p>会有很多长尾单词很少甚至几乎没有出现过, 所以在总数为1的概率池子了, 为了给这些长尾单词分配至少频次1的概率, 需要从真正出现的单词(所谓真实发生的事件)中分走很多概率.</p><p>更多高级的平滑方案参考<a href="/NOTE-ANLP-02-n-gram-model">N-gram</a>部分。</p><h4 id="语言模型-Language-modeling"><a href="#语言模型-Language-modeling" class="headerlink" title="语言模型 Language modeling"></a>语言模型 Language modeling</h4><p>语言模型: 一种用于计算连续的单词（就是句子）或者任何其他序列数据（比如语音）出现的概率的模型，最基本的应用是基于某种语言模型，预测下一个单词出现的概率 <code>P(w|w1, w2, w3...)</code>。</p><p>语言模型本身即是一种概率模型(或者说人们选择用概率模型来描述为语言建模). 因为近现代的自然语言处理主要集中在信息沟通传输方面(比如密码,语音识别, 机器翻译, 校正等), 而香农的信息传输模型使用条件概率来描述鉴定噪音中的真实信息.</p><p>如何表达: 一个句子发生的概率就是里面各个单词的概率的乘积。依赖于概率的链式法则, 一个位置的单词的概率，条件于该位置之前的句子部分的概率。所以通过链式法则得出的语言模型概率是冗长的条件概率乘积。</p><p>但我们可以通过马尔可夫性质 Markov property 把语言模型简化，一个位置单词出现的条件概率可以通过某种近似来逼近: 仅考虑离它最近的（若干）单词，得到<code>P(the| water is so transparent that) ≈ P(the| that)</code>.</p><p><a href="/NOTE-ANLP-01-evaluation#evaluation-concepts-and-methods">Evaluation</a>：一般通过困惑度（Perplexity）来衡量语言模型的好坏。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;爱丁堡大学的自然语言处理入门课程笔记。&lt;/p&gt;
&lt;p&gt;References:&lt;br&gt;&lt;a href=&quot;http://www.inf.ed.ac.uk/teaching/courses/anlp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Accelerated natural language processing&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.inf.ed.ac.uk/teaching/courses/anlp/review/review_ay17.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ANLP revision guide&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://web.stanford.edu/~jurafsky/NLPCourseraSlides.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christopher Manning&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Python" scheme="http://shukebeta.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java | Hash @Override equals() hashcode()</title>
    <link href="http://shukebeta.me/Java-hashcode-equals/"/>
    <id>http://shukebeta.me/Java-hashcode-equals/</id>
    <published>2018-02-27T00:00:00.000Z</published>
    <updated>2018-06-29T19:10:35.858Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍：</p><ol><li>Hashcode（哈希码）与 equals（判断相等）的关系</li><li>Hashcode 方法的底层实现原理</li><li>开发中需要掌握的原则和方法</li></ol><h3 id="HashSet-HashMap-HashTable"><a href="#HashSet-HashMap-HashTable" class="headerlink" title="HashSet, HashMap, HashTable"></a>HashSet, HashMap, HashTable</h3><p>HashSet底层是调用HashMap. HashMap 使用hashCode和equals来进行对象比较。<br><a id="more"></a><br>拿HashSet和add()举例(其余的数据结构,和 remove, contains等方法类似):假设HashSet里面已经有了obj1, 那么当调用HashSet.add(obj2)时:</p><ol><li>if (obj1 == obj2), 那么没有必要调用 hashCode(), 已经有了这个对象, 没必要添加了</li><li>else, if hashCode 不同，那么可以直接添加了, 没必要进一步调用 obj1.equals(obj2) 来判断对象是否相等</li><li>else hashCode 相同，那么需要进一步调用obj1.equals(obj2)</li></ol><p>下面这段代码虽然 HashSet 只存了 a 对象，但当检查是否包含 b 对象时，返回true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; wordSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">String a = <span class="string">"hello"</span>;</span><br><span class="line">String b = <span class="string">"hello"</span>;</span><br><span class="line">wordSet.add(a);</span><br><span class="line"><span class="keyword">return</span> wordSet.contains(b); <span class="comment">// return true</span></span><br></pre></td></tr></table></figure></p><p>根据<a href="https://docs.oracle.com/javase/6/docs/api/java/util/Set.html#add%28E%29" target="_blank" rel="noopener">Javadoc for Set</a>.</p><blockquote><p>adds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)).</p></blockquote><p>根据<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#equals-java.lang.Object-" target="_blank" rel="noopener">Javadoc for String.equals</a></p><blockquote><p>Compares this string to the specified object. The result is true if and only if the argument is not null and is a String object that represents the same sequence of characters as this object.</p></blockquote><p>Java的set是使用它包含的元素（对象）的 <code>equals()</code>来比较 b 和 a 的。这里 String 类的<code>equals()</code>method 是比较字符串值是否相等(准确的说，是先检查是不是引用同一个对象，再看是不是同一个类，再比较值)，而不是引用的对象是否一样，故<code>b.equals(a)</code>是 true。</p><p>同样的，remove 和 add 也会先进行类似检查。</p><p>问题是，为何 hashCode 不同，就没有进一步调用<code>equals()</code>的必要呢？因为有一个前提是代码遵守The hashCode contract。</p><h3 id="Hashcode-and-equals"><a href="#Hashcode-and-equals" class="headerlink" title="Hashcode and equals"></a>Hashcode and equals</h3><p>在Java中，每个对象都有一个hashCode，它有时容易被人遗忘或误用。有以下三点需要注意，避免掉入常见的陷阱。</p><h4 id="The-hashCode-contract"><a href="#The-hashCode-contract" class="headerlink" title="The hashCode contract"></a>The hashCode contract</h4><p>根据 The hashCode contract:</p><blockquote><p>Objects that are equal must have the same hash code within a running process.</p></blockquote><p>除了字面意思，也有其他隐含的意思: 不相等的对象的hashcode也可能一样; 具有相同 hash code 的对象不一定相等.</p><blockquote><p>You must override hashCode() in every class that overrides equals(). Failure to do so will result in a violation of the general contract for Object.hashCode(), which will prevent your class from functioning properly in conjunction with all hash-based collections, including HashMap, HashSet, and Hashtable. — Effective Java, by Joshua Bloch</p></blockquote><p>根据这个contract，可以延伸出以下实践原则：</p><p><strong>一、 每当你 override equals 时，也要 override hashCode</strong><br>假如你需要使用不一样的equals判断标准，那么就需要重写equals。但假如仅仅重写equals，而不重写hashcode()，就可能会违背 The hashCode contract。</p><p>为什么？因为 hashCode method 需要同时适配真正使用到的 equals method 的判断标准。通过重写equals，我们重新声明了一种判断对象是否相等的标准，但原始的 hashCode method还是会将所有对象视为不同的对象。所以如果没有不重写hashcode，那么根据@Override equals 判断为相同的对象将拥有不同的hashcode（可能）。这样，即使已经有了这个object，在HashMap上调用 contains() 也会返回false。</p><p>例子：在Java的创建街道street这个类，在判断两条街道是否相同时，我们有自定义的规则 - 只要是在同一个城市，有同样的街道名，那么两个street就相等，即使他们是存放在不同内存位置的两个对象（Java 的 Object 原生的equals是根据引用的对象内存地址来比较判断的）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Street</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Street))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        Street rhs = (Street) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EqualsBuilder().</span><br><span class="line">            <span class="comment">// if deriving: appendSuper(super.equals(obj)).</span></span><br><span class="line">            append(name, rhs.name).</span><br><span class="line">            append(age, rhs.city).</span><br><span class="line">            isEquals();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashCodeBuilder(<span class="number">17</span>, <span class="number">31</span>). <span class="comment">// two randomly chosen prime numbers</span></span><br><span class="line">            <span class="comment">// if deriving: appendSuper(super.hashCode()).</span></span><br><span class="line">            append(name).</span><br><span class="line">            append(city).</span><br><span class="line">            toHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果没有重写hashCode()， 那么两个名字和所在城市一样的，但引用不同地址的street就会按照默认的 hashcode() 返回不一样的code，但是根据重写的equals(), 他们是一样的, 这样就违背了 hashCode contract。</p><p>为了安全起见，让Eclipse IDE 生成 equals 和 hashCode 函数：<code>Source &gt; Generate hashCode() and equals()...</code><br><img src="https://eclipsesource.com/wp-content/uploads/2012/09/generate-hashcode-equals.png" alt=""></p><p>为了提醒自己, 还可以配置Eclipse以检测是否有违反此规则的情况，并为仅重写了equals但没重写hashCode的情况显示错误：<code>Preferences &gt; Java &gt; Compiler &gt; Errors/Warnings, then use the quick filter to search for “hashcode”</code><br><img src="https://eclipsesource.com/wp-content/uploads/2012/09/hashcode-error-config.png" alt=""></p><h3 id="HashCode-collisions"><a href="#HashCode-collisions" class="headerlink" title="HashCode collisions"></a>HashCode collisions</h3><p>HashCode collisions 指两个不同的对象具有相同的hashcode这种情况, 这不是什么严重的问题. 只是会导致更多的搜索步骤，太多collisions就可能会降低系统性能</p><p>但是，如果将HashCode错误地用作对象的唯一句柄，例如将其用作Map中的key，那么有时会得到错误的对象。虽然collisions一般很少见，但却是不可避免的。例如，字符串“Aa”和“BB”产生相同的hashCode：2112. 因此衍生出第二个原则</p><p><strong>二、永远不要把hashcode当做key来使用</strong></p><p>Java中有4,294,967,296个（2<sup>32</sup>)可能的int值）。既然拥有40亿个插槽，collisions似乎几乎不可能对吧？</p><p>但事实上，也不是那么不可能。试想，一个房间里有23名随机人员。你如何估计里面有两个人生日一样的概率？很低？因为一年有365天？事实上，概率约为50％！这种现象被称为<a href="http://en.wikipedia.org/wiki/Birthday_paradox" target="_blank" rel="noopener">生日问题(悖论)</a>。</p><blockquote><p>如果一个房间里有23个或23个以上的人，那么至少有两个人的生日相同的概率要大于50%。</p></blockquote><p>问题的本质是”23人之中两两之间存在生日相同的概率””,而不是”其他22人与其中一个人的生日相同的概率”.</p><p>类比到hashcode里，这意味着有77,163个不同的对象，collisions概率是50%（假设有一个理想的hashCode函数，将对象均匀分布在所有可用的buckets中）。</p><h3 id="HashCodes-会变"><a href="#HashCodes-会变" class="headerlink" title="HashCodes 会变"></a>HashCodes 会变</h3><p>HashCode 不保证在不同的执行过程中总能返回相同的code。根据JavaDoc：Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. <strong>This integer need not remain consistent from one execution of an application to another execution</strong> of the same application.</p><p>这种情况并不常见，实际上，库中的某些类甚至指定了用于计算hashcode的精确公式（例如String）。对于这些类，hashcode总是相同的。但是，尽管大多数的hashCode方法提供了稳定的值，但我们不能依赖它。正如<a href="http://martin.kleppmann.com/2012/06/18/java-hashcode-unsafe-for-distributed-systems.html" target="_blank" rel="noopener">这篇文章</a>所指出的那样，Java库实际上在不同的进程中返回不同的hashCode值，这往往会让人们感到困惑。 Google的<a href="http://code.google.com/p/protobuf/" target="_blank" rel="noopener">Protocol Buffers</a>就是一个例子。 因此，您不应该在分布式应用程序中使用hash code。即使两者相等，远程对象的 hash code 也可能与本地的不同。</p><p><strong>三、不要在分布式应用程序中使用 hashCode</strong><br>此外，要意识到，hashCode函数的实现可能会随着版本的更改而改变。因此我们的代码最好不依赖任何特定的hash code 值。例如，你不应该使用hash code来保持某种状态，不然下次运行时，“相同”对象的hash code可能会不同。</p><p>所以最好的建议可能是：除非自己创建了基于 hashcode 算法，否则根本就不要使用 hashCode 呵呵……</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在依赖于 HashSet, HashMap, HashTable … 等数据结构的程序中：</p><ol start="3"><li>仅重写 equals()，会导致业务出错</li><li>仅重写 hashcode(), 在比较两个对象时不会强制Java忽略内存地址</li><li>如果不涉及对象比较(比如仅仅是iteration), 那么不需要hashCode and/or equals</li></ol><p>参考：<br><a href="https://eclipsesource.com/blogs/2012/09/04/the-3-things-you-should-know-about-hashcode/" target="_blank" rel="noopener">https://eclipsesource.com/blogs/2012/09/04/the-3-things-you-should-know-about-hashcode/</a><br><a href="https://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java" target="_blank" rel="noopener">https://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hashcode（哈希码）与 equals（判断相等）的关系&lt;/li&gt;
&lt;li&gt;Hashcode 方法的底层实现原理&lt;/li&gt;
&lt;li&gt;开发中需要掌握的原则和方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;HashSet-HashMap-HashTable&quot;&gt;&lt;a href=&quot;#HashSet-HashMap-HashTable&quot; class=&quot;headerlink&quot; title=&quot;HashSet, HashMap, HashTable&quot;&gt;&lt;/a&gt;HashSet, HashMap, HashTable&lt;/h3&gt;&lt;p&gt;HashSet底层是调用HashMap. HashMap 使用hashCode和equals来进行对象比较。&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 - Java | 13 实现继承 Implementation Inheritance - CS61B Berkeley - Josh Hug</title>
    <link href="http://shukebeta.me/NOTE-CS61B-data-structures-13-Implementation-Inheritance/"/>
    <id>http://shukebeta.me/NOTE-CS61B-data-structures-13-Implementation-Inheritance/</id>
    <published>2018-02-24T00:00:00.000Z</published>
    <updated>2018-06-29T19:34:55.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Implementation-Inheritance"><a href="#Implementation-Inheritance" class="headerlink" title="Implementation Inheritance"></a>Implementation Inheritance</h2><p>除了signature之外，Java也允许subclass继承具体的实现方法。实现继承是subclass从superclass继承实现的关系。<br><a id="more"></a></p><h3 id="缺省方法"><a href="#缺省方法" class="headerlink" title="缺省方法"></a>缺省方法</h3><p>从 Java 8开始支持 Default method。</p><p>我们可以在List中列出已实现的method。这些方法就是 default method，定义了List hypernyms的一些默认行为：<code>default public void method() { ... }</code>.</p><p>我们可以自由调用interface中定义的方法，而不用操心具体的实现。Default method 适用于实现接口的任何类型的对象！子类可以直接调用，而不必重新实现 default method。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过，我们仍然可以override default method，在子类中重新定义该方法。这样，只要我们在LinkedLList上调用<code>print()</code>，它就会调用子类override的方案，而不是父类的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedList</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Dynamic-type"><a href="#Dynamic-type" class="headerlink" title="Dynamic type"></a>Dynamic type</h3><p>Java是通过一个叫“dynamic method selection”的特性，来确定要调用 default method 还是已经被子类override的method。</p><p>当实例声明<code>List&lt;String&gt; l = new LinkedList&lt;String&gt;();</code>, 则指明<code>l</code>是 static 类型的 List。由 new 生成的 object 是LinkedList类型，也从属于 List 类型。但是，因为这个对象本身是使用 LinkedList 构造函数实例化的，所以我们称之为 dynamic type。</p><blockquote><p>Dynamic type 的名称源于: 当<code>l</code>被重新分配指向另一种类型的对象时，比如说一个 ArrayList 对象，<code>l</code>的动态类型现在就变为 ArrayList. 因为它根据当前引用的对象的类型而改变, 所以是动态的。</p></blockquote><p>Static vs. Dynamic Type:</p><ul><li>Java 每个变量都有一个static type （compile-time type），这是变量声明时指定的类型，在编译时会检查。</li><li>每个变量也有一个 Dynamic Type（run-time type），此类型在变量实例化（new）时指定，并在运行时检查。等同于地址指向的对象的类型。</li></ul><p>当Java运行一个被overriden的方法时，会根据该实例的dynamic type 匹配对应的 method。</p><p>注意，如果是overload:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">peek</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">peek</span><span class="params">(LinkedList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于上面的实例化的<code>l</code>, 当Java检查要调用哪个方法时，它会检查 static type (此时是List)并使用相同类型的参数调用该方法，也就是使用List作为签名的那个方法。</p><h3 id="区别-Interface-Inheritance-与-Implementation-Inheritance"><a href="#区别-Interface-Inheritance-与-Implementation-Inheritance" class="headerlink" title="区别 Interface Inheritance 与 Implementation Inheritance"></a>区别 Interface Inheritance 与 Implementation Inheritance</h3><p>Interface Inheritance 接口继承（what）：指定 subclass 应该实现的功能，即只提供 method signature。</p><p>Implementation Inheritance 实现继承（how）：提供功能的实现方案，即提供 method implementation。允许代码再利用，也给subclass设计者提供了更多的自由度，由他们自行决定是否override default method。</p><p>Implementation inheritance 也有一些缺点：</p><ul><li>人会犯错。我们有可能忘了自己曾经override过一个方法。</li><li>如果两个接口给出冲突的 default method，则可能很难解决冲突。</li><li>无形中鼓励代码复杂化。</li><li>Breaks encapsulation!</li></ul><p>最后，注意<strong>从属</strong>和<strong>拥有</strong>的区别：subclass 和 superclass 是上下级从属分类，而不是拥有与被拥有的关系，不要跟 nested class 混淆。</p><blockquote><p>Interface Methods: Default methods and abstract methods in interfaces are inherited like instance methods. However, when the supertypes of a class or interface provide multiple default methods with the same signature, the Java compiler follows inheritance rules to resolve the name conflict.<br>– <a href="https://docs.oracle.com/javase/tutorial/java/IandI/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/IandI/index.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Implementation-Inheritance&quot;&gt;&lt;a href=&quot;#Implementation-Inheritance&quot; class=&quot;headerlink&quot; title=&quot;Implementation Inheritance&quot;&gt;&lt;/a&gt;Implementation Inheritance&lt;/h2&gt;&lt;p&gt;除了signature之外，Java也允许subclass继承具体的实现方法。实现继承是subclass从superclass继承实现的关系。&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="cs61b" scheme="http://shukebeta.me/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 - Java | 12 接口继承 Interface Inheritance - CS61B Berkeley - Josh Hug</title>
    <link href="http://shukebeta.me/NOTE-CS61B-data-structures-12-Interface-Inheritance/"/>
    <id>http://shukebeta.me/NOTE-CS61B-data-structures-12-Interface-Inheritance/</id>
    <published>2018-02-23T00:00:00.000Z</published>
    <updated>2018-06-29T19:35:00.697Z</updated>
    
    <content type="html"><![CDATA[<p>我们前面创建的 <code>LinkedList</code> and <code>ArrayList</code> 其实很相似 - 所有的method都一样.</p><p>如果我们需要写一个需要用到 list 的类比如<code>WordUtils</code> class, 我们如何让它既可以使用<code>LinkedList</code>又可以用<code>ArrayList</code>？<br><a id="more"></a><br>简单的方法及时写两个同名不同参数的methods。即所谓<code>method overloading</code>。<br><code>public static String longest(LinkedList&lt;String&gt; list)</code><br><code>public static String longest(ArrayList&lt;String&gt; list)</code></p><p>但 overload 有几个缺点:</p><ul><li>重复冗余，写两个几乎相同的代码块。</li><li>产生更多需要维护的代码，那意味着如果你想对的方法做一个小优化或debug，你需要在对应每种list的方法中改变它。</li><li>如果我们想要适配更多的列表类型，不得不复制每个新列表类的方法。</li></ul><p>为避免以上问题，我们一般希望能尽量把两个功能近似的方法合并，但要保证其足够广泛的适用场景。此时可以使用<strong>接口 interface</strong>。<br><!-- more --></p><h3 id="上位词，下义词和接口继承"><a href="#上位词，下义词和接口继承" class="headerlink" title="上位词，下义词和接口继承"></a>上位词，下义词和接口继承</h3><p>Hypernyms, Hyponyms, and Interface Inheritance</p><p>首先要理解，上位词和下位词是语言学的定义，直接沿用到编程语言中。就像狗是哈士奇的上位词，哈士奇是狗的下义词，在Java把这种关系形式化：如果<code>LinkedList</code>是List的Hyponyms，那么<code>LinkedList</code>类是List的subclass，而List类是<code>LinkedList</code>类的superclass(超类/父类)。</p><p>在Java中，为了表达这种层次结构，我们需要：</p><ol><li>定义通用列表 List interface。</li><li>把<code>LinkedList</code>和<code>ArrayList</code>指定为 List 的 hyponyms。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Item x)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 List 是Java中的 interface 接口。本质上是一个指定list必须能够做什么的合约，具体如何做并不是它关心的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">Item</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 具体的执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Item x)</span> </span>&#123;</span><br><span class="line">        insert(x, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>指定ArrayList是List的hyponyms. <code>implements List&lt;Item&gt;</code>类似一种承诺 - 保证具备 List interface 中制定的所有属性（变量）和行为（方法），并提供具体实现方案。</p><p>这样就可以同时适配多种list：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordUtils</span> </span>&#123;</span><br><span class="line">   <span class="comment">/** Returns the length of the longest word. */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longest</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> list.get(maxDex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     ArrayList&lt;String&gt; someList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="comment">//or</span></span><br><span class="line">     LinkedList&lt;String&gt; someList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">     ...</span><br><span class="line">     System.out.println(longest(someList));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Overriding"><a href="#Overriding" class="headerlink" title="Overriding"></a>Overriding</h3><p>Subclass 可以<strong>覆盖 override</strong> superclass的方法。</p><blockquote><p>区分 Override 与 重载 overloaded：Override 的方法 signature 相同；overloaded的方法同名但不同signature。</p></blockquote><p>在子类中实现合约指定的功能时，需要在method的signature顶部包含<code>@Override</code>标签。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Item x)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但即使不包含这个<code>@Override</code>，我们仍然override了这个方法。所以从技术上来说，<code>@Override</code>并不是必须的。但是，它可以作为一个保障, 提醒编译器我们打算override此方法, 如果过程中出现问题, 编译器可以提醒。假设当我们想 override <code>addLast</code>，却不小心写成<code>addLsat</code>。此时如果不包含<code>@Override</code>，那么可能无法发现错误。如果有了<code>@Override</code>，编译器就会提示我们修复错误。</p><h3 id="总结：Interface-Inheritance"><a href="#总结：Interface-Inheritance" class="headerlink" title="总结：Interface Inheritance"></a>总结：Interface Inheritance</h3><p>接口继承是指subclass继承superclass的所有方法/行为的关系：</p><ul><li>子类继承父类</li><li>Interfaces 接口列出所有方法的签名，就像‘合约’，但没有具体的实现</li><li>根据‘合约’，由子类来实现且必须实现（override）每一个method，否则无法通过编译</li><li>继承关系可以延续多代。例如，B可以继承A，C可以继承B.</li></ul><h3 id="GRoE"><a href="#GRoE" class="headerlink" title="GRoE"></a>GRoE</h3><p>根据Java的Golden Rule of Equals，每一个赋值a = b，本质上是把b中的bits拷贝到a中，着要求b和a的类型相同。</p><p>同理, 假设<code>public static String longest(List&lt;String&gt; list)</code>既接受List, 也接受ArrayList和LinkedList，但是由于ArrayList和List是不同的类，那怎么遵守GRoE呢？</p><p>因为ArrayList与List有着上下位包含的关系，这意味着ArrayList应该能够赋值给List的内存位中.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; someList = <span class="keyword">new</span> SLList&lt;String&gt;();</span><br><span class="line">    someList.addFirst(<span class="string">"elk"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码运行时，会创建SLList并将其地址存储在someList变量中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们前面创建的 &lt;code&gt;LinkedList&lt;/code&gt; and &lt;code&gt;ArrayList&lt;/code&gt; 其实很相似 - 所有的method都一样.&lt;/p&gt;
&lt;p&gt;如果我们需要写一个需要用到 list 的类比如&lt;code&gt;WordUtils&lt;/code&gt; class, 我们如何让它既可以使用&lt;code&gt;LinkedList&lt;/code&gt;又可以用&lt;code&gt;ArrayList&lt;/code&gt;？&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="cs61b" scheme="http://shukebeta.me/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>Accelerated Natural Language Processing - Informatics - University of Edinburgh</title>
    <link href="http://shukebeta.me/UoE-anlp/"/>
    <id>http://shukebeta.me/UoE-anlp/</id>
    <published>2018-01-31T00:00:00.000Z</published>
    <updated>2018-06-29T19:34:11.842Z</updated>
    
    <content type="html"><![CDATA[<p>References:<br><a href="http://www.inf.ed.ac.uk/teaching/courses/anlp/" target="_blank" rel="noopener">Accelerated natural language processing</a><br><a href="https://www.inf.ed.ac.uk/teaching/courses/anlp/review/review_ay17.html" target="_blank" rel="noopener">ANLP revision guide</a><br><a href="https://web.stanford.edu/~jurafsky/NLPCourseraSlides.html" target="_blank" rel="noopener">Lecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christopher Manning</a><br><a id="more"></a></p><h2 id="概率模型-Probability-model"><a href="#概率模型-Probability-model" class="headerlink" title="概率模型 Probability model"></a>概率模型 Probability model</h2><p>概率模型是随机现象的数学表示，由样本空间，样本空间内的事件以及与每个事件相关的概率定义。目标是模拟给一个事件发生的概率</p><h3 id="估算概率-Probability-estimation"><a href="#估算概率-Probability-estimation" class="headerlink" title="估算概率 Probability estimation"></a>估算概率 Probability estimation</h3><p>相关频率/最大似然估计<br>Relative frequency / maximum likelihood estimation p(X) = Count(x)/N</p><h3 id="平滑-Smoothing"><a href="#平滑-Smoothing" class="headerlink" title="平滑 Smoothing"></a>平滑 Smoothing</h3><p>一般用于处理0概率的问题，比如在训练集中看不到, 但出现在测试集中的词。</p><h3 id="Language-modeling"><a href="#Language-modeling" class="headerlink" title="Language modeling"></a>Language modeling</h3><ul><li>What: To compute the probability of sentence /sequence of words P(w1, w2, w3…), or to predict upcomming words P(w|w1, w2, w3…)… a language model is also a probability model.</li><li>Why: the motivation is that probability is essential in identifying information in noisy, ambiguous inputs: speech recognition, machine translation, spelling correction…</li><li>How: rely on chain rule of probability, the products of a sequence of <strong>conditional</strong> probability.</li><li>Simplified by Markov Assumption: approximate the conditional probability by only accounting several prefixes,<br><code>P(the| water is so transparent that) ≈ P(the| that)</code></li><li><a href="#evaluation-concepts-and-methods">Evaluation</a>: how good is the model</li></ul><h2 id="GENERATIVE-PROBABILISTIC-MODELS"><a href="#GENERATIVE-PROBABILISTIC-MODELS" class="headerlink" title="GENERATIVE PROBABILISTIC MODELS"></a>GENERATIVE PROBABILISTIC MODELS</h2><p>Generative(joint) models palce probabilities P(c,d) over both observed data d and the hidden variables c (generate the obersved data from hidden stuff).</p><h3 id="N-Gram-Language-Model"><a href="#N-Gram-Language-Model" class="headerlink" title="N-Gram Language Model"></a>N-Gram Language Model</h3><ul><li>Unigram P(w1,w2,w3..) ≈ P(w1)*P(w2)*P(w3)</li><li>Bigram P(wn| w1,w2,w3..) ≈ P(wn| wn-1)</li><li>Estimate probability by counting:<br><code>P(wi| prefixes) = count(prefixes, wi)/count(prefixes)</code></li><li>In practice, use log space to avoid underflow, and adding is faster than multiplying.</li><li>Insufficient:<ul><li>long-distance dependencies</li><li>N-grams only work well for word prediction if the test corpus looks like the training corpus.</li></ul></li><li>To deal with 0 probability, commonly use <a href="#kneser-ney-smoothing">Kneser-Ney smoothing</a>, for very large N-grams like web, use stupid backoff.</li></ul><h4 id="Add-alpha-smoothing"><a href="#Add-alpha-smoothing" class="headerlink" title="Add alpha smoothing"></a>Add alpha smoothing</h4><ul><li>Assign equal probability to all unseen events.</li><li>Applied in text classification, or domains where zeros probability is not common.</li></ul><h4 id="Backoff-smoothing"><a href="#Backoff-smoothing" class="headerlink" title="Backoff smoothing"></a>Backoff smoothing</h4><ul><li>Use information from lower order N-grams (shorter histories)</li><li>Back off to a lower-order N-gram if we have zero evidence for a higher-order interpolation N-gram.</li><li>Discount: In order for a backoff model to give a correct probability distribution, we have to discount the higher-order N-grams to save some probability mass for the lower order N-grams.</li></ul><h4 id="Interpolation-smoothing"><a href="#Interpolation-smoothing" class="headerlink" title="Interpolation smoothing"></a>Interpolation smoothing</h4><ul><li>Interpolation: mix the probability estimates from all the N-gram estimators, weighing and combining the trigram, bigram, and unigram counts</li><li>Simple interpolation: <code>P(w3|w1,w2)=1P(w3|w1,w2)+λ2P(w3|w2)+λ3P(w3)</code>, Σλ=1.</li><li>λ could be trianed/conditioned on training set/contest, choose λ that maximie the probability of held-out data</li></ul><h4 id="Kneser-Ney-smoothing"><a href="#Kneser-Ney-smoothing" class="headerlink" title="Kneser-Ney smoothing"></a>Kneser-Ney smoothing</h4><ul><li>Combine absolute discounting and interpolation: Extending interpolatation with an absolute discounting 0.75 for high order grams.</li><li>Use a better estimate for probabilities of lower-order unigrams, the continuation probability, P_continuatin(w) is how likely is w to appear as a novel continutaion.<ul><li>For each word w, count the number of bigram types it completes. Or count the number of word types seen to precede w.</li><li>Every bigram type was a novel continuation the first time it was seen.</li><li>normalized by the total number of word bigram types.</li></ul></li><li>To lower the probability of some fix bigram like “San Franscio”</li><li>For bigram, <code>Pkn(wi|wi-1)=max(count(wi-1,wi)-d, 0)/c(wi-1) +λ(wi-1)P_continuatin(wi), λ(wi-1) = d{w:count(wi-1,w)&gt;0}/c(wi-1)</code>, where {w:count(wi-1,w)&gt;0} is the number of word types that can follow wi-1, also is the # of word types we discounted, also is the # of times we applied normalized discount.</li><li>For general N-gram, <img src="/images/kneser-ney.png" alt=""></li></ul><h3 id="Naive-Bayes-classifier"><a href="#Naive-Bayes-classifier" class="headerlink" title="Naive Bayes classifier"></a>Naive Bayes classifier</h3><ul><li>Application: <a href="#text-classification">Text classification</a>, to classify a text, we calculate each class probability given the test sequence, and choose the biggest one.</li><li>Evaluation: <a href="#precision-recall-f-measure">precision, recall, F-measure</a></li><li>Strength and Weakness: 高效, 快速, 但对于组合性的短语词组, 当这些短语与其组成成分的字的意思不同时, NB的效果就不好了</li></ul><h3 id="Text-classification"><a href="#Text-classification" class="headerlink" title="Text classification"></a>Text classification</h3><p>Or text categorization, method is not limited to NB, see <a href="http://www.inf.ed.ac.uk/teaching/courses/anlp/labs/lab7.html" target="_blank" rel="noopener">lab7</a>.<br>Spam email, gender/authorship/language identification, sentiments analysis,(opinion extraction, subjectivity analysis)…</p><h4 id="Sentiments-analysis"><a href="#Sentiments-analysis" class="headerlink" title="Sentiments analysis"></a>Sentiments analysis</h4><ul><li>For sentiment(or other text classification), word occurrence may matter more than word frequency. Thus it often improves performance to clip the word counts in each document at 1.<ul><li>This variant binary NB is called binary multinominal naive Bayes or binary NB.</li><li>Remove duplicates in each data sample - bag of words representation, boolean features. Binarized seems to work better than full word counts.</li></ul></li><li>Deal with negation: <code>like, not like</code>, A very simple baseline that is commonly used in sentiment to deal with negation is during text normalization to prepend the prefix NOT_ to every word after a token of logical negation</li><li>Sentiment lexicons: lists of words that are preannotated with positive or negative sentiment. To deal with insufficient labeled training data. A common way to use lexicons in the classifier is to use as one feature the total<br>count of occurrences of any words in the positive lexicon, and as a second feature the total count of occurrences of words in the negative lexicon. Using just two features results in classifiers that are much less sparse to small amounts of training data, and may generalize better. See <a href="http://www.inf.ed.ac.uk/teaching/courses/anlp/labs/lab8.html" target="_blank" rel="noopener">lab8</a>.</li></ul><h4 id="Naive-Bayes-Assumptions"><a href="#Naive-Bayes-Assumptions" class="headerlink" title="Naive Bayes Assumptions"></a>Naive Bayes Assumptions</h4><ul><li>Bags of words: a set of unordered words/features with its frequency in the documents, their order was ignored.</li><li>Conditional independence: the probabilities P(w|C) are independence given the class, thus a sequence of words(w1,w2,w3…) probability coculd be estimate via prducts of each P(wi|C) by walking through every pisition of the sequence, noted that the orders in the sequnce does not matter.</li></ul><h4 id="NB-Training"><a href="#NB-Training" class="headerlink" title="NB Training"></a>NB Training</h4><ul><li>Each classes’ prior probability P(C) is the percentage of the classes in the training set.</li><li>For the test set, its probability as a class j, is the products of its sequence probability P(w1, w2, w3…|Cj) and P(Cj), normalized by the sequence probability P(w1, w2, w3…), which could be calculated by summing all P(w1, w2, w3…|Cj)*P(Cj).</li><li>The joint features probability P(w1, w2, w3…|C) of each class is calculated by naively multiplying each word’s MLE given that class.</li><li>In practice, to deal with 0 probability, we dun use MLE, instead we use add alpha smoothing.<ul><li>Why 0 probability matters? Because it makes the whole sequence probability P(w1, w2, w3…|C) 0, then all the other features as evidence for the class are eliminated too.</li><li>How: first extract all the vocabulary V in the training set.</li><li>Then, for each feature/word k, its add alpha smoothing probability estimation within a class j is (Njk + alpha)/(Nj+V*alpha).</li><li>This is not the actual probability, but just the numerator.</li></ul></li></ul><h4 id="Naive-bayes-relationship-to-language-modelling"><a href="#Naive-bayes-relationship-to-language-modelling" class="headerlink" title="Naive bayes relationship to language modelling"></a>Naive bayes relationship to language modelling</h4><ul><li>When using all of the words as features for naive bayes, then each class in naive bayes is a unigram languange model.</li><li>For each word, assign probability P(word|C),</li><li>For each sentence, assign probability P(S|C) = P(w1,w2,w3…|C)</li><li>Running multiple languange models(classes) to assign probabilities, and pick out the highest language model.</li></ul><h3 id="Hidden-Markov-Model"><a href="#Hidden-Markov-Model" class="headerlink" title="Hidden Markov Model"></a>Hidden Markov Model</h3><ul><li>What: The HMM is a probabilistic sequence model: given a sequence of units (words, letters, morphemes, sentences, whatever), they compute a probability distribution over possible sequences of labels and choose the best label sequence.</li><li>parameter λ: A Transition probability matrix, B Emission probability</li><li>Application: part-of-speech tagging, name entity recognition(NEr), parse tree, speech recognition</li><li>Hidden: these tags, trees or words is not observed(hidden)</li><li>The three fundamental problems of HMM:<ul><li>decoding: discover the best hidden state sequnce via <a href="#viterbi-algorithm">Viterbi algorithm</a></li><li>Probability of the observation: Given an HMM with know parameters λ and an observation sequence O, determine the likelihood P(O| λ) (a language model regardless of tags) via <a href="#forward-algorithm">Forward algorithm</a></li><li>Learning: Given only the observed sequence, learn the best(MLE) HMM parameters λ via <a href="#forward-backward-algorithm">forward-backward algorithm</a>, thus <a href="#hmm-training">training a HMM</a> is an unsupervised learning task.</li></ul></li></ul><h4 id="Part-of-speech-tagging"><a href="#Part-of-speech-tagging" class="headerlink" title="Part-of-speech tagging"></a>Part-of-speech tagging</h4><ul><li>Part-of-speech(POS), word classes, or syntactic categories, a description of eight parts-of-speech: noun, verb, adjective, adverb, pronoun, preposition, conjunction, interjection, and sometimes numeral, article or determiner.<ol><li>noun 名詞 (代號 n. )</li><li>pronoun 代名詞 (代號 pron. )</li><li>verb 動詞 (代號 v. )</li><li>adjective 形容詞 (代號 adj. )</li><li>adverb 副詞 (代號 adv. )</li><li>preposition 介系詞 (代號 prep. )</li><li>conjunction 連接詞 (代號 conj. )</li><li>interjection 感歎詞 (代號 int. )</li></ol></li><li>Motivation: Use model to find the best tag sequnce T for an untagged senetnce S: argmax P(T|S) -&gt; argmax P(S|T)*P(T), where P(T) is the  transition (prior) probabilities,  P(S|T) is the emission (likelihood) probabilities.</li><li>Parts-of-speech can be divided into two broad supercategories: <a href="#open-class-closed-class">closed class types and open class types</a></li><li>Search for the best tag sequnce: <a href="#viterbi-algorithm">Viterbi algorithm</a></li><li>evaluation: tag accuracy</li></ul><h5 id="Transition-probability-matrix"><a href="#Transition-probability-matrix" class="headerlink" title="Transition probability matrix"></a>Transition probability matrix</h5><ul><li>Tags or states</li><li>Each (i,j) represent the probability of moving from state i to j</li><li>When estimated from sequnces, should include beginning <s> and end<br></s> markers.</li><li>Tag transition probability matrix: the probability of tag i followed by j</li></ul><h5 id="Emission-probability"><a href="#Emission-probability" class="headerlink" title="Emission probability"></a>Emission probability</h5><ul><li>Also called observation likelihoods, each expressing the probability of an observation j being generated from a states i.</li><li>Word/symbol</li></ul><h5 id="Penn-Treebank"><a href="#Penn-Treebank" class="headerlink" title="Penn Treebank"></a>Penn Treebank</h5><p><img src="/images/Treebank.png" alt=""></p><h4 id="Viterbi-algorithm"><a href="#Viterbi-algorithm" class="headerlink" title="Viterbi algorithm"></a>Viterbi algorithm</h4><ul><li>Decoding task: the task of determining which sequence of variables is the underlying source of some sequence of observations.</li><li>Intuition: The probability of words w1 followed by w2 with tag/state i and j (i,j is index of all Tags), is the chain rule of the probability of i followed by j and the probability of i output wi P(w1|i) and P(w2 |j), then choose the maximum from all the possible i j. Then using chain rule to multiply the whole sequence of words.</li><li>The value of each cell Vt(j) is computed by recursively taking the most probable path that could lead us to this cell from left columns to right. See exampls in <a href="http://www.inf.ed.ac.uk/teaching/courses/anlp/labs/lab_solutions.html#Tutorial_2" target="_blank" rel="noopener">tutorial 2</a><br><img src="/images/viterbi.png" alt=""></li><li>Since HMM based on Markov Assumptions, so the present column Vt is only related with the nearby left column Vt-1.</li></ul><h4 id="Forward-algorithm"><a href="#Forward-algorithm" class="headerlink" title="Forward algorithm"></a>Forward algorithm</h4><ul><li>Compute the likelihood of a particular observation sequence.</li><li>Implementation is almost the same as Viterbi.</li><li>Yet Viterbi takes the max over the previous path probabilities whereas the forward algorithm takes the sum.</li></ul><h4 id="HMM-Training"><a href="#HMM-Training" class="headerlink" title="HMM Training"></a>HMM Training</h4><p>learning the parameters of an HMM</p><h5 id="Forward-backward-algorithm"><a href="#Forward-backward-algorithm" class="headerlink" title="Forward-backward algorithm"></a>Forward-backward algorithm</h5><ul><li>inputs: just the observed sequence</li><li>output: the converged λ(A,B).</li><li>For each interation k until λ converged:<ul><li>Compute expected counts using λ(k-1)</li><li>Set λ(k) using MLE on the expected counts.</li></ul></li></ul><h3 id="Context-free-grammar"><a href="#Context-free-grammar" class="headerlink" title="Context-free grammar"></a>Context-free grammar</h3><p>CFG(phrase-structure grammar) consists of a set of rules or productions, each of which expresses the ways that symbols of the language can be grouped and ordered toLexicon gether, and a lexicon of words and symbols.</p><h4 id="Probabilistic-Context-Free-Grammar"><a href="#Probabilistic-Context-Free-Grammar" class="headerlink" title="Probabilistic Context-Free Grammar"></a>Probabilistic Context-Free Grammar</h4><p>PCFG(Stochastic Context-Free Grammar SCFG (SCFG)), a probabilistic augmentation of context-free grammars in which each rule is associated with a probability.</p><ul><li>G = (T,N,S,R,P)<ul><li>T, N: Terminal and Non-terminal</li><li>S: starts symbol</li><li>R: Derive rule/grammar, N -&gt; N/C</li><li>P: a probability function, for a given N, ΣP(N-&gt;Ni/Ci)=1. Normally P(S-&gt;NP VP)=1, because this is the only rule for S.</li></ul></li><li>PCFG could generates a sentence/tree,<ul><li>thus it is a language model, assigns a probability to the string of words constituting a sentence</li><li>The probability of a tree t is the product of the probabilities of the rules used to generate it.</li><li>The probability of the string s is the sum of the probabilities of the trees/parses which have that string as their yield.</li><li>The probability of an ambiguous sentence is the sum of the probabilities of all the parse trees for the sentence.</li></ul></li><li>Application: Probabilistic parsing</li><li>Shortage: lack the lexicalization of a trigram model, i.e only a small fraction of the rules contains information about words. To solve this problem, use <a href="#lexicalization-of-pcfgs">lexicalized PCFGs</a></li></ul><h4 id="Lexicalization-of-PCFGs"><a href="#Lexicalization-of-PCFGs" class="headerlink" title="Lexicalization of PCFGs"></a>Lexicalization of PCFGs</h4><ul><li>The head word of phrase gives a good representation of the phrase’s structure and meaning</li><li>Puts the properties of words back into a PCFG</li><li>Word to word affinities are useful for certain ambiguities, because we know the probability of rule with words and words now, e.g. PP attachment ambiguity</li></ul><h4 id="Recursive-Descent-Parsing"><a href="#Recursive-Descent-Parsing" class="headerlink" title="Recursive Descent Parsing"></a>Recursive Descent Parsing</h4><ul><li>It is a top-down, depth-first parser:<ol><li>Blindly expand nonterminals until reaching a terminal (word).</li><li>If multiple options available, choose one but store current state<br>as a backtrack point (in a stack to ensure depth-first.)</li><li>If terminal matches next input word, continue; else, backtrack<br><img src="/images/Recursive_descent.png" alt=""></li></ol></li><li>can be massively inefficient (exponential in sentence length) if faced with local ambiguity</li><li>infinite loop</li></ul><h4 id="CKY-parsing"><a href="#CKY-parsing" class="headerlink" title="CKY parsing"></a>CKY parsing</h4><h5 id="Dynamic-programming"><a href="#Dynamic-programming" class="headerlink" title="Dynamic programming"></a>Dynamic programming</h5><h5 id="Well-formed-substring-table"><a href="#Well-formed-substring-table" class="headerlink" title="Well-formed substring table"></a>Well-formed substring table</h5><p>For parsing, subproblems are analyses of substrings, memoized in well-formed substring table(WFST, chart).</p><ul><li>Chart entries are indexed by start and end positions in the sentence, and correspond to:<ul><li>either a complete constituent (sub-tree) spanning those positions (if working bottom-up),</li><li>or a prediction about what complete constituent might be found (if working top-down).</li></ul></li><li>The chart is a matrix where cell [i, j] holds information about the word span from position i to position j:<ul><li>The root node of any constituent(s) spanning those words</li><li>Pointers to its sub-constituents</li><li>(Depending on parsing method,) predictions about what<br>constituents might follow the substring.</li></ul></li></ul><h5 id="Probability-CKY-parsing"><a href="#Probability-CKY-parsing" class="headerlink" title="Probability CKY parsing"></a>Probability CKY parsing</h5><p><img src="/images/CKY_proba1.png" alt=""><br><img src="/images/CKY_proba2.png" alt=""></p><h3 id="Noisy-channel-model"><a href="#Noisy-channel-model" class="headerlink" title="Noisy channel model:"></a>Noisy channel model:</h3><ul><li>The intuition of the noisy channel model is to treat the misspelled word as if a correctly spelled word had been “distorted” by being passed through a noisy communication channel.</li><li>a probability model using Bayesian inference, input -&gt; noisy/errorful encoding -&gt; output, see an observation x (a misspelled word) and our job is to find the word w that generated this misspelled word.</li><li><code>P(w|x) = P(x|w)\*P(w)/P(x)</code></li></ul><h4 id="Noisy-channel-model-of-spelling-using-naive-bayes"><a href="#Noisy-channel-model-of-spelling-using-naive-bayes" class="headerlink" title="Noisy channel model of spelling using naive bayes"></a>Noisy channel model of spelling using <a href="#nb-training">naive bayes</a></h4><ul><li>The noisy channel model is to maximize the product of likelihood(probability estimation) P(s|w) and the prior probability of correct words P(w). Intuitively it is modleing the noisy channel that turn a correct word ‘w’ to the misspelling.</li><li>The likelihood(probability estimation) P(s|w) is called the the channel/error model, telling if it was the word ‘w’, how likely it was to generate this exact error.</li><li>The P(w) is called the language model</li></ul><h2 id="DISCRIMINATIVE-PROBABILISTIC-MODELS"><a href="#DISCRIMINATIVE-PROBABILISTIC-MODELS" class="headerlink" title="DISCRIMINATIVE PROBABILISTIC MODELS"></a>DISCRIMINATIVE PROBABILISTIC MODELS</h2><p>Discriminative(conditional) models take the data as given, and put a probability over hidden structure given the data, P(c|d).</p><h3 id="Exponential-Log-linear-MaxEnt-Logistic-models"><a href="#Exponential-Log-linear-MaxEnt-Logistic-models" class="headerlink" title="Exponential (Log-linear, MaxEnt, Logistic) models"></a>Exponential (Log-linear, MaxEnt, Logistic) models</h3><p>Make probability model from the linear combination of weights λ and features f as votes, normalized by the total votes<img src="/images/softmax.png" alt="">.</p><ul><li>It is a probabilistic distribution: it estimates a probability for each class/label, aka Softmax.</li><li>It is a classifier, choose the highest probability label.</li><li>Application: dependency parsing actions prediction, text classification, <a href="#word-sense-disambiguation">Word sense disambiguation</a><br><img src="/images/discriminative.png" alt=""></li></ul><h4 id="Topics-categorization"><a href="#Topics-categorization" class="headerlink" title="Topics categorization"></a>Topics categorization</h4><h4 id="Training-discriminative-model"><a href="#Training-discriminative-model" class="headerlink" title="Training discriminative model"></a>Training discriminative model</h4><ul><li>Features in NLP are more general, they specify indicator function(a yes/no[0,1] boolean matching function) of properties of the input and each class.</li><li>Weights: low possibility features will associate with low/negative weight, vise versa.</li><li>Define features: Pick sets of data points d which are distinctive enough to deserve model parameters: related words, words contians #, words end with ing, etc.</li></ul><h4 id="Regularization-in-discriminative-model"><a href="#Regularization-in-discriminative-model" class="headerlink" title="Regularization in discriminative model"></a>Regularization in discriminative model</h4><p>The issue of scale:</p><ul><li>Lots of features</li><li>sparsity:<ul><li>easily overfitting: need smoothing</li><li>Many features seen in training never occur again in test</li></ul></li><li>Optimization problem: feature weights can be infinite, and iterative solvers can take a long time to get to those infinities. See <a href="http://www.inf.ed.ac.uk/teaching/courses/anlp/tutorials/anlp_t04-sol.pdf" target="_blank" rel="noopener">tutorial 4</a>.</li><li>Solution:<ul><li>Early stopping</li><li>Smooth the parameter via L2 regularization.</li><li>Smooth the data, like the add alpha smoothing, but hard to know what artificial data to create</li></ul></li></ul><h3 id="Generative-vs-Discriminative-Models"><a href="#Generative-vs-Discriminative-Models" class="headerlink" title="Generative vs. Discriminative Models"></a>Generative vs. Discriminative Models</h3><ul><li>Navie bayes models multi-count correlated evidence: each feature is multipled in, even when you have multiple features telling the same informaiton.</li><li>Maxent: solve this issue by weighting features so that model expectations match the observed(empirical) expectations.</li></ul><h2 id="Basic-Text-Processing"><a href="#Basic-Text-Processing" class="headerlink" title="Basic Text Processing"></a>Basic Text Processing</h2><h3 id="Regular-Expressions"><a href="#Regular-Expressions" class="headerlink" title="Regular Expressions"></a>Regular Expressions</h3><p>a language for specifying text search strings.</p><h3 id="Word-tokenization"><a href="#Word-tokenization" class="headerlink" title="Word tokenization"></a>Word tokenization</h3><p>NLP task needs to do text normalizaGon:</p><ol><li>Segmenting/tokenizing words in running text</li><li>Normalizing word formats</li><li>Segmenting sentences in running text</li></ol><p><code>they lay back on the San Francisco grass and looked at the stars and their</code></p><ul><li>Type: an element of the vocabulary.</li><li>Token: an instance of that type in the actual text.</li></ul><h2 id="LINGUISTIC-AND-REPRESENTATIONAL-CONCEPTS"><a href="#LINGUISTIC-AND-REPRESENTATIONAL-CONCEPTS" class="headerlink" title="LINGUISTIC AND REPRESENTATIONAL CONCEPTS"></a>LINGUISTIC AND REPRESENTATIONAL CONCEPTS</h2><h3 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h3><ul><li>Parsing is a combination of recognizing an input string and assigning a <strong>correct</strong> linguistic structure/tree to it based on a grammar.</li><li>The Syntactic, Statistical parsing are constituent-based representations(context-free grammars).</li><li>The Dependency Parsing are based on dependency structure(dependency grammars).</li></ul><h4 id="Syntactic-Parsing"><a href="#Syntactic-Parsing" class="headerlink" title="Syntactic Parsing"></a>Syntactic Parsing</h4><p>Syntactic parsing, is the task of recognizing a sentence and assigning a correct syntactic structure to it.</p><ul><li>Syntactic parsing can be viewed as a search<ul><li>search space: all possible trees generated by the grammar</li><li>search guided by the structure of the space and the input.</li><li>search direction<ul><li>top-down: start with root category (S), choose expansions, build down to words.</li><li>bottom-up: build subtrees over words, build up to S.</li></ul></li><li>Search algorithm/strategy: DFS, BFS, Recursive descent parsing, CKY Parsing</li></ul></li><li>Challenge: Structual <a href="#ambiguity">Ambiguity</a></li></ul><h4 id="Statistical-Parsing"><a href="#Statistical-Parsing" class="headerlink" title="Statistical Parsing"></a>Statistical Parsing</h4><p>Or probabilistic parsing, Build probabilistic models of syntactic knowledge and use some of this probabilistic knowledge to build efficient probabilistic parsers.</p><ul><li>motivation: to solve the problem of disambiguation</li><li>algorithm: <a href="#probability-cky-parsing">probability CKY parsing</a></li><li>evaluation: Compare the output <strong>constituency</strong> parser with golden standard tree, a constituent(part of the output parser) marked as correct if it spans the same sentence positions with the corresponding constituent in golder standard tree. Then we get the <a href="#precision-recall-f-measure">precision, recall and F1 measure</a>.<ul><li>constituency: S-(0:10), NP-(0:2), VP-(0:9)…</li><li>Precission = (# correct constituents)/(# in parser output), recall = (# correct constituents)/(# in gold standard)</li><li>Not a good evaluation, because it higher order constituent is marked wrong simply it contains a lower level wrong constituent.</li></ul></li></ul><h4 id="Dependency-Parsing"><a href="#Dependency-Parsing" class="headerlink" title="Dependency Parsing"></a><a href="#dependency-parsing">Dependency Parsing</a></h4><h3 id="Constituency"><a href="#Constituency" class="headerlink" title="Constituency"></a>Constituency</h3><p>Phrase structure, organizes words into nested constituents. Groups of words behaving as a single units, or constituents.</p><ul><li>Noun phrase(NP), a sequence of words surrounding at least one noun. While the whole noun phrase can occur before a verb, this is not true of each of the individual words that make up a noun phrase</li><li>Preposed or Postposed constructions. While the entire phrase can be placed differently, the individual words making up the phrase cannot be.</li><li>Fallback: In languages with free word order, phrase structure<br>(constituency) grammars don’t make as much sense.</li><li>Headed phrase structure: many phrase has head, VP-&gt;VB, NP-&gt;NN, the other symbols excepct the head is modifyer.</li></ul><h3 id="Dependency-syntax"><a href="#Dependency-syntax" class="headerlink" title="Dependency syntax"></a>Dependency syntax</h3><p>Dependency structure shows which words depend on (modify or are arguments of) which other words.</p><ul><li>A fully lexicalized formalism without phrasal constituents and phrase-structure rules: binary, asymmetric grammatical relations between words.</li><li>More specific, head-dependent relations, with edges point from heads to their dependents.</li><li>Motivation: In languages with free word order, phrase structure (constituency) grammars don’t make as much sense. E.g. we may need both S → NP VP and S → VP NP, but could not tell too much information simply looking at the rule.</li><li>Dependencies: Identifies syntactic relations directly. The syntactic structure of a sentence is described solely in terms of the words (or lemmas) in a sentence and an associated set of directed binary grammatical relations that hold among the words.</li><li>Relation between phrase structure and dependency structure<ul><li>Convert phrase structure annotations to dependencies via head rules. (Convenient if we already have a phrase structure treebank.): For a given lexicalized constituency parse(CFG tree), remove the phrasal categories, remove the (duplicated) terminals,  and collapse chains of duplicates.</li><li>The closure of dependencies give constituency from a dependency tree</li></ul></li></ul><p><img src="/images/Dependency_Relations.png" alt=""></p><h4 id="Dependency-parsing"><a href="#Dependency-parsing" class="headerlink" title="Dependency parsing"></a>Dependency parsing</h4><ul><li>Motivation: context-free parsing algorithms base their decisions on adjacency; in a dependency structure, a dependent need not be adjacent to its head (even if the structure is projective); we need new parsing algorithms to deal with non-adjacency (and with non-projectivity if present).</li><li>Approach: Transition-based dependency parsing</li></ul><h4 id="Transition-based-dependency-parsing"><a href="#Transition-based-dependency-parsing" class="headerlink" title="Transition-based dependency parsing"></a>Transition-based dependency parsing</h4><p>transition-based systems use supervised machine learning methods to train classifiers that play the role of the oracle. Given appropriate training data, these methods learn a function that maps from configurations to transition operators(actions).</p><ul><li>Bottom up</li><li>Like shift-reduce parsing, but the ‘reduce’ actions are specialized to create dependencies with head on left or right.</li><li>configuration：consists of a stack, an input buffer of words or tokens, and a set of relations/arcs, a set of actions.</li><li>How to choose the next action: each action is predicted by a <a href="#discriminative-probability-models">discriminative classifier</a>(often SVM, could be maxent) over each legal move.<ul><li>features: a sequence of the correct (configuration, action) pairs f(c ; x).</li></ul></li><li>Evaluation: accuracy (# correct dependencies with or ignore label)).</li></ul><h4 id="Dependency-tree"><a href="#Dependency-tree" class="headerlink" title="Dependency tree"></a>Dependency tree</h4><ul><li>Dependencies from a CFG tree using heads, must be projective: There must not be any crossing dependency arcs when the words are laid out in their linear order, with all arcs above the words.</li><li>But dependency theory normally does allow non-projective structures to account for displaced constituents.</li></ul><h4 id="Bounded-and-unbounded-dependencies"><a href="#Bounded-and-unbounded-dependencies" class="headerlink" title="Bounded and unbounded dependencies"></a>Bounded and unbounded dependencies</h4><p>Unbounded dependency could be considered as long distance dependency</p><ul><li>Long-distance dependencies: contained in wh-non-subject-question, “What flights do you have from Burbank to Tacoma Washington?”, the Wh-NP <code>what flights</code> is far away from the predicate that it is semantically related to, the main verb <code>have</code> in the VP.</li></ul><h3 id="Ambiguity"><a href="#Ambiguity" class="headerlink" title="Ambiguity"></a>Ambiguity</h3><h4 id="Structural-ambiguity"><a href="#Structural-ambiguity" class="headerlink" title="Structural ambiguity"></a>Structural ambiguity</h4><p>Occurs when the grammar can assign more than one parse to a sentence.</p><h5 id="Attachment-ambiguity"><a href="#Attachment-ambiguity" class="headerlink" title="Attachment ambiguity"></a>Attachment ambiguity</h5><p>A sentence has an attachment ambiguity if a particular constituent can be attached to the parse tree at more than one place.</p><h5 id="Coordination-ambiguity"><a href="#Coordination-ambiguity" class="headerlink" title="Coordination ambiguity"></a>Coordination ambiguity</h5><p>different sets of phrases can be conjoined by a conjunction like and. E.g <code>green egg and bread</code>.</p><ul><li>Coordination: The major phrase types discussed here can be conjoined with conjunctions like <code>and, or, and but</code> to form larger constructions of the same type.</li></ul><h4 id="Global-and-local-ambiguity"><a href="#Global-and-local-ambiguity" class="headerlink" title="Global and local ambiguity"></a>Global and local ambiguity</h4><ul><li>global ambiguity: multiple analyses for a full sentence, like <code>I saw the man with the telescope</code></li><li>local ambiguity: multiple analyses for parts of sentence.<ul><li><code>the dog bit the child</code>: first three words could be NP (but aren’t).</li><li>Building useless partial structures wastes time.</li></ul></li></ul><h3 id="Morphology"><a href="#Morphology" class="headerlink" title="Morphology"></a>Morphology</h3><blockquote><p>构词学（英语言学分科学名：morphology，“组织与形态”；morphology (/mɔːrˈfɒlədʒi/[1]) is the study of words, how they are formed, and their relationship to other words in the same language.<ref>），又称形态学，是语言学的一个分支，研究单词（word）的内部结构和其形成方式。如英语的dog、dogs和dog-catcher有相当的关系，英语使用者能够利用他们的背景知识来判断此关系，对他们来说，dog和dogs的关系就如同cat和cats，dog和dog-catcher就如同dish和dishwasher。构词学正是研究这种单字间组成的关系，并试着整理出其组成的规则。</ref></p></blockquote><h4 id="Challenge-of-rich-Morphology"><a href="#Challenge-of-rich-Morphology" class="headerlink" title="Challenge of rich Morphology"></a>Challenge of rich Morphology</h4><p>For a morphologically rich language, many issues would arise because of the morphological complexity.</p><ul><li>These productive word-formation processes result in a large vocabulary for these languages</li><li>Large vocabularies mean many unknown words, and these unknown words cause significant performance degradations in a wide variety of languages</li><li>For POS, augmentations become necessary when dealing with highly inflected or agglutinative languages with rich morphology like Czech, Hungarian and Turkish., part-of-speech taggers for morphologically rich languages need to label words with case and gender information. Tagsets for morphologically rich languages are therefore sequences of morphological tags rather than a<br>single primitive tag.</li><li>Dependency grammar is better than constituency in dealing with languages that are morphologically rich。</li></ul><h4 id="morphemes"><a href="#morphemes" class="headerlink" title="morphemes"></a>morphemes</h4><p>The way words are built up from smaller meaning-bearing units.</p><h4 id="Lemma"><a href="#Lemma" class="headerlink" title="Lemma"></a>Lemma</h4><ul><li>Lexeme, refers to the set of all the forms that have the same meaning,</li><li>lemma: refers to the particular form that is chosen by convention to represent the lexeme.</li><li>E.g: <code>run, runs, ran, running</code> are forms of the same lexeme, with run as the lemma.</li></ul><h4 id="Affixes"><a href="#Affixes" class="headerlink" title="Affixes"></a>Affixes</h4><p>Adding additional meanings of various kinds. “+ed, un+”</p><ul><li>suffix : follow the stem<ul><li>Plural of nouns ‘cat+s’</li></ul><ol start="2"><li>Comparative and superlative of adjectives ‘small+er’ </li><li>Formation of adverbs ‘great+ly’</li><li>Verb tenses ‘walk+ed’ </li><li>All inflectional morphology in English uses suffixes</li></ol></li><li>Prefix: precede the stem<ul><li>In English: these typically change the meaning </li></ul><ol start="2"><li>Adjectives ‘un+friendly’, ‘dis+interested’</li><li>Verbs ‘re+consider’</li><li>Some language use prefixing much more widely</li></ol></li><li>Infix: inserted inside the stem</li><li>Circumfix: do both(follow, precede)</li></ul><h4 id="Morphological-parsing"><a href="#Morphological-parsing" class="headerlink" title="Morphological parsing"></a>Morphological parsing</h4><p>Method: Finite-state transducers</p><h5 id="Finite-state-transducers"><a href="#Finite-state-transducers" class="headerlink" title="Finite-state transducers"></a>Finite-state transducers</h5><p>FST, a transducer maps between one representation and another; It is a kind of FSA which maps between two sets of symbols.</p><h4 id="Root"><a href="#Root" class="headerlink" title="Root"></a>Root</h4><ul><li>Root, stem and base are all terms used in the literature to designate that part of a word that remains when all affixes have been removed.</li><li>The root word is the primary lexical unit of a word, and of a word family (this root is then called the base word), which carries the most significant aspects of semantic content and cannot be reduced into smaller constituents.</li><li>E.g: In the form ‘untouchables’ the root is ‘touch’, to which first the suffix ‘-able’, then the prefix ‘un-‘ and finally the suffix ‘-s’ have been added. In a compound word like ‘wheelchair’ there are two roots, ‘wheel’ and ‘chair’.</li></ul><h4 id="Stem"><a href="#Stem" class="headerlink" title="Stem"></a>Stem</h4><ul><li>Stem is of concern only when dealing with inflectional morphology</li><li>Stemming: reduce terms to their stems in info retrieval,</li><li>E.g: In the form ‘untouchables’ the stem is ‘untouchable’, ‘touched’ -&gt; ‘touch’; ‘wheelchairs’ -&gt; ‘wheelchair’.</li></ul><h4 id="Inflectional-vs-Derivational-Morphology"><a href="#Inflectional-vs-Derivational-Morphology" class="headerlink" title="Inflectional vs. Derivational Morphology"></a>Inflectional vs. Derivational Morphology</h4><p>Inflectional<br>· nouns for count (plural: +s) and for possessive case (+’s)<br>· verbs for tense (+ed, +ing) and a special 3rd person singular present form (+s)<br>· adjectives in comparative (+er) and superlative (+est) forms.</p><p>Derivational<br>· Changing the part of speech, e.g. noun to verb: ‘word → wordify’<br>· Changing the verb back to a noun<br>· Nominalization: formation of new nouns, often verbs or adjectives</p><table><thead><tr><th>Inflectional</th><th>Derivational</th></tr></thead><tbody><tr><td>does not change basic meaning or part of speech</td><td>may change the part of speech or meaning of a word</td></tr><tr><td>expresses grammatical features or relations between words</td><td>not driven by syntactic relations outside the word</td></tr><tr><td>applies to all words of the same part of speech, inflection occurs at word edges: govern+ment+s, centr+al+ize+d</td><td>applies closer to the stem</td></tr></tbody></table><h3 id="Open-class-Closed-class"><a href="#Open-class-Closed-class" class="headerlink" title="Open-class Closed-class"></a>Open-class Closed-class</h3><p>Closed classes are those with relatively fixed membership</p><ul><li>prepositions: on, under, over, near, by, at, from, to, with</li><li>determiners: a, an, the</li><li>pronouns: she, who, I, others</li><li>conjunctions: and, but, or, as, if, when</li><li>auxiliary verbs: can, may, should, are</li><li>particles: up, down, on, off, in, out, at, by</li><li>numerals: one, two, three, first, second, third</li></ul><p>Open-class</p><ul><li>Nouns, verbs, adjectives, adverbs</li></ul><h3 id="Word-sense"><a href="#Word-sense" class="headerlink" title="Word sense"></a>Word sense</h3><p>A discrete representation of an aspect of a word’s meaning.<br>How: <a href="#distributional-semantic-models">Distributional semantic models</a></p><h4 id="Word-sense-disambiguation"><a href="#Word-sense-disambiguation" class="headerlink" title="Word sense disambiguation"></a>Word sense disambiguation</h4><p>WSD, The task of selecting the correct sense for a word, formulated as a classification task.</p><ul><li>Chose features: Directly neighboring words, content words, syntactically related words, topic of the text, part-of-speech tag, surrounding part-of-speech tags, etc …</li></ul><h4 id="Collocation"><a href="#Collocation" class="headerlink" title="Collocation"></a>Collocation</h4><p>A sequence of words or terms that co-occur more often than would be expected by chance.</p><h4 id="Lexical-semantic-relationships"><a href="#Lexical-semantic-relationships" class="headerlink" title="Lexical semantic relationships"></a>Lexical semantic relationships</h4><p>Relations between word senses</p><h5 id="synonym"><a href="#synonym" class="headerlink" title="synonym"></a>synonym</h5><p>代名词, When two senses of two different words (lemmas) are identical, or nearly identical, the two senses are synonyms. E.g. couch/sofa vomit/throw up filbert/hazelnut car/automobile</p><h5 id="hyponym"><a href="#hyponym" class="headerlink" title="hyponym"></a>hyponym</h5><p>下义词, One sense is a hyponym of another sense if the first sense is more specific, denoting a subclass of the other. E.g. car is a hyponym of vehicle; dog is a hyponym of animal, and mango is a hyponym of fruit.</p><h5 id="hypernym"><a href="#hypernym" class="headerlink" title="hypernym"></a>hypernym</h5><p>Superordinate, 上位词, vehicle is a hypernym of car, and animal is a hypernym of dog.</p><h5 id="similarity"><a href="#similarity" class="headerlink" title="similarity"></a>similarity</h5><p>Or distance, a looser metric than synonymy.<br>Two ways to measure similarity:</p><ul><li>Thesaurus词库-based: are words nearby in hypernym hierarchy? Do words have similar definitions?</li><li>Distributional: do words have similar distributional contexts</li></ul><h3 id="Distributional-semantic-models"><a href="#Distributional-semantic-models" class="headerlink" title="Distributional semantic models"></a>Distributional semantic models</h3><p>Vector semantics(embeddings): The meaning of a word is represented as a vector.</p><ul><li>Two words are similar if they have similar word contexts vector.</li><li>Term-context matrix(Co-occurrence    Matrices): a word/term is defined by a vector over counts of context words. The row represent words, columns contexts.<ul><li>Problem: simple frequency isn’t the best measure of association between words. One problem is that raw frequency is very skewed and not very discriminative. “the” and “of” are very frequent, but maybe not the most discriminative.</li><li>Sulution: use <a href="#pointwise-mutual-information">Pointwise mutual information</a>. Then the Co-occurrence    Matrices is filled with PPMI, instead of raw counts.</li></ul></li><li>Measuring vectors similarity based on PPMI:<ul><li>Dot product(inner product): More frequent words will have higher dot products, which cause similarity sensitive to word frequency.</li><li>Cosine: normalized dot product <img src="/images/cos.png" alt="Cosine">, Raw frequency or PPMI is non-negative, so cosine range [0,1].</li></ul></li><li>Evaluation of similarity<ul><li>Intrinsic: <a href="#correlation">correlation</a> between algorithm and human word similarity ratings.</li><li>Check if there is <a href="#correlation">correlation</a> between similarity measures and word frequency.</li></ul></li><li>Application: sentiment analysis, see <a href="http://www.inf.ed.ac.uk/teaching/courses/anlp/labs/lab8.html" target="_blank" rel="noopener">lab8</a></li></ul><h4 id="Pointwise-mutual-information"><a href="#Pointwise-mutual-information" class="headerlink" title="Pointwise mutual information"></a>Pointwise mutual information</h4><p>PMI: do events x and y co-occur more than if they were independent?</p><ul><li>PMI between two words: <img src="/images/PMI.png" alt="PMI"></li><li>Compute PMI on a term-context matrix(using counts):<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PMI(x, y) = log2( N·C(x, y)/C(x)C(y) )</span><br><span class="line">p(w=information,c=data)= 6/19</span><br><span class="line">p(w=information) = 11/19</span><br><span class="line">p(c=data) = 7/19</span><br><span class="line">PMI(information,data) = log2(6\*19/(11\*7))</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/PMI_counts.png" alt="PMI"></p><ul><li>PMI is biased towards infrequent events, solution:<ul><li>Add-one smoothing<h5 id="PPMI"><a href="#PPMI" class="headerlink" title="PPMI"></a>PPMI</h5>Positive PMI, could better handle low frequencies<br><code>PPMI = max(PMI,0)</code></li></ul></li></ul><h4 id="t-test"><a href="#t-test" class="headerlink" title="t-test"></a>t-test</h4><p>The t-test statistic, like PMI, can be used to measure how much<br>more frequent the association is than chance.</p><ul><li>The t-test statistic computes the difference between observed and expected means, normalized by the variance.</li><li>The higher the value of t, the greater the likelihood that we can reject the null hypothesis.</li><li>Null hypothesis: the two words are independent, and hence P(a,b) = P(a)P(b) correctly models the relationship between the two words.<br><img src="/images/t_test.png" alt="t-test"></li></ul><h4 id="Minimum-Edit-Distance"><a href="#Minimum-Edit-Distance" class="headerlink" title="Minimum Edit Distance"></a>Minimum Edit Distance</h4><p>the minimum number of editing operations (operations like insertion, deletion, substitution) needed to transform one string into another.<br>Algorithm: searching the shortest path, use Dynamic programming to avoid repeating, (use BFS to search the shortest path?)</p><h4 id="WordNet"><a href="#WordNet" class="headerlink" title="WordNet"></a><a href="http://wordnetweb.princeton.edu/perl/webwn" target="_blank" rel="noopener">WordNet</a></h4><p>A hierarchically organizesd lexical database, resource for English sense relations</p><ul><li>Synset: The set of near-synonyms for a WordNet sense (for synonym set)</li></ul><h3 id="Topic-modelling"><a href="#Topic-modelling" class="headerlink" title="Topic modelling"></a>Topic modelling</h3><p>Instead of using supervised topic classification – rather not fix topics in advance nor do manual annotation, Use clustering to teases out the topics. Only the number of topics is specified in advance.</p><ul><li>Latent Dirichlet allocation(LDA): each document may be viewed as a mixture of various topics where each document is generated by LDA.</li><li>A topic is a distribution over words</li><li>generate document:<ol><li>Randomly choose a distribution over topics</li><li>For each word in the document<ol><li>randomly choose a topic from the distribution over topics</li><li>randomly choose a word from the corresponding topic (distribution over the vocabulary)</li></ol></li></ol></li><li>training: repeat until converge<ol><li>assign each word in each document to one of T topics.</li><li>For each document d, go through each word w in d and for each topic t, compute: p(t|d), P(w|t)</li><li>Reassign w to a new topic, where we choose topic t with probability P(w|t)xP(t|d)</li></ol></li></ul><h3 id="Meaning-representation-language"><a href="#Meaning-representation-language" class="headerlink" title="Meaning representation language"></a>Meaning representation language</h3><p>The symbols in our meaning representations correspond to objects, properties, and relations in the world.</p><ul><li>Qualifications of MRL:<ul><li>Canonical form: sentences with the same (literal) meaning should have the same MR.</li><li>Compositional: The meaning of a complex expression is a function of the meaning of its parts and of the rules by which they are combined.</li><li>Verifiable: Can use the MR of a sentence to determine whether the sentence is true with respect to some given model of the world.</li><li>Unambiguous: an MR should have exactly one interpretation.</li><li>Inference: we should be able to verify sentences not only directly, but also by drawing conclusions based on the input MR and facts in the knowledge base.</li><li>Expressivity: the MRL should allow us to handle a wide range of meanings and express appropriate relationships between the words in a sentence.</li></ul></li><li>Good MRL: First-order Logic</li></ul><h4 id="First-order-Logic"><a href="#First-order-Logic" class="headerlink" title="First-order Logic"></a>First-order Logic</h4><p>FOL, Predicate logic, meets all of the MRL qualifications <strong>except compositionality</strong>.</p><ul><li>Expressions are constructed from terms:<ul><li>constant and variable symbols that represent entities</li><li>function symbols that allow us to indirectly specify entities</li><li>predicate symbols that represent properties of entities and relations between entities</li></ul></li><li>Terms can be combined into predicate-argument structures<ul><li>Logical connectives: ∨ - or, ∧ - and, ¬, ⇒</li><li>Quantifiers: ∀ (universal quantifier, i.e., “for all”), ∃ (existential<br>quantifier, i.e. “exists”)</li></ul></li><li>Predicates in FOL<ul><li>Predicates with multiple arguments represent relations between entities: member-of(UK, EU)</li><li>“/N” to indicate that a predicate takes N arguments: member-of/2</li></ul></li><li>Variables in FOL<ul><li>An expression consisting only of a predicate with a variable among its arguments is interpreted as a set: likes(x, Gim) is the set of entities that like Gim.</li><li>A predicate with a variable among its arguments only has a truth value if it is bound by a quantifier: ∀x.likes(x, Gim) has an interpretation as either true or false.</li><li>Universal Quantifier (∀): Cats are mammals has MR ∀x.cat(x) ⇒ mammal(x)</li><li>Existential Quantifier (∃): Used to express that a property/relation is true of some entity, without specifying which one: Marie owns a cat has MR ∃x.cat(x) ∧ owns(Marie,x)</li></ul></li></ul><h4 id="Lambda-λ-Expression"><a href="#Lambda-λ-Expression" class="headerlink" title="Lambda λ Expression"></a>Lambda λ Expression</h4><p>Extend FOL, to work with ‘partially constructed’ formula, <strong>Compositionality</strong>.</p><ul><li>E.g.： λx.sleep(x) is the function that takes an entity x to the FOL expression sleep(x). λx.sleep(x)(Marie) -&gt; sleep(Marie)</li><li>Verbal (event) MRs： <code>λz. λy. λx. Giving1(x,y,z) (book)(Mary)(John) -&gt; Giving1(John, Mary, book) -&gt; John gave Mary a book</code></li><li>Problem:<ul><li>fixed arguments</li><li>Requires separate <code>Giving</code> predicate for each syntactic subcategorisation frame(number/type/position of arguments).</li><li>Separate predicates have no logical relation: if <code>Giving3(a, b, c, d, e)</code> is true, what about <code>Giving2(a, b, c, d)</code> and <code>Giving1(a, b, c)</code>.</li></ul></li><li>Solution: Reification of events 事件具象化</li></ul><h4 id="Reification-of-events"><a href="#Reification-of-events" class="headerlink" title="Reification of events"></a>Reification of events</h4><p><code>John gave Mary a book -&gt; ∃e, z. Giving(e) ∧ Giver(e, John) ∧ Givee(e, Mary)∧ Given(e,z) ∧ Book(z)</code></p><ul><li>Reify: to “make real” or concrete, i.e., give events the same status as<br>entities.</li><li>In practice, introduce variables for events, which we can quantify over</li><li>Entailment relations: automatically gives us logical entailment relations between events<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[John gave Mary a book on Tuesday] -&gt; [John gave Mary a book]</span><br><span class="line">∃ e, z. Giving(e) ∧ Giver(e, John) ∧ Givee(e, Mary) ∧ Given(e,z) ∧ Book(z) ∧ Time(e, Tuesday)</span><br><span class="line">-&gt;</span><br><span class="line">∃ e, z. Giving(e) ∧ Giver(e, John) ∧ Givee(e, Mary) ∧ Given(e,z) ∧ Book(z)</span><br></pre></td></tr></table></figure></li></ul><h3 id="Semantic-Parsing"><a href="#Semantic-Parsing" class="headerlink" title="Semantic Parsing"></a>Semantic Parsing</h3><p>Aka semantic analysis. Systems for mapping from a text string to any logical form.</p><ul><li>Motivation: deriving a meaning representation from a sentence.</li><li>Application: question answering</li><li>Method: Syntax driven semantic analysis with semantic attachments</li></ul><h4 id="Syntax-Driven-Semantic-Analysis"><a href="#Syntax-Driven-Semantic-Analysis" class="headerlink" title="Syntax Driven Semantic Analysis"></a>Syntax Driven Semantic Analysis</h4><ul><li>Principle of compositionality: the construction of constituent meaning is derived from/composed of the meaning of the constituents/words within that constituent, guided by word order and syntactic relations.</li><li>Build up the MR by augmenting CFG rules with semantic composition rules. Add semantic attachments to CFG rules.</li><li>Problem: encounter invalide FOL for some (base-form) MR, need type-raise.</li><li>Training</li></ul><h4 id="Semantic-attachments"><a href="#Semantic-attachments" class="headerlink" title="Semantic attachments"></a>Semantic attachments</h4><p>E.g<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VP → Verb NP : &#123;Verb.sem(NP.sem)&#125;</span><br><span class="line">Verb.sem = λy. λx. ∃e. Serving(e) ∧ Server(e, x) ∧ Served(e, y)</span><br><span class="line">NP.sem = Meat</span><br><span class="line">-&gt;</span><br><span class="line">VP.sem = λy. λx. ∃e. Serving(e) ∧ Server(e, x) ∧ Served(e, y) (Meat)</span><br><span class="line">= λx. ∃e. Serving(e) ∧ Server(e, x) ∧ Served(e, Meat)</span><br></pre></td></tr></table></figure></p><p>The MR for VP, is computed by applying the MR function to VP’s children.</p><p>Complete the rule:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S → NP VP : &#123;VP.sem(NP.sem)&#125;</span><br><span class="line">VP.sem = λx. ∃e. Serving(e) ∧ Server(e, x) ∧ Served(e, Meat)</span><br><span class="line">NP.sem = AyCaramba</span><br><span class="line">-&gt;</span><br><span class="line">S.sem = λx. ∃e. Serving(e) ∧ Server(e, x) ∧ Served(e, Meat) (AyCa.)</span><br><span class="line">= ∃e. Serving(e) ∧ Server(e, AyCaramba) ∧ Served(e, Meat)</span><br></pre></td></tr></table></figure></p><h4 id="Lexical-semantics"><a href="#Lexical-semantics" class="headerlink" title="Lexical semantics"></a>Lexical semantics</h4><p>the meaning of individual words.</p><h2 id="EVALUATION-CONCEPTS-AND-METHODS"><a href="#EVALUATION-CONCEPTS-AND-METHODS" class="headerlink" title="EVALUATION CONCEPTS AND METHODS"></a>EVALUATION CONCEPTS AND METHODS</h2><h3 id="Instrinsic-vs-extrinsic-evaluation"><a href="#Instrinsic-vs-extrinsic-evaluation" class="headerlink" title="Instrinsic vs. extrinsic evaluation"></a>Instrinsic vs. extrinsic evaluation</h3><h4 id="Extrinsic"><a href="#Extrinsic" class="headerlink" title="Extrinsic"></a>Extrinsic</h4><p>Use something external to measure the model. End-to-end evaluation, the best way to evaluate the performance of a language model is to embed it in an application and measure how much the application improves.</p><ol><li>Put each model in a task: spelling corrector, speech recognizer, MT system</li><li>Run the task, get an accuracy for A and for B<ul><li>How many misspelled words corrected properly</li><li>How many words translated correctly</li></ul></li><li>Compare accuracy for A and B</li></ol><p>Unfortunately, running big NLP systems end-to-end is often very expensive.</p><h4 id="Intrinsic"><a href="#Intrinsic" class="headerlink" title="Intrinsic"></a>Intrinsic</h4><p>Measures independenly to any application. Train the parameters of both models on the training set, and then compare how well the two trained models fit the test set. Which means whichever model assigns a higher probability to the test set</p><h3 id="Perplexity"><a href="#Perplexity" class="headerlink" title="Perplexity"></a>Perplexity</h3><ul><li>It is intrinsic.</li><li>Intuition based on Shannon game:The best language model is one that best predicts an unseen test set(e.g. next word), gives the highest P(sentence) to the word that actually occurs.</li><li>Definition： Perplexity is the inverse probability of the test set, normalized by the number of words(lie between 0-1).</li><li><img src="/images/perplexity.png" alt="Use log probability"></li><li>So minimizing perplexity is the same as maximizing probability</li><li>Cannot divide 0, so use <a href="#smoothing">smoothing</a>.</li><li>Bad approximation: unless the test data looks just like the training data, so generally only useful in pilot experiments.</li></ul><h3 id="Human-evaluation"><a href="#Human-evaluation" class="headerlink" title="Human evaluation"></a>Human evaluation</h3><p>E.g to know whether the email is actually spam or not, i.e. the human-defined labels for each document that we are trying to<br>gold labels match. We will refer to these human labels as the <strong>gold labels</strong>.</p><h3 id="Precision-Recall-F-measure"><a href="#Precision-Recall-F-measure" class="headerlink" title="Precision, Recall, F-measure"></a>Precision, Recall, F-measure</h3><ul><li>To deal with unbalanced lables</li><li>Application: <a href="#text-classification">text classification</a>, parsing.</li><li>Evaluation in text classification: the 2 by 2 contingency table<img src="/images/Contingency.png" alt="contingency table">, golden lable is true or false, the classifier output is positive or negative.</li></ul><h4 id="Precision"><a href="#Precision" class="headerlink" title="Precision"></a>Precision</h4><p>% of positive items that are golden correct, from the view of classifier</p><h4 id="Recall"><a href="#Recall" class="headerlink" title="Recall"></a>Recall</h4><p>% of golden correct items that are positive, from the view of test set.</p><h4 id="F-measure"><a href="#F-measure" class="headerlink" title="F-measure"></a>F-measure</h4><ul><li>Motivation: there is tradeoff between precision and recall, so we need a combined meeasure that assesses the P/R tradeoff.</li><li>The b parameter differentially weights the importance of recall and precision, based perhaps on the needs of an application. Values of b &gt; 1 favor recall, while values of b &lt; 1 favor precision.</li><li>Balanced F1 measure with beta =1, F = 2PR/(P+R)</li></ul><h4 id="Confusion-matrix"><a href="#Confusion-matrix" class="headerlink" title="Confusion matrix"></a>Confusion matrix</h4><p>Recalled that confusion matrix’s row represent golden label, column represent the classifier’s output, to anwser the quesion：for any pair of classes(c1,c2), how many test sample from c1 were incorrectly assigned to c2&gt;</p><ul><li>Recall: Fraction of samples in c1 classified correctly, CM(c1,c1)/sum(CM(c1,:))</li><li>Precision: fraction of samples assigned c1 that are actually c1, CM(c1,c1)/sum(CM(:,c1))</li><li>Accuracy: sum of diagnal / all</li></ul><h3 id="Correlation"><a href="#Correlation" class="headerlink" title="Correlation"></a>Correlation</h3><p>When two sets of data are strongly linked together we say they have a High Correlation.<br>Correlation is Positive when the values increase together, and Correlation is Negative when one value decreases as the other increases.</p><ul><li>Pearson correlation: covariance of the two variables divided by the product of their standard deviations.<img src="/images/Pearson.png" alt="Pearson"></li><li>Spearman correlation: the Pearson correlation between the rank values of the two variables</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;References:&lt;br&gt;&lt;a href=&quot;http://www.inf.ed.ac.uk/teaching/courses/anlp/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Accelerated natural language processing&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.inf.ed.ac.uk/teaching/courses/anlp/review/review_ay17.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ANLP revision guide&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://web.stanford.edu/~jurafsky/NLPCourseraSlides.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christopher Manning&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Python" scheme="http://shukebeta.me/tags/Python/"/>
    
      <category term="UoE" scheme="http://shukebeta.me/tags/UoE/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 - Java | 11 测试 Testing - CS61B Berkeley - Josh Hug</title>
    <link href="http://shukebeta.me/NOTE-CS61B-data-structures-11-testing/"/>
    <id>http://shukebeta.me/NOTE-CS61B-data-structures-11-testing/</id>
    <published>2018-01-29T00:00:00.000Z</published>
    <updated>2018-06-29T19:35:04.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>如何知道自己的程序是否真的在工作？在现实世界中，程序员相信他们的代码，因为代码通过了他们自己编写的测试。常用的测试有 Ad Hoc Testing， Unit test 和 Integration Testing。</p><p>Ad Hoc Testing，是指没有计划和记录的软件测试，除非发现缺陷，不然一般只运行一次。</p><h3 id="Unit-test"><a href="#Unit-test" class="headerlink" title="Unit test"></a>Unit test</h3><p>程序可分解为单元（或程序中可测试的最小部分），Unit test 严格测试代码的每个单元，最终确保项目正确运行。<br>Unit test 好处：</p><ol><li>Unit test 保证良好的代码结构（每个 method “只打一份工”），帮助我们较好地解析任务，</li><li>允许我们考虑每个方法的所有边界情况，并单独测试它们。</li><li>让我们每次只专注于一个单元，进行测试，debug，对准确度有信心后，再进行下一个单元的开发。相比于一次性写完所有代码，再测试debug，Unit test 减少了 debugging 时间。<a id="more"></a>坏处：</li><li>测试也要花时间</li><li>测试本身也是有可能出错的，测试可能不全面，不规范，或者有bug</li><li>有些单元是依赖于其他单元的</li><li>Unit testing 无法保证各个模块的交互，无法保证整个系统作为一个整体是否正常工作。</li></ol><h3 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h3><p>JUnit是一个给Java做测试的框架，由Erich Gamma（Design Patterns）和Kent Beck（eXtreme Programming）编写。<br>JUnit使用Java的 reflection 功能（Java程序可以检查自己的代码）和注释。<br>JUnit允许我们：</p><ul><li>定义并执行测试和测试套件</li><li>使用测试作为规范的有效手段</li><li>使用测试来支持重构</li><li>将修改的代码集成到构建中<br>JUnit可用于多个IDE，例如BlueJ，JBuilder和Eclipse在一定程度上具有JUnit集成。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(&lt;expected&gt;, &lt;actual&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>assertEquals</code>测试一个变量的实际值是否等于它的期望值。<br>JUnit test 各个测试方法，必须是非静态的（JUnit的设计人员设计规定的）。</p><p>JUnit的术语</p><ul><li>Test runner：测试运行器， 运行测试和报告结果的软件。实现方式：集成到IDE中，独立GUI，命令行等</li><li>Test suite：测试套件是一组测试用例。</li><li>Test case：测试用例用于测试单个方法对特定输入集的响应。</li><li>Unit test：单元测试的单元，是代码中我们能够相对合理地测试的最小的元素，通常是单个类。</li></ul><p>常用的JUnit接口和方法<br><code>@Before</code>: Creates a test fixture by creating and initialising objects and values.</p><p><code>@After</code>: Releases any system resources used by the test fixture. Java usually does this for free, but files, network connections etc. might not get tidied up automatically.</p><p><code>@Test</code>：tests cases.</p><p><code>static void assertTrue(boolean test)</code>, <code>static void assertTrue(String message, boolean test)</code>, <code>static void assertFalse(boolean test)</code>, <code>static void assertFalse(String message, boolean test)</code></p><h3 id="Integration-Testing"><a href="#Integration-Testing" class="headerlink" title="Integration Testing"></a>Integration Testing</h3><p>鉴于 Unit testing 无法保证，有交互的多个模块，作为一个整体是否正常工作。<br>我们可能需要 integration testing，把各个模块合并，作为一个组合，进行测试（也可以把 Unit test 组合起来变成 integration testing）。</p><p>Integration testing 一般都比较麻烦，也不容易自动化，而且一般是在比较高的抽象层进行测试，可能会漏掉微小的错误。</p><p>当把所有模块都作为一个整体，也就是整个系统作为测试对象时，就是 system testing。</p><h3 id="Test-driven-development"><a href="#Test-driven-development" class="headerlink" title="Test driven development"></a>Test driven development</h3><p>TDD开发步骤：</p><ol><li>明确一项新功能需求。</li><li>为该功能编写 Unit test。</li><li>运行测试，<font color="red">按理应该无法通过测试</font>（因为还没写功能程序）。</li><li>编写通过实现该功能的代码，<font color="green">通过测试</font>。</li><li>可选：重构代码，使其更快，更整洁等等。</li></ol><p><img src="http://www.pathfindersolns.com/wp-content/uploads/2012/05/red-green-refactorFINAL2.png" alt="source from http://ryantablada.com/post/red-green-refactor---a-tdd-fairytale " title="image from: http://ryantablada.com/post/red-green-refactor---a-tdd-fairytale"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h2&gt;&lt;p&gt;如何知道自己的程序是否真的在工作？在现实世界中，程序员相信他们的代码，因为代码通过了他们自己编写的测试。常用的测试有 Ad Hoc Testing， Unit test 和 Integration Testing。&lt;/p&gt;
&lt;p&gt;Ad Hoc Testing，是指没有计划和记录的软件测试，除非发现缺陷，不然一般只运行一次。&lt;/p&gt;
&lt;h3 id=&quot;Unit-test&quot;&gt;&lt;a href=&quot;#Unit-test&quot; class=&quot;headerlink&quot; title=&quot;Unit test&quot;&gt;&lt;/a&gt;Unit test&lt;/h3&gt;&lt;p&gt;程序可分解为单元（或程序中可测试的最小部分），Unit test 严格测试代码的每个单元，最终确保项目正确运行。&lt;br&gt;Unit test 好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Unit test 保证良好的代码结构（每个 method “只打一份工”），帮助我们较好地解析任务，&lt;/li&gt;
&lt;li&gt;允许我们考虑每个方法的所有边界情况，并单独测试它们。&lt;/li&gt;
&lt;li&gt;让我们每次只专注于一个单元，进行测试，debug，对准确度有信心后，再进行下一个单元的开发。相比于一次性写完所有代码，再测试debug，Unit test 减少了 debugging 时间。
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="cs61b" scheme="http://shukebeta.me/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 - Java | 10 LinkedList 还是 ArrayList - CS61B Berkeley - Josh Hug</title>
    <link href="http://shukebeta.me/NOTE-CS61B-data-structures-10-java-which-list/"/>
    <id>http://shukebeta.me/NOTE-CS61B-data-structures-10-java-which-list/</id>
    <published>2018-01-28T00:00:00.000Z</published>
    <updated>2018-06-29T19:35:09.766Z</updated>
    
    <content type="html"><![CDATA[<p>Java 提供了 <code>ArrayList</code>, <code>ArrayDeque</code> 和 <code>LinkedList</code> 几个API.</p><p>队列 queue, 通俗的含义, 就是不能插队, 只能在末尾插入.</p><blockquote><p>双端队列 Double Ended Queue (Deque) 是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩<br>–<a href="http://www.cplusplus.com/reference/deque/deque/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/deque/deque/</a></p></blockquote><p>CS61b的<a href="http://sp18.datastructur.es/materials/proj/proj1a/proj1a" target="_blank" rel="noopener">project 1a</a>需要实现两种双端队列（array based 和 linkedklist based）.</p><p>不同的API, 在考虑什么时候应该用哪个时, 我们需要考虑它们的性能差异:</p><ul><li><strong>搜索/定位</strong>：与<code>LinkedList</code>相比，<code>ArrayList</code>搜索更快。 <code>ArrayList</code>的<code>get(int index)</code>性能是<code>O(1)</code>的，而LinkedList的性能是<code>O(n)</code>。因为<code>ArrayList</code>基于<code>array</code>数据结构，可以直接用 array index 定位元素。</li><li><strong>删除/插入</strong>：<code>LinkedList</code> 操作性能是<code>O(1)</code>，而<code>ArrayList</code>的性能从<code>O(n)</code>（删除/插入第一个元素）到<code>O(n)</code>（最后一个元素）都有可能。因为<code>LinkedList</code>的每个元素都包含两个指向其相邻前后元素的指针（地址），因此仅需要改变，被删节点的<code>prev</code>和<code>next</code>指针位置。而在<code>ArrayList</code>中，需要移动剩余元素，来重新填充<code>array</code>空间。</li><li><strong>内存开销</strong>：<code>LinkedList</code>的每个元素都有更多的内存开销(额外的指针), 而<code>ArrayLists</code>没有这个开销。但是，<code>ArrayLists</code>需要占用初始容量。一般<code>ArrayList</code>的默认初始容量非常小（Java 1.4 - 1.8使用10）。但是，往<code>ArrayLists</code>添加元素时， 它可能会适当地增大容量，所以如果添加了很多元素，则必须不断调整数组的大小，那样也可能会导致元素频繁挪动位置。</li></ul><p>综上所述：</p><ol><li>如果在应用中需要<strong>频繁插入和删除</strong>，那么选择<code>LinkedList</code>。</li><li>假如一开始，就知道后面要添加大量元素，那就使用较高的初始容量来构造<code>ArrayList</code>。</li><li>大部分用例中, 相比LinkedList, 人们更偏爱ArrayList以及ArrayDeque。如果你不确定应该选哪个, 那么就直接考虑ArrayList吧(参考 <a href="https://stackoverflow.com/questions/322715/when-to-use-linkedlist-over-arraylist)" target="_blank" rel="noopener">https://stackoverflow.com/questions/322715/when-to-use-linkedlist-over-arraylist)</a>.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 提供了 &lt;code&gt;ArrayList&lt;/code&gt;, &lt;code&gt;ArrayDeque&lt;/code&gt; 和 &lt;code&gt;LinkedList&lt;/code&gt; 几个API.&lt;/p&gt;
&lt;p&gt;队列 queue, 通俗的含义, 就是不能插队, 只能在末尾插入.&lt;/p&gt;
&lt;b
      
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="cs61b" scheme="http://shukebeta.me/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 - Java | 09 双向链表 Doubly Linked List - CS61B Berkeley - Josh Hug</title>
    <link href="http://shukebeta.me/NOTE-CS61B-data-structures-09-java-doubly-linked-list/"/>
    <id>http://shukebeta.me/NOTE-CS61B-data-structures-09-java-doubly-linked-list/</id>
    <published>2018-01-13T00:00:00.000Z</published>
    <updated>2018-06-29T19:35:13.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>Doubly Linked List</p><p>前面介绍过的单向链表有几个缺点. 第一个就是它的<code>addLast</code>操作非常慢。单向链表只有一个变量保存列表头的地址, 以及每个节点对后面节点的单向引用(链接). 对于很长的列表，<code>addLast</code>方法必须遍历整个列表, 直到找到列表末尾才能执行插入操作.<br><a id="more"></a><br>最直观的优化方案就是加个’车尾’<img src="/images/sllist_last_pointer.png" alt="" title="image from: https://joshhug.gitbooks.io/"> 这样我们就可以直接通过<code>last.next</code>引用末尾位置.</p><p>不过另一个问题并没有解决, 就是删除列表最后一项<code>removeLast</code>这个操作还是很慢。因为在目前的结构设计下, 我们需要先找到倒数第二项，然后将其下一个指针设置为<code>null</code>。而要找到倒数第二节点, 我们就得先找到倒数第三个节点…… 以此类推。也就是说，对于删除末尾的操作，还是要几乎遍历整个列表。</p><h3 id="反方向的链接"><a href="#反方向的链接" class="headerlink" title="反方向的链接"></a>反方向的链接</h3><p>基于前面单向链表构建双向链表, 一个比较有效的方法是额外为每个节点添加一个指向前面节点的链接 - 指针.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> OneNode prev; <span class="comment">//指向前</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">public</span> OneNode next; <span class="comment">//指向后</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>增加这些额外的指针会导致额外的代码复杂度, 以及额外的内存开销, 这就是追求时间效率的代价.</p><h3 id="Sentinel-与尾节点"><a href="#Sentinel-与尾节点" class="headerlink" title="Sentinel 与尾节点"></a>Sentinel 与尾节点</h3><p>双向链表的一个设计初衷，就是为了解决单向链表针对列表末尾位置的操作效率不高的问题，除了sentinel和反方向的链接还不够，我们还需要一个节点（指针）能够直接帮我们定位到列表末端。可以考虑添加一个的尾节点<code>last</code><img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_basic_size_0.png" alt="" title="image from: https://joshhug.gitbooks.io/"> <img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_basic_size_2.png" alt="" title="image from: https://joshhug.gitbooks.io/"> 这样的列表就可以支持<code>O(1)</code>复杂度的<code>addLast</code>,<code>getLast</code> 和 <code>removeLast</code>操作了。</p><h2 id="循环双端队列"><a href="#循环双端队列" class="headerlink" title="循环双端队列"></a>循环双端队列</h2><p>Circular double ended queue</p><p>上面的尾节点设计虽然没什么错误，但有点瑕疵：最后一个尾节点指针有时指向前哨节点，有时指向一个真正的节点。更好的方法是使双向链表首尾相连, 构成一个循环，即前后节点共享唯一的一个前哨节点。<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_0.png" alt="" title="image from: https://joshhug.gitbooks.io/"> <img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_2.png" alt="fig source https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_2.png" title="image from: https://joshhug.gitbooks.io/"><br>这样的设计相对更整洁，更美观(主观上的), sentinel的<code>prev</code>就指向列表最后一个节点, sentinel的<code>next</code>指向列表第一个节点.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDeque</span>&lt;<span class="title">GType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">OneNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> OneNode prev;</span><br><span class="line">        <span class="keyword">public</span> GType item;</span><br><span class="line">        <span class="keyword">public</span> OneNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OneNode</span><span class="params">(OneNode p, GType i, OneNode n)</span> </span>&#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            item = i;</span><br><span class="line">            next = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Sentinel’s forward link always points to the last element.<br>Sentinel’s backward link always points to the first element.</p><p>然后修改构造函数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Creates an empty deque. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedListDeque</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sentinel = <span class="keyword">new</span> OneNode(<span class="keyword">null</span>,<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    sentinel.prev = sentinel;</span><br><span class="line">    sentinel.next = sentinel;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Creates a deque with x  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedListDeque</span><span class="params">(GType x)</span></span>&#123;</span><br><span class="line">    sentinel = <span class="keyword">new</span> OneNode(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    sentinel.next = <span class="keyword">new</span> OneNode(sentinel, x, sentinel);</span><br><span class="line">    sentinel.prev = sentinel.next;</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果初始化的是空列表, 其实就是一个自己指向自己的<code>sentinel</code>节点. 如果是非空列表, 那么<code>sentinel</code>节点和真实的节点就构成了一个最简单的二元循环体.</p><h3 id="针对列表末尾位置的操作"><a href="#针对列表末尾位置的操作" class="headerlink" title="针对列表末尾位置的操作"></a>针对列表末尾位置的操作</h3><p>双端链表结构优雅，虽然某些操作如<code>addFirst</code>等编码复杂度会提高, 但不影响速度. 更重要的是, 相比单向链表, 它反而使得<code>addLast, moveLast</code>等方法的代码实现变得简单了, 而且还进一步提升了运行速度(<code>从O(n)到O(c)</code>).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Adds an item to the back of the Deque - O(c) */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(GType x)</span></span>&#123;</span><br><span class="line">    OneNode oldBackNode = sentinel.prev;</span><br><span class="line">    OneNode newNode = <span class="keyword">new</span> OneNode(oldBackNode, x, sentinel);</span><br><span class="line">    sentinel.prev = newNode;</span><br><span class="line">    oldBackNode.next = newNode;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes and returns the item at the front of the Deque.</span></span><br><span class="line"><span class="comment"> * If no such item exists, returns null.O(c). */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GType <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OneNode oldFrontNode = sentinel.next;</span><br><span class="line">    sentinel.next = oldFrontNode.next;</span><br><span class="line">    oldFrontNode.next.prev = sentinel;</span><br><span class="line">    size -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldFrontNode.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;双向链表&quot;&gt;&lt;a href=&quot;#双向链表&quot; class=&quot;headerlink&quot; title=&quot;双向链表&quot;&gt;&lt;/a&gt;双向链表&lt;/h2&gt;&lt;p&gt;Doubly Linked List&lt;/p&gt;
&lt;p&gt;前面介绍过的单向链表有几个缺点. 第一个就是它的&lt;code&gt;addLast&lt;/code&gt;操作非常慢。单向链表只有一个变量保存列表头的地址, 以及每个节点对后面节点的单向引用(链接). 对于很长的列表，&lt;code&gt;addLast&lt;/code&gt;方法必须遍历整个列表, 直到找到列表末尾才能执行插入操作.&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="cs61b" scheme="http://shukebeta.me/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构 - Java | 08 单向链表 Singly Linked List - CS61B Berkeley - Josh Hug</title>
    <link href="http://shukebeta.me/NOTE-CS61B-data-structures-08-java-singly-linked-list/"/>
    <id>http://shukebeta.me/NOTE-CS61B-data-structures-08-java-singly-linked-list/</id>
    <published>2018-01-12T00:00:00.000Z</published>
    <updated>2018-06-29T19:35:17.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>Linked List</p><p>前面有介绍以array为基础搭建的列表，支持自动扩容, 各种插入，删除速度都很快. 这里再介绍另一种方案, 链表, 也可以实现列表自动扩容.</p><h3 id="带链接的节点"><a href="#带链接的节点" class="headerlink" title="带链接的节点"></a>带链接的节点</h3><p>链表的核心组成是带链接的节点, 每个节点就像火车车厢, 有钩子连接下一节车厢.<img src="/images/408px-Singly-linked-list.png" alt=""><br><a id="more"></a><br>以int节点为例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">public</span> IntNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntNode</span><span class="params">(<span class="keyword">int</span> i, IntNode n)</span> </span>&#123;</span><br><span class="line">        item = i;</span><br><span class="line">        next = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>next</code>就是这个链接, 每一个节点就是其上一个节点的<code>next</code>.</p><h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>Nested static class</p><p>这个节点作为一个相对独立的数据结构, 我们更希望让他单独作为一个类来维护. 再另外创建一个名为<code>LinkedList</code>的class与用户进行交互. 这样还有另一个好处就是提供一个命名为<code>LinkedList</code>的类给用户交互，用户更直观地知道自己是在调用链表。如果直接与node类交互，用户可能会困扰. 但同时考虑到这个node类只有<code>LinkedList</code>会调用，所以我们可以把node类嵌套进<code>LinkedList</code>中，也就是嵌套类，在类中定义类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">XXX</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">OneNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> XXX item;</span><br><span class="line">        <span class="keyword">public</span> OneNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OneNode</span><span class="params">(XXX i, OneNode n)</span> </span>&#123;</span><br><span class="line">            item = i;</span><br><span class="line">            next = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OneNode first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(XXX x)</span> </span>&#123;</span><br><span class="line">        first = <span class="keyword">new</span> OneNode(x, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面是各种方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上定义使用了<a href="/NOTE-CS61B-data-structures-05-java-variable-types#通用数据类型">泛型</a>。声明<code>OneNode</code>实例<code>first</code>为私有变量, 是为了防止用户错误地摆弄链接指向，<code>private</code>和<code>public</code>的使用<a href="/NOTE-CS61B-data-structures-07-java-array-based-list#公共与私有">参考</a>.</p><h4 id="静态与非静态嵌套类"><a href="#静态与非静态嵌套类" class="headerlink" title="静态与非静态嵌套类"></a>静态与非静态嵌套类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticNestedClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果嵌套类不需要使用外部类的任何实例方法或变量，那可以声明嵌套类为static。像静态类方法一样， <strong>静态</strong>嵌套类不能直接引用其外部类中定义的<strong>实例</strong>变量或方法。外部类不能直接访问静态嵌套类的成员变量，要通过静态嵌套类来访问。</p><p><strong>非静态</strong>嵌套类一般叫做内部类 inner class，可以直接访问外部类的方法和变量。一个内部类的实例作为成员存在于其外部类的实例中。因为内部类与一个实例相关联，所以它不能自己定义任何静态成员。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> outVar;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> inVar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Outer O = <span class="keyword">new</span> Outer();</span><br><span class="line">    Outer.Inner I = O.new Inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>作为OuterClass的成员，嵌套类可以声明为private，public，protected或package private。外部类只能声明为public或package private。更多详情<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html" target="_blank" rel="noopener">参考官网</a>.</p><h3 id="补充必要的实例方法"><a href="#补充必要的实例方法" class="headerlink" title="补充必要的实例方法"></a>补充必要的实例方法</h3><p>插入的操作核心是改变链接指向， 比如原来是<code>A-&gt;B-&gt;D</code>, 要插入C, 则把<code>C.next</code>指向D,然后把<code>B.next</code>改为指向C, 变为<code>A-&gt;B-&gt;C-&gt;D</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">XXX</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">OneNode</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OneNode first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(XXX x)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="comment">/** 在列表开头插入 x. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(XXX x)</span> </span>&#123;</span><br><span class="line">        first = <span class="keyword">new</span> OneNode(x, first);</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 返回列表第一个元素. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XXX <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 在列表末尾插入 x. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(XXX x)</span> </span>&#123;</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        OneNode p = first;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 把 p 当做指针顺藤摸瓜一直挪到列表末尾. */</span></span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p.next = <span class="keyword">new</span> OneNode(x, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 删除列表末尾的元素. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//自行补充...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，如果用户不小心把某节点x指回自己<code>x.next=x</code>,那就会进入死循环，所以我们需要把<code>OnoNode</code>实例<code>first</code>声明为私有变量已提供必要的保护。</p><h3 id="超载"><a href="#超载" class="headerlink" title="超载"></a>超载</h3><p>Overloading</p><p>如果想初始化一个空列表, 可以:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 构造一个空列表. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fist = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即使原来已经有一个带参数x的构造器了, 这里再加一个同名构造器也没问题. 因为Java允许有不同参数的方法重名, 即超载 overloading.</p><h3 id="程序不变条件"><a href="#程序不变条件" class="headerlink" title="程序不变条件"></a>程序不变条件</h3><p>Invariants</p><p>上面超载了一个初始化空列表的构造器, 加入初始化一个空列表，然后直接调用<code>addLast</code>，程序会报错, 因为<code>null</code>没有<code>next</code>.</p><p>有几种修改方法, 比如用<code>if else</code>这种加特例的方法. 这个方案虽然可以能解决问题，但是应尽量避免加入特例代码。毕竟有特例就意味着增加了复杂度和额外的代码特例记忆需求, 而人记忆是有限的.</p><p>一个更简洁（尽管不太显而易见）的解决方案是修改数据结构本身，让所有<code>LinkedList</code>，维护起来都没有差别，即使是空的。如果把列表比做拉货的火车，那么货物就是列表承载的数据。一列火车如果只有车厢而没有车头（或者车尾）的话是没有意义的，因为没有动力。所以不管火车有没有拉货，有车厢还是没车厢，要称之为火车我们至少需要一个火车头，通过创建一个特殊节点 - 前哨节点 sentinel。前哨节点将保存一个值，具体数值我们不关心，它只是作为火车头，不装货。<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig22/three_item_sentenlized_SLList.png" alt="" title="image from: https://joshhug.gitbooks.io/"><br>所以我们要修改<code>LinkedList</code>为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第一个元素 （假如有的话）就是 sentinel.next. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">XXX</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">OneNode</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OneNode sentinel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造一个空列表. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> OneNode(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 构造一个初始元素为x的列表. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(XXX x)</span> </span>&#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> OneNode(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> OneNode(x, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于像<code>LinkedList</code>这样简单的数据结构来说，特例不多，我们也许可以hold住, 一旦后续遇到像树tree等更复杂的数据结构，控制特例数量就显得极为重要了。所以现在就要培养自己的这方面的习惯，保持程序不变条件成立。所谓 invariants 就是指数据结构任何情况下都是不会出错（除非程序有bug）.</p><p>具有前哨节点的<code>LinkedList</code>至少具有以下 invariants：</p><ul><li>列表默认存在前哨节点。</li><li>列表第一个元素（如果非空的话）总是在<code>sentinel.next.item</code>。</li><li>size变量始终是已添加的元素总数。</li></ul><p>不变条件使得代码的推敲变得更加容易，同时给程序员提供了能够确保代码正常工作的具体目标。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h2&gt;&lt;p&gt;Linked List&lt;/p&gt;
&lt;p&gt;前面有介绍以array为基础搭建的列表，支持自动扩容, 各种插入，删除速度都很快. 这里再介绍另一种方案, 链表, 也可以实现列表自动扩容.&lt;/p&gt;
&lt;h3 id=&quot;带链接的节点&quot;&gt;&lt;a href=&quot;#带链接的节点&quot; class=&quot;headerlink&quot; title=&quot;带链接的节点&quot;&gt;&lt;/a&gt;带链接的节点&lt;/h3&gt;&lt;p&gt;链表的核心组成是带链接的节点, 每个节点就像火车车厢, 有钩子连接下一节车厢.&lt;img src=&quot;/images/408px-Singly-linked-list.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="cs61b" scheme="http://shukebeta.me/tags/cs61b/"/>
    
  </entry>
  
</feed>
