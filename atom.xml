<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Computer Science &amp; AI</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shukebeta.me/"/>
  <updated>2019-01-01T10:43:51.580Z</updated>
  <id>http://shukebeta.me/</id>
  
  <author>
    <name>Cong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>概率图模型 - 朴素贝叶斯 - 隐马尔科夫 - 条件随机场 - 逻辑回归</title>
    <link href="http://shukebeta.me/NLP-HMM-CRF/"/>
    <id>http://shukebeta.me/NLP-HMM-CRF/</id>
    <published>2018-12-15T16:00:00.000Z</published>
    <updated>2019-01-01T10:43:51.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="词性标注（Part-of-Speech-Tagging）"><a href="#词性标注（Part-of-Speech-Tagging）" class="headerlink" title="词性标注（Part-of-Speech-Tagging）"></a>词性标注（Part-of-Speech-Tagging）</h2><p>POS任务是指根据观察得到的序列, 推断出对应的词性标注, 比如<code>Bob drank coffee at Starbucks</code>, 标注可能为<code>Bob (NOUN) drank (VERB) coffee (NOUN) at (PREPOSITION) Starbucks (NOUN)</code>.</p><p>除此之外, 还有命名实体识别, 以及其他涉及到需要根据观察序列推断隐含状态的问题, 都可以考虑用隐马尔可夫模型(Hidden Markov Model, HMM)或者条件随机场(conditional random fields, CRF)来处理.</p><a id="more"></a><h2 id="概率图模型"><a href="#概率图模型" class="headerlink" title="概率图模型"></a>概率图模型</h2><p>Graphical Models, 用图的形式表示随机变量之间条件依赖关系的概率模型，是概率论与图论的结合。图中的节点表示随机变量，缺少边表示条件独立假设。<br>G = (V, E). 其中 V: vertex, 顶点/节点, 表示随机变量. E: edge, 边/弧. 如果两个节点不存在边, 则二者条件独立.<br><img src="/images/probabilistic_graphical_models.png" alt="" title="image from: Probabilistic Graphical Models Principles and Techniques"><br>从图上可以看到, 贝叶斯网络(Bayesian Networks, BNs)是有向图, 每个节点的条件概率分布表示为<code>P(当前节点 | 父节点)</code>.</p><p>而马尔可夫网络则是无向图, 包含了一组具有马尔可夫性质的随机变量. 马尔可夫随机场(Markov Random Fields, MRF)是由参数$λ=(S, π, A)$表示, 其中S是状态的集合，π是初始状态的概率, A是状态间的转移概率。一阶马尔可夫链就是假设t时刻的状态只依赖于前一时刻的状态，与其他时刻的状态和观测无关。这个性质可以用于简化概率链的计算。使用类似性质作为假设的模型还有Bi-gram语言模型等.</p><h3 id="朴素贝叶斯分类器与隐马尔可夫模型"><a href="#朴素贝叶斯分类器与隐马尔可夫模型" class="headerlink" title="朴素贝叶斯分类器与隐马尔可夫模型"></a>朴素贝叶斯分类器与隐马尔可夫模型</h3><p>朴素贝叶斯分类器(NBs)假设条件独立性(朴素贝叶斯假设, Hand and Yu, 2001)：$p(x_i | y, x_j) = p(x_i | y)$, 在给定目标值 y 时，x的属性值之间相互条件独立。这样, 计算可以简化为 $$p(y | \overrightarrow{x}) \propto p(y, \overrightarrow{x}) = p(y) \prod_{i=1} p(x_i | y).$$</p><p>朴素贝叶斯模型只考虑了单个输出变量y。如果要为一个观察序列$\overrightarrow{x} =(x_1, …, x_n)$预测对应的分类序列$\overrightarrow{y} =（y_1, …, y_n)$ ，一个简单的序列模型可以表示为多个NBs的乘积。此时不考虑序列单个位置之间的相互依赖。$$p(\overrightarrow{y}, \overrightarrow{x}) = \prod^n_{i=1} p(y_i) p(x_i | y_i).$$<br>此时每个观察值$x_i$仅取决于对应序列位置的类变量$y_i$。由于这种独立性假设，从一个步骤到另一个步骤的转换概率不包括在该模型中。然而这种假设在实践中几乎不会符合，这导致这种模型的性能很有限。</p><p>因此，比较合理的假设是观测序列在连续相邻位置间的观测值存在依赖。要模拟这种依赖关系, 就要引入状态转移概率$p(y_i | y_{i-1})$, 由此引出著名的隐马尔可夫模型 Hidden Markov model, HMM, Rabiner (1989):<br>$$p(\overrightarrow{y}, \overrightarrow{x}) = \prod^n_{i=1} p(y_i | y_{i-1}) p(x_i | y_i).$$ $$p(\overrightarrow{x}) = \sum_{y\in \mathcal{Y}} \prod^n_{i=1} p(y_i | y_{i-1}) p(x_i | y_i).$$</p><p>HMM参数$λ = (Y, X, π, A, B)$ ，其中Y是隐状态（输出变量）的集合，X是观察值（输入）集合，π是初始状态的概率，A是状态转移概率矩阵$p(y_i | y_{i-1})$，B是输出观察值概率矩阵$p(x_i | y_{i})$。在POS任务中, X就是观察到的句子, Y就是待推导的标注序列, 因为词性待求的, 所以人们称之为<strong>隐含状态</strong>.</p><p>HMM的缺陷是其基于观察序列中的每个元素都相互条件独立的假设。即在任何时刻观察值仅仅与状态（即要标注的标签）有关。对于简单的数据集，这个假设倒是合理。但大多数现实世界中的真实观察序列是由多个相互作用的特征和观察序列中较长范围内的元素之间的依赖而形成的。而条件随机场(conditional random fiel, CRF)恰恰就弥补了这个缺陷.</p><h2 id="条件随机场"><a href="#条件随机场" class="headerlink" title="条件随机场"></a>条件随机场</h2><p>随机场, 可以看成是一组随机变量的集合（这组随机变量对应同一个样本空间）。当给每一个位置按照某种分布随机赋予一个值之后，其全体就叫做随机场。这些随机变量之间可能有依赖关系，一般来说，也只有当这些变<br>量之间有依赖关系的时候，我们将其单独拿出来看成一个随机场才有实际意义。</p><p>如果给定的MRF中每个随机变量下面还有观察值，我们要确定的是给定观察集合下，这个MRF的分布，也就是条件分布，那么这个MRF就称为 conditional random fields (CRF)。它的条件分布形式完全类似于MRF的分布形式，只不过多了一个观察集合X。所以, CRF本质上是给定了条件(观察值observations)集合的MRF</p><p>1.特征函数的选择: 特征函数的选取直接关系模型的性能。<br>2.参数估计: 从已经标注好的训练数据集学习条件随机场模型的参数，即各特征函数的权重向量λ。<br>3.模型推断: 在给定条件随机场模型参数λ下，预测出最可能的状态序列。</p><h3 id="CRF特征函数"><a href="#CRF特征函数" class="headerlink" title="CRF特征函数"></a>CRF特征函数</h3><p>在CRF中，首先需要定义特征函数. 特征函数的定义非常灵活, 可以是：</p><ol><li>一个句子 s</li><li>句子中单词的位置 i</li><li>当前单词的标签$l_i$</li><li>前一个单词的标签$l_{i-1}$ (如果仅限于相邻位置的单词, 那么就是 linear-chain CRF).</li><li>任意其他单词的标签$l_{j}$</li></ol><p>然后为每个特征函数$f_{j}$分配权重$\lambda_j$, 权重是从数据中学习而来. 对$j$个特征方程求和, 对序列每个位置$i$求和:<br>$$ score(l | s) = \sum_{j = 1}^m \sum_{i = 1}^n \lambda_j f_j(s, i, l_i, l_{i-1})$$<br>CRF的每个特征函数都是一个输入的函数, 对应的输出是一个实数值（只是0或1）。例如, 选择特征函数$f_1(s, i, l_i, l_{i-1}) = 1$, 当且仅当$l_i = ADVERB$, 且第i个单词以“<code>-ly</code>”结尾; 否则为0. 如果与此特征相关的权重$\lambda_j$很大且为正，那么这个特征等同于说模型倾向于把以<code>-ly</code>结尾的单词标记为ADVERB。</p><p>通过指数化和归一化把这些得分转换为概率值:<br>$$p(l | s) = \frac{exp[score(l|s)]}{\sum_{l^\prime} exp[score(l^\prime|s)]} = \frac{exp[\sum_{j = 1}^m \sum_{i = 1}^n \lambda_j f_j(s, i, l_i, l_{i-1})]}{\sum_{l’} exp[\sum_{j = 1}^m \sum_{i = 1}^n \lambda_j f_j(s, i, l^\prime_i, l^\prime_{i-1})]} $$</p><h3 id="CRF与HMM"><a href="#CRF与HMM" class="headerlink" title="CRF与HMM"></a>CRF与HMM</h3><p>只需要在CRF的对数线性形式中, 设置权重为对应HMM取对数后的二元转换和发射概率: $\log p(l,s) = \log p(l_0) + \sum_i \log p(l_i | l_{i-1}) + \sum_i \log p(w_i | l_i)$</p><ul><li>对于HMM的每个状态转换概率$p(l_i = y | l_{i-1} = x)$, CRF定义一组特征函数为$f_{x,y}(s, i, l_i, l_{i-1}) = 1$ 如果 $l_i = y$ 且 $l_{i-1} = x$, 为这些特征赋予权重$w_{x,y} = \log p(l_i = y | l_{i-1} = x)$</li><li>类似的, 对于HMM的每个发射概率$p(w_i = z | l_{i} = x)$, CRF定义一组特征函数为$g_{x,y}(s, i, l_i, l_{i-1}) = 1$ 如果 $w_i = z$ 且 $l_i = x$, 赋予权重$w_{x,z} = \log p(w_i = z | l_i = x)$.</li></ul><p>如此, CRF计算的分值$p(l|s)$就精确地正比于对应的HMM, 也就是说, 任意的HMM都可以由CRF表达出来.</p><p>CRF比HMM更强大, 更广泛</p><ol><li>CRF可以定义更广泛的特征函数：HMM受限于相邻位置的状态转换（二元转换）和发射概率函数，迫使每个单词仅依赖于当前标签，并且每个标签仅依赖于前一个标签。而CRF可以使用更多样的全局特征。例如，如果句子的结尾包含问号，则可以给给CRF模型增加一个特征函数，记录此时将句子的第一个单词标记为VERB的概率。这使得CRF可以使用长距离依赖的特征。</li><li>CRF可以有任意的权重值：HMM的概率值必须满足特定的约束， $0 &lt;= p(w_i | l_i) &lt;= 1, \sum_w p(w_i = w | l_1) = 1)$, 而CRF的权重值是不受限制的。</li></ol><p>CRF既具有判别式模型的优点，又考虑到长距离上下文标记间的转移概率，以序列化形式进行全局参数优化和解码的特点，解决了其他判别式模型(如MEMM)难以避免的标记偏见问题。</p><h3 id="CRF与Logistic-Regression"><a href="#CRF与Logistic-Regression" class="headerlink" title="CRF与Logistic Regression"></a>CRF与Logistic Regression</h3><p>CRF的概率计算与Logistic Regression (LR)的形式类似，<br>$$CRF: p(l | s) = \frac{exp[\sum_{j = 1}^m \sum_{i = 1}^n \lambda_j f_j(s, i, l_i, l_{i-1})]}{\sum_{l’} exp[\sum_{j = 1}^m \sum_{i = 1}^n \lambda_j f_j(s, i, l^\prime_i, l^\prime_{i-1})]} $$<br>$$LR: P(y|x) = \frac{\exp \bigg( \sum\limits_{i=1}^{N} w_{i} \cdot f_{i}(x,y) \bigg)} {\sum\limits_{y’ \in Y} \exp \bigg( \sum\limits_{i=1}^{N} w_{i} \cdot f_{i}(x,y’) \bigg)}$$<br>在LR中, $f_i(y, x)$是一个特征，$w_i$是与该特征相关的权重。提取的特征是二元特征，取值0或1，通常称为指示函数。这些特征中的每一个都由与输入$x$和分类$y$相关联的函数计算。</p><p>实际上，CRF基本上就是逻辑回归的序列化：与逻辑回归是用于分类的对数线性模型不同，CRF是标签序列的对数线性模型。</p><h3 id="CRF模型训练"><a href="#CRF模型训练" class="headerlink" title="CRF模型训练"></a>CRF模型训练</h3><p>如何通过数据训练CRF模型, 估计特征函数的权重? 利用极大似然估计（Maximum Likelihood Estimation，MLE)和梯度优化(gradient descent).</p><p>$\log p(l | s)$相对于参数$λ_i$的梯度为:$$\frac{\partial}{\partial w_j} \log p(l | s) = \sum_{j = 1}^m f_i(s, j, l_j, l_{j-1}) - \sum_{l’} p(l’ | s) \sum_{j = 1}^m f_i(s, j, l^\prime_j, l^\prime_{j-1})$$<br>导数的第一项是真实标签下的特征$f_i$的贡献，第二项是当前模型下特征$f_i$的期望贡献。</p><p>对于一堆训练样例（句子和相关的词性标签）。随机初始化CRF模型的权重。要将这些随机初始化的权重转移到正确的权重，对于每个训练示例:</p><ul><li>遍历每个特征函数$f_i$，计算训练示例相对于$λ_i$的对数概率的梯度</li><li>以learning rate $\alpha$的速率沿梯度方向不断修正$λ_i$: $\lambda_i = \lambda_i + \alpha [\sum_{j = 1}^m f_i(s, j, l_j, l_{j-1}) - \sum_{l’} p(l’ | s) \sum_{j = 1}^m f_i(s, j, l^\prime_j, l^\prime_{j-1})]$</li><li>重复这些训练步骤，直到满足停止条件（例如，更新低于某个阈值）。</li></ul><p>CRF的缺点是模型训练时收敛速度比较慢.</p><p>训练后的CRF模型, 可以用于预测一个未标记序列的最大可能标记. 我们需要每个标记的概率$p(l | s)$, 对于大小为k的标签集和长度为m的句子, 需要比较的$p(l | s)$组合有$k^m$种. 但是计算时, 可以利用动态规划的方法, 原理类似于Viterbi算法.</p><h3 id="CRF中文命名实体识别"><a href="#CRF中文命名实体识别" class="headerlink" title="CRF中文命名实体识别"></a>CRF中文命名实体识别</h3><p>比如中文命名实体识别任务, 假如需要判断人名、地名、组织名三类命名实体.</p><p>对于人名, 通过一些模板来筛选特征。模板是对上下文的特定位置和特定信息的考虑, 适用于人名的特征模板:</p><ul><li>人名的指界词：主要包括称谓词、动词和副词等，句首位置和标点符号也可。根据指界词与人名共现的概率的大小，将人名的左右指界词各分为两级，生成4个人名指界词列表：<img src="/images/人名指界词.png" alt=""></li><li>人名识别特征的原子模板，每个模板都只考虑了一种因素：<img src="/images/人名识别特征原子模板.png" alt=""></li></ul><p>当特征函数取特定值时，特征模板被实例化, 就可以得到具体的特征。比如当前词的前一个词 $w_{i-1}$ 在人名1级左指界词列表中出现, $f_i(x, y) = 1, if: PBW1(w_{i-1}) = true, y = PERSON$</p><p>类似的，做地名、组织名的特征提取和选择，并将其实例化，得到所有的特征函数。</p><p>评测指标:<br>召回 recall = $ \frac{正确识别的命名实体首部（尾部）的个数}{标准结果中命名实体首部（尾部）的的总数} \times 100\%$</p><p>精确率 precision = $ \frac{正确识别的命名实体首部（尾部）的个数}{识别出的命名实体首部（尾部）的总数} \times 100\%$</p><p>F1 =  $ \frac{2 \times precision \times recall}{precision + recall}$</p><h2 id="生成式模型和判别式模型"><a href="#生成式模型和判别式模型" class="headerlink" title="生成式模型和判别式模型"></a>生成式模型和判别式模型</h2><p>从朴素贝叶斯, 到HMM; 从Logistic Regression到CRF, 这些概率图模型有如下转换关系:<br><img src="/images/relationship_nbs_hmm_lr_crf.png" alt="" title="Diagram of the relationship between naive Bayes, logistic regression, HMMs, linear-chain CRFs, generative models, and general CRFs. image from: An Introduction to Conditional Random Fields, by Charles Sutton and Andrew McCallum"></p><p>而在朴素贝叶斯与Logistic Regression, 以及HMM和CRF之间, 又有生成式和判别式的区别.</p><ul><li>生成式模型描述标签向量y如何有概率地<strong>生成</strong>特征向量x, 即尝试构建x和y的联合分布$p(y, x)$, 典型的模型有HMM，贝叶斯模型，MRF。生成式模型</li><li>而判别模型直接描述如何根据特征向量x判断其标签y, 即尝试构建$p(y | x)$的条件概率分布, 典型模型如如LR, SVM，CRF，MEMM等.</li></ul><p>原则上，任何类型的模型都可以使用贝叶斯规则转换为另一种类型，但实际上这些方法是不同的. 生成模型和判别模型都描述了$p(y, x)$的概率分布，但努力的方向不同。生成模型，例如朴素贝叶斯分类器和HMM，是一类可以因式分解为$p(y, x) = p(y)p(x|y)$的联合分布, 也就是说，它们描述了如何为给定标签的特征采样或“生成”值。生成式模型从统计的角度表示数据的分布情况，能够反映同类数据本身的相似度，不关心判别边界。生成式模型的优点是:<br>• 实际上带的信息要比判别模型丰富， 研究单类问题比判别模型灵活性强<br>• 能更充分的利用先验知识<br>• 模型可以通过增量学习得到<br>缺点也很明显: • 学习过程比较复杂; • 在目标分类问题中准确度不高</p><p>而判别式模型, 比如 LR, 是一系列条件分布$p(y | x)$. 也就是说，分类规则是直接建模的。原则上，判别模型也可通过为输入提供边际分布$p(x)$来获得联合分布$p(y, x)$，但很少需要这样。条件分布$p(y | x)$不包括$p(x)$的信息，在分类任务中其实无论如何也用不到。其次，对$p(x)$建模的困难之处在于它通常包含很多建模难度较高的有高度依赖性的特征。判别式模型寻找不同类别之间的最优分类面，反映的是异类数据之间的差异。优点是:<br>• 分类边界更灵活，比使用纯概率方法或生产模型得到的更高级。<br>• 能清晰的分辨出多类或某一类与其他类之间的差异特征<br>• 在聚类、viewpoint changes, partial occlusion and scale variations中的效果较好<br>•适用于较多类别的识别<br>缺点是：• 不能反映训练数据本身的特性。• 能力有限，可以分类, 但无法把整个场景描述出来。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.echen.me/2012/01/03/introduction-to-conditional-random-fields/" target="_blank" rel="noopener">http://blog.echen.me/2012/01/03/introduction-to-conditional-random-fields/</a><br>Classical probabilistic models and conditional random fields<br><a href="http://homepages.inf.ed.ac.uk/csutton/publications/crftut-fnt.pdf" target="_blank" rel="noopener">An Introduction to Conditional Random Fields</a>, by Charles Sutton and Andrew McCallum</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;词性标注（Part-of-Speech-Tagging）&quot;&gt;&lt;a href=&quot;#词性标注（Part-of-Speech-Tagging）&quot; class=&quot;headerlink&quot; title=&quot;词性标注（Part-of-Speech-Tagging）&quot;&gt;&lt;/a&gt;词性标注（Part-of-Speech-Tagging）&lt;/h2&gt;&lt;p&gt;POS任务是指根据观察得到的序列, 推断出对应的词性标注, 比如&lt;code&gt;Bob drank coffee at Starbucks&lt;/code&gt;, 标注可能为&lt;code&gt;Bob (NOUN) drank (VERB) coffee (NOUN) at (PREPOSITION) Starbucks (NOUN)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;除此之外, 还有命名实体识别, 以及其他涉及到需要根据观察序列推断隐含状态的问题, 都可以考虑用隐马尔可夫模型(Hidden Markov Model, HMM)或者条件随机场(conditional random fields, CRF)来处理.&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>循环神经网络</title>
    <link href="http://shukebeta.me/NLP-recurrent-neural-networks/"/>
    <id>http://shukebeta.me/NLP-recurrent-neural-networks/</id>
    <published>2018-12-14T16:00:00.000Z</published>
    <updated>2019-01-01T06:46:51.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h2><p>当人类阅读时，会根据对之前单词的理解和记忆来辅助理解当前看到的每个单词。也就是人能够很好地处理语言的长距离依赖特性（long-term dependency）。在自然语言处理任务中，很多传统的模型无法做到这一点，比如前馈神经网络；而传统的n-gram模型固然可以通过把把n系数增大来捕捉长距离依赖，但带来的非常巨大的内存消耗。<br><a id="more"></a></p><p>循环神经网络（Recurrent Neural Networks, RNNs)可以看做是多个<strong>共享参数</strong>的前馈神经网络不断叠加的结果<br><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/RNN-unrolled.png" alt="" title="A recurrent neural network and the unfolding in time of the computation involved in its forward computation. &quot;image from: http://colah.github.io"></p><p>这里的核心是想办法解码历史信息, 即通过递归方程$s_i = R(x_i, s_{i−1})$让$s_i$解码序列$x_{1:n}$. 比如把所有历史信息累加就是一种非常简单粗暴的方式, 这样得到的是连续词袋模型(continuous-bag-of-words model)$s_i = R_{CBOW}(x_i, s_{i-1}) = x_i + s_{i−1}$, 虽然简单，但这种RNN其实忽略了数据的时序性质。</p><p>一般意义上的RNN是指Elman Network or Simple-RNN (S-RNN)(<code>Elman [1990]</code>), $s_i = R_{SRNN}(x_i, s_{i-1}) = g(x_iW^x + s_{i−1}W^s + b)$, 也就是把历史信息先进行线性变换(乘以矩阵), 再和bias加起来, 再通过一个非线性激活函数(tanh或ReLU). 添加了线性变换再进行非线性激活, 使网络对输入的顺序变得敏感。</p><p><img src="http://d3kbpzbmcynnmx.cloudfront.net/wp-content/uploads/2015/09/rnn.jpg" alt="" title="image from: Nature"><br>在使用时, 给定输入序列（单词序列或语音）得出输出序列的过程如下：</p><ul><li>把每个词$x_{t}$(以向量表示)逐个输入RNN</li><li>每一时间步$t$都有对应的隐含状态$s_t$，用于解码历史信息: $s_t = g(Ux_t + Ws_{t-1} + b)$.</li><li>每一时间步都可以有一个输出（虽然大部分应用只用到最后一时间步）$o(t)$： 例如，语言模型想要预测下一个单词，那么输出就是在词汇表上的概率分布向量，$o_t = softmax(Vs_t)$.</li><li>其中，各个时间步共享几个参数矩阵（$U, V, W$）</li></ul><p>In addition to the above normal many to many structure RNNs, there are other non-sequence input or output: Many to one, e.g. when predicting the sentiment of a sentence we may only care about the final output, not the sentiment after each word. One to many: Music generation.<br><img src="http://karpathy.github.io/assets/rnn/diags.jpeg" alt="" title="source from http://karpathy.github.io/2015/05/21/rnn-effectiveness/"></p><p>除了应用于语言模型, RNNs 还可以应用于<br>· tagging, e.g. part-of-speech tagging, named entity recognition (many to many RNNs)<br>· sentence classification, e.g. sentiment classification (many to one RNNs)<br>· generate text, e.g. speech recognition, machine translation, summarization</p><h3 id="RNNs-Backpropagation"><a href="#RNNs-Backpropagation" class="headerlink" title="RNNs Backpropagation"></a>RNNs Backpropagation</h3><p>Backpropagation Through Time (BPTT): Because the parameters are shared by all time steps in the network, the gradient at each output depends not only on the calculations of the current time step, but also the previous time steps.</p><p>RNNs trained with BPTT have difficulties learning long-term dependencies (e.g. dependencies between steps that are far apart) due to what is called the vanishing/exploding gradient problem.</p><h3 id="梯度消失与爆炸"><a href="#梯度消失与爆炸" class="headerlink" title="梯度消失与爆炸"></a>梯度消失与爆炸</h3><p>The Vanishing/Exploding Gradient problem。</p><p>RNNs shares the same matrix (w, u, etc.) at each time step during forward prop and backprop. 求导数时, 根据链式法则, loss对各参数的导数会转换为loss对输出y的导数, 乘以y对隐含层的导数, 乘以隐含层相对隐含层之间的导数, 再乘以隐含层对参数的导数.<img src="/images/vanish_gradient.png" alt=""></p><p>不同隐含层（举例如$h_t$和$h_k$）之间如果相隔太远, $h_t$对$h_k$的导数就变成多个jacobian矩阵的相乘， 对各个jacobian范数（norms）进行分析后，发现$h_t$对$h_k$的导数值在训练过程中会很快变得很极端（非常小或者非常大）。</p><p>Gradient作为传导误差以帮助系统纠正参数的关键角色，如果本身变得接近于<code>0</code>或者<code>nan</code>，那么我们就无法判断t和t+n的数据的依赖性（是没有依赖？还是因为vanish of gradient？还是因为参数设置错误？）。梯度衰减会直接降低模型学习长距离依赖关系的能力，给定一个时间序列，例如文本序列，循环神经网络较难捕捉两个时刻距离较大的文本元素（字或词）之间的依赖关系。</p><p>在使用RNN学习language model的时候，非常容易出现梯度爆炸，解决办法是使用 gradient clipping 梯度裁剪，就是通过把梯度映射到另一个大小的空间，以限制梯度范数的最大值<a href="https://arxiv.org/abs/1211.5063" target="_blank" rel="noopener">On the difficulty of training Recurrent Neural Networks</a>。</p><p>虽然梯度裁剪可以应对梯度爆炸，但无法解决梯度衰减的问题。一个缓解梯度衰减的方案是使用更好的参数初始化方案和激活函数（ReLUs）<a href="https://arxiv.org/abs/1504.00941" target="_blank" rel="noopener">A Simple Way to Initialize Recurrent Networks of Rectified Linear Units</a>.</p><p>不过更主流的解决梯度衰减的方案是使用更复杂的rnn隐含单元: Gated Recurrent Units (GRU) introduced by <a href="https://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation</a> and LSTMs.</p><h2 id="门控循环网络"><a href="#门控循环网络" class="headerlink" title="门控循环网络"></a>门控循环网络</h2><p>因为梯度消失的问题，RNN的解码能力是很有限的。S-RNN架构的一个明显缺陷是对历史信息的记忆是不受控制，在每一时间步的计算，读写整个记忆状态$s_t$。而门控循环网络，比如Long Short-Term Memory（LSTMs），Gated Recurring Unit（GRUs），使用<strong>门</strong>的概念，让网络拥有控制哪些信息需要记录, 哪些需要丢弃的能力。如何实现这种门呢? 考虑一种介于<code>[0, 1]</code>中间的因子, 让这种因子与各种状态信息相乘, 可以为每个状态信息独自训练一个因子, 也就是由简单的神经网络(非线性激活函数Sigmoid)来控制.</p><p>是否允许信息通过（打开）或不通过（关闭）取决于其门控单元内部Sigmoid激活层的点乘运算。Sigmoid函数值介于0和1之间，可用于描述允许通过单元格的信息量。</p><p>LSTM架构将状态向量$s_i$分成两半，其中一半被视为“记忆单元”$C$, 而另一半被视为一般的工作存储单元-隐含状态$h$。</p><p>1, LSTM用<strong>遗忘门</strong>来决定从前一时间步的记忆单元中丢弃哪些信息，控制当前记忆单元应该忘记多少来自前一步状态$h_{t-1}$的信息量，标记为<strong>遗忘信息</strong>。遗忘门由一个sigmoid层学习而来 <img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-f.png" alt="" title="image from: http://colah.github.io/posts/2015-08-Understanding-LSTMs/"></p><p>2, 用<strong>输入门</strong> Input gate (a sigmoid hidden layer) 来决定有多少新信息是值得储存的（当前时间步$t$）。输入门控制哪些信息需要更新. 再通过一个隐含层(tanh/relu)生成新的<strong>候选信息</strong>向量$\widetilde{C}_t$. <img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-i.png" alt="" title="image from: http://colah.github.io/posts/2015-08-Understanding-LSTMs/"></p><p>输入门和遗忘门一起，控制每一步的信息存储和改写, 将遗忘信息和候选信息组合在一起作为<strong>更新信息</strong>，作为当前时间步的新记忆单元，$C_{t}$.<img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-C.png" alt="" title="image from: http://colah.github.io/posts/2015-08-Understanding-LSTMs/"></p><p>3, 最后，用一个<strong>输出门</strong> Output gate (a sigmoid layer) 来控制多少记忆单元作为当前步的工作隐含状态$h_t$。先通过一个tanh激活层把当前记忆单元$C_t$推送为<code>[-1, 1]</code>之间的值, 再乘以输出门.<img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-o.png" alt="" title="image from: http://colah.github.io/posts/2015-08-Understanding-LSTMs/"></p><p>总的来说, LSTM有遗忘门, 输入门和输出门这<strong>三个门</strong>. 加上其中的更新信息, 形式上LSTM有<strong>四个神经网络</strong>, 输入都是上一步隐含状态和当前步的输入向量的.</p><h3 id="GRUs"><a href="#GRUs" class="headerlink" title="GRUs"></a>GRUs</h3><p>LSTMs有两种隐含状态, 但GRUs (<a href="http://arxiv.org/pdf/1406.1078v3.pdf" target="_blank" rel="noopener">Cho, et al. (2014)</a>)抛弃了这种设计, 只用一种隐含状态$h$. 这导致了一系列的变化.</p><p>GRUs首先根据当前的输入词向量和隐含状态计算<strong>更新门</strong>$z_t$和一个<strong>重置门</strong>$r_t$。重置门用于协助计算隐含层的更新信息$\widetilde{h}_t$. 输出的隐含状态$h_t$是由更新门$z_t$来控制.<img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-var-GRU.png" alt="" title="image from: http://colah.github.io/posts/2015-08-Understanding-LSTMs/"></p><p>LSTMs的遗忘门和输入门的合作核心是<strong>更新信息</strong>. 而GRUs将LSTMs的遗忘门和输入门合并成一个更新门, 抛弃了输出门的概念, 让更新门负责计算新的隐含状态. 这样GRUs内部总共只有两个门, 三个神经网络, 某种程度上简化了LSTMs模型。</p><p>GRU intuition</p><ul><li>重置门赋予了模型丢弃与未来无关的信息的能力。若重置门接近于0，则忽略之前的记忆，仅储存新加入的信息.</li><li>更新门控制过去的状态对现在的影响程度（即决定更新多少），如果接近于1，则 $h_t=z_t\cdot h_{t-1}$, 等同于把过去的信息完整复制到未来，相应地缓解梯度衰减。</li><li>短距离依赖的单元，过去的信息仅保留很短的时间，重置门一般很活跃，也就是数值在0和1之间频繁变动。</li><li>长距离依赖的单元，重置门较稳定（保留过去的记忆较长时间），而更新门较活跃。</li></ul><h3 id="不同RNNs变种的比较"><a href="#不同RNNs变种的比较" class="headerlink" title="不同RNNs变种的比较"></a>不同RNNs变种的比较</h3><p>Vanilla RNNs Execution:</p><ol><li>Read the whole register h</li><li>Update the whole register</li></ol><p>GRU Execution:</p><ol><li>Select a readable subset</li><li>Read the subset</li><li>Select a writable subset</li><li>Update the subset</li></ol><p><img src="/images/gru.vs.lstm.png" alt="" title="image from: http://web.stanford.edu/class/cs224n"></p><h3 id="门控循环神经网络的训练"><a href="#门控循环神经网络的训练" class="headerlink" title="门控循环神经网络的训练"></a>门控循环神经网络的训练</h3><ol><li>把参数矩阵初始化为正交</li><li>把遗忘门的bias初始化为1，默认不遗忘</li><li>别忘了梯度裁剪</li><li>注意dropout在RNNs中的应用不同于DNN和CNN</li></ol><h2 id="Bidirectional-RNNs"><a href="#Bidirectional-RNNs" class="headerlink" title="Bidirectional RNNs"></a>Bidirectional RNNs</h2><p>Bidirectional RNNs are based on the idea that the output at time t may not only depend on the previous elements in the sequence, but also future elements. They are just two RNNs stacked on top of each other. The output is then computed based on the hidden state of both RNNs.<br><img src="/images/bidirectional_rnn.png" alt="" title="image from: http://web.stanford.edu/class/cs224n"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>斯坦福cs224n <a href="http://web.stanford.edu/class/cs224n" target="_blank" rel="noopener">http://web.stanford.edu/class/cs224n</a></p><p><a href="http://colah.github.io" target="_blank" rel="noopener">http://colah.github.io</a></p><p>Neural Network Methods in Natural Language Processing, by Yoav Goldberg</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;循环神经网络&quot;&gt;&lt;a href=&quot;#循环神经网络&quot; class=&quot;headerlink&quot; title=&quot;循环神经网络&quot;&gt;&lt;/a&gt;循环神经网络&lt;/h2&gt;&lt;p&gt;当人类阅读时，会根据对之前单词的理解和记忆来辅助理解当前看到的每个单词。也就是人能够很好地处理语言的长距离依赖特性（long-term dependency）。在自然语言处理任务中，很多传统的模型无法做到这一点，比如前馈神经网络；而传统的n-gram模型固然可以通过把把n系数增大来捕捉长距离依赖，但带来的非常巨大的内存消耗。&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>语言模型</title>
    <link href="http://shukebeta.me/NLP-language-model/"/>
    <id>http://shukebeta.me/NLP-language-model/</id>
    <published>2018-11-11T16:00:00.000Z</published>
    <updated>2019-01-03T08:52:50.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h2><p>语言模型Language modeling（LM）最初是针对语音识别问题而开发的, 现在广泛用于其他NLP应用中, 比如机器翻译需要利用LM来给翻译出的句子打分.<br><a id="more"></a><br>假设我们有一个语料库 - 某种语言的句子的无限集合$\mathcal{V^+}$（这些句子是由有限的词$\mathcal{V}$组成的）。例如，我们可能从网上获得大量文本。给定了此语料库，我们想估计LM的参数。这些参数包含语料库中所有单词的有限集合$\mathcal{V}$, 以及句子的概率分布函数$p(x_1, x_2, …, x_n)$，必须满足</p><ol><li>For any $\langle x_1…x_n \rangle \in \mathcal{V^+}$, $p(x_1, x_2, …, x_n) ≥ 0$</li><li>$\sum_{\langle x_1…x_n \rangle \in \mathcal{V^+}}p(x_1, x_2, …, x_n) = 1$</li></ol><p>比如，当$\mathcal{V}$只有<code>cat, eat, fish</code>, 那么它组合成的句子按照人类的评价标准, 通顺程度从高到低是: <code>cat eat fish</code>, <code>fish eat cat</code>, <code>cat fish eat</code>, <code>eat cat fish</code>, <code>eat fish cat</code>, <code>fish cat eat</code>. 这些是可能出现的句子(还没出现的不代表未来不会出现), 从概率分布的角度看待, 这些句子的概率之和是<code>1</code>, 因为这三个词只能组成这几个句子. 而LM的意义就在于能够赋予<code>cat eat fish</code>最大的概率, 代替人来判断句子是否准确, 通俗的说是一个句子通顺打分机器.</p><p>广义的语言模型, 可以计算任何连续的单词或者任何其他序列数据（比如语音）出现的概率, 当然是以参数的训练样本的角度来看待。除了为每个词序列指定概率之外，语言模型还指定给定的单词（或单词序列）跟随前面的单词序列的似然概率。</p><p>语言模型本身即是一种概率模型. 概率模型是随机现象的数学表示，由样本空间，样本空间内的事件以及与每个事件相关的概率定义。目标是模拟一个事件发生的概率。</p><p>LM的任务就是为单词序列$w_{1:n}$分配概率$P(w_{1:n})$, 等同于给序列的每个位置预测可能出现的单词，给定前面的单词（作为条件），预测下一个单词出现的概率 <code>P(w|w1, w2, w3...)</code>。听起来有点像词性标注(Tagging)… 事实上最初为语言建模开发的参数估计技术也给词性标注做了不少贡献.</p><p>利用链式法则, $$P(w_{1:n}) = P(w_1)P(w_2|w_1)P(w_3|w_{1:2})P(w_4|w_{1:3})…P(w_n|w_{1:n-1}),$$ 最后一项基于<code>n-1</code>个词的条件概率计算难度非常大。为了简化LM参数的训练，利用<code>k</code>阶马尔可夫假设，声明序列的下一个词仅依赖于前<code>k</code>个词。如利用一阶马尔可夫假设得到<code>P(transparent | the water is so ) ≈ P(transparent | so)</code>.</p><p>使用马尔可夫假设简化前面的乘链:<br>$$\begin{align}<br>P(w_{1:n}) &amp;= \prod_{i=1}^n P(w_i | w_1, …, w_{i-1}) \\<br>&amp;\propto \prod_{i=1}^n P(w_i | w_{i-k}, …, w_{i-1}) \end{align}$$<br>在语料处理时，开头的句子前面需要相应的加上<code>k</code>个补丁符号<code>&lt;s&gt;</code>，才能计算第一个词的条件概率。LM也是一种生成模型, 一般是在句子末尾加上特殊符号<code>&lt;/s&gt;</code>表示句子结束, 以方便生成任务时判断句子的生成结束.</p><p>固然Markov假设对于任意<code>k</code>阶都是有偏差的（毕竟句子可以有任意长的依赖性），但仍可以使用较小的k建模出较强的LM，并且几十年来一直是语言建模的主要方法。</p><p>对于LM参数中每一项似然概率的估算，可以使用<strong>最大似然估计（MLE）</strong>：$P(w_{i}=m|w_{i-k:i-1}) = \frac{Count(w_{i-k:i})}{Count(w_{i-k:i-1})}$</p><p>这个就是经典的N-gram模型。</p><h2 id="N-Gram语言模型"><a href="#N-Gram语言模型" class="headerlink" title="N-Gram语言模型"></a>N-Gram语言模型</h2><p><code>N-Gram</code>语言模型是基于<code>N-1</code>阶马尔可夫假设且由MLE估算出的LM。<code>N-Gram</code>LM 预测下一个单词出现概率仅条件于前面的<code>(N-1)</code>个单词, 以<code>The students opened their books</code>为例:</p><ul><li><code>Bi-gram</code>: 统计$P(w_{i}=m|w_{i-1})$, <code>P(students | the)</code>, <code>P(opened | students)</code>, …, 属于<code>马尔可夫一阶模型</code>, 即当前<code>t</code>时间步的状态仅跟<code>t-1</code>相关.</li><li><code>Tri-gram</code>: <code>P(students | &lt;/s&gt; The)</code>, <code>P(opened | The students)</code>, <code>马尔可夫二阶模型</code></li><li><code>Four-gram</code>: 依此类推</li></ul><p>特殊的<code>Uni-gram</code>: 统计$P(w_i)$, <code>P(the)</code>, <code>P(students)</code>, …, 此时整个模型退化为词袋模型, 不再属于马尔可夫模型, 而是基于贝叶斯假设, 即各个单词是条件独立的. 所以一般<code>N-gram</code>是指<code>N&gt;1</code>的.</p><p>N-Gram模型因为使用MLE估算参数，缺点很明显：</p><ul><li>无法很好地解决NLP中的长距离依赖现象, 比如一般表现比较好的Trigram语言模型，没有考虑到两步之外的词</li><li>没有考虑词的相似性，泛化能力差。比如在训练集出现了<code>The cat is walking in the bedroom</code>,理论上应该泛化到给<code>A dog was running in a room</code>, 因为<code>dog</code>和<code>cat</code>(resp. “the” and “a”, “room” and “bedroom”, etc…)有类似的语义和语法定位.</li><li>N-gram只是在测试语料库与训练语料库比较相似时表现才比较好。否则基于训练语料训练出来的参数肯定无法很好地评估测试语料，就像人无法对其不认识的语言做任何语法句法上的评价。</li><li>稀疏问题1：大多数高阶Gram几乎不会出现，虽然<code>u v w</code>在训练语料中从来没有出现过, 但我们不能简单地把<code>P(w | u, v)</code>定义为0，因为语言是千变万化的，有些词组虽然少见但不代表不存在。句子的概率是由各个gram似然概率相乘而来，如果仅仅因为一个词组出现次数为0就导致整个句子概率变为0, 那显然是不合理的.</li><li>稀疏问题2：部分低阶gram没有出现过，低阶gram的次数作为MLE公式中分母变为0，那计算就没法进行下去了.</li><li>一般而言，N越高，模型表现越好，但是更大的N使稀疏问题变得更糟。通常人们不会取大于5的N。</li><li>需要存储所有可能的N-Gram，所以模型的大小是 <code>O(exp(n))</code>, 需要大量的内存，而其实大部分都是出现次数为0.</li></ul><h3 id="平滑"><a href="#平滑" class="headerlink" title="平滑"></a>平滑</h3><p>针对数据稀疏问题（0概率的问题）, 可以使用各种平滑处理（Smoothing）.</p><p>加一（Laplace）平滑：最简单的平滑法，为所有事件（不管有没出现过）的频次加一，这样保证了没有0概率事件出现。这种平滑效果很差，因为齐夫定律<code>Zipf&#39;s law</code>的关系</p><blockquote><p><code>Zipf&#39;s law</code>：在自然语言的语料库里，一个单词出现的频率与它在频率表里的排名成反比。</p></blockquote><p>会有很多长尾单词很少甚至几乎没有出现过, 所以在总数为1的概率池子里, 为了给这些长尾单词分配至少频次1的概率, 需要从真正出现的单词(所谓真实发生的事件)中分走很多概率.</p><p>因此可以给Laplace平滑加入控制因子，变为 Add alpha smoothing。更多平滑方案参考<a href="/UoE-anlp#平滑Smoothing">UoE-anlp</a></p><h2 id="语言模型评估方法"><a href="#语言模型评估方法" class="headerlink" title="语言模型评估方法"></a>语言模型评估方法</h2><p>既然LM是用于评估句子是否准确的模型，那么在评价LM好坏时，就要看它在测试集上的表现如何。给定测试集包含$m$个句子$x^{(1)}, x^{(2)}, …, x^{(m)}$, 各个句子的长度分别为$n_i$. LM给这些测试集句子评估的概率大小为$$\prod_{i=1}^m p(x^{(i)})$$ 这个数值越高，说明LM评估测试集句子的质量越好。<strong>注意, 测试集必须是完全没有参与模型训练, 且是在人类标准中是好的句子.</strong></p><p>但在实际使用中, 我们往往使用上面这个概率的一种变换 - <code>困惑度</code>（<code>Perplexity</code>）来评价LM的质量. 首先取整个测试语料库的对数概率除以测试语料库中的单词总数$M$: $$l = \frac{1}{M} \log_2 \prod_{i=1}^m p(x^{(i)}) = \frac{1}{M} \sum_{i=1}^m \log_2 p(x^{(i)})$$<br>然后得到<br>$$\begin{align}<br>Perplexity &amp;= 2^{-l} \\<br>&amp;= 2^{-\frac{1}{M} \sum_{i=1}^m \log_2 p(x^{(i)})}\\<br>\\<br>&amp;= t^{-1}<br>\end{align}$$<br>其中，$t = \sqrt[\leftroot{-2}\uproot{2}M]{\prod_{i=1}^m p(x^{(i)})}$, 作为测试集概率的几何平均. 例如，如果困惑等于100，则$t = 0.01$，表明几何平均值为0.01. 可以看到, Perplexity的值越小，语言模型建模测试集的能力就越好.</p><p>概率取对数转换可以避免数值下溢，可以把乘法转换为加法, 计算也更快.</p><p>困惑度为何就是一种好的衡量标准呢？对于任何一个任务，我们需要定义Baseline模型作为基准，如果后续有一个新的模型，但无法超过此baseline，那么我们认为这个新的模型是没有进步的。对于语言建模这一个任务，最无脑最简单的baseline，就是假设每一个位置的每个单词出现概率相等，这就是最大熵分布，即假设此baseline对这个任务一无所知，所有位置所有单词在它眼里都是没区别的(均匀分布)。如果词汇集(包含<code>&lt;/s&gt;</code>)大小为<code>N</code>, 那么$$P_{i \in T}(w_i | w_{1:i-1}) = \frac{1}{N},$$ 此时的困惑度等于<code>N</code>, 即在均匀概率分布模型下，困惑度等于词汇量的大小。显而易见任何一个有效模型的困惑度必须小于类别个数. 此时困惑度可以理解为模型的<strong>有效词汇量</strong>：例如，词汇量大小为10,000, 而模型的困惑度为120，那么这大致说明有效的词汇量只有大概120个。最佳情况下，模型总是把测试集的概率预测为 1, 此时困惑度为 1。最坏情况下，概率预测为 0, 此时困惑度为正无穷。Baseline模型总是预测所有类别的概率都相同, 此时困惑度为词汇量大小（类别个数）。</p><p>目前很多神经网络框架计算语言模型的损失函数都是用交叉熵损失函数并取对数,<br>要得到perplexity，只需要把这个loss取指数运算。</p><p>那么困惑度一般都是多大呢？Goodman (“A bit of progress in language modeling”, figure 2) 评估了在英语数据上的unigram，bigram和trigram语言模型，词汇量为50,000。Goodman的报告结果显示，trigram模型的困惑度约为74，bigram模型为137，unigram模型为955。相比于Baseline模型困惑度50,000，trigram模型显然有了巨大的改进，且比bigram和unigram模型也有很大的改进。而更强大的SOTA神经语言模型，可以在wikitext-2数据集上跑出40以下的困惑度。</p><h2 id="神经网络语言模型"><a href="#神经网络语言模型" class="headerlink" title="神经网络语言模型"></a>神经网络语言模型</h2><p>神经网络模型解决了传统语言模型的一些缺点：它们允许越来越长的距离依赖，而参数数量仅线性增加，它们减少了手动设计backoff顺序的需要，并且它们支持跨不同上下文的泛化。</p><p><code>Bengio et al. [2003]</code>提出的神经网络语言模型(NNLM, 确切的说是前馈神经网络语言模型), 把文本处理成n个k-gram词窗口$w_{i:i+k-1}$,  每个词转换为词镶嵌的形式$\mathcal{v}(w) \in \mathcal{R}^{d_w}$, 一整个窗口的词向量拼接为矩阵向量$x = [\mathcal{v}(w_0); …; \mathcal{v}(w_{k-1})]$, 作为输入数据输入到一个1到2层的感知机.</p><p>训练数据的处理一般这么操作, 每个句子的开头加上<code>&lt;s&gt;</code>, 末尾加上<code>&lt;/s&gt;</code>, 然后按照k大小的长度一段段截断成k-gram词窗口$w_{i:i+k-1}$. 每一段k-gram的词拼接为一个向量$x = (C(w_{i}), C(w_{i+1}), ···, C(w_{i+k-1}))$, 作为一个训练样本, 其末尾的下一个词$w_{i+k}$作为样本对应的预测标签$y_i = \mathcal{v}(w_{i+k})$. 训练时，以输出的词向量概率分布向量和对应正确标签的 one-hoc-vector 间的 cross-entropy loss 为损失函数.</p><p>神经网络的参数数量比传统的N-gram少，因为其每增加一个词，参数就多$d_w$, 也就是线性增加, 而N-gram是多项式增加速率. 并且NNLM的参数矩阵对所有输入都是共享的, 这进一步减少了参数量. 虽然如此, NNLM的训练时间还是比N-gram LM长.</p><p>神经网络语言模型的泛化能力更好，因为相似的词具有相似的特征向量，并且因为概率函数（模型参数）是这些特征值的平滑函数，所以特征的微小变化相应地引起概率的微小变化。</p><p>真正影响NNLM计算效率的是输出层的softmax计算, 因为训练样本的词汇量$\mathcal{V}$往往很大. 输出层的softmax需要与隐含层参数矩阵$W^2 \in \mathcal{R}^{d_{hid} \times \mathcal{V}}$进行昂贵的矩阵向量乘法, 然后进行$\mathcal{V}$次对数操作. 这部分计算占据了大部分运行时间，使得大词汇量的NNLM建模令人望而却步。</p><p>后续发展的NNLM普遍使用循环神经网络（RNN, LSTM）来代替简单的前馈神经网络。循环神经网络可以理解为多层前馈神经网络叠加, 但各神经网络隐含层的参数是共享的. 句子逐词输入循环神经网络, 也就是循环神经网络使用同样参数方程来处理每一个词, 因此循环神经网络的参数量比前馈神经网络更少. 使用循环神经网络作为LM模型时, 同样最后一层还是使用softmax输出层。不同的是输入不再局限于定长的kgram词窗口，LSTM理论上可以接受无限长序列, 但事实上LSTM的记忆能力也是有限的, 太长就会遗忘掉前面的信息.</p><h3 id="对大词汇量语言模型的尝试"><a href="#对大词汇量语言模型的尝试" class="headerlink" title="对大词汇量语言模型的尝试"></a>对大词汇量语言模型的尝试</h3><p>Hierarchical softmax [Morin and Bengio, 2005]</p><p>Self-normalizing aproaches, 比如 noise-contrastive estimation (NCE) <code>[Mnih and Teh, 2012, Vaswani et al., 2013]</code> 或者在训练目标函数中加入正则化项 <code>[Devlin et al., 2014]</code>.</p><p>有关处理大输出词汇表的这些和其他技术的良好评论和比较，请参阅 <code>Chen et al. [2016]</code>.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>class notes by Michael Collins: <a href="http://www.cs.columbia.edu/~mcollins/lm-spring2013.pdf" target="_blank" rel="noopener">http://www.cs.columbia.edu/~mcollins/lm-spring2013.pdf</a><br>Neural Network Methods in Natural Language Processing, by Yoav Goldberg</p><p>A Neural Probabilistic Language Model, Yoshua Bengio, 2003</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;语言模型&quot;&gt;&lt;a href=&quot;#语言模型&quot; class=&quot;headerlink&quot; title=&quot;语言模型&quot;&gt;&lt;/a&gt;语言模型&lt;/h2&gt;&lt;p&gt;语言模型Language modeling（LM）最初是针对语音识别问题而开发的, 现在广泛用于其他NLP应用中, 比如机器翻译需要利用LM来给翻译出的句子打分.&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>信息抽取</title>
    <link href="http://shukebeta.me/NLP-information-extraction/"/>
    <id>http://shukebeta.me/NLP-information-extraction/</id>
    <published>2018-11-10T16:00:00.000Z</published>
    <updated>2018-12-17T13:07:21.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息抽取"><a href="#信息抽取" class="headerlink" title="信息抽取"></a>信息抽取</h2><p>1997年MUC会议（MUC-7） 召开时，评测任务已经增加到5个：<br>① 场景模板（scenario template, ST）填充：定义了描述场景的模板及槽填充规范；<br>② 命名实体（named entity, NE）识别：识别出文本中出现的专有名称和有意义的数量短语， 并加以归类；<br>③ 共指（coreference, CR）关系确定：识别出给定文本中的参照表达（ referring expressions），并确定这些表达之间的共指关系；<br>④ 模板元素（template element, TE）填充：类似于人名和组织机构名识别，但是要求系统必须识别出实体的描述和名字，如果一个实体在文本中被提到了多次，使用了几种可能的描述和不同的名字形式，要求系统都要把它们识别出来，一个文本中的每个实体只有一个模板元素［Grishman and Sundheim, 1996］；<br>⑤ 模板关系（template relation, TR）：确定实体之间与特定领域无关的关系。<br><a id="more"></a></p><p>1999年起美国NIST组织了自动内容抽取（automatic content extraction, ACE）评测会议，旨在研究和<br>开发自动内容技术以支持对三种不同来源文本（普通文本、经语音识别后得到的文本、 由OCR识别得到的文本）的自动处理，以实现新闻语料中出现的实体、关系、事件等内容的自动抽取。评测任务设计:<br>实体检测与跟踪（entity detection and tracking, EDT）、数值检测与识别（value detection and recognition, VDR）、时间识别和规范化（time expression recognition and normalization, TERN）、关系检测与描述（relation detection and characterization, RDC）、事件检测与描述（event detection and characterization, EDC）和实体翻译（entity translation, ET）等。</p><h3 id="TF-IDF-关键词抽取"><a href="#TF-IDF-关键词抽取" class="headerlink" title="TF-IDF 关键词抽取"></a>TF-IDF 关键词抽取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba.analyse</span><br><span class="line">jieba.analyse.extract_tags(sentence, topK=<span class="number">20</span>, withWeight=<span class="keyword">False</span>, allowPOS=())</span><br></pre></td></tr></table></figure><p><code>sentence</code> 为待提取的文本<br><code>topK</code> 为返回几个 TF/IDF 权重最大的关键词，默认值为 <code>20</code><br><code>withWeight</code> 为是否一并返回关键词权重值，默认值为 <code>False</code><br><code>allowPOS</code> 仅包括指定词性的词，默认值为空，即不筛选. 如电商评论指定要形容词</p><p>关键词提取所使用逆向文件频率（IDF）文本语料库可以切换成自定义语料库的路径, 用法： <code>jieba.analyse.set_idf_path(file_name) # file_name为自定义语料库的路径</code><br>自定义语料库示例见 <a href="https://github.com/fxsjy/jieba/blob/master/extra_dict/idf.txt.big" target="_blank" rel="noopener">https://github.com/fxsjy/jieba/blob/master/extra_dict/idf.txt.big</a><br>用法示例见 <a href="https://github.com/fxsjy/jieba/blob/master/test/extract_tags_idfpath.py" target="_blank" rel="noopener">https://github.com/fxsjy/jieba/blob/master/test/extract_tags_idfpath.py</a></p><p>关键词提取所使用停止词（Stop Words）文本语料库可以切换成自定义语料库的路径, 用法： <code>jieba.analyse.set_stop_words(file_name) # file_name为自定义语料库的路径</code><br>自定义语料库示例见 <a href="https://github.com/fxsjy/jieba/blob/master/extra_dict/stop_words.txt" target="_blank" rel="noopener">https://github.com/fxsjy/jieba/blob/master/extra_dict/stop_words.txt</a><br>用法示例见 <a href="https://github.com/fxsjy/jieba/blob/master/test/extract_tags_stop_words.py" target="_blank" rel="noopener">https://github.com/fxsjy/jieba/blob/master/test/extract_tags_stop_words.py</a></p><p>关键词一并返回关键词权重值 <a href="https://github.com/fxsjy/jieba/blob/master/test/extract_tags_with_weight.py" target="_blank" rel="noopener">https://github.com/fxsjy/jieba/blob/master/test/extract_tags_with_weight.py</a></p><h3 id="TextRank"><a href="#TextRank" class="headerlink" title="TextRank"></a>TextRank</h3><p>论文：<a href="http://web.eecs.umich.edu/~mihalcea/papers/mihalcea.emnlp04.pdf" target="_blank" rel="noopener">TextRank: Bringing Order into Texts</a>.</p><ul><li>将待抽取关键词的文本进行分词</li><li>以固定窗口大小(默认为5，通过span属性调整)，词之间的共现关系，构建图</li><li>计算图中节点的PageRank，是无向带权图</li><li>数据量越大，构建的图越精准</li></ul><p><code>jieba.analyse.textrank(sentence, topK=20, withWeight=False, allowPOS=(&#39;ns&#39;, &#39;n&#39;, &#39;vn&#39;, &#39;v&#39;))</code> 默认过滤词性。<code>jieba.analyse.TextRank()</code> 新建自定义实例</p><h2 id="开放式信息抽取"><a href="#开放式信息抽取" class="headerlink" title="开放式信息抽取"></a>开放式信息抽取</h2><p>处理的文本领域不再限定于规范的新闻文本或者某一领域文本，而是不限定领域的网络文本, 不仅需要考虑文本<br>特征，同时需要综合考虑网页结构特征和用户行为特征等。</p><h3 id="开放式实体抽取"><a href="#开放式实体抽取" class="headerlink" title="开放式实体抽取"></a>开放式实体抽取</h3><p>开放式实体抽取关注的是从海量、冗余、不规范的网络数据源上抽取出符合某个语义类的实体列表，侧重于抽取。</p><p>基于这样的假设：同类实体在网络上具有相似的网页结构或者相似的上下文特征。因此可以根据给出的特定语义类的若干实体（“种子”），找出该语义类包含的其他实体，其中特定语义类的标签可能是显式，也可能是隐式给出的。如给出“中国、美国、俄罗斯”这三个实体，要求找出“国家”这个语义类的其他实体诸如“德国、法国、日本”等。</p><p>训练步骤包含两部分：候选实体获取和候选实体置信度计算和排序。</p><p>具体训练过程：通常从种子实体出发，通过分析种子实体在语料中的上下文特征得到模板，根据模板得到更多候选实体，选取置信度高的候选实体作为新种子进行迭代，满足一定条件后停止迭代， 返回<br>历次置信度高的候选实体作为结果输出。</p><p>抽取比识别在任务上更加底层，实体抽取的结果可以作为列表支撑实体的识别。</p><p>对于中文而言，当不存在网页结构特征时，实体抽取任务变得更加困难，其中一个重要原因来自汉语分词，未知实体往往在分词过程中被分开。</p><h3 id="实体消歧"><a href="#实体消歧" class="headerlink" title="实体消歧"></a>实体消歧</h3><p>Entity disambiguation的难点在于指称项多样性（name variation）和指称项歧义（name ambiguity）。<br>指称项多样性指一个实体概念可以用多种命名性指称项指称，如全称、别称、简称、拼写错误、多语言名称等。</p><p>单语言的实体消歧问题的主要方法：</p><ol><li>实体聚类消歧法：对每一个实体指称项抽取其上下文特征（包括词、实体等），并将其表示成特征向量；然后计算实体指称项之间的相似度；计算基于指称项之间的相似度时，可采用一定聚类算法将其聚类，将每个类看作一个实体概念。这种方法的核心任务是计算实体指称项之间的相似度，<ul><li>传统的方法是利用上下文的词信息建立词袋模型（bag-of-words, BOW）。</li><li>针对人名消歧，采用基于图的算法，利用社会化关系的传递性考虑隐藏的实体关系知识。</li><li>利用知识资源，如Wikipedia、Web上的链接信息、命名实体的同现信息、领域特定语料库等，来提升实体消歧的效果。</li></ul></li><li>实体链接消歧法：实体链接（entity linking）也称实体分辨或实体解析（entity resolution），或记录链接（record linkage）。基于实体链接消歧法的目的是解决基于聚类的实体消歧法不能显式地给出实体语义信息的问题，其基本任务是：给定一个实体指称项，将其链接到知识库中的实体概念上。实体链接的核心任务仍是计算实体指称项和候选实体之间的相似度，选择相似度最大的候选实体作为链接的目标实体。</li></ol><p>实体消歧仍面临很多难题，包括空目标实体问题（NIL entity problem）（即实体知识库中不包含某指称项的目标实体）、知识库覆盖度有限、来自互联网的知识源可靠性差和知识库使用方法单一（集中于使用单文档特征）等。</p><h3 id="开放式实体关系抽取"><a href="#开放式实体关系抽取" class="headerlink" title="开放式实体关系抽取"></a>开放式实体关系抽取</h3><p>实体关系通常采用采用三元组表示：<code>(Arg1, Pred, Arg2)</code>， 其中，<code>Arg1</code>表示实体，<code>Arg2</code>表示实体关系值，通常也是实体，<code>Pred</code>表示关系名称，通常为动词、名词或者名词短语。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;信息抽取&quot;&gt;&lt;a href=&quot;#信息抽取&quot; class=&quot;headerlink&quot; title=&quot;信息抽取&quot;&gt;&lt;/a&gt;信息抽取&lt;/h2&gt;&lt;p&gt;1997年MUC会议（MUC-7） 召开时，评测任务已经增加到5个：&lt;br&gt;① 场景模板（scenario template, ST）填充：定义了描述场景的模板及槽填充规范；&lt;br&gt;② 命名实体（named entity, NE）识别：识别出文本中出现的专有名称和有意义的数量短语， 并加以归类；&lt;br&gt;③ 共指（coreference, CR）关系确定：识别出给定文本中的参照表达（ referring expressions），并确定这些表达之间的共指关系；&lt;br&gt;④ 模板元素（template element, TE）填充：类似于人名和组织机构名识别，但是要求系统必须识别出实体的描述和名字，如果一个实体在文本中被提到了多次，使用了几种可能的描述和不同的名字形式，要求系统都要把它们识别出来，一个文本中的每个实体只有一个模板元素［Grishman and Sundheim, 1996］；&lt;br&gt;⑤ 模板关系（template relation, TR）：确定实体之间与特定领域无关的关系。&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Information Retrieval" scheme="http://shukebeta.me/tags/Information-Retrieval/"/>
    
  </entry>
  
  <entry>
    <title>Java BitMap 和 Bloom Filter</title>
    <link href="http://shukebeta.me/java-BitMap/"/>
    <id>http://shukebeta.me/java-BitMap/</id>
    <published>2018-10-18T16:00:00.000Z</published>
    <updated>2018-12-05T09:31:24.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bit-Map"><a href="#Bit-Map" class="headerlink" title="Bit Map"></a>Bit Map</h2><p>Bit-map用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。<br><a id="more"></a><br>假设我们要对0-7内的5个元素<code>4,7,2,5,3</code>排序（假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），</p><ol><li>首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0，<code>0 0 0 0 0 0 0 0</code>.</li><li>然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置设为1, <code>p+(i/8)|(0x01&lt;&lt;(i%8))</code>, 这里默认为Big-ending, <code>0 0 0 0 1 0 0 0</code>.</li><li>然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态<code>0 0 1 1 1 1 0 1</code></li><li>遍历一遍Bit区域，把<code>1</code>的索引依次输出（<code>2，3，4，5，7</code>），这样就达到了排序的目的。</li></ol><p>算法的关键是如何确定十进制的数映射到二进制bit位的map图。算法占用很少内存，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M。缺点是不能有重复数据。</p><h3 id="Map映射表"><a href="#Map映射表" class="headerlink" title="Map映射表"></a>Map映射表</h3><p>假设需要排序或者查找的总数<code>N=10000000</code>，那么我们需要申请内存空间的大小为<code>int a[1 + N/32]</code>，其中：<code>a[0]</code>在内存中占32位, 可以对应十进制数0-31，依次类推：<br>bitmap表为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a[0]---------&gt;0-31</span><br><span class="line">a[1]---------&gt;32-63</span><br><span class="line">a[2]---------&gt;64-95</span><br><span class="line">a[3]---------&gt;96-127</span><br><span class="line">..........</span><br></pre></td></tr></table></figure></p><p>十进制数需要转换为对应的bit位</p><h3 id="位移转换"><a href="#位移转换" class="headerlink" title="位移转换"></a>位移转换</h3><p>将十进制数转换为对应的bit位, 申请一个<code>int</code>一维数组，作为32列的二维数组，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a[0]    |0000000000000000000000000000000000000|</span><br><span class="line"></span><br><span class="line">int a[1]    |0000000000000000000000000000000000000|</span><br><span class="line"></span><br><span class="line">………………</span><br><span class="line"></span><br><span class="line">int a[N]    |0000000000000000000000000000000000000|</span><br></pre></td></tr></table></figure></p><p>例如十进制0，对应在<code>a[0]</code>第一位： <code>00000000000000000000000000000001</code></p><ol><li>求十进制<code>0-N</code>对应在数组<code>a</code>的索引：十进制<code>0-31</code>，对应<code>a[0]</code>，先由十进制数n转换为与32的余可转化为对应在数组<code>a</code>中的索引<code>0</code>。比如n=24,那么 n/32=0，则24对应<code>a[0]</code>。又比如n=60, 那么n/32=1，则60对应<code>a[1]</code>。</li><li>求<code>0-N</code>对应<code>0-31</code>中的数：十进制0-31就对应0-31，而32-63则对应也是0-31，即给定一个数n可以通过模32求得对应0-31中的数。</li><li>利用移位0-31使得对应32bit位为1. 找到对应0-31的数为M, 左移M位：即<code>2 ^ M</code>, 置1.</li></ol><h3 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h3><p>为了降低键值冲突的概率，Bloom Filter使用了多个哈希函数：创建一个m位BitSet，先将所有位初始化为0，然后选择k个不同的哈希函数。第i个哈希函数对字符串str哈希的结果记为<code>h(i, str)</code>，且<code>h(i, str)</code>的范围是0到m-1 。</p><p>对于字符串<code>str</code>，分别计算<code>h(1, str), h(2, str), ... h(k, str)</code>, 以这些哈希值作为索引, 将BitSet的对应位置的位设为1, 这样就把<code>str</code>映射到BitSet的k个二进制位了.<img src="/images/bloom_filter.png" alt=""></p><p>如果要检查某<code>string</code>是否已经被记录在BitSet中, 只需要计算其哈希值数组, 并检查BitSet上对应位置的值是否为<code>1</code>, 若对应位置中有任何一个不是<code>1</code>, 那么该字符串<strong>一定</strong>没有被记录过, 若全部对应位置都为<code>1</code>, 那么按照<strong>false positive</strong>认为该字符串已经被记录过了(但不是100%肯定).</p><p>删除操作会影响到其他字符串。如果需要删除字符串的功能，使用Counting bloomfilter(CBF)，这是一种Bloom Filter的变体，CBF将Bloom Filter每一个Bit改为一个计数器，这样就可以实现删除字符串的功能了。</p><p>Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。</p><p>所以Bloom Filter适用以下几个特点：</p><ol><li>只要返回数据不存在，则肯定不存在。</li><li>返回数据存在，但只能是大概率存在。</li><li>不能清除其中的数据。</li></ol><p>BloomFilter的应用很多，比如数据库、爬虫（用爬虫抓取网页时对网页url去重）、防缓存击穿等。特别是需要精确知道某个数据不存在时做点什么事情就非常适合布隆过滤。 Goolge在BigTable中就使用了BloomFilter，以避免在硬盘中寻找不存在的条目。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Java实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">作者：crossoverJie</span><br><span class="line">链接：https:<span class="comment">//zhuanlan.zhihu.com/p/50926087</span></span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilters</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> arraySize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BloomFilters</span><span class="params">(<span class="keyword">int</span> arraySize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arraySize = arraySize;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[arraySize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = hashcode_1(key);</span><br><span class="line">        <span class="keyword">int</span> second = hashcode_2(key);</span><br><span class="line">        <span class="keyword">int</span> third = hashcode_3(key);</span><br><span class="line"></span><br><span class="line">        array[first % arraySize] = <span class="number">1</span>;</span><br><span class="line">        array[second % arraySize] = <span class="number">1</span>;</span><br><span class="line">        array[third % arraySize] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断数据是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = hashcode_1(key);</span><br><span class="line">        <span class="keyword">int</span> second = hashcode_2(key);</span><br><span class="line">        <span class="keyword">int</span> third = hashcode_3(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> firstIndex = array[first % arraySize];</span><br><span class="line">        <span class="keyword">if</span> (firstIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> secondIndex = array[second % arraySize];</span><br><span class="line">        <span class="keyword">if</span> (secondIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> thirdIndex = array[third % arraySize];</span><br><span class="line">        <span class="keyword">if</span> (thirdIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash 算法1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hashcode_1</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; key.length(); ++i) &#123;</span><br><span class="line">            hash = <span class="number">33</span> * hash + key.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(hash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash 算法2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hashcode_2</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> p = <span class="number">16777619</span>;</span><br><span class="line">        <span class="keyword">int</span> hash = (<span class="keyword">int</span>) <span class="number">2166136261L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length(); i++) &#123;</span><br><span class="line">            hash = (hash ^ data.charAt(i)) * p;</span><br><span class="line">        &#125;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">17</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(hash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  hash 算法3</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hashcode_3</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash, i;</span><br><span class="line">        <span class="keyword">for</span> (hash = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; key.length(); ++i) &#123;</span><br><span class="line">            hash += key.charAt(i);</span><br><span class="line">            hash += (hash &lt;&lt; <span class="number">10</span>);</span><br><span class="line">            hash ^= (hash &gt;&gt; <span class="number">6</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hash += (hash &lt;&lt; <span class="number">3</span>);</span><br><span class="line">        hash ^= (hash &gt;&gt; <span class="number">11</span>);</span><br><span class="line">        hash += (hash &lt;&lt; <span class="number">15</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.abs(hash);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Guava 实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">guavaTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> star = System.currentTimeMillis();</span><br><span class="line">    BloomFilter&lt;Integer&gt; filter = BloomFilter.create(</span><br><span class="line">            Funnels.integerFunnel(),</span><br><span class="line">            <span class="number">10000000</span>,</span><br><span class="line">            <span class="number">0.01</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        filter.put(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Assert.assertTrue(filter.mightContain(<span class="number">1</span>));</span><br><span class="line">    Assert.assertTrue(filter.mightContain(<span class="number">2</span>));</span><br><span class="line">    Assert.assertTrue(filter.mightContain(<span class="number">3</span>));</span><br><span class="line">    Assert.assertFalse(filter.mightContain(<span class="number">10000000</span>));</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"执行时间："</span> + (end - star));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造方法有两个比较重要的参数，一个是预计存放多少数据，一个是可以接受的误报率。Guava 会通过你预计的数量以及误报率帮你计算出你应当会使用的数组大小 numBits 以及需要计算几次 Hash 函数 <code>numHashFunctions</code> 。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp, Strategy strategy)</span> </span>&#123;</span><br><span class="line">  checkNotNull(funnel);</span><br><span class="line">  checkArgument(</span><br><span class="line">      expectedInsertions &gt;= <span class="number">0</span>, <span class="string">"Expected insertions (%s) must be &gt;= 0"</span>, expectedInsertions);</span><br><span class="line">  checkArgument(fpp &gt; <span class="number">0.0</span>, <span class="string">"False positive probability (%s) must be &gt; 0.0"</span>, fpp);</span><br><span class="line">  checkArgument(fpp &lt; <span class="number">1.0</span>, <span class="string">"False positive probability (%s) must be &lt; 1.0"</span>, fpp);</span><br><span class="line">  checkNotNull(strategy);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (expectedInsertions == <span class="number">0</span>) &#123;</span><br><span class="line">    expectedInsertions = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * TODO(user): Put a warning in the javadoc about tiny fpp values, since the resulting size</span></span><br><span class="line"><span class="comment">   * is proportional to -log(p), but there is not much of a point after all, e.g.</span></span><br><span class="line"><span class="comment">   * optimalM(1000, 0.0000000000000001) = 76680 which is less than 10kb. Who cares!</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">long</span> numBits = optimalNumOfBits(expectedInsertions, fpp);</span><br><span class="line">  <span class="keyword">int</span> numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BloomFilter&lt;T&gt;(<span class="keyword">new</span> LockFreeBitArray(numBits), numHashFunctions, funnel, strategy);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Could not create BloomFilter of "</span> + numBits + <span class="string">" bits"</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>put</code>有不同的策略，如<code>MURMUR128_MITZ_64()</code>策略根据 <code>murmur3_128</code> 方法的到一个 <code>128</code> 位长度的 <code>byte[]</code>。分别取高低 8 位的到两个 hash 值(<code>lowerEight, upperEight</code>)。再根据初始化时的到的执行 hash 的次数进行 hash 运算。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This strategy uses all 128 bits of &#123;<span class="doctag">@link</span> Hashing#murmur3_128&#125; when hashing. It looks different</span></span><br><span class="line"><span class="comment"> * than the implementation in MURMUR128_MITZ_32 because we're avoiding the multiplication in the</span></span><br><span class="line"><span class="comment"> * loop and doing a (much simpler) += hash2. We're also changing the index to a positive number by</span></span><br><span class="line"><span class="comment"> * AND'ing with Long.MAX_VALUE instead of flipping the bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MURMUR128_MITZ_64() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">put</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, LockFreeBitArray bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> bitSize = bits.bitSize();</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = Hashing.murmur3_128().hashObject(object, funnel).getBytesInternal();</span><br><span class="line">    <span class="keyword">long</span> hash1 = lowerEight(bytes);</span><br><span class="line">    <span class="keyword">long</span> hash2 = upperEight(bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> bitsChanged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">long</span> combinedHash = hash1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numHashFunctions; i++) &#123;</span><br><span class="line">      <span class="comment">// Make the combined hash positive and indexable</span></span><br><span class="line">      bitsChanged |= bits.set((combinedHash &amp; Long.MAX_VALUE) % bitSize);</span><br><span class="line">      combinedHash += hash2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bitsChanged;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>LockFreeBitArray</code>就是真正存放数据的底层数据结构。利用了一个 <code>AtomicLongArray data</code> 来存放数据。所以 <code>set()</code> 时候也是对这个 <code>data</code> 做处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Models a lock-free array of bits.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;We use this instead of java.util.BitSet because we need access to the array of longs and we</span></span><br><span class="line"><span class="comment"> * need compare-and-swap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LockFreeBitArray</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LONG_ADDRESSABLE_BITS = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">final</span> AtomicLongArray data;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LongAddable bitCount;</span><br><span class="line"></span><br><span class="line">  LockFreeBitArray(<span class="keyword">long</span> bits) &#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> <span class="keyword">long</span>[Ints.checkedCast(LongMath.divide(bits, <span class="number">64</span>, RoundingMode.CEILING))]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Used by serialization</span></span><br><span class="line">  LockFreeBitArray(<span class="keyword">long</span>[] data) &#123;</span><br><span class="line">    checkArgument(data.length &gt; <span class="number">0</span>, <span class="string">"data length is zero!"</span>);</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">new</span> AtomicLongArray(data);</span><br><span class="line">    <span class="keyword">this</span>.bitCount = LongAddables.create();</span><br><span class="line">    <span class="keyword">long</span> bitCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> value : data) &#123;</span><br><span class="line">      bitCount += Long.bitCount(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.bitCount.add(bitCount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Returns true if the bit changed value. */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> bitIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (get(bitIndex)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> longIndex = (<span class="keyword">int</span>) (bitIndex &gt;&gt;&gt; LONG_ADDRESSABLE_BITS);</span><br><span class="line">    <span class="keyword">long</span> mask = <span class="number">1L</span> &lt;&lt; bitIndex; <span class="comment">// only cares about low 6 bits of bitIndex</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> oldValue;</span><br><span class="line">    <span class="keyword">long</span> newValue;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      oldValue = data.get(longIndex);</span><br><span class="line">      newValue = oldValue | mask;</span><br><span class="line">      <span class="keyword">if</span> (oldValue == newValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!data.compareAndSet(longIndex, oldValue, newValue));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We turned the bit on, so increment bitCount.</span></span><br><span class="line">    bitCount.increment();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <code>set()</code> 之前先通过 <code>get()</code> 判断这个数据是否存在于集合中，如果已经存在则直接返回告知客户端写入失败。接下来就是通过位运算进行位或赋值。<code>get()</code> 方法的计算逻辑和 <code>set()</code> 类似，只要判断为 0 就直接返回存在该值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Bit-Map&quot;&gt;&lt;a href=&quot;#Bit-Map&quot; class=&quot;headerlink&quot; title=&quot;Bit Map&quot;&gt;&lt;/a&gt;Bit Map&lt;/h2&gt;&lt;p&gt;Bit-map用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 08 - 数据压缩 - 哈夫曼编码</title>
    <link href="http://shukebeta.me/NLP-08-data-compression-huffman-compression/"/>
    <id>http://shukebeta.me/NLP-08-data-compression-huffman-compression/</id>
    <published>2018-10-11T16:00:00.000Z</published>
    <updated>2018-12-17T13:06:05.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="避免歧义的编码"><a href="#避免歧义的编码" class="headerlink" title="避免歧义的编码"></a>避免歧义的编码</h2><p>在构建压缩编码的对应关系时，我们使用不同的数量的位来编码不同的字符.<br><a id="more"></a><br>比如摩斯密码<img src="/images/Morse_Code.png" alt="" title="Chart of the Morse code letters and numerals.">. 如果单纯使用这种对应关系，会出现一些问题， 如<code>•••−−−•••</code>会产生歧义: <code>SOS</code>? <code>V7</code>? <code>IAMIE</code>? <code>EEWNI</code>? 所以在实际使用中, 密码使用一些间隔来分隔代码字。</p><p>那么对于不同的压缩编码, 有什么常用方法来避免歧义？<br>方法是确保没有一个编码是另一个编码的前缀。比如</p><ul><li>使用固定长度编码。</li><li>为每个编码添加特殊的stop char。</li><li><strong>使用一种具备广泛使用性的prefix-free编码</strong>。</li></ul><p>用什么数据结构来设计prefix-free编码?</p><h3 id="用Trie构造编码"><a href="#用Trie构造编码" class="headerlink" title="用Trie构造编码"></a>用Trie构造编码</h3><p>一个二叉(<code>0, 1</code>)Trie: 叶节点是字符, 根节点到叶节点的路径就是编码.<img src="/images/huffman_trie.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"></p><p>压缩:<br>方法1：从叶开始; 按照路径到达根; 反向打印bits。<br>方法2：创建<code>键-值</code>对的符号表。</p><p>解压:</p><ol><li>从根节点开始, 根据位值是0还是1在Trie图上游走, 直到走到叶节点，则解压出一个字符</li><li>返回根节点, 继续第一步, 直到跑完所有编码.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> ch;   <span class="comment">// used only for leaf nodes</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> freq;  <span class="comment">// used only for compress</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> freq, Node left, Node right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.ch    = ch;</span><br><span class="line">      <span class="keyword">this</span>.freq  = freq;</span><br><span class="line">      <span class="keyword">this</span>.left  = left;</span><br><span class="line">      <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compare Nodes by frequency</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node that)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="keyword">return</span> <span class="keyword">this</span>.freq - that.freq;  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Runtime - Linear in input size N</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       Node root = readTrie(); <span class="comment">// read in encoding trie</span></span><br><span class="line">       <span class="keyword">int</span> N = BinaryStdIn.readInt(); <span class="comment">// read in number of chars</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">       &#123;</span><br><span class="line">          Node x = root;</span><br><span class="line">          <span class="keyword">while</span> (!x.isLeaf())</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="keyword">if</span> (!BinaryStdIn.readBoolean())</span><br><span class="line">                x = x.left;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                x = x.right;</span><br><span class="line">          &#125;</span><br><span class="line">          BinaryStdOut.write(x.ch, <span class="number">8</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       BinaryStdOut.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何读取一个Trie：根据Trie的前序遍历序列重构.<img src="/images/preorder_traversal_trie.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">readTrie</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (BinaryStdIn.readBoolean())</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">char</span> c = BinaryStdIn.readChar(<span class="number">8</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(c, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   Node x = readTrie();</span><br><span class="line">   Node y = readTrie();</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">'\0'</span>, <span class="number">0</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如何把Trie写为序列：以前序遍历的方式写Trie；额外用一个位标记是否叶节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTrie</span><span class="params">(Node x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (x.isLeaf())</span><br><span class="line">   &#123;</span><br><span class="line">      BinaryStdOut.write(<span class="keyword">true</span>);</span><br><span class="line">      BinaryStdOut.write(x.ch, <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   BinaryStdOut.write(<span class="keyword">false</span>);</span><br><span class="line">   writeTrie(x.left);</span><br><span class="line">   writeTrie(x.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="用哈夫曼算法构建最优编码"><a href="#用哈夫曼算法构建最优编码" class="headerlink" title="用哈夫曼算法构建最优编码"></a>用哈夫曼算法构建最优编码</h3><p>就是用Huffman算法. Huffman算法是把最短的编码赋给出现频率最高的字符, 把最长的编码留给出现频率较低的字符. 在Trie上的效果就变成频率最高的字符路径最短, 长路径都留给频率低的字符. 这样总的效果就是使用了更少的数据位来表达同样的信息.</p><ol><li>统计输入的各个字符的频率<code>freq[i]</code>。</li><li>为每个<code>char i</code>构建一个具有权重<code>freq[i]</code>的Trie(子节点为null), 从此节点开始</li><li>重复以下过程直到融合为一个trie(根节点)：<ul><li>选择当前权重最小的两Tries, <code>freq[i]</code>和<code>freq[j]</code>, 其中<code>i &lt;= j, freq[i] &lt;= freq[j]</code></li><li>给它们创建父节点, 权重为<code>freq[i] + freq[j]</code>, 两个子Trie和其父节点合并为一个Trie, 而且路径0(左边)总是指向较小的子Trie, 路径1(右边)指向较大的.</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">buildTrie</span><span class="params">(<span class="keyword">int</span>[] freq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinPQ&lt;Node&gt; pq = <span class="keyword">new</span> MinPQ&lt;Node&gt;();</span><br><span class="line">    <span class="comment">// initialize PQ with singleton tries</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="number">0</span>; i &lt; R; i++)</span><br><span class="line">       <span class="keyword">if</span> (freq[i] &gt; <span class="number">0</span>)</span><br><span class="line">          pq.insert(<span class="keyword">new</span> Node(i, freq[i], <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;  <span class="comment">// merge two smallest tries</span></span><br><span class="line">       Node x = pq.delMin();</span><br><span class="line">       Node y = pq.delMin();</span><br><span class="line">       Node parent = <span class="keyword">new</span> Node(<span class="string">'\0'</span>, x.freq + y.freq, x, y);</span><br><span class="line">       pq.insert(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.delMin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个算法, 可以保证频率最高(权重最大)的字符的叶节点就是最左叶节点, 一般编码为<code>0</code>, 其他依次类推. 可以证明Huffman算法生成的最优prefix-free编码.</p><p><a href="https://algs4.cs.princeton.edu/55compression/Huffman.java.html" target="_blank" rel="noopener">完整代码见</a></p><p>Implementation.<br>・Pass 1:  tabulate char frequencies and build trie.<br>・Pass 2:  encode file by traversing trie or lookup table</p><p>Running time. Using a binary heap ⇒ <code>N + R log R</code>. N input size, R alphabet size.</p><p>对于具有n个叶子节点的哈夫曼树，一共需要<code>2*n-1</code>个节点: 二叉树有三种类型节点，即子节点数为2的节点，为1的节点和为0的叶节点。而哈夫曼树的非叶子节点是由两个节点生成的，因此不能出现只有单子节点的节点，如果叶子节点个数为n, 那么非叶子节点的个数为<code>n-1</code>.</p><p>哈夫曼编码广泛应用于jpeg, pdf, MP3, MP4等文件编码中.</p><p>在神经网络中, 哈夫曼树也被用于构建层级Softmax.</p><p>一个使用Huffman Encoding的实例：<br><a href="https://github.com/congchan/cs106b-programming-abstraction/tree/master/HW6_Huffman%20Encoding/Huffman/src" target="_blank" rel="noopener">https://github.com/congchan/cs106b-programming-abstraction/tree/master/HW6_Huffman%20Encoding/Huffman/src</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;避免歧义的编码&quot;&gt;&lt;a href=&quot;#避免歧义的编码&quot; class=&quot;headerlink&quot; title=&quot;避免歧义的编码&quot;&gt;&lt;/a&gt;避免歧义的编码&lt;/h2&gt;&lt;p&gt;在构建压缩编码的对应关系时，我们使用不同的数量的位来编码不同的字符.&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Information Retrieval" scheme="http://shukebeta.me/tags/Information-Retrieval/"/>
    
      <category term="Data Compression" scheme="http://shukebeta.me/tags/Data-Compression/"/>
    
      <category term="Huffman Compression" scheme="http://shukebeta.me/tags/Huffman-Compression/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 07 - 数据压缩</title>
    <link href="http://shukebeta.me/NLP-07-data-compression-introduction/"/>
    <id>http://shukebeta.me/NLP-07-data-compression-introduction/</id>
    <published>2018-10-09T16:00:00.000Z</published>
    <updated>2018-12-17T13:06:31.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><p>压缩数据以节省储存空间，节省传输时间。同时很多文件都有很多冗余信息，这为压缩提供了很多可能性。<br><a id="more"></a><br>通用文件压缩<br>·文件：GZIP，BZIP，7z<br>·Archivers：PKZIP<br>·文件系统：NTFS，HFS +，ZFS</p><p>多媒体<br>·图像：GIF，JPEG<br>·声音：MP3<br>·视频：MPEG，DivX™，HDTV</p><p>通讯<br>·ITU-T T4 Group 3 Fax<br>·V.42bis调制解调器<br>·Skype</p><p>数据库</p><h3 id="压缩率"><a href="#压缩率" class="headerlink" title="压缩率"></a>压缩率</h3><p><code>Compression ratio = Bits in Compressed B / bits in B</code>.</p><blockquote><p>自然语言的压缩率为50-75％或更高.</p></blockquote><h3 id="读写二进制"><a href="#读写二进制" class="headerlink" title="读写二进制"></a>读写二进制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BinaryStdIn &#123;</span><br><span class="line">    boolean readBoolean() // read 1 bit of data and return as a boolean value</span><br><span class="line">    char readChar() // read 8 bits of data and return as a char value</span><br><span class="line">    char readChar(int r) // read r bits of data and return as a char value</span><br><span class="line">    // similar methods for byte (8 bits); short (16 bits); int (32 bits); long and double (64 bits)</span><br><span class="line">    boolean isEmpty() // is the bitstream empty?</span><br><span class="line">    void close() // close the bitstream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BinaryStdOut &#123;</span><br><span class="line">    void write(boolean b) // write the specified bit</span><br><span class="line">    void write(char c) // write the specified 8-bit char</span><br><span class="line">    void write(char c, int r) // write the r least significant bits of the specified char</span><br><span class="line">    // similar methods for byte (8 bits); short (16 bits); int (32 bits); long and double (64 bits)</span><br><span class="line">    void close() // close the bitstream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如使用三种方法表达<code>12/31/1999</code><br>1, A character stream (StdOut),<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StdOut.print(month + <span class="string">"/"</span> + day + <span class="string">"/"</span> + year);</span><br></pre></td></tr></table></figure></p><p><code>00110001</code> 1<br><code>00110010</code> 2<br><code>00101111</code> /<br><code>00110111</code> 3<br><code>00110001</code> 1<br><code>00101111</code> /<br><code>00110001</code> 1<br><code>00111001</code> 9<br><code>00111001</code> 9<br><code>00111001</code> 1<br>共 80bits<br>2, Three ints (BinaryStdOut)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BinaryStdOut.write(month);</span><br><span class="line">BinaryStdOut.write(day);</span><br><span class="line">BinaryStdOut.write(year);</span><br></pre></td></tr></table></figure></p><p><code>00000000 00000000 00000000 00001100</code> 12<br><code>00000000 00000000 00000000 00011111</code> 31<br><code>00000000 00000000 00000111 11001111</code> 1999<br>共96bits<br>3，A 4-bit field, a 5-bit field, and a 12-bit field (BinaryStdOut)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BinaryStdOut.write(month, <span class="number">4</span>);</span><br><span class="line">BinaryStdOut.write(day, <span class="number">5</span>);</span><br><span class="line">BinaryStdOut.write(year, <span class="number">12</span>);</span><br></pre></td></tr></table></figure></p><p><code>1100</code> 12<br><code>11111</code> 13<br><code>0111110 01111</code> 1999<br>共21bits</p><h3 id="通用数据压缩算法？"><a href="#通用数据压缩算法？" class="headerlink" title="通用数据压缩算法？"></a>通用数据压缩算法？</h3><p>不存在的，因为假如真的存在一种可以压缩所有比特串的算法，那么该算法就可以继续压缩已经被它压缩过的数据，那意味着所有比特串可以被压缩为0比特.</p><h2 id="Run-length-encoding"><a href="#Run-length-encoding" class="headerlink" title="Run-length encoding"></a>Run-length encoding</h2><p>Simple type of redundancy in a bitstream. Long runs of repeated bits：<br><code>0000000000000001111111000000011111111111</code><br>Compression, 4-bit counts to represent alternating runs of 0s and 1s: 15 0s, then 7 1s, then 7 0s, then 11 1s.<br><code>1111 0111 0111 1011</code><br><!-- more --><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunLength</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// maximum run-length count</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> R    = <span class="number">256</span>;</span><br><span class="line">   <span class="comment">// number of bits per count</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> LG_R = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads a sequence of bits from standard input; compresses</span></span><br><span class="line"><span class="comment">     * them using run-length coding with 8-bit run lengths; and writes the</span></span><br><span class="line"><span class="comment">     * results to standard output.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> run = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> old = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!BinaryStdIn.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> b = BinaryStdIn.readBoolean();</span><br><span class="line">            <span class="keyword">if</span> (b != old) &#123;</span><br><span class="line">                BinaryStdOut.write(run, LG_R);</span><br><span class="line">                run = <span class="number">1</span>;</span><br><span class="line">                old = !old;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 如果长度超过最大值, 写入0</span></span><br><span class="line">                <span class="keyword">if</span> (run == R-<span class="number">1</span>) &#123;</span><br><span class="line">                    BinaryStdOut.write(run, LG_R);</span><br><span class="line">                    run = <span class="number">0</span>;</span><br><span class="line">                    BinaryStdOut.write(run, LG_R);</span><br><span class="line">                &#125;</span><br><span class="line">                run++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryStdOut.write(run, LG_R);</span><br><span class="line">        BinaryStdOut.close();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads a sequence of bits from standard input (that are encoded</span></span><br><span class="line"><span class="comment">     * using run-length encoding with 8-bit run lengths); decodes them;</span></span><br><span class="line"><span class="comment">     * and writes the results to standard output.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> bit = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">while</span> (!BinaryStdIn.isEmpty())</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">int</span> run = BinaryStdIn.readInt(lgR);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; run; i++)</span><br><span class="line">            BinaryStdOut.write(bit);</span><br><span class="line">         bit = !bit;</span><br><span class="line">      &#125;</span><br><span class="line">      BinaryStdOut.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据压缩&quot;&gt;&lt;a href=&quot;#数据压缩&quot; class=&quot;headerlink&quot; title=&quot;数据压缩&quot;&gt;&lt;/a&gt;数据压缩&lt;/h2&gt;&lt;p&gt;压缩数据以节省储存空间，节省传输时间。同时很多文件都有很多冗余信息，这为压缩提供了很多可能性。&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Information Retrieval" scheme="http://shukebeta.me/tags/Information-Retrieval/"/>
    
      <category term="Data Compression" scheme="http://shukebeta.me/tags/Data-Compression/"/>
    
  </entry>
  
  <entry>
    <title>机器阅读理解 - 自注意力机制</title>
    <link href="http://shukebeta.me/NLP-attention-03-self-attention/"/>
    <id>http://shukebeta.me/NLP-attention-03-self-attention/</id>
    <published>2018-10-02T16:00:00.000Z</published>
    <updated>2018-10-24T10:19:11.963Z</updated>
    
    <content type="html"><![CDATA[<p>计算注意力主要分为三个步骤。</p><ol><li>计算query和每个key之间的相似性以获得权重。常用的相似性函数包括点积，拼接，检测器等。</li><li>然后通常是使用softmax函数来正则化这些权重。</li><li>最后将这些权重与相应的value一起加权并获得最终的注意力。</li></ol><a id="more"></a><p>在大部分NLP任务中，key一般就是value。</p><p>在前面的介绍中， 注意力机制一般都是附加于seq2seq或者encoder-decoder架构中。但这篇2017 NIPS的文章<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Attention is all you need</a>提出了自注意力机制. 与过去流行的使用基于RNN的Seq2Seq模型框架不同:</p><ol><li>文章中使用注意机制完全取代了RNN来构建整个模型框架。</li><li>Multi-Headed Attention Mechanism: 在编码器和解码器中使用 Multi-Headed self-attention。</li><li>比LSTM更快的计算速度。</li></ol><p>文章的实验数据暂且不论，其提出的核心想法很重要，就是LSTM这种时序模型速度实在是太慢了，很难应用到超大规模的数据和线上的应用中。Google因其自身业务的大规模性质，本身是很工程化的。所以他们非常反感需要繁琐特征提取的任务，所以他们早早就转投了神经网络。也非常不看好繁琐的神经网络，特别是那些无法并行化计算的。</p><p>近些年来，RNN（及其变种 LSTM, GRU）已成为很多nlp任务如机器翻译的经典网络结构。RNN从左到右或从右到左的方式顺序处理语言。RNN的按顺序处理的性质也使得其更难以充分利用现代快速计算设备，例如GPU等优于并行而非顺序处理的计算单元。虽然卷积神经网络（CNN）的时序性远小于RNN，但CNN体系结构如ByteNet或ConvS2S中，糅合远距离部分的信息所需的步骤数仍随着距离的增加而增长。</p><p>因为一次处理一个单词，RNN需要处理多个时序的单词来做出依赖于长远离单词的决定。但各种研究和实验逐渐表明，决策需要的步骤越多，循环网络就越难以学习如何做出这些决定。而本身LSTM就是为了解决long term dependency问题，但是解决得并不好。很多时候还需要额外加一层注意力层来处理long term dependency。</p><p>所以这次他们直接在编码器和解码器之间直接用attention，这样句子单词的依赖长度最多只有1，减少了信息传输路径。他们称之为Transformer。Transformer只执行一小段constant的步骤（根据经验选择）。在每个步骤中，应用self-attention机制，直接模拟句子中所有单词之间的关系，不管它们之间的位置如何。比如子“I arrived at the bank after crossing the river”，要确定“bank”一词是指河岸而不是金融机构，Transformer可以学会立即关注“river”这个词并在一步之内做出这个决定。</p><h3 id="Transformer总体架构"><a href="#Transformer总体架构" class="headerlink" title="Transformer总体架构"></a>Transformer总体架构</h3><p>Seq2seq神经网络通常包含读取输入句子并生成其表达的编码器。具体地说，为了计算给定单词的下一个表示 - 例如“bank” - Transformer将其与句子中的所有其他单词进行比较。这些比较的结果就是其他单词的注意力权重。这些注意力权重决定了其他单词应该为“bank”的下一个表达做出多少贡献。在计算“bank”的新表示时，能够消除歧义的“river”可以获得跟高的关注。将注意力权重用来加权平均所有单词的表达，然后将加权平均的表达喂给一个全连接网络以生成“bank”的新表达，以反映出该句子正在谈论的是“河岸”。<img src="/images/transform20fps.gif" alt="" title="image from: https://ai.googleblog.com/2017/08/transformer-novel-neural-network.html"><br>Transformer的解码阶段概括起来就是：首先为每个单词生成初始表达或embeddings。这些由空心圆表示。然后，使用自我注意力，聚合来自所有其他单词的信息，生成参考了整个上下文的每个单词的新表达，由实心球表示。不断对每个单词并行地重复这个步骤多次，连续地生成新的表达。</p><p>解码器操作类似，只是从左到右依次生成一个字。它不仅关注先前生成的单词，而且还参考编码器生成的最终表示。</p><p><img src="/images/transformer.png" alt="" title="单层编码器（左）和解码器（右），由 N = 6 个相同的层构建。"><br><code>N = 6</code>实际超过6层。这些“层”中的每一个实际上由两层组成：position-wise FNN 和一个（编码器），或两个（解码器），基于注意力的子层。其中每个还包含4个线性投影和注意逻辑。</p><p>编码器:</p><ol><li>Stage 1 - 输入编码: 序列的顺序信息是非常重要的。由于没有循环，也没有卷积，因此使用“位置编码”表示序列中每个标记的绝对（或相对）位置的信息。<ul><li>位置编码信息 + embedded input</li></ul></li><li>Stage 2 – Multi-head attention 和 Stage 3 – position-wise FFN. 两个阶段都是用来残差连接, 接着正则化输出层</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stage1_out = Embedding512 + TokenPositionEncoding512</span><br><span class="line">Stage2_out = layer_normalization(multihead_attention(Stage1_out) + Stage1_out)</span><br><span class="line">Stage3_out = layer_normalization(FFN(Stage2_out) + Stage2_out)</span><br><span class="line"></span><br><span class="line">out_enc = Stage3_out</span><br></pre></td></tr></table></figure><p>解码器的架构类似，但它在第3阶段采用了附加层, 在输出层上的 mask multi-head attention:</p><ol><li>Stage 1 – 输入解码: 输入 output embedding，偏移一个位置以确保对位置<code>i</code>的预测仅取决于<code>&lt; i</code>的位置。</li><li>Stage 2 - Masked Multi-head attention: 稍作修改以防止注意到后续位置。</li></ol><p>阶段2,3和4同样使用了残差连接，然后在输出使用归一化层。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Stage1_out = OutputEmbedding512 + TokenPositionEncoding512</span><br><span class="line"></span><br><span class="line">Stage2_Mask = masked_multihead_attention(Stage1_out)</span><br><span class="line">Stage2_Norm1 = layer_normalization(Stage2_Mask) + Stage1_out</span><br><span class="line">Stage2_Multi = multihead_attention(Stage2_Norm1 + out_enc) +  Stage2_Norm1</span><br><span class="line">Stage2_Norm2 = layer_normalization(Stage2_Multi) + Stage2_Multi</span><br><span class="line"></span><br><span class="line">Stage3_FNN = FNN(Stage2_Norm2)</span><br><span class="line">Stage3_Norm = layer_normalization(Stage3_FNN) + Stage2_Norm2</span><br><span class="line"></span><br><span class="line">out_dec = Stage3_Norm</span><br></pre></td></tr></table></figure></p><p>可以利用开源的<a href="https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/transformer.py" target="_blank" rel="noopener">Tensor2Tensor</a>，通过调用几个命令来训练Transformer网络进行翻译和解析。</p><h3 id="各个技术细节"><a href="#各个技术细节" class="headerlink" title="各个技术细节"></a>各个技术细节</h3><h3 id="Positional-Encoding"><a href="#Positional-Encoding" class="headerlink" title="Positional Encoding"></a>Positional Encoding</h3><p>在解码时序信息时，跟RNN和FNN不同，Transformer提出了一种把时序解码为正弦波的方法。这些信号作为额外的信息加入到输入和输出中以表达时间的流逝.<br>$$ \begin{eqnarray} PE_{(pos,2i)} = sin(pos/10000^{2i/d_{model}}) \end{eqnarray} $$<br>$$ \begin{eqnarray} PE_{(pos,2i+1)} = cos(pos/10000^{2i/d_{model}})\end{eqnarray} $$</p><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><h4 id="Scaled-Dot-Product-Attention"><a href="#Scaled-Dot-Product-Attention" class="headerlink" title="Scaled Dot-Product Attention"></a>Scaled Dot-Product Attention</h4><h4 id="Multi-head-attention"><a href="#Multi-head-attention" class="headerlink" title="Multi-head attention"></a>Multi-head attention</h4><h4 id="Self-Attention-SA"><a href="#Self-Attention-SA" class="headerlink" title="Self-Attention (SA)"></a>Self-Attention (SA)</h4><h3 id="Position-wise-FFN"><a href="#Position-wise-FFN" class="headerlink" title="Position-wise FFN"></a>Position-wise FFN</h3><h3 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h3><p>作者已经进行了一系列测试（论文表3），其中他们讨论N = 6层的建议，模型大小为512，基于h = 8个heads，键值维度为64，使用100K步。</p><p>还指出，由于模型质量随着$d_k$（行B）的减小而降低，因此可以进一步优化点积兼容性功能。</p><p>其声称提出的固定正弦位置编码，与学习到的位置编码相比，产生几乎相等的分数。</p><h3 id="算法适合哪些类型的问题？"><a href="#算法适合哪些类型的问题？" class="headerlink" title="算法适合哪些类型的问题？"></a>算法适合哪些类型的问题？</h3><ul><li>序列转导（语言翻译）</li><li>语法选区解析的经典语言分析任务 syntactic constituency parsing</li><li>共指消解 coreference resolution</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://research.googleblog.com/2017/08/transformer-novel-neural-network.html" target="_blank" rel="noopener">https://research.googleblog.com/2017/08/transformer-novel-neural-network.html</a><br><a href="https://research.googleblog.com/2017/06/accelerating-deep-learning-research.html" target="_blank" rel="noopener">https://research.googleblog.com/2017/06/accelerating-deep-learning-research.html</a><br><a href="https://mchromiak.github.io/articles/2017/Sep/12/Transformer-Attention-is-all-you-need/" target="_blank" rel="noopener">https://mchromiak.github.io/articles/2017/Sep/12/Transformer-Attention-is-all-you-need/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算注意力主要分为三个步骤。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算query和每个key之间的相似性以获得权重。常用的相似性函数包括点积，拼接，检测器等。&lt;/li&gt;
&lt;li&gt;然后通常是使用softmax函数来正则化这些权重。&lt;/li&gt;
&lt;li&gt;最后将这些权重与相应的value一起加权并获得最终的注意力。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>众数问题 - Boyer–Moore majority vote algorithm</title>
    <link href="http://shukebeta.me/algorithms-majority-element/"/>
    <id>http://shukebeta.me/algorithms-majority-element/</id>
    <published>2018-10-02T16:00:00.000Z</published>
    <updated>2018-10-17T09:15:10.517Z</updated>
    
    <content type="html"><![CDATA[<p>数组中有一个数字出现的次数超过数组长度的一半，例如输入一个长度为9的数组<code>1,2,3,2,2,2,5,4,2</code>。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。因为这个数出现次数超过了数组长度一半以上, 那么它就是数组中出现次数最多的数, 故谓之<strong>众数</strong>.<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        most = numbers[<span class="number">0</span>]</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> item == most:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count &lt; <span class="number">0</span>:</span><br><span class="line">                    most = item</span><br><span class="line">                    count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> numbers.count(most) &lt;= len(numbers) / <span class="number">2</span> <span class="keyword">else</span> most</span><br></pre></td></tr></table></figure></p><h2 id="众数问题"><a href="#众数问题" class="headerlink" title="众数问题"></a>众数问题</h2><p>众数问题可以推广泛化：给定大小为<code>n</code>的整数数组，找到所有出现超过<code>n / m</code>次的元素。这种问题可以使用 Boyer-Moore 算法解决.</p><blockquote><p>The Boyer–Moore majority vote algorithm is an algorithm for finding the majority of a sequence of elements using linear time and constant space. It is named after Robert S. Boyer and J Strother Moore, who published it in 1981, and is a prototypical example of a streaming algorithm.</p></blockquote><p>如果存在众数元素，该算法会找到众数元素：对于出现次数一半以上的元素。但是，如果没有众数，算法将不会检测到该事实，并且仍将输出其中一个元素。</p><p>这个时候需要第二次遍历数据, 验证在第一次通过中找到的元素是否真正占众数。</p><p>比如找到所有出现超过<code>n / 3</code>次的元素, 最多只可能有2个, 可以用长度为2的数据结构(这里选择map)来记录众数.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = <span class="number">2</span></span><br><span class="line">        cand = [<span class="number">0</span>] * m</span><br><span class="line">        freq = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> len(freq) &lt; m:</span><br><span class="line">                freq[item] = <span class="number">1</span> + freq.get(item, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span> item <span class="keyword">in</span> freq:</span><br><span class="line">                freq[item] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> list(freq):</span><br><span class="line">                    freq[k] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> freq[k] &lt;= <span class="number">0</span>:</span><br><span class="line">                        freq.pop(k)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [k <span class="keyword">for</span> k <span class="keyword">in</span> freq <span class="keyword">if</span> nums.count(k) &gt; len(nums) // (m + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组中有一个数字出现的次数超过数组长度的一半，例如输入一个长度为9的数组&lt;code&gt;1,2,3,2,2,2,5,4,2&lt;/code&gt;。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。因为这个数出现次数超过了数组长度一半以上, 那么它就是数组中出现次数最多的数, 故谓之&lt;strong&gt;众数&lt;/strong&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Java" scheme="http://shukebeta.me/tags/Java/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Dynamic Programming" scheme="http://shukebeta.me/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 06 - 不同树结构的字符串符号表</title>
    <link href="http://shukebeta.me/NLP-06-string-symbol-table-other-Trie/"/>
    <id>http://shukebeta.me/NLP-06-string-symbol-table-other-Trie/</id>
    <published>2018-09-30T16:00:00.000Z</published>
    <updated>2018-10-09T15:20:32.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="各种树的变种"><a href="#各种树的变种" class="headerlink" title="各种树的变种"></a>各种树的变种</h2><p>为了适应不同的应用场景, 人们使用不同的树结构来实现符号表.</p><h3 id="九宫格输入法"><a href="#九宫格输入法" class="headerlink" title="九宫格输入法"></a>九宫格输入法</h3><p>对于手机的九宫格输入法, 简单的实现方式是多次敲击: 通过反复按键输入一个字母，直到出现所需的字母。<br><a id="more"></a><br>但 <a href="http://www.t9.com/" target="_blank" rel="noopener">http://www.t9.com/</a> 的 T9 texting 支持更高效的输入方法:<br>・Find all words that correspond to given sequence of numbers.<br>・Press 0 to see all completion options.<br><img src="/images/t9.png" alt=""><br>Ex. hello<br>・多次敲击: 4 4 3 3 5 5 5 5 5 5 6 6 6<br>・T9: 4 3 5 5 6</p><p>可以使用 8-way trie 来实现.</p><h3 id="三元搜索Trie"><a href="#三元搜索Trie" class="headerlink" title="三元搜索Trie"></a>三元搜索Trie</h3><p><code>R</code>较大的R-way trie的空间效率不高，读取比较大的文件往往导致内存不足。但弊端是开辟出的数组内存利用率其实不高。现在很多系统都使用Unicode，分支可高达<code>65,536</code>. 所以需要更高效的方法。</p><p>Ternary search tries:<br>・Store characters and values in nodes (not keys).<br>・Each node has 3 children: smaller (left), equal (middle), larger (right).<br><img src="/images/tst.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br>Search in a TST: Follow links corresponding to each character in the key.<br>・If less, take left link; if greater, take right link.<br>・If equal, take the middle link and move to the next key character.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TST</span>&lt;<span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Value val;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">private</span> Node left, mid, right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Value val)</span></span></span><br><span class="line"><span class="function">    </span>&#123; root = put(root, key, val, <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, String key, Value val, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123; x = <span class="keyword">new</span> Node(); x.c = c; &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; x.c) x.left = put(x.left, key, val, d);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; x.c) x.right = put(x.right, key, val, d);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; key.length() - <span class="number">1</span>) x.mid = put(x.mid, key, val, d+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> x.val = val;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> get(key) != <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node x = get(root, key, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">get</span><span class="params">(Node x, String key, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">         <span class="keyword">if</span> (c &lt; x.c) <span class="keyword">return</span> get(x.left, key, d);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; x.c) <span class="keyword">return</span> get(x.right, key, d);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; key.length() - <span class="number">1</span>) <span class="keyword">return</span> get(x.mid, key, d+<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>TSTs比hashing更快（特别是对于搜索缺失键的情况）。</p><h3 id="基数树"><a href="#基数树" class="headerlink" title="基数树"></a>基数树</h3><p>Radix Tree, 也叫 Patricia trie (Practical Algorithm to Retrieve Information Coded in Alphanumeric), crit-bit tree, 压缩前缀树:<br>・Remove one-way branching.<br>・Each node represents a sequence of characters.<br>・Implementation: one step beyond this course.<br><img src="/images/radix_trie.png" alt="" title="put(&quot;shells&quot;, 1); put(&quot;shellfish&quot;, 2); image from: https://algs4.cs.princeton.edu/"><br>对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。</p><p>Applications.<br>・Database search.<br>・P2P network search.<br>・IP routing tables: find longest prefix match.<br>・Compressed quad-tree for N-body simulation.<br>・Efficiently storing and querying XML documents.</p><h3 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h3><p>后缀树（Suffix tree）指字符串后缀的基数树: 一个<code>String S</code>的后缀树是一个边（edge）被标记为字符串的树。因此每一个<code>S</code>的后缀都唯一对应一条从根节点到叶节点的路径。这样就形成了一个<code>S</code>的后缀的基数树。<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Suffix_tree_BANANA.svg/250px-Suffix_tree_BANANA.svg.png" alt="" title="image from: https://en.wikipedia.org/"></p><p>Applications.<br>・Linear-time: longest repeated substring, longest common substring, longest palindromic substring, substring search, tandem repeats, ….<br>・Computational biology databases (BLAST, FASTA).</p><h2 id="字符符号表总结"><a href="#字符符号表总结" class="headerlink" title="字符符号表总结"></a>字符符号表总结</h2><p>Red-black BST.<br>・Performance guarantee: log N key compares.<br>・Supports ordered symbol table API.</p><p>Hash tables.<br>・Performance guarantee: constant number of probes.<br>・Requires good hash function for key type.</p><p>Tries. R-way, TST.<br>・Performance guarantee: log N characters accessed.<br>・Supports character-based operations.<br><img src="/images/string_symbol_table_cost_sum.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"></p><blockquote><p>You can get at anything by examining 50-100 bits</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;各种树的变种&quot;&gt;&lt;a href=&quot;#各种树的变种&quot; class=&quot;headerlink&quot; title=&quot;各种树的变种&quot;&gt;&lt;/a&gt;各种树的变种&lt;/h2&gt;&lt;p&gt;为了适应不同的应用场景, 人们使用不同的树结构来实现符号表.&lt;/p&gt;
&lt;h3 id=&quot;九宫格输入法&quot;&gt;&lt;a href=&quot;#九宫格输入法&quot; class=&quot;headerlink&quot; title=&quot;九宫格输入法&quot;&gt;&lt;/a&gt;九宫格输入法&lt;/h3&gt;&lt;p&gt;对于手机的九宫格输入法, 简单的实现方式是多次敲击: 通过反复按键输入一个字母，直到出现所需的字母。&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Trie" scheme="http://shukebeta.me/tags/Trie/"/>
    
      <category term="Information Retrieval" scheme="http://shukebeta.me/tags/Information-Retrieval/"/>
    
      <category term="Symbol table" scheme="http://shukebeta.me/tags/Symbol-table/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 05 - 字符串符号表和三元搜索Trie</title>
    <link href="http://shukebeta.me/NLP-05-string-symbol-table-Trie/"/>
    <id>http://shukebeta.me/NLP-05-string-symbol-table-Trie/</id>
    <published>2018-09-29T16:00:00.000Z</published>
    <updated>2018-09-30T09:02:12.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><blockquote><p>在计算机科学中，符号表是一种用于语言翻译器（例如编译器和解释器）中的数据结构。在符号表中，程序源代码中的每个标识符都和它的声明或使用信息绑定在一起，比如其数据类型、作用域以及内存地址。<br>常用哈希表来实现.</p></blockquote><p>符号表的应用非常广泛, 可用于实现Set, Dictionary, 文件索引, 稀疏向量/矩阵等数据结构和相关的运算操作, 还有其他如过滤查询(Exception filter), 一致性查询(concordance queries)等操作.</p><p>字符符号表就是专门针对字符操作的符号表, API:<br>Prefix match - Keys with prefix <code>sh</code>: <code>she</code>, <code>shells</code>, and <code>shore</code>.<br>Wildcard match - Keys that match <code>.he</code>: <code>she</code> and <code>the</code>.<br>Longest prefix - Key that is the longest prefix of <code>shellsort</code>: <code>shells</code>.<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StringST</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    StringST(); create a symbol table with string keys</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Value val)</span></span>; put key-value pair into the symbol table</span><br><span class="line">    <span class="function">Value <span class="title">get</span><span class="params">(String key)</span></span>; value paired with key</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(String key)</span></span>; delete key and corresponding value</span><br><span class="line">    <span class="function">Iterable&lt;String&gt; <span class="title">keys</span><span class="params">()</span></span>; all keys</span><br><span class="line">    <span class="function">Iterable&lt;String&gt; <span class="title">keysWithPrefix</span><span class="params">(String s)</span></span>; keys having s as a prefix</span><br><span class="line">    <span class="function">Iterable&lt;String&gt; <span class="title">keysThatMatch</span><span class="params">(String s)</span></span>; <span class="function">keys that match <span class="title">s</span> <span class="params">(where . is a wildcard)</span></span></span><br><span class="line"><span class="function">    String <span class="title">longestPrefixOf</span><span class="params">(String s)</span></span>; longest key that is a prefix of s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="以Trie为基础的字符符号表"><a href="#以Trie为基础的字符符号表" class="headerlink" title="以Trie为基础的字符符号表"></a>以Trie为基础的字符符号表</h3><p>algs4中提供了用 R-way trie 来实现符号表(symbol table)例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieST</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">256</span>; <span class="comment">// extended ASCII</span></span><br><span class="line">    <span class="keyword">private</span> Node root = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object value;</span><br><span class="line">        <span class="keyword">private</span> Node[] next = <span class="keyword">new</span> Node[R];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Value val)</span> </span>&#123;</span><br><span class="line">        root = put(root, key, val, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, String key, Value val, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) x = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="keyword">if</span> (d == key.length()) &#123; x.value = val; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        x.next[c] = put(x.next[c], key, val, d+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String key)</span> </span>&#123; <span class="keyword">return</span> get(key) != <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Node x = get(root, key, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> (Value) x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">get</span><span class="params">(Node x, String key, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (d == key.length()) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        <span class="keyword">return</span> get(x.next[c], key, d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按顺序迭代所有键：<br>·中序遍历trie，找到的键添加到队列中<br>·维护从根到当前节点路径的字符序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">keys</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> Queue&lt;String&gt;();</span><br><span class="line">    collect(root, <span class="string">""</span>, queue);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Node x, String prefix, Queue&lt;String&gt; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x.val != <span class="keyword">null</span>) q.enqueue(prefix);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">        collect(x.next[c], prefix + c, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="前缀匹配"><a href="#前缀匹配" class="headerlink" title="前缀匹配"></a>前缀匹配</h3><p>Find all keys in a symbol table starting with a given prefix.<br>Ex. Autocomplete in a cell phone, search bar, text editor, or shell.<br>・User types characters one at a time.<br>・System reports all matching strings.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">keysWithPrefix</span><span class="params">(String prefix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> Queue&lt;String&gt;();</span><br><span class="line">    Node x = get(root, prefix, <span class="number">0</span>);</span><br><span class="line">    collect(x, prefix, queue);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最长前缀"><a href="#最长前缀" class="headerlink" title="最长前缀"></a>最长前缀</h3><p>Find longest key in symbol table that is a prefix of query string.<br>Ex. To send packet toward destination IP address, router chooses IP address in routing table that is longest prefix match.</p><p>・Search for query string.<br>・Keep track of longest key encountered.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPrefixOf</span><span class="params">(String query)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = search(root, query, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> query.substring(<span class="number">0</span>, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Node x, String query, <span class="keyword">int</span> d, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> length;</span><br><span class="line">    <span class="keyword">if</span> (x.val != <span class="keyword">null</span>) length = d;</span><br><span class="line">    <span class="keyword">if</span> (d == query.length()) <span class="keyword">return</span> length;</span><br><span class="line">    <span class="keyword">char</span> c = query.charAt(d);</span><br><span class="line">    <span class="keyword">return</span> search(x.next[c], query, d+<span class="number">1</span>, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;符号表&quot;&gt;&lt;a href=&quot;#符号表&quot; class=&quot;headerlink&quot; title=&quot;符号表&quot;&gt;&lt;/a&gt;符号表&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在计算机科学中，符号表是一种用于语言翻译器（例如编译器和解释器）中的数据结构。在符号表中，程序源代码中的每个标识符都和它的声明或使用信息绑定在一起，比如其数据类型、作用域以及内存地址。&lt;br&gt;常用哈希表来实现.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;符号表的应用非常广泛, 可用于实现Set, Dictionary, 文件索引, 稀疏向量/矩阵等数据结构和相关的运算操作, 还有其他如过滤查询(Exception filter), 一致性查询(concordance queries)等操作.&lt;/p&gt;
&lt;p&gt;字符符号表就是专门针对字符操作的符号表, API:&lt;br&gt;Prefix match - Keys with prefix &lt;code&gt;sh&lt;/code&gt;: &lt;code&gt;she&lt;/code&gt;, &lt;code&gt;shells&lt;/code&gt;, and &lt;code&gt;shore&lt;/code&gt;.&lt;br&gt;Wildcard match - Keys that match &lt;code&gt;.he&lt;/code&gt;: &lt;code&gt;she&lt;/code&gt; and &lt;code&gt;the&lt;/code&gt;.&lt;br&gt;Longest prefix - Key that is the longest prefix of &lt;code&gt;shellsort&lt;/code&gt;: &lt;code&gt;shells&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Trie" scheme="http://shukebeta.me/tags/Trie/"/>
    
      <category term="Information Retrieval" scheme="http://shukebeta.me/tags/Information-Retrieval/"/>
    
      <category term="Symbol table" scheme="http://shukebeta.me/tags/Symbol-table/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 04 - “和谐” - 多模式匹配算法 - AC自动机</title>
    <link href="http://shukebeta.me/NLP-04-string-match-algorithm-ac-automaton/"/>
    <id>http://shukebeta.me/NLP-04-string-match-algorithm-ac-automaton/</id>
    <published>2018-09-28T16:00:00.000Z</published>
    <updated>2018-09-30T09:02:18.827Z</updated>
    
    <content type="html"><![CDATA[<p>虽然KMP可以用于<a href="/NLP-01-string-searching-algorithm-01-kmp">单模式匹配问题</a>，但如果是多模式问题, KMP的性能就得不到保证。比如根据墙内法律要求, 墙内的搜索引擎需要过滤敏感词后才能合法运营。敏感词的数量不少, 如果要求包含敏感词的网页不能被搜索到, 那么搜索引擎在爬取网页信息时, 就要标记网页的文本中是否包含任意个敏感词.<br><a id="more"></a></p><p>这就是典型的多模匹配问题. 这种情况下如果使用Trie，那么需要遍历网页的每一个字符位置，对每一个位置进行Trie前缀匹配。如果词典的词语数量为N，每个词语长度为L，文章的长度为M，那么需要进行的计算次数是在<code>N*M*L</code>这个级别的. 即使把词语的长度L简化为常数级别的, 整个算法的复杂度也至少是$O(n^2)$.</p><h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>可以看到，KMP算法可以避免back up（在检查字符的过程中不需要回头），而Trie可以存储多个模式的信息。如果把二者结合在一起，也许能从性能上解决多模式（任意位置）匹配问题。这就是Aho–Corasick算法（AC自动机）。</p><blockquote><p>Aho–Corasick算法是由Alfred V. Aho和Margaret J.Corasick 发明的字符串搜索算法，用于在输入的一串字符串中匹配有限组字典中的子串。它与普通字符串匹配的不同点在于同时与所有字典串进行匹配。算法均摊情况下具有近似于线性的时间复杂度，约为字符串的长度加所有匹配的数量。</p></blockquote><p>所以算法的关键就是通过Trie把多个模式构建为一个DFA（Deterministic finite state automaton），然后让模式串末尾对应的状态作为一个DFA的终止节点。这样，对于一个要检查的长字符串（如一段网页内容），让这个字符串在DFA上跑一趟，每一个字符表示一种跳转方式，如果这段字符能够跳到任何一个终结节点, 那么就表明这段字符串匹配了至少一个模式, 如果整段字符跑完都没到达终结节点, 那么这个网页就是”和谐的”.</p><p>在单模式匹配中, 用KMP构建的DFA是比较简单的, 从左到右, 开头的状态就是开始状态, 结尾的状态就是结束状态:<br><img src="/images/build_dfa.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br>而多模式匹配中, 在Trie的结构基础上构建出来的DFA更像一个DFA的样子:<br><img src="/images/ushers_dfa.png" alt="" title="经典的ushers自动机，模式串是he/ she/ his /hers, 忽略了部分到根节点的转移边. image from: https://baike.baidu.com/pic"><br>Trie中的节点, 就类似于DFA中的状态. 如果让字符串<code>shis</code>在上面跑, 假如仅仅是靠Trie(也即是没有虚线标识的转移), 那么第一次从字符串的第一个字符<code>s</code>开始转移, 经过转移路径<code>0 - 85 - 90</code>之后就转不动了, 因为Trie记录的模式中没有<code>shi</code>, 这个时候得back up, 从第二个位置<code>h</code>开始再匹配一遍. 这个过程中就产生重复匹配, 而参考KMP的思路, 在匹配<code>shi</code>的过程中, 其实已经挖掘出了<code>hi</code>这个子串了, 而这个子串是跟模式<code>his</code>对应的, 如果有办法不回头继续匹配下去就能提高性能了.</p><p>而DFA中虚线的失败转移就是用来解决这个问题的: 当走到状态<code>90</code>时, 前面有了小部分子串<code>h</code>刚好对应状态<code>74</code>, 这个时候用虚线作为失败转移, 转移到<code>74</code>, 在状态<code>74</code>中寻找下一个转移<code>i</code>, 这样就实现了不回头继续匹配了.</p><p>因为AC自动机是在Trie的基础上添加边, 用于指示各个节点经过不同字符后跳转到哪个节点, 结果就变成了图, 所以也叫做<strong>Trie图</strong>.</p><p>要构建AC自动机:</p><ol><li>首先要把所有模式都吃进一个Trie中(最近看多进击的巨人了), 构建出一个由不同实线串联起来的状态机, 其中代表更好吻合一个模式的状态标记为终结节点(如上图绿色节点)</li><li>然后补全其他字符的转移(失败转移), 用虚线表示. 补全了所有字符的转移方式, 才能让字符串永不回头地匹配下去, 避免了back up, 保证性能.</li></ol><p>问题的关键在如何补全所有的状态转移.</p><h3 id="补全状态转移"><a href="#补全状态转移" class="headerlink" title="补全状态转移"></a>补全状态转移</h3><p><img src="/images/ushers_dfa.png" alt="" title="经典的ushers自动机，模式串是he/ she/ his /hers, 忽略了部分到根节点的转移边. image from: https://baike.baidu.com/pic"><br>这里要在Trie结构中定义一个<a href="https://hihocoder.com/problemset/problem/1036" target="_blank" rel="noopener">后缀节点</a>的概念: Trie中对应路径(已有模式)去掉部分前缀字符后剩余的后缀字符在Trie中对应的结点. 比如上图中, <code>h</code>作为<code>sh</code>的一个后缀, <code>h</code>对应的Trie节点<code>74</code>就是<code>sh</code>对应节点<code>90</code>的后缀节点. 等于说, <strong>节点和其后缀节点对应的模式有一部分后缀是相同</strong>.</p><p>如果知道了每一个节点的后缀节点, 那么在匹配的过程中, 在任一位置匹配失败, 都可以通过失败转移的方式转移到后缀节点, 继续进行后续匹配, 而不会遗漏, 因为后缀节点对应这个目前为止已匹配字符的某一部分后缀. 等于说, 后缀节点告诉我们, 在字符串中出现与模式不同的字符串时(匹配失败), 如何转移到其他状态.</p><p>所以问题的关键又变成了如何求后缀节点.</p><h3 id="求后缀节点"><a href="#求后缀节点" class="headerlink" title="求后缀节点"></a>求后缀节点</h3><p>观察Trie结构可以发现两个要点</p><ol><li>字符串任何一个位置对应的状态节点，一定比它的后缀节点更深，比如前面例子中状态节点<code>90</code>在第二层, 而其后缀节点<code>74</code>在第一层. 这点也是理所当然的, 毕竟后缀比较短. 从动态规划的角度考虑, 字符串任一位置<code>i</code>对应的状态节点的后缀节点一定是<code>k&lt;i</code>的节点中的某一个.</li><li>因为每一个状态<code>i</code>都是由其父节点<code>j</code>通过某一个字符<code>c</code>转移而来, 那么<code>i</code>的后缀节点一定是<code>j</code>的后缀节点通过同样的字符<code>c</code>转移而来. 或者说, 如果<code>j</code>的后缀节点是<code>jj</code>, 那么<code>j</code>和<code>jj</code>有着相同的后缀, 它们通过同样的转移字符<code>c</code>转移后, 二者到达的节点也一定有着相同的后缀.</li></ol><p>比如上面Ushers自动机例子中, 如果用字符串<code>sshis</code>来跑, 那么<code>ssh</code>对应的状态<code>90</code>, 是由前缀<code>ss</code>通过字符<code>h</code>转移而来. 因为<code>ssh</code>的后缀节点, 同样是某一个有共同后缀的字符(<code>h</code>或者<code>sh</code>)对应的状态(在这里是<code>h</code>对应的<code>74</code>). 可以发现<code>74</code>是由根节点<code>0</code>通过同样的字符<code>h</code>转移而来的. 反过来说, 节点<code>0</code>就是节点<code>90</code>的父节点<code>85</code>的后缀节点.</p><p>在多个模式中, 如果有某模式的前缀刚好是另一模式的子串(后缀). 比如上面Ushers自动机例子中, 模式<code>her</code>(或者<code>he</code>)的前缀<code>he</code>就是模式<code>she</code>的子串, 则会二者存在失败转移的关联. 如果没有, 那么就跳回初始状态节点.</p><p>所以补全所有状态转移的具体实现方法就是运用动态规划的原理:</p><ul><li>从Trie根节点开始, 逐层往下补全每一层的状态转移, 也就是宽度优先遍历(BFS), 这样下层的状态转移就可以利用上层的结果. 动态规划的转移方程可以描述为: <strong>每一个通过字符<code>c</code>转移而来的状态节点<code>i</code>的后缀节点 = <code>i</code>的父节点的后缀节点通过<code>c</code>转移到的状态节点</strong></li><li>初始状态包含两部分:<ul><li>一个是根节点(初始状态<code>0</code>), 它的后缀节点就是它自己,</li><li>另一个是第一层的状态节点, 如<code>85, 74</code>, 因为它们对应的是长度为<code>1</code>的字符, 没有后缀, 所以它们的后缀节点也是根节点<code>0</code>.</li></ul></li></ul><p>在实现中还要注意, <strong>后缀结点为标记结点的结点也需要被标记</strong>. 因为在状态转移过程中, 如果某个虚线转移刚好转移到终结节点, 但在字符串遍历的过程中, 并没有选择走这一条线, 就会忽略了这个终结节点, 导致匹配失败, 或者多走了更多的路. 比如在上面的例子中, 如果把模式<code>she</code>改为<code>shee</code>, <code>91</code>不再是终结节点, 而是延伸到<code>92</code>为终结节点, <code>91</code>的后缀节点是<code>76</code>. 如果用字符串<code>sshe</code>来跑这个DFA, 就会出现走到最后字符<code>e</code>时, 在节点<code>91</code>结束, 匹配失败. 所以需要把<code>91</code>也标记为终结节点.</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 把字典通过insert把所有单词插入Trie树，</span></span><br><span class="line"><span class="comment"> * 然后通过setSuffix()构建出对应的Trie图，</span></span><br><span class="line"><span class="comment"> * 然后从Trie图的根节点开始，沿着文章str的每一个字符，走出对应的边，</span></span><br><span class="line"><span class="comment"> * 直到遇到一个标记结点或者整个str都遍历完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode trie;</span><br><span class="line">    Queue&lt;TrieNode&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        trie = <span class="keyword">new</span> TrieNode(<span class="keyword">null</span>, <span class="string">' '</span>);</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode curNode = trie;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x : word.toCharArray()) &#123;</span><br><span class="line">            curNode = insert(curNode, x);</span><br><span class="line">        &#125;</span><br><span class="line">        curNode.setLast(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** insert char x, means create a new node in the x edge.</span></span><br><span class="line"><span class="comment">     * return created node  */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">insert</span><span class="params">(TrieNode node, <span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.get(x) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.set(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.get(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** BFS on the trie */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue.add(trie);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">/** poll() removes the present head.</span></span><br><span class="line"><span class="comment">             http://www.tutorialspoint.com/java/util/linkedlist_poll.htm */</span></span><br><span class="line">            TrieNode node = queue.poll();</span><br><span class="line">            setSuffix(node);</span><br><span class="line">            complementDFA(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Set node's suffix, complement lacking edge</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">setSuffix</span><span class="params">(TrieNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.root == <span class="keyword">null</span>) &#123; <span class="comment">// Trie root</span></span><br><span class="line">            node.suffix = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.root.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.suffix = node.root.suffix;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.suffix = node.root.suffix.get(node.fromIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.suffix.isLast) &#123;</span><br><span class="line">            node.isLast = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Complement DFA according to suffix */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">complementDFA</span><span class="params">(TrieNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.isLast) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node.edges.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.edges[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.edges[i] = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.edges[i] = node.suffix.edges[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.add(node.edges[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> contains = <span class="keyword">false</span>;</span><br><span class="line">        TrieNode curNode = trie;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> x = s.charAt(i);</span><br><span class="line">            curNode = curNode.get(x);</span><br><span class="line">            <span class="keyword">if</span> (curNode.isLast) &#123;</span><br><span class="line">                contains = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> contains;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATO0 = <span class="number">97</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isLast;</span><br><span class="line">        TrieNode[] edges;</span><br><span class="line">        TrieNode root;</span><br><span class="line">        <span class="keyword">char</span> fromIndex;</span><br><span class="line">        TrieNode suffix;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(TrieNode root, <span class="keyword">char</span> from)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.root = root;</span><br><span class="line">            fromIndex = from;</span><br><span class="line">            edges = <span class="keyword">new</span> TrieNode[R];</span><br><span class="line">            isLast = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> edges[ch - ATO0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** instantiate the ch child in edges */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            edges[ch - ATO0] = <span class="keyword">new</span> TrieNode(<span class="keyword">this</span>, ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLast</span><span class="params">(<span class="keyword">boolean</span> isLast)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isLast = isLast;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Trie t = <span class="keyword">new</span> Trie();</span><br><span class="line">        String[] X = &#123;<span class="string">"sb"</span>, <span class="string">"dsb"</span>, <span class="string">"cjdsb"</span>, <span class="string">"qnmlgb"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String x : X) &#123;</span><br><span class="line">            t.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t.setSuffix();</span><br><span class="line">        String s = <span class="string">"aadbaaadaaac"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t.search(s)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"YES"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"NO"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然KMP可以用于&lt;a href=&quot;/NLP-01-string-searching-algorithm-01-kmp&quot;&gt;单模式匹配问题&lt;/a&gt;，但如果是多模式问题, KMP的性能就得不到保证。比如根据墙内法律要求, 墙内的搜索引擎需要过滤敏感词后才能合法运营。敏感词的数量不少, 如果要求包含敏感词的网页不能被搜索到, 那么搜索引擎在爬取网页信息时, 就要标记网页的文本中是否包含任意个敏感词.&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Trie图" scheme="http://shukebeta.me/tags/Trie%E5%9B%BE/"/>
    
      <category term="AC自动机" scheme="http://shukebeta.me/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 03 - 单模式匹配与拼写检查 - Trie</title>
    <link href="http://shukebeta.me/NLP-03-string-match-algorithm-Trie/"/>
    <id>http://shukebeta.me/NLP-03-string-match-algorithm-Trie/</id>
    <published>2018-09-27T16:00:00.000Z</published>
    <updated>2018-09-30T09:02:24.563Z</updated>
    
    <content type="html"><![CDATA[<p>Trie 也称字典树，名称来源于Re<font color="red">trie</font>val，支持$O(n)$插入和查询操作，以空间换取时间的数据结构. 用于词频统计和输入统计领域, 可以高效地存储大规模的字典数据, 也可以用于模糊匹配, 搜索最长前缀词等.</p><blockquote><p>A <strong>trie</strong>, also called <strong>digital tre</strong>e, <strong>radix tree</strong> or <strong>prefix tree</strong> is a kind of search tree - an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings. Unlike a binary search tree, no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the string associated with that node, and the root is associated with the empty string. Keys tend to be associated with leaves, though some inner nodes may correspond to keys of interest. Hence, keys are not necessarily associated with every node.</p></blockquote><a id="more"></a><p><img src="/images/Trie_example.png" alt="" title="A trie for keys &quot;A&quot;,&quot;to&quot;, &quot;tea&quot;, &quot;ted&quot;, &quot;ten&quot;, &quot;i&quot;, &quot;in&quot;, and &quot;inn&quot;. Image from https://en.wikipedia.org/wiki/Trie"></p><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>Trie没有规定每一个节点的分支数量, 用<strong>R-way Trie</strong>来表示分支数量为<code>R</code>的Trie. 对于不同的应用, 可以设置不同的<code>R</code>.</p><h3 id="字符（模糊）匹配与拼写检查"><a href="#字符（模糊）匹配与拼写检查" class="headerlink" title="字符（模糊）匹配与拼写检查"></a>字符（模糊）匹配与拼写检查</h3><p>应用例子是在一本字典中查找特定前缀的所有单词. 简化的例子是在英文字典中, 根据查询前缀, 返回相同前缀的所有单词数. 同样的结构可以用来检查拼写错误.</p><p>那么只需要在每一个节点存储该节点以下所有单词数就行了. 每一个节点包含一个长度26的数组，以方便快速定位对应的26个字母, 类似B-tree:<img src="/images/b_tree.png" alt="" title="image from https://www.coursera.org/learn/algorithms-part1"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字母本身可以用来作为索引：a - 97, z - 122</span></span><br><span class="line"><span class="comment"> * Color 是备用属性， 用于标记该节点是否为单词结尾，这里暂时用不到。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALPHABET = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATO0 = <span class="number">97</span>;</span><br><span class="line">    <span class="keyword">int</span> color;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    Trie[] node;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        node = <span class="keyword">new</span> Trie[ALPHABET];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String words)</span> </span>&#123;</span><br><span class="line">        Trie[] curNode = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x : words.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = x - ATO0;</span><br><span class="line">            insert(curNode, index);</span><br><span class="line">            curNode = curNode[index].node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Trie[] curNode, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            curNode[index] = <span class="keyword">new</span> Trie(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curNode[index].n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Trie[] curNode = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = x - ATO0;</span><br><span class="line">            <span class="keyword">if</span> (curNode[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count = curNode[index].n;</span><br><span class="line">            curNode = curNode[index].node;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果要问题扩展为返回所有相同前缀的单词，那么就要在插入字典时，在对应单词结尾的节点标记颜色。</p><h3 id="提高扩展性"><a href="#提高扩展性" class="headerlink" title="提高扩展性"></a>提高扩展性</h3><p>用固定长度为26的数组来处理英文，好处是数组内存占用小，索引时也不需要搜索，直接用字符码作为索引。也可以根据ASCII码进一步扩大数组长度以支持更多字符。</p><p>为了提高可扩展性，可以考虑用其他更灵活的数据结构来替代数组，比如HashMap，同时把HashMap放进一个TrieNode类。这样以后要修改核心的存储结构，只需要改动TrieNode即可，其余的接口不用改。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode node;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode curNode = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x : word.toCharArray()) &#123;</span><br><span class="line">            curNode = curNode.set(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode curNode = node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> x : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curNode.get(x) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode.get(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curNode.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, TrieNode&gt; map;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(Character val)</span> </span>&#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.value = val;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TrieNode <span class="title">set</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            TrieNode t = map.get(ch);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                t = <span class="keyword">new</span> TrieNode(ch);</span><br><span class="line">                <span class="keyword">this</span>.map.put(ch, t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>HashMap的寻址虽然会靠字符码作为地址的数组慢一点点，但也是非常快的:$O(\log N)$。但HashMap本身是比较耗内存的数据结构, 所以如果知道要处理的数据是在特定范围内的, 比如节点就是在256个字符中, 那么还是不要不用HashMap.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Trie 也称字典树，名称来源于Re&lt;font color=&quot;red&quot;&gt;trie&lt;/font&gt;val，支持$O(n)$插入和查询操作，以空间换取时间的数据结构. 用于词频统计和输入统计领域, 可以高效地存储大规模的字典数据, 也可以用于模糊匹配, 搜索最长前缀词等.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;trie&lt;/strong&gt;, also called &lt;strong&gt;digital tre&lt;/strong&gt;e, &lt;strong&gt;radix tree&lt;/strong&gt; or &lt;strong&gt;prefix tree&lt;/strong&gt; is a kind of search tree - an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings. Unlike a binary search tree, no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the string associated with that node, and the root is associated with the empty string. Keys tend to be associated with leaves, though some inner nodes may correspond to keys of interest. Hence, keys are not necessarily associated with every node.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Trie" scheme="http://shukebeta.me/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 02 - 字符搜索匹配算法 02 - Boyer-Moore(BM) 和 Rabin-Karp(RK)</title>
    <link href="http://shukebeta.me/NLP-02-string-searching-algorithm-02-bm-rk/"/>
    <id>http://shukebeta.me/NLP-02-string-searching-algorithm-02-bm-rk/</id>
    <published>2018-09-26T16:00:00.000Z</published>
    <updated>2018-10-07T07:44:44.008Z</updated>
    
    <content type="html"><![CDATA[<p>字符串搜索/匹配算法中, Boyer-Moore(BM)比前面的<a href="/NLP-01-string-searching-algorithm-kmp">Knuth–Morris–Pratt(KMP)</a>更高效. BM算法从右到左扫描模式中的字符。当匹配的字符在模式中不存在时，可以跳过最多达M个字符.<img src="/images/bm.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br><a id="more"></a></p><h2 id="BM"><a href="#BM" class="headerlink" title="BM"></a>BM</h2><p>在决定要跳过多少字符时, 分几种情况考虑:<br>1, mismatch character <code>T</code> not in pattern: increment <code>i</code> one character beyond <code>T</code><br>2.1, Mismatch character in pattern: mismatch character <code>N</code> in pattern, align text <code>N</code> with rightmost pattern <code>N</code><br>2.2, Mismatch character in pattern (but heuristic no help): mismatch character <code>E</code> in pattern, align text <code>E</code> with rightmost pattern <code>E</code>? 还是 increment i by 1? 无法确定, 需要辅助信息.</p><p>需要预先计算模式各个字符在模式最右边出现的索引(若无则<code>-1</code>):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">right = <span class="keyword">new</span> <span class="keyword">int</span>[R];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">right[c] = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)</span><br><span class="line">right[pat.charAt(j)] = j;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = txt.length();</span><br><span class="line"><span class="keyword">int</span> M = pat.length();</span><br><span class="line"><span class="keyword">int</span> skip;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N-M; i += skip)</span><br><span class="line">&#123;</span><br><span class="line">skip = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = M-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pat.charAt(j) != txt.charAt(i+j))</span><br><span class="line">&#123;</span><br><span class="line">skip = Math.max(<span class="number">1</span>, j - right[txt.charAt(i+j)]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (skip == <span class="number">0</span>) <span class="keyword">return</span> i; <span class="comment">// match</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Substring search with the Boyer-Moore mismatched character heuristic takes about <code>~ N / M</code> character compares to search for a pattern of length <code>M</code> in a text of length <code>N</code>.<br>Worst-case. Can be as bad as <code>~ M N</code>.</p></blockquote><p>Boyer-Moore变种: 通过添加类似KMP的规则来防止重复模式，可以将最坏情况改善为<code>~3 N</code>字符比较。</p><h2 id="RK"><a href="#RK" class="headerlink" title="RK"></a>RK</h2><p>Rabin-Karp 基于 modular hashing：<br>・Compute a hash of pattern characters <code>0</code> to <code>M - 1</code>.<br>・For each <code>i</code>, compute a hash of text characters <code>i</code> to <code>M + i - 1</code>.<br>・If pattern hash = text substring hash, check for a match.</p><p>所以算法的关键在于如何高效地计算哈希值：Horner’s method - 用于评估M阶多项式的线性时间方法<br><img src="/images/horner_method.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute hash for M-digit key</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(String key, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)</span><br><span class="line">h = (R * h + key.charAt(j)) % Q;</span><br><span class="line"><span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>给定$x_i$，如何计算$x_{i+1}$：<br>$$x_i = t_i R^{M-1} + T_{i+1}R^{M-2} + … + t_{i+M-1}R^0$$<br>$$x_{i+1} = t_{i+1}R^{M-1} + T_{i+2}R^{M-2} + … + t_{i+M}R^0$$<br>$$x_{i+1} = (x_i - t_i R^{M-1}) R + t_{i+M}$$<br>M-digit, base-R integer, modulo Q，$R^{M-1}$是可以预先计算的.<br><img src="/images/rk.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabinKarp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> patHash; <span class="comment">// pattern hash value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> M; <span class="comment">// pattern length</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> Q; <span class="comment">// modulus</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> R; <span class="comment">// radix</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> RM; <span class="comment">// R^(M-1) % Q</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RabinKarp</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">M = pat.length();</span><br><span class="line">R = <span class="number">256</span>;</span><br><span class="line">Q = longRandomPrime(); <span class="comment">// a large prime (but avoid overflow)</span></span><br><span class="line"></span><br><span class="line">RM = <span class="number">1</span>; <span class="comment">// precompute R^&#123;M – 1&#125; (mod Q)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M-<span class="number">1</span>; i++)</span><br><span class="line">RM = (R * RM) % Q;</span><br><span class="line">patHash = hash(pat, M);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(String key, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* as before */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** check for hash collision using rolling hash function */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = txt.length();</span><br><span class="line"><span class="keyword">int</span> txtHash = hash(txt, M);</span><br><span class="line"><span class="keyword">if</span> (patHash == txtHash) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">txtHash = (txtHash + Q - RM*txt.charAt(i-M) % Q) % Q;</span><br><span class="line">txtHash = (txtHash*R + txt.charAt(i)) % Q;</span><br><span class="line"><span class="keyword">if</span> (patHash == txtHash) <span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有两种方式判断是否匹配：</p><ul><li>Monte Carlo version. Return match if hash match.<ul><li>Always runs in linear time. Extremely likely to return correct answer (but not always!).</li></ul></li><li>Las Vegas version. Check for substring match if hash match; continue search if false collision.<ul><li>Always returns correct answer. Extremely likely to run in linear time (but worst case is M N).</li></ul></li></ul><blockquote><p>In theory, if <code>Q</code> is a sufficiently large random prime (about $M N^2$), then the probability of a false collision is about <code>1 / N</code>.<br>In practice, choose <code>Q</code> to be a large prime (but not so large to cause overflow). Under reasonable assumptions, probability of a collision is about <code>1 / Q</code>.</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/substring_search_cost_summary.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br>算法可以拓展到二维模式匹配, 多模式匹配等问题.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字符串搜索/匹配算法中, Boyer-Moore(BM)比前面的&lt;a href=&quot;/NLP-01-string-searching-algorithm-kmp&quot;&gt;Knuth–Morris–Pratt(KMP)&lt;/a&gt;更高效. BM算法从右到左扫描模式中的字符。当匹配的字符在模式中不存在时，可以跳过最多达M个字符.&lt;img src=&quot;/images/bm.png&quot; alt=&quot;&quot; title=&quot;image from: https://www.coursera.org/learn/algorithms-part2/&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Boyer-Moore" scheme="http://shukebeta.me/tags/Boyer-Moore/"/>
    
  </entry>
  
  <entry>
    <title>NLP与信息处理 01 - 字符搜索匹配算法 01 - KMP</title>
    <link href="http://shukebeta.me/NLP-01-string-searching-algorithm-01-kmp/"/>
    <id>http://shukebeta.me/NLP-01-string-searching-algorithm-01-kmp/</id>
    <published>2018-09-25T16:00:00.000Z</published>
    <updated>2018-10-07T07:57:01.029Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>In computer science, string-searching algorithms, sometimes called string-matching algorithms, are an important class of string algorithms that try to find a place where one or several strings (also called patterns) are found within a larger string or text.</p></blockquote><p>字符串搜索/匹配算法在大规模文本应用中有非常重要的作用，比如文章敏感词搜索，多关键词过滤搜索等。如果使用暴力搜索，则时间复杂度很高（若 m 为关键字的长度， n 为要待搜索的字符串长度， k为关键字数量，则复杂度为$O(n \times m \times k)$。而好的算法可以让这些问题的时间复杂度大大降低。</p><p>常用的算法有Knuth–Morris–Pratt(KMP), Boyer-Moore(BM), Rabin-Karp(RK), Trie, Trie图, AC自动机等.<br><a id="more"></a></p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>Knuth–Morris–Pratt 算法在每次搜索匹配前，预处理模式字符串，记录模式字符串自身重复的情况，即包含左临界的子字符串和包含右临界的子字符串的重复长度，以此来作为后续匹配的参考。当实际去匹配带搜索字符串时，想象是我们拿着模式字符串从左到右匹配过去。任何时候，如果发现匹配不上的时，不是简单地右移一位继续重新匹配，而是在已匹配部分的范围内，直接跳过k个字符，右移到与模式开头部分重复的位置，并接着重复部分后面继续开始匹配（重复的部分证明已经匹配过）。</p><p>一个很好解释<a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">参考</a><br><img src="/images/kmp1.png" alt=""><img src="/images/kmp2.png" alt="" title="https://blog.csdn.net/v_july_v/article/details/7041827"><br>KMP算法的理论基础基于确定性有限状态自动机 DFA（Deterministic finite state automaton）。DFA可以理解为抽象的字符搜索机：</p><ul><li>有限数量的<strong>状态</strong>（包括开始和停止）。</li><li>字母表每个字符对应一个状态转换。</li><li>只接受能通往停止状态的转换序列。</li></ul><p><img src="/images/kmp_dfa.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br>如<code>ABCAABABABAB</code>对应<code>0→1→2→0→1→1→2→3→4→5→4→5→4</code></p><p>可以看出KMP算法的几个要点:</p><ul><li>状态State: 表示模式中已匹配的字符数。<code>pattern[]</code>最长前缀(同时是<code>txt[0..i]</code>的后缀)的长度.</li><li>需要预先从<code>pattern</code>中计算<code>dfa[][]</code></li><li>字符串遍历指针只会前进不会后退</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, N = txt.length();</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; N &amp;&amp; j &lt; M; i++)</span><br><span class="line">j = dfa[txt.charAt(i)][j];</span><br><span class="line"><span class="keyword">if</span> (j == M) <span class="keyword">return</span> i - M;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Running time: at most N character accesses to Simulate DFA on text.</p><h3 id="使用DFA"><a href="#使用DFA" class="headerlink" title="使用DFA"></a>使用DFA</h3><p>用状态<code>state j</code>表示模式<code>pat</code>的前<code>j</code>个字符已经匹配. 用<code>dfa[c][j]</code>表示在状态<code>state j</code>时, 遇到下一个字符<code>c</code>, 应该转移到什么状态.</p><p>在状态<code>state j</code>：<br>· 如果匹配成功，<code>char c == pat.charAt(j)</code>，则转移到<code>state j+1</code>: <code>dfa[pat.charAt(j)][j] = j+1</code>.<br>· 如果失败，则从<code>pat[1..j-1]</code>对应的DFA状态<code>X</code>，向着<code>c</code>方向转移：<code>copy dfa[][X] to dfa[][j]</code>.<br>・Update <code>X</code>.<br><img src="/images/build_dfa.png" alt="" title="image from: https://www.coursera.org/learn/algorithms-part2/"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.pat = pat;</span><br><span class="line">M = pat.length();</span><br><span class="line">dfa = <span class="keyword">new</span> <span class="keyword">int</span>[R][M];</span><br><span class="line">dfa[pat.charAt(<span class="number">0</span>)][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> X = <span class="number">0</span>, j = <span class="number">1</span>; j &lt; M; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">dfa[c][j] = dfa[c][X]; <span class="comment">// copy mismatch cases</span></span><br><span class="line">dfa[pat.charAt(j)][j] = j+<span class="number">1</span>;</span><br><span class="line">X = dfa[pat.charAt(j)][X];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Running time. M character accesses (but space/time proportional to R M).</p><h3 id="NEXT数组"><a href="#NEXT数组" class="headerlink" title="NEXT数组"></a>NEXT数组</h3><p>假设现在文本串<code>S</code>匹配到<code>i</code>位置，模式串<code>P</code>匹配到<code>j</code>位置:<br><img src="https://img-blog.csdn.net/20140812223633281" alt="" title="image from: https://blog.csdn.net/v_july_v/article/details/7041827"><br>首先第一位NEXT值<code>next[0]</code>一定是<code>-1</code>, 后面的第<code>j+1</code>个值<code>next[j]</code>代表<code>[0, j-1]</code>部分有多少重复前后缀. 可以根据前一位的<code>next[j-1]</code>值<code>k</code>推断:</p><ul><li>如果<code>P[j] == P[k]</code>, 则意味着重复前后缀长度<code>+1</code>, 那么<code>next[j] = next[j-1] + 1 = k + 1</code>.</li><li>如果<code>P[j] != P[k]</code>, 则意味着前面重复前后缀无法继续下去. 此时不能简单地判定<code>next[j] = 0</code>, 需要继续往前看是否有更短小的重复前后缀. 又因为重复前后缀意味着前后端相同, 因此可以直接匹配<code>P[j] ?= P[k&#39;], k&#39; = next[k]</code>, 以此循环下去直到<code>k&#39; = -1</code>为止.</li></ul><p>以上算法还可以进一步优化: 当<code>P[j] != S[i]</code>时，下次必然匹配<code>P[next [j]] ?= S[i]</code>，此时如果<code>P[j] == P[next[j]]</code>，则意味着匹配必然失败. 这样就出现了冗余匹配。所以如果出现<code>P[j] == P[next[j]]</code>，则令<code>next[j] = next[next[j]] = next[next[j-1] + 1] = next[k + 1]</code>.<img src="http://hi.csdn.net/attachment/201106/14/8394323_13080758591kyV.jpg" alt="" title="image from: https://blog.csdn.net/v_july_v/article/details/7041827"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span>[] p, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; p.length - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line"><span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[++j] != p[++k])</span><br><span class="line">                next[j] = k;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">next[j] = next[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>对于优化后的next数组可以发现一点：如果模式串的后缀跟前缀相同，那么它们的next值也是相同的，例如模式串abcabc，它的前缀后缀都是abc，其优化后的next数组为：-1 0 0 -1 0 0，前缀后缀abc的next值都为-1 0 0.</p></blockquote><h3 id="基于NEXT数组的KMP算法"><a href="#基于NEXT数组的KMP算法" class="headerlink" title="基于NEXT数组的KMP算法"></a>基于NEXT数组的KMP算法</h3><p>基于前面求出的NEXT数组, 可以根据以下步骤实现KMP算法:</p><ul><li>假设现在文本串<code>S</code>匹配到<code>i</code>位置，模式串<code>P</code>匹配到<code>j</code>位置<ul><li>if <code>j = -1</code>, or <code>S[i] == P[j]</code>(当前字符匹配成功), then <code>i++, j++</code></li><li>else, <code>j = next[j]</code>。当失配时，模式串<code>P</code>相对于文本串<code>S</code>向右移动<code>j - next[j]</code>位(大于等于1)。</li></ul></li></ul><p><img src="https://img-blog.csdn.net/20150812214857858" alt="" title="image from: https://img-blog.csdn.net/20150812214857858"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 返回模式串第一次在文本串中出现的位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">char</span>[] p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; s.length &amp;&amp; j &lt; p.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (j == -<span class="number">1</span> || s[i] == p[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="KMP应用"><a href="#KMP应用" class="headerlink" title="KMP应用"></a>KMP应用</h3><p>判断一段文字（原串）里面是否存在敏感词（模式串）。原题地址 <a href="http://hihocoder.com/problemset/problem/1015?sid=1368409：" target="_blank" rel="noopener">http://hihocoder.com/problemset/problem/1015?sid=1368409：</a></p><p>输入：第一行一个整数N，表示测试数据组数。接下来的N*2行，每两行表示一个测试数据。在每一个测试数据中，第一行为模式串，由不超过10^4个大写字母组成，第二行为原串，由不超过10^6个大写字母组成。其中N&lt;=20.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">HA</span><br><span class="line">HAHAHA</span><br><span class="line">WQN</span><br><span class="line">WQN</span><br><span class="line">ADA</span><br><span class="line">ADADADA</span><br><span class="line">BABABB</span><br><span class="line">BABABABABABABABABB</span><br><span class="line">DAD</span><br><span class="line">ADDAADAADDAAADAAD</span><br></pre></td></tr></table></figure></p><p>输出: 对于每一个测试数据，按照它们在输入中出现的顺序输出一行Ans，表示模式串在原串中出现的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>这里是需要找出出现的次数，因此不仅仅是找到第一个，还要继续遍历原串统计剩余出现的次数，同时要考虑重叠的部分。关键的功能代码可以复制上面的，但是需要作出一些改动。</p><p>首先，因为部分重叠情况也是要统计的，比如<code>ADADADA</code>这个原串, 包含3个<code>ADA</code>. 所以要考虑即使匹配成功后, 模式串的索引<code>j</code>能够跳回前面的重复前缀位置. 考虑使用未优化过的NEXT计算方法.</p><p>除此之外, 通过额外计算多一位NEXT值, 记录完整的模式串的重复前后缀长度, 以协助索引.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span>[] p, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; p.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k]) &#123;</span><br><span class="line">            next[++j] = ++k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于<code>ADA</code>, 原来未优化过的NEXT是<code>-1,0,0</code>, 现在是<code>-1,0,0,1</code>, 最后一位<code>1</code>表示<code>ADA</code>这个模式串的重复前后缀是长度为<code>1</code>的<code>A</code>.</p><p>借助额外长度的NEXT, 只需要小小地改动KMP计算逻辑, 最重要的是当<code>j</code>到达<code>NEXT</code>的额外位置时, 通过<code>j = next[j];</code>把<code>j</code>后拨到重复前缀的位置, 以方便进行后面的搜索.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 返回模式串在原串中出现的次数 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">char</span>[] p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[p.length + <span class="number">1</span>]; <span class="comment">// 额外多计算一位</span></span><br><span class="line">    GetNext(p, next);</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || s[i] == p[j]) &#123;</span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line">            c++;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;In computer science, string-searching algorithms, sometimes called string-matching algorithms, are an important class of string algorithms that try to find a place where one or several strings (also called patterns) are found within a larger string or text.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;字符串搜索/匹配算法在大规模文本应用中有非常重要的作用，比如文章敏感词搜索，多关键词过滤搜索等。如果使用暴力搜索，则时间复杂度很高（若 m 为关键字的长度， n 为要待搜索的字符串长度， k为关键字数量，则复杂度为$O(n \times m \times k)$。而好的算法可以让这些问题的时间复杂度大大降低。&lt;/p&gt;
&lt;p&gt;常用的算法有Knuth–Morris–Pratt(KMP), Boyer-Moore(BM), Rabin-Karp(RK), Trie, Trie图, AC自动机等.&lt;br&gt;
    
    </summary>
    
      <category term="AI" scheme="http://shukebeta.me/categories/AI/"/>
    
      <category term="NLP" scheme="http://shukebeta.me/categories/AI/NLP/"/>
    
    
      <category term="NLP" scheme="http://shukebeta.me/tags/NLP/"/>
    
      <category term="Algorithm" scheme="http://shukebeta.me/tags/Algorithm/"/>
    
      <category term="Trie" scheme="http://shukebeta.me/tags/Trie/"/>
    
      <category term="KMP" scheme="http://shukebeta.me/tags/KMP/"/>
    
      <category term="Aho–Corasick algorithm" scheme="http://shukebeta.me/tags/Aho%E2%80%93Corasick-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 快速幂</title>
    <link href="http://shukebeta.me/bits-operations-07/"/>
    <id>http://shukebeta.me/bits-operations-07/</id>
    <published>2018-09-25T16:00:00.000Z</published>
    <updated>2018-10-22T09:18:06.806Z</updated>
    
    <content type="html"><![CDATA[<p>如何实现快速的幂运算？<br><a id="more"></a></p><p>要求$c = a^b$, 按照朴素算法把<code>a</code>连乘<code>b</code>次的时间复杂度是$O(n)$. 而快速幂能做到$O(\log n)$。把<code>b</code>转换为二进制, 二进制数第<code>i</code>位的权为$2^{i-1}$，就可以把二进制拆分为若干个以<code>2</code>为底的真数, 然后利用幂数的性质，例如用朴素算法求$a^{11}$要求乘<code>11</code>次. 考虑到<code>11</code>的二进制为<code>1011</code>, 如果把$a^{11}$拆分为:<br>$$a^{11} = a^{a_0 2^0 + a_1 2^1 + a_2 0 + a_3 2^3} = a^1 a^2 a^8$$<br>可以看到每一个因子都是上一个因子的平方，利用$a^2 a^2$求出$a^4$, 同样利用$a^4$的平方求出$a^8$, 每次计算只需要用到上一次计算出来的结果, 所以总的运算次数是<code>4</code>次. 任何一个数<code>b</code>最多能写成长度为$O(\log b)$的二进制, 因此这个算法就是$O(\log n)$.</p><p>在程序设计中是根据<code>b</code>的二进制中是否为<code>1</code>来控制是否乘以上一次翻倍的积</p><ul><li>不断右移<code>b</code>, 直到<code>b</code>不再有<code>1</code>：<ul><li>根据当前位的权重（当前<code>b</code>最后一位）是否为<code>1</code>来决定<code>c</code>是否乘以最新的<code>a</code></li><li>把<code>a</code>平方，用于下一位计算</li></ul></li></ul><p>在Java中要考虑极端值INT_MIN<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> temp = myPow(x, n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> ==<span class="number">0</span>) <span class="keyword">return</span> temp * temp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>) <span class="keyword">return</span> x*temp*temp;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (temp*temp) / x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        n = -(n+<span class="number">1</span>); <span class="comment">// 处理极端值</span></span><br><span class="line">        x = <span class="number">1</span>/x;</span><br><span class="line">        ans *= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) ans *= x;</span><br><span class="line">        x *= x;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂取余"><a href="#快速幂取余" class="headerlink" title="快速幂取余"></a>快速幂取余</h3><p>求<code>a^b mod c</code>.<br>如果<code>b</code>是偶数, <code>a^b mod c</code> = $(a^2)^{b/2} \% c$<br>如果<code>b</code>是奇数, <code>a^b mod c</code> = $((a^2)^{b/2} \times a) \% c$</p><p>又因为取余有性质:<code>a^b mod c = (a mod c)^b</code></p><p>引理：<code>(a * b) mod c = [( a mod c ) * (b mod c) ] mod c</code></p><p>证明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设 a mod c =d，b mod c= e;</span><br><span class="line">       则：a=t*c + d ;  b=k*c + e ;</span><br><span class="line">       (a*b)mod c = (t*c+d)(t*c+e)</span><br><span class="line">                 = (tk c^2 + ( te+dk ) *c + d*e) mod c</span><br><span class="line">                 = de mod c</span><br></pre></td></tr></table></figure></p><p>即积的取余等于取余的积的取余.</p><p>利用快速幂的思想, 令<code>k = (a * a) mod c</code>，所要求的最终结果即为 <code>k^(b/2) mod c</code>, 这个过程可以迭代下去, 如果b是奇数, 或多出一项<code>a mod c</code>. 当<code>b = 0</code>时, 所有因子已经相乘, 迭代结束, 复杂度为<code>O(log b)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span>  <span class="title">PowerMod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  ans = <span class="number">1</span>;</span><br><span class="line">    a = a % c;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b % <span class="number">2</span> = = <span class="number">1</span>)</span><br><span class="line">            ans = (ans * a) % c;</span><br><span class="line">        b = b/<span class="number">2</span>;       <span class="comment">//   b&gt;&gt;=1;</span></span><br><span class="line">        a = (a * a) % c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何实现快速的幂运算？&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 汉明距离</title>
    <link href="http://shukebeta.me/bits-operations-06/"/>
    <id>http://shukebeta.me/bits-operations-06/</id>
    <published>2018-09-24T16:00:00.000Z</published>
    <updated>2018-10-10T03:26:37.010Z</updated>
    
    <content type="html"><![CDATA[<p>求两个整数的汉明距离 hamming distance<br><a id="more"></a><br><a href="https://leetcode.com/problems/hamming-distance/description/" target="_blank" rel="noopener">Leetcode 461</a><br>两个整数之间的汉明距离是该两个数之间不同的位数。 给定两个整数x和y，计算汉明距离。问题也可以理解为对于两个整数<code>m</code>和<code>n</code>, 需要改变<code>m</code>的二进制多少位才能得到<code>n</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Use Brian Kernighan's way to count bits */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = x ^ y;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        y++;</span><br><span class="line">        x &amp;= x - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(x ^ y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样用到Brian Kernighan算法：</p><blockquote><p>Lets say that the bit at index n is 1 and that the bits in indexes 0 up to <code>n-1</code> are all 0 (we’ll use little endianess - so index 0 is 1, index 1 is 2, index 2 is 4, index 3 is 8 and so on).</p></blockquote><blockquote><p><code>v-1</code> subtracts from index 0 - but it’s 0, so it converts it to 1 and subtracts from index 1 - but it’s also 0, so it converts it to 1 and subtracts from index 2 - and so on until we reach index n. Since index n is 1 it can subtract from it and turn it to 0 - and there it stops: <code>1101000 - 1 = 1100111</code></p></blockquote><blockquote><p>So, <code>v-1</code> is like <code>v</code> except there are <code>n</code> 0 that became 1 and one 1 that became 0. In <code>v &amp; v - 1</code> all the other bits remain as is, the <code>n</code> zeros that where turned to ones remain 0 (because <code>0 &amp; 1 == 0</code>), and the one 1 that was turned to 0 turns to 0(because <code>1 &amp; 0 == 0</code>). So overall - only a single bit was changed in the iteration, and this change was from 1 to 0: <code>1101000 &amp; 1100111 = 1100000</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;求两个整数的汉明距离 hamming distance&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 找出只出现一次的数 - 及类似问题</title>
    <link href="http://shukebeta.me/bits-operations-04/"/>
    <id>http://shukebeta.me/bits-operations-04/</id>
    <published>2018-09-23T16:00:00.000Z</published>
    <updated>2018-10-16T10:30:09.411Z</updated>
    
    <content type="html"><![CDATA[<p>“找出只出现一次的数”， “找出唯二的只出现M次的数”， “找出缺失的数”等等，都可以利用异或操作的特性， 即一个整数和自己进行异或运算会归0的性质。</p><h2 id="找出唯一一个仅出现M次的数"><a href="#找出唯一一个仅出现M次的数" class="headerlink" title="找出唯一一个仅出现M次的数"></a>找出唯一一个仅出现M次的数</h2><p>在一个非空整数数组，找出那个只出现了一次的元素，已知其余每个元素均出现两次。<br><a id="more"></a><br>要达到O(n)复杂度需要利用<strong>位异或</strong>. 位异或运算能够把二进制相同的数化为0. 把数组所有的数都异或, 出现两次的数就会互相抵消为0, 剩余的就是那个只出现了一次的数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums)</span><br><span class="line">        output ^= i;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但如果把问题扩展为“其余每个元素均出现三次”， 这样就无法直接利用异或抵消的性质了。剑指Offer的解法是用一个长度<code>32</code>的数组<code>bitSum</code>, 把原数组所有整数的二进制每一位分别累加到<code>bitSum</code>里面, 这样就可以通过判断<code>bitSum</code>哪些位不可以被3整除来找出那个数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bitSum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> bitMask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> b = nums[i] &amp; bitMask;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="number">0</span>)</span><br><span class="line">                bitSum[j] += <span class="number">1</span>;</span><br><span class="line">            bitMask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        res += bitSum[i] % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为<code>bitSum</code>的长度是常数, 所以该方法复杂度还是O(N). 该方法可以进一步扩展问题为求唯一一个元素出现M次，其他所有元素出现K次的问题。</p><p>除此之外, 还有其他更精简的通用的方法来解决此类问题.</p><h3 id="构造状态转移表"><a href="#构造状态转移表" class="headerlink" title="构造状态转移表"></a>构造状态转移表</h3><p>方法来自<a href="https://leetcode.com/problems/single-number-ii/discuss/43296/An-General-Way-to-Handle-All-this-sort-of-questions." target="_blank" rel="noopener">An General Way to Handle All this sort of questions</a>, 这个方法核心思想是建立一个记录状态的变量, 该变量代表某个数字出现一次后的状态. 目标就是使得一个数字重复出现K次后状态刚好归0.</p><p>对于<code>K=2</code>, 就要使两次叠加后归0, 需要两种状态, 从信息论的角度看待, 只需要一个位(<code>0</code>,<code>1</code>)来表达，状态<code>0</code>对应着两种等价的情况: 一个数字完全没出现过, 或者出现了2次后一起抵消重置. 状态<code>1</code>对应着仅仅出现一次的情况. 在这里数字和状态概念等价，构建一个状态转移表（真值表）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">状态 输入 输出</span><br><span class="line">a    c    a</span><br><span class="line">0    0    0</span><br><span class="line">1    0    1</span><br><span class="line">0    1    1</span><br><span class="line">1    1    0</span><br></pre></td></tr></table></figure></p><p>可以看到，不管是状态1还是0，如果输入相同数字，就会变为0；如果输入不同的数字，就会变为1. 根据表写出逻辑表达式为异或运算.</p><p>根据真值表写出逻辑式的基本套路是: 只看输出结果为1的转移, 凡取值为1的变量写成原变量，取值为0的变量写成反变量, 得出对应的表达式, 再把所有转移方程的表达式加起来. 如输出为1的是<code>0 &amp; 1 = 1, 1 &amp; 0 = 1</code>, 表达式就是<code>(~a &amp; c) | (a &amp; ~c)</code>, 这个本质上就是<code>a ^ c</code></p><p>对于<code>K = 3, M = 1(or 2)</code>, 需要三种状态, 那么至少需要两个位(<code>00</code>, <code>01</code>, <code>10</code>)来表达. 让状态<code>00</code>对应”假”输出, 对应两种等价的情况: 一个数字完全没出现过, 或者出现了3次后一起抵消重置. 再定义<code>01</code>为出现了一次的状态, <code>10</code>为出现了2次, 这两种状态都对应着”真”输出, 也就是我们想要的答案, 得出状态转移为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">状态      输入      输出</span><br><span class="line">(a, b)    (c)      (a,b)</span><br><span class="line">0, 0   0   0, 0</span><br><span class="line">0, 1   0   0, 1</span><br><span class="line">1, 0   0   1, 0</span><br><span class="line">0, 0   1   0, 1</span><br><span class="line">0, 1   1   1, 0</span><br><span class="line">1, 0   1   0, 0</span><br></pre></td></tr></table></figure></p><p>得出<code>a = (a &amp; ~b &amp; ~c) | (~a &amp; b &amp; c)</code>, <code>b = (~a &amp; b &amp; ~c) | (~a &amp; ~b &amp; c)</code>.<br>只要把数组所有数按照这个逻辑分别叠加到<code>a</code>和<code>b</code>上面, 最后答案就是<code>a | b</code>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = (a &amp; ~b &amp; ~c) | (~a &amp; b &amp; c);</span><br><span class="line">        b = (~a &amp; b &amp; ~c) | (~a &amp; ~b &amp; c);</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (a | b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上只是一种通用的套路，对于每一种特定的<code>K, M</code>组合, 可能会有不同的特殊最优方案.</p><h3 id="通过不同集合收录不同数字"><a href="#通过不同集合收录不同数字" class="headerlink" title="通过不同集合收录不同数字"></a>通过不同集合收录不同数字</h3><p>同上面的问题，LeetCode某大神给出一个<a href="https://leetcode.com/problems/single-number-ii/discuss/43294/Challenge-me-thx" target="_blank" rel="noopener">目前为止最优的方案</a>, 并放言”Challenge me”, 草鸡们看了瑟瑟发抖：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        ones = (ones ^ c) &amp; ~twos;</span><br><span class="line">        twos = (twos ^ c) &amp; ~ones;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原理是利用两个数<code>ones</code>和<code>twos</code>作为一种概念上的集合<code>set</code>，通过异或操作来收录分别出现了1次和2次的数, <code>set ^ val</code>有两种结果:</p><ul><li>如果<code>set</code>里面没有<code>val</code>, 把<code>val</code>异或进去, 如<code>a ^ 0 = a</code></li><li>如果<code>set</code>之前已经收录了<code>val</code>, 那么亦或操作就会在<code>set</code>中移除这个<code>val</code>, 如 <code>a ^ a = 0</code></li></ul><p>按照上面的定义来理解:</p><ul><li><code>(ones ^ c) &amp; ~twos</code>: 当且仅当<code>c</code>没有收录在<code>twos</code>中, 把<code>ones</code>收录<code>c</code>，否则移除<code>c</code>。这样的话，任何第一次出现的数都会被收入<code>ones</code>中, 而任何第二次出现的数会从<code>ones</code>中移出.<br>So, effectively anything that appears for the first time will be in the set. Anything that appears a second time will be removed. We’ll see what happens when an element appears a third time (thats handled by the set “twos”).</li><li>紧接着, <code>(twos ^ c) &amp; ~ones</code>用同样的逻辑更新<code>twos</code>. 这样意味着<ul><li><code>twos</code>不会收录第一次出现的数;</li><li>但对于第二次出现的数, 因为上一步已经把这个数从<code>ones</code>中移除, 那么这个数就会被收录进<code>twos</code>中,</li><li>对于第三次出现的数, 因为<code>twos</code>中已经收录了, 所以<code>ones</code>不会再收录, 而异或操作会把<code>twos</code>中的这个数移除.</li></ul></li></ul><p>最后的结果就是, <code>ones</code>仅保留出现了1次的数, <code>twos</code>仅保留出现了2次的数, 而那些出现了3次的数都被移除了.</p><p>这种方法可以扩展为通用方法, 适用于任何仅存在一个只出现了<code>M</code>次的数, 其他数都出现了<code>K</code>次的数组, 如<code>K = 4, M = 3</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>, threes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        ones = (ones ^ c) &amp; ~twos &amp; ~threes;</span><br><span class="line">        twos = (twos ^ c) &amp; ~ones &amp; ~threes;</span><br><span class="line">        threes = (threes ^ c) &amp; ~twos &amp; ~ones;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> threes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    System.out.println(singleNumber(nums)); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="找出唯二的仅出现M次的数"><a href="#找出唯二的仅出现M次的数" class="headerlink" title="找出唯二的仅出现M次的数"></a>找出唯二的仅出现M次的数</h2><p><a href="https://leetcode.com/problems/single-number-iii/" target="_blank" rel="noopener">LeetCode原题</a>:给定一个整数数组<code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。跟前面的问题类似, 我们需要再次使用XOR来解决这个问题。通过分割数组, 把出现一次的两个数, 划分到不同的数组中, 问题就转化为寻找唯一的出现一次的数问题. 所以关键就是如何拆分数组.</p><p>具体需要两次遍历：</p><ul><li>第一次遍历，对数组所有元素进行异或，获得要找的两个数字的XOR。由于两个数字是不同的，因此在XOR结果中必定有一个<code>set bit</code>, 即位值为’1’的位。</li><li>找出任意<code>set bit</code>（如最右边的）。</li><li>第二次遍历，将所有数字分成两组: 一组为具有上述<code>set bit</code>的数, 另一组没有。按照这种方法分组, 相同的数字一定会被分配到同一组中, 而两个只出现一次的数会分配到不同数组中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**代码来自: https://leetcode.com/problems/single-number-iii/discuss/68900/Accepted-C%2B%2BJava-O(n)-time-O(1)-space-Easy-Solution-with-Detail-Explanations</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// Pass 1 :</span></span><br><span class="line">        <span class="comment">// Get the XOR of the two numbers we need to find</span></span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            diff ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Get its last set bit</span></span><br><span class="line">        diff &amp;= -diff;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pass 2 :</span></span><br><span class="line">        <span class="keyword">int</span>[] rets = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">// this array stores the two numbers we will return</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; diff) == <span class="number">0</span>) <span class="comment">// the bit is not set</span></span><br><span class="line">            &#123;</span><br><span class="line">                rets[<span class="number">0</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// the bit is set</span></span><br><span class="line">            &#123;</span><br><span class="line">                rets[<span class="number">1</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找出缺失的数"><a href="#找出缺失的数" class="headerlink" title="找出缺失的数"></a>找出缺失的数</h2><p>给定一个包含n个不同数字的数组，取自<code>0,1,2,...,n</code>，找到数组中缺少的数字。把所有数字和索引<code>0 ~ n</code>取异或, 索引是完整的, 但数字缺失了一个, 最后得到的就一定是那个缺失的数.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> miss = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        miss ^= (nums[i] ^ i);</span><br><span class="line">    <span class="keyword">return</span> miss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外也可以通过求等差数列和， 然后减去实际的数组和，得出缺失的数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“找出只出现一次的数”， “找出唯二的只出现M次的数”， “找出缺失的数”等等，都可以利用异或操作的特性， 即一个整数和自己进行异或运算会归0的性质。&lt;/p&gt;
&lt;h2 id=&quot;找出唯一一个仅出现M次的数&quot;&gt;&lt;a href=&quot;#找出唯一一个仅出现M次的数&quot; class=&quot;headerlink&quot; title=&quot;找出唯一一个仅出现M次的数&quot;&gt;&lt;/a&gt;找出唯一一个仅出现M次的数&lt;/h2&gt;&lt;p&gt;在一个非空整数数组，找出那个只出现了一次的元素，已知其余每个元素均出现两次。&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 不使用加减符号求和整数</title>
    <link href="http://shukebeta.me/bits-operations-05/"/>
    <id>http://shukebeta.me/bits-operations-05/</id>
    <published>2018-09-22T16:00:00.000Z</published>
    <updated>2018-10-16T03:13:41.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不使用加减符号求和整数"><a href="#不使用加减符号求和整数" class="headerlink" title="不使用加减符号求和整数"></a>不使用加减符号求和整数</h2><p>不能使用<code>+</code>和<code>-</code>, 仅通过<code>^</code>和<code>&amp;</code>操作来求和两个整数<code>a</code>.<br><a id="more"></a><br>参考<a href="https://www.cnblogs.com/kiven-code/archive/2012/09/15/2686922.html" target="_blank" rel="noopener"></a><br>每位相加可能会产生进位(carry), 所以可以把相加拆分为两部分, 如<code>759 + 674</code>可以拆分为不考虑进位的部分<code>323</code>和仅考虑进位的部分<code>1110</code>, 故<code>759 + 674 = 323 + 1110 = 1433</code>.</p><p>二进制的加法也是从低位开始逐步往高位计算:</p><ol><li>进行一位二进制的加法, 也就是暂不考虑进位的位相加: <code>0+0=0， 0+1=1, 1+0=1， 1+1=0</code>, 那么就是<code>^</code>操作. 所得的和作为新的<code>a</code>.</li><li>求进位: 通过<code>a &amp; b</code>判断是否进位, 因为只有两个位均为<code>1</code>才会进位. 所得的进位左移一位作为新的<code>b</code>.</li><li>不断重复这个过程, 把低位的进位传递到高位, 累加到<code>a</code>中, 直到进位为<code>0</code>, 最后得到的<code>a</code>就是答案.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123; <span class="comment">// 关键在于判断终止的时机</span></span><br><span class="line"><span class="keyword">int</span> c = a &amp; b; <span class="comment">//carry</span></span><br><span class="line">a ^= b; <span class="comment">//add</span></span><br><span class="line">b = c &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及的运算就是一个多位二进制加法真值表：(对应于硬件中的全加器)</p><blockquote><p>全加器（full adder）将两个一位二进制数相加，并根据接收到的低位进位信号，输出和、进位输出。全加器的三个输入信号为两个加数A、B和低位进位Cin。全加器通常可以通过级联（cascade）的方式，构成多位（如8位、16位、32位）二进制数加法器的基本部分。全加器的输出和半加器类似，包括向高位的进位信号Cout和本位的和信号S，相加结果的总和表达为 ${\displaystyle \mathrm {sum} =2\times C_{out}+S}$。</p></blockquote><p><img src="/images/full_adder.png" alt="" title="image from https://en.wikipedia.org/wiki/Adder_(electronics)"><br>规则是<br><code>s = (x ^ y) ^ Cin</code><br><code>Cout = (x &amp; y) | (y &amp; Cin) | (x &amp; Cin)</code></p><p>更简单的版本:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : getSum(a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="不使用缓存交换整数"><a href="#不使用缓存交换整数" class="headerlink" title="不使用缓存交换整数"></a>不使用缓存交换整数</h2><p>利用一个整数和自己进行异或运算会归0的性质<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] exchangeAB(<span class="keyword">int</span>[] AB) &#123;</span><br><span class="line">   AB[<span class="number">0</span>] = AB[<span class="number">0</span>] ^ AB[<span class="number">1</span>];</span><br><span class="line">   AB[<span class="number">1</span>] = AB[<span class="number">0</span>] ^ AB[<span class="number">1</span>]; <span class="comment">// 只剩下AB[0]</span></span><br><span class="line">   AB[<span class="number">0</span>] = AB[<span class="number">0</span>] ^ AB[<span class="number">1</span>]; <span class="comment">// 只剩下AB[1]</span></span><br><span class="line">   <span class="keyword">return</span> AB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以使用加减法来操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] exchangeAB(<span class="keyword">int</span>[] AB) &#123;</span><br><span class="line">   AB[<span class="number">0</span>] = AB[<span class="number">0</span>] + AB[<span class="number">1</span>];</span><br><span class="line">   AB[<span class="number">1</span>] = AB[<span class="number">0</span>] - AB[<span class="number">1</span>]; <span class="comment">// 只剩下AB[0]</span></span><br><span class="line">   AB[<span class="number">0</span>] = AB[<span class="number">0</span>] - AB[<span class="number">1</span>]; <span class="comment">// 只剩下AB[1]</span></span><br><span class="line">   <span class="keyword">return</span> AB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;不使用加减符号求和整数&quot;&gt;&lt;a href=&quot;#不使用加减符号求和整数&quot; class=&quot;headerlink&quot; title=&quot;不使用加减符号求和整数&quot;&gt;&lt;/a&gt;不使用加减符号求和整数&lt;/h2&gt;&lt;p&gt;不能使用&lt;code&gt;+&lt;/code&gt;和&lt;code&gt;-&lt;/code&gt;, 仅通过&lt;code&gt;^&lt;/code&gt;和&lt;code&gt;&amp;amp;&lt;/code&gt;操作来求和两个整数&lt;code&gt;a&lt;/code&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>位操作 - 风骚的走位操作</title>
    <link href="http://shukebeta.me/bits-operations-03/"/>
    <id>http://shukebeta.me/bits-operations-03/</id>
    <published>2018-09-21T16:00:00.000Z</published>
    <updated>2018-10-10T09:45:33.617Z</updated>
    
    <content type="html"><![CDATA[<p>通过位移实现很多风骚的操作， 参考<a href="https://www.youtube.com/watch?v=7jkIUgLC29I" target="_blank" rel="noopener">这个视频</a>。<br><a id="more"></a><br>检查一个数是否是偶数, 本质上就是取最后一位来判断, 如果是1那么就一定是奇数, 反之则为偶数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x &amp; <span class="number">1</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>Check if power of two:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x &amp; x - <span class="number">1</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>因为如果数<code>x</code>是以2底的真数, 那么其二进制一定只有一个位置是<code>1</code>, 如<code>0b1000</code>, 那么<code>x-1</code>就会变成只有该位置是<code>0</code>其右边所有位变为<code>1</code>, 即<code>0b0111</code>, 也就是说这种情况下<code>x</code>和<code>x-1</code>所有位置都互异. 那么它们的位与运算就是<code>x &amp; x - 1 = 0b0000</code>.</p><p><code>x &amp; x - 1</code>的广义用途是求<code>x</code>二进制中<code>1</code>的个数, <a href="https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan" target="_blank" rel="noopener">Counting bits set</a>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned int v; // count the number of bits set in v</span><br><span class="line">unsigned int c; // c accumulates the total bits set in v</span><br><span class="line">for (c = 0; v; c++)</span><br><span class="line">&#123;</span><br><span class="line">  v &amp;= v - 1; // clear the least significant bit set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>Brian Kernighan’s algorithm takes <code>O(log N)</code> to count set bits (1s) in an integer: each iteration sets the least significance bit that isn’t zero to zero - and only it. Since each iteration converts exactly bit from 1 to 0, it’ll take as many iterations as there are non-0 bits to convert all the bits to 0(and thus <code>v == 0</code> and the loop finishes). An integer n has <code>log(n)</code> bits, hence the worst case is <code>O(log(n))</code></p></blockquote><p>如果一个整数不为<code>0</code>, 那么其二进制就至少有一个<code>1</code>. 假设最右边一位是<code>1</code>, 那么减<code>1</code>就会把最后一位变为<code>0</code>, 前面所有位保持不变. 假如最后一位是<code>0</code>, 那么最靠右的<code>1</code>假设在<code>m</code>位置, 那么减去<code>1</code>, 该位置会变为<code>0</code>, 而其右边的所有<code>0</code>都会变为<code>1</code>, 其左边的所有位不变. <code>v &amp;= v - 1</code>把最右的<code>1</code>变为<code>0</code>.</p><p>获取二进制的最后一个<code>1</code>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last_set_bit</span><span class="params">(x)</span>:</span></span><br><span class="line">    y = ~(x - <span class="number">1</span>) <span class="comment"># = - (x - 1) - 1 = -x</span></span><br><span class="line">    <span class="keyword">return</span> x &amp; y</span><br></pre></td></tr></table></figure></p><p>假设最右边的<code>1</code>位于n, <code>-1</code>操作会把n右边所有<code>0</code>变为<code>1</code>, 而n位变为<code>0</code>. 接着<code>~</code>操作会把n左边所有位翻转, 而n及其右边的数会变为原来的样子, 也就是n为<code>1</code>, 右边全为<code>0</code>(或者没有右边). 最后<code>&amp;</code>操作就只剩下n位的<code>1</code>和右边的<code>0</code>(如果有的话).</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过位移实现很多风骚的操作， 参考&lt;a href=&quot;https://www.youtube.com/watch?v=7jkIUgLC29I&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个视频&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://shukebeta.me/categories/CS/"/>
    
    
      <category term="Software Engineer" scheme="http://shukebeta.me/tags/Software-Engineer/"/>
    
      <category term="Algorithms" scheme="http://shukebeta.me/tags/Algorithms/"/>
    
      <category term="Computer Science" scheme="http://shukebeta.me/tags/Computer-Science/"/>
    
  </entry>
  
</feed>
